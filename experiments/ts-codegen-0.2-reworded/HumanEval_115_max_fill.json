{
  "name": "HumanEval_115_max_fill",
  "language": "ts",
  "prompt": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
  "completions": [
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      if (wells[i][j] === 1) {\n        wells_filled[i][j] = 1\n        wells_filled_count++\n      }\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      buckets[i][j] = capacity\n      if (wells[i][j] === 1) {\n        buckets_filled[i][j] = 1\n        buckets_filled_count++\n      }\n    }\n  }\n  let [wells_filled_count_new, buckets_filled_count_new] = [0, 0]\n  while (wells_filled_count_new < wells_filled_count) {\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        if (wells_filled[i][j] === 1 && buckets[i][j] > 0) {\n          wells_filled[i][j] = 0\n          wells_filled_count_new++\n          buckets[i][j]--\n        }\n      }\n    }\n  }\n  return buckets_filled_count_new\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows2, cols2] = grid[0].length\n  let [rows3, cols3] = grid[0][0].length\n  let [rows4, cols4] = grid[0][0][0].length\n  let [rows5, cols5] = grid[0][0][0][0].length\n  let [rows6, cols6] = grid[0][0][0][0][0].length\n  let [rows7, cols7] = grid[0][0][0][0][0][0].length\n  let [rows8, cols8] = grid[0][0][0][0][0][0][0].length\n  let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length\n  let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length\n  let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length\n  let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows17, cols17] = grid[0][0][0][0][0][0][0][0][0][0][0",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n      if (wells[i] === 1) {\n        wells[i] = 0\n        buckets[i] -= 1\n      }\n      if (wells[i] === 0 && buckets[i] > 0) {\n        wells[i] = 1\n        buckets[i] -= 1\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    if (wells[i] === 1) {\n      count += 1\n    }\n  }\n  return count\n}\n",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let cur = 0;\n      let left = i - 1;\n      let right = i + 1;\n      let up = j - 1;\n      let down = j + 1;\n      if (left >= 0 && grid[left][j] === 1) {\n        cur += 1;\n      }\n      if (right < grid.length && grid[right][j] === 1) {\n        cur += 1;\n      }\n      if (up >= 0 && grid[i][up] === 1) {\n        cur += 1;\n      }\n      if (down < grid[i].length && grid[i][down] === 1) {\n        cur += 1;\n      }\n      max = Math.max(max, cur);\n    }\n  }\n  return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [rows2, cols2] = grid[0].length;\n    let [rows3, cols3] = grid[0][0].length;\n    let [rows4, cols4] = grid[0][0][0].length;\n    let [rows5, cols5] = grid[0][0][0][0].length;\n    let [rows6, cols6] = grid[0][0][0][0][0].length;\n    let [rows7, cols7] = grid[0][0][0][0][0][0].length;\n    let [rows8, cols8] = grid[0][0][0][0][0][0][0].length;\n    let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length;\n    let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows17, cols17] = grid[0][0][0",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur === max) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1;\n        if (curr > max) {\n          max = curr;\n        }\n      }\n    }\n  }\n  let curr = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1;\n        if (curr > max) {\n          max = curr;\n        }\n      }\n    }\n  }\n  return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [row, col] = [0, 0];\n    let [max_fill, max_fill_row, max_fill_col] = [0, 0, 0];\n    let [max_fill_row_col, max_fill_row_col_row, max_fill_row_col_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col, max_fill_row_col_row_col_row, max_fill_row_col_row_col_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col, max_fill_row_col_row_col_row_col_row_col_row, max_fill_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [0, 0];\n    let [wells_max_count, buckets_max_count] = [0, 0];\n    let [wells_min_count, buckets_min_count] = [0, 0];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_count++;\n                wells_max = Math.max(wells_max, wells_count);\n                wells_min = Math.min(wells_min, wells_count);\n                wells_max_count = Math.max(wells_max_count, wells_count);\n                wells_min_count = Math.min(wells_min_count, wells_count);\n            }\n            if (wells[i][j] === 0) {\n                buckets_count++;\n                buckets_max = Math.max(buckets_max, buckets_count);\n                buckets_min = Math.min(buckets_min, buckets_count);\n                buckets_max_count = Math.max(buckets_max_count, buckets_count);\n                buckets_min_count = Math.min(buckets_min_count, buckets_count);\n            }\n        }\n    }\n    let max_fill = 0;\n    for (let i = wells_min; i <= wells_max; i++) {\n        let max_fill_count = 0;\n        for (let j = buckets_min; j <= buckets_max; j++) {\n            if (wells[i - wells_min][j - buckets_min] === 1) {\n                max_fill_count++;\n                if (max_fill_count === capacity) {\n                    max_fill++;\n                    break;\n                }\n            ",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [max_fill, max_fill_count] = [0, 0]\n  let [max_fill_count_r, max_fill_count_c] = [0, 0]\n  let [max_fill_count_r_c, max_fill_count_c_r] = [0, 0]\n  let [max_fill_count_r_c_r, max_fill_count_c_r_c] = [0, 0]\n  let [max_fill_count_r_c_r_c, max_fill_count_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r, max_fill_count_c_r_c_r_c] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c, max_fill_count_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c, max_fill_count_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c, max_fill_count_c_r_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c_r_c, max_fill_count_c_r_c_r_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c_r_c_r_c, max_fill_count_c_r_c_r_c_r_c_r_c_r_",
    "    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [i, j] = [0, 0];\n    let [k, l] = [0, 0];\n    let [max_fill, max_fill_count] = [0, 0];\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                k = i;\n                l = j;\n                while (k < n && l < m && grid[k][l] === 1) {\n                    k++;\n                    l++;\n                }\n                max_fill = Math.max(max_fill, k - i);\n                max_fill_count++;\n            }\n        }\n    }\n    return max_fill_count * max_fill;\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n      if (wells[i] === 1) {\n        wells[i] = 0\n        buckets[i] -= 1\n      }\n      if (wells[i] === 0 && buckets[i] > 0) {\n        wells[i] = 1\n        buckets[i] -= 1\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    if (wells[i] === 1) {\n      count += 1\n    }\n  }\n  return count\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i]\n    let curr = 0\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        curr += capacity\n      }\n    }\n    max = Math.max(max, curr)\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let res = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur === max) {\n        res += 1\n      }\n    }\n  }\n  return res\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_filled, buckets_filled] = [[0] * cols, [0] * cols];\n    let [wells_max, buckets_max] = [[0] * cols, [0] * cols];\n    let [wells_min, buckets_min] = [[0] * cols, [0] * cols];\n    let [wells_max_filled, buckets_max_filled] = [[0] * cols, [0] * cols];\n    let [wells_min_filled, buckets_min_filled] = [[0] * cols, [0] * cols];\n    let [wells_max_filled_count, buckets_max_filled_count] = [[0] * cols, [0] * cols];\n    let [wells_min_filled_count, buckets_min_filled_count] = [[0] * cols, [0] * cols];\n    let [wells_max_filled_count_count, buckets_max_filled_count_count] = [[0] * cols, [0] * cols];\n    let [wells_min_filled_count_count, buckets_min_filled_count_count] = [[0] * cols, [0] * cols];\n    let [wells_max_filled_count_count_count, buckets_max_filled_count_count_count] = [[0] * cols, [0] * cols];\n    let [wells_min_filled_count_count_count, buckets_min_filled_count_count_count] = [[0] * cols, [0] * cols];\n    let [wells_max_filled_count_count_count_count, buckets_max_filled_count_count_count_count] = [[0] * cols, [0] * cols];\n    let [wells_min_filled_count_count_count_count, buckets_min_filled_count_count_count_count] = [[0] * cols, [0] * cols];\n    let",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  let [wells_filled_max, buckets_filled_max] = [0, 0]\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = capacity\n    }\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled[i] = 0\n    wells_filled_count += wells[i][0]\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_max = Math.max(wells_filled_max, wells_filled[i])\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_count -= wells[i][0]\n    wells_filled[i] = wells_filled_count\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_count += wells[i][0]\n    wells_filled_count -= wells[i][1]\n    wells_filled[i] = wells_filled_count\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_max = Math.max(wells_filled_max, wells_filled[i])\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_count -= wells[i][0]\n    wells_filled[i] = wells_filled_count\n  }\n\n  for (let i = 0; i < rows; i++) {\n    wells_filled_count += wells[i][0]\n    wells_filled_count -= wells[i",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = 0\n    }\n  }\n  let filled = 0\n  while (filled < rows * cols) {\n    let [i, j] = find_max_well(wells, capacity)\n    if (wells[i][j] > 0) {\n      wells[i][j]--\n      filled++\n    }\n    buckets[i][j]++\n  }\n  return filled\n}\n\nfunction find_max_well(wells: number[][], capacity: number): [number, number] {\n  let [rows, cols] = wells.length\n  let [i, j] = [0, 0]\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] > max) {\n        max = wells[i][j]\n        i = j = 0\n      }\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] > 0 && wells[i][j] <= capacity && wells[i][j] > max) {\n        max = wells[i][j]\n        i = j = 0\n      }\n    }\n  }\n  return [i, j]\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * rows, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * rows, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * cols]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * cols]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * cols]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * cols]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * cols]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * cols]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * cols]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * cols]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * cols]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * cols]\n  let [wells_down_left_left, buckets_down_left_left] = [[0] * cols, [0] * cols]\n  let [wells_down_left_right, buckets_down_left_right] = [[0] * cols, [0] * cols]\n  let [wells_down_right_left, buckets_down_right_left] = [[0] * cols, [0] * cols]\n  let [wells",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1 && buckets[i] === max) {\n        count += 1\n        buckets[i] -= 1\n        if (buckets[i] === 0) {\n          buckets[i] = capacity\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_filled, buckets_filled] = [[0] * rows, [0] * cols];\n    let [wells_empty, buckets_empty] = [[0] * rows, [0] * cols];\n    let [wells_max, buckets_max] = [[0] * rows, [0] * cols];\n    let [wells_min, buckets_min] = [[0] * rows, [0] * cols];\n    let [wells_max_filled, buckets_max_filled] = [[0] * rows, [0] * cols];\n    let [wells_min_filled, buckets_min_filled] = [[0] * rows, [0] * cols];\n    let [wells_max_empty, buckets_max_empty] = [[0] * rows, [0] * cols];\n    let [wells_min_empty, buckets_min_empty] = [[0] * rows, [0] * cols];\n    let [wells_max_filled_empty, buckets_max_filled_empty] = [[0] * rows, [0] * cols];\n    let [wells_min_filled_empty, buckets_min_filled_empty] = [[0] * rows, [0] * cols];\n    let [wells_max_filled_max, buckets_max_filled_max] = [[0] * rows, [0] * cols];\n    let [wells_min_filled_max, buckets_min_filled_max] = [[0] * rows, [0] * cols];\n    let [wells_max_filled_min, buckets_max_filled_min] = [[0] * rows, [0] * cols];\n    let [wells_min_filled_min, buckets_min_filled_min] = [[0] * rows, [0] * cols];\n    let [wells_max_filled_max_filled, buckets_max_filled_max_filled] = [[0] * rows, [0] * cols];\n    let [wells",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      if (wells[j] === 1) {\n        buckets[j] = Math.min(buckets[j], buckets[j - 1] + 1)\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    let max = buckets[i]\n    for (let j = i + 1; j < rows; j++) {\n      if (wells[j] === 1) {\n        max = Math.min(max, buckets[j] + 1)\n      }\n    }\n    count += max\n  }\n  return count\n}\n",
    "  const buckets = new Array(grid.length).fill(0);\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1;\n        if (buckets[i] > capacity) {\n          buckets[i] = capacity;\n          max += 1;\n        }\n      }\n    }\n  }\n  return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [rows2, cols2] = grid[0].length;\n    let [rows3, cols3] = grid[0][0].length;\n    let [rows4, cols4] = grid[0][0][0].length;\n    let [rows5, cols5] = grid[0][0][0][0].length;\n    let [rows6, cols6] = grid[0][0][0][0][0].length;\n    let [rows7, cols7] = grid[0][0][0][0][0][0].length;\n    let [rows8, cols8] = grid[0][0][0][0][0][0][0].length;\n    let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length;\n    let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows17, cols17] = grid[0][0][0",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        wells[i][wells_filled[i][wells_filled_count]] = j\n        wells_filled_count++\n      }\n    }\n  }\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] !== 0) {\n        buckets[i][buckets_filled[i][buckets_filled_count]] = j\n        buckets_filled_count++\n      }\n    }\n  }\n\n  let max_fill_count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let well = wells[i][j]\n      let bucket = buckets[i][j]\n      let well_filled = wells_filled[i][wells_filled_count - 1]\n      let bucket_filled = buckets_filled[i][buckets_filled_count - 1]\n      let well_filled_count = wells_filled_count - 1\n      let bucket_filled_count = buckets_filled_count - 1\n\n      if (well_filled_count === 0) {\n        well_filled_count = wells_filled[i][wells_filled_count]\n        well_filled = wells[i][wells_filled[i][wells_filled_count]]\n        wells_filled_count++\n      }\n\n      if (bucket_filled_count === 0) {\n        bucket_filled_count = buckets_filled[i][buckets_filled_count]\n        bucket",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let cur = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  return max\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let cur = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                cur += 1;\n            }\n            if (cur > max) {\n                max = cur;\n            }\n            if (cur === capacity) {\n                cur = 0;\n            }\n        }\n    }\n    return max;\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i]\n    let buckets = []\n    for (let j = 0; j < row.length; j++) {\n      let well = row[j]\n      if (well === 1) {\n        buckets.push(capacity)\n      } else {\n        buckets.push(0)\n      }\n    }\n    let filled = 0\n    while (filled < capacity) {\n      let max_bucket = buckets[0]\n      let max_index = 0\n      for (let j = 0; j < buckets.length; j++) {\n        if (buckets[j] > max_bucket) {\n          max_bucket = buckets[j]\n          max_index = j\n        }\n      }\n      if (max_index === 0) {\n        break\n      }\n      buckets[max_index] = 0\n      filled += max_bucket\n    }\n    max = Math.max(max, filled)\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n      wells[i] = Math.max(wells[i], wells[i] + grid[i][j])\n      buckets[i] = Math.min(buckets[i], buckets[i] + grid[i][j])\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    let well = wells[i]\n    let bucket = buckets[i]\n    if (well > 0 && bucket > 0) {\n      count++\n      well -= bucket\n      bucket = 0\n    }\n    wells[i] = well\n    buckets[i] = bucket\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  const max = new Array(rows).fill(0)\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        max[i] = Math.max(max[i], buckets[i])\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (buckets[i] === max[i]) {\n        count += 1\n        buckets[i] -= 1\n        max[i] = Math.max(max[i], buckets[i])\n      }\n    }\n  }\n  return count\n}\n",
    "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let buckets = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        buckets.push(j);\n      }\n    }\n    let max = 0;\n    for (let j = 0; j < buckets.length; j++) {\n      let bucket = buckets[j];\n      let left = bucket - 1;\n      let right = bucket + 1;\n      if (left >= 0 && grid[i][left] === 0) {\n        max = Math.max(max, fill(grid, i, left, capacity));\n      }\n      if (right < row.length && grid[i][right] === 0) {\n        max = Math.max(max, fill(grid, i, right, capacity));\n      }\n    }\n    result = Math.max(result, max);\n  }\n  return result;\n}\n\nfunction fill(grid: number[][], i: number, j: number, capacity: number): number {\n  let count = 0;\n  while (grid[i][j] === 1) {\n    grid[i][j] = 0;\n    count++;\n    let left = j - 1;\n    let right = j + 1;\n    if (left >= 0 && grid[i][left] === 0) {\n      count += fill(grid, i, left, capacity);\n    }\n    if (right < grid[i].length && grid[i][right] === 0) {\n      count += fill(grid, i, right, capacity);\n    }\n  }\n  return count;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [rows2, cols2] = grid[0].length;\n    let [rows3, cols3] = grid[0][0].length;\n    let [rows4, cols4] = grid[0][0][0].length;\n    let [rows5, cols5] = grid[0][0][0][0].length;\n    let [rows6, cols6] = grid[0][0][0][0][0].length;\n    let [rows7, cols7] = grid[0][0][0][0][0][0].length;\n    let [rows8, cols8] = grid[0][0][0][0][0][0][0].length;\n    let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length;\n    let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows17, cols17] = grid[0][0][0",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_empty, buckets_empty] = [rows, cols];\n    let [wells_full, buckets_full] = [0, 0];\n    let [wells_full_count, buckets_full_count] = [0, 0];\n    let [wells_empty_count, buckets_empty_count] = [0, 0];\n    let [wells_empty_count_max, buckets_empty_count_max] = [0, 0];\n    let [wells_full_count_max, buckets_full_count_max] = [0, 0];\n    let [wells_full_count_min, buckets_full_count_min] = [0, 0];\n    let [wells_empty_count_min, buckets_empty_count_min] = [0, 0];\n    let [wells_full_count_min_max, buckets_full_count_min_max] = [0, 0];\n    let [wells_empty_count_min_max, buckets_empty_count_min_max] = [0, 0];\n    let [wells_full_count_min_min, buckets_full_count_min_min] = [0, 0];\n    let [wells_empty_count_min_min, buckets_empty_count_min_min] = [0, 0];\n    let [wells_full_count_min_max_min, buckets_full_count_min_max_min] = [0, 0];\n    let [wells_empty_count_min_max_min, buckets_empty_count_min_max_min] = [0, 0];\n    let [wells_full_count_min_min_min, buckets_full_count_min_min_min] = [0, 0];\n    let [wells_empty_count_min_min_min, buckets_empty_count_min_min",
    "    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [i, j] = [0, 0];\n    let [max_fill, max_fill_count] = [0, 0];\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                let [left, right, top, bottom] = [0, 0, 0, 0];\n                let [left_count, right_count, top_count, bottom_count] = [0, 0, 0, 0];\n                let [left_max, right_max, top_max, bottom_max] = [0, 0, 0, 0];\n                let [left_count_max, right_count_max, top_count_max, bottom_count_max] = [0, 0, 0, 0];\n                let [left_count_max_count, right_count_max_count, top_count_max_count, bottom_count_max_count] = [0, 0, 0, 0];\n                let [left_count_max_count_count, right_count_max_count_count, top_count_max_count_count, bottom_count_max_count_count] = [0, 0, 0, 0];\n                let [left_count_max_count_count_count, right_count_max_count_count_count, top_count_max_count_count_count, bottom_count_max_count_count_count] = [0, 0, 0, 0];\n                let [left_count_max_count_count_count_count, right_count_max_count_count_count_count, top_count_max_count_count_count_count, bottom_count_max_count_count_count_count] = [0, 0, 0, 0];\n                let [left_count_max_count_count_count_count_count, right_count_max_count_count_count_count_count, top_count_max_count_count_count_count_count, bottom_count",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_count_max, buckets_filled_count_max] = [0, 0];\n    let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_per_bucket, buckets_per_well] = [wells / buckets, buckets / wells]\n  let [wells_per_row, buckets_per_row] = [wells_per_bucket, buckets_per_well]\n  let [wells_per_col, buckets_per_col] = [wells_per_row, buckets_per_row]\n  let [wells_per_well, buckets_per_well] = [wells_per_row, buckets_per_row]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  ",
    "  const n = grid.length\n  const m = grid[0].length\n  const dp = Array(n).fill(0)\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        dp[i] = Math.max(dp[i], dfs(grid, i, j, capacity))\n      }\n    }\n  }\n  return dp.reduce((a, b) => a + b)\n}\n\nfunction dfs(grid: number[][], i: number, j: number, capacity: number): number {\n  if (i === 0 || j === 0 || i === grid.length - 1 || j === grid[0].length - 1) {\n    return 0\n  }\n  const left = grid[i - 1][j] === 1 ? 1 : 0\n  const right = grid[i + 1][j] === 1 ? 1 : 0\n  const down = grid[i][j + 1] === 1 ? 1 : 0\n  const up = grid[i][j - 1] === 1 ? 1 : 0\n  return Math.max(left, right, down, up, dfs(grid, i - 1, j, capacity) + 1, dfs(grid, i + 1, j, capacity) + 1, dfs(grid, i, j - 1, capacity) + 1, dfs(grid, i, j + 1, capacity) + 1)\n}\n",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        if (buckets[i] === max) {\n          count += 1\n          buckets[i] -= 1\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let result = 0\n  for (let i = 0; i < grid.length; i++) {\n    let buckets = grid[i].length\n    let filled = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        filled += 1\n        if (filled === buckets) {\n          result += 1\n          filled = 0\n        }\n      }\n    }\n  }\n  return result\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_len, buckets_len] = grid[0].length;\n    let max_fill = 0;\n    let [wells_index, buckets_index] = [0, 0];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_index = i;\n                buckets_index = j;\n                break;\n            }\n        }\n    }\n    let well_len = wells_len - 1;\n    let bucket_len = buckets_len - 1;\n    while (well_len > 0) {\n        let bucket_max = Math.min(well_len, capacity);\n        let well_max = Math.min(bucket_max, bucket_len);\n        max_fill += well_max;\n        well_len -= well_max;\n        bucket_len -= bucket_max;\n        wells[wells_index][buckets_index] = 0;\n        wells_index += 1;\n        buckets_index += 1;\n        if (wells_index === wells_len) {\n            wells_index = 0;\n        }\n        if (buckets_index === buckets_len) {\n            buckets_index = 0;\n        }\n    }\n    return max_fill;\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let curr = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                curr += 1;\n            }\n            if (curr > max) {\n                max = curr;\n            }\n        }\n    }\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let curr = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                curr += 1;\n                if (curr > max) {\n                    count += 1;\n                    curr = 0;\n                }\n            }\n        }\n    }\n    return count;\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[], []]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = []\n    for (let j = 0; j < cols; j++) {\n      wells[i].push(grid[i][j])\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    buckets[i] = []\n    for (let j = 0; j < cols; j++) {\n      buckets[i].push(0)\n    }\n  }\n  let [wells_filled, buckets_filled] = [0, 0]\n  while (wells_filled < wells.length) {\n    let [well_filled, bucket_filled] = max_well(wells, buckets, capacity)\n    wells_filled += well_filled\n    buckets_filled += bucket_filled\n  }\n  return buckets_filled\n}\n\nfunction max_well(wells: number[], buckets: number[], capacity: number): [number, number] {\n  let [well_filled, bucket_filled] = [0, 0]\n  let [wells_filled, buckets_filled] = [0, 0]\n  for (let i = 0; i < wells.length; i++) {\n    let [well_filled, bucket_filled] = max_bucket(wells[i], buckets[i], capacity)\n    wells_filled += well_filled\n    buckets_filled += bucket_filled\n  }\n  return [wells_filled, buckets_filled]\n}\n\nfunction max_bucket(well: number, bucket: number, capacity: number): [number, number] {\n  let [well_filled, bucket_filled] = [0, 0]\n  if (well > 0) {\n    well_filled = 1\n    bucket_filled = well\n  } else {\n    well_filled = 0\n    bucket_filled = 0\n  }\n  if (well_filled === capacity) {\n    well_filled = 0\n    bucket_filled = 0\n  }\n  return [well_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = capacity\n    }\n  }\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  while (wells_filled_count < wells.length) {\n    let [wells_filled_count, buckets_filled_count] = fill(wells, buckets, wells_filled, buckets_filled)\n  }\n  return buckets_filled_count\n}\n\nfunction fill(wells: number[][], buckets: number[][], wells_filled: number[][], buckets_filled: number[][]): [number, number] {\n  let [rows, cols] = wells.length\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        wells_filled[i][j] = 1\n        buckets_filled[i][j] = 0\n        for (let k = 0; k < rows; k++) {\n          for (let l = 0; l < cols; l++) {\n            if (wells[k][l] === 1 && buckets[k][l] > 0) {\n              wells_filled_count++\n              buckets_filled_count++\n              buckets[k][l]--\n              wells[k][l] = 0\n            }\n          }\n        }\n      }\n    }\n  }\n  return [wells_filled_count, buckets_filled_count]\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_len, buckets_len] = grid[0].length;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [wells_len, buckets_len];\n    let [wells_max_len, buckets_max_len] = [0, 0];\n    let [wells_min_len, buckets_min_len] = [wells_len, buckets_len];\n    let [wells_max_count, buckets_max_count] = [0, 0];\n    let [wells_min_count, buckets_min_count] = [wells_count, buckets_count];\n    let [wells_max_len_count, buckets_max_len_count] = [0, 0];\n    let [wells_min_len_count, buckets_min_len_count] = [wells_count, buckets_count];\n    let [wells_max_len_max, buckets_max_len_max] = [0, 0];\n    let [wells_min_len_max, buckets_min_len_max] = [wells_len, buckets_len];\n    let [wells_max_len_min, buckets_max_len_min] = [0, 0];\n    let [wells_min_len_min, buckets_min_len_min] = [wells_len, buckets_len];\n    let [wells_max_len_count, buckets_max_len_count] = [0, 0];\n    let [wells_min_len_count, buckets_min_len_count] = [wells_count, buckets_count];\n    let [wells_max_len_max_count, buckets_max_len_max_count] = [0, 0];\n    let [wells_min_len_max_count, buckets_min_len_max_count] = [wells_count, buckets_count];",
    "  let [wells, buckets] = [[], []];\n  for (let i = 0; i < grid.length; i++) {\n    wells[i] = [];\n    for (let j = 0; j < grid[i].length; j++) {\n      wells[i][j] = grid[i][j] === 1;\n      if (wells[i][j]) {\n        buckets[i] = buckets[i] || [];\n        buckets[i][j] = buckets[i][j] || 0;\n      }\n    }\n  }\n  let max = 0;\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      if (wells[i][j]) {\n        let filled = 0;\n        for (let k = 0; k < buckets.length; k++) {\n          for (let l = 0; l < buckets[k].length; l++) {\n            if (wells[k][l]) {\n              if (buckets[k][l] > 0) {\n                buckets[k][l]--;\n                filled++;\n              }\n            }\n          }\n        }\n        if (filled > max) {\n          max = filled;\n        }\n      }\n    }\n  }\n  return max;\n}\n",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        max = Math.max(max, buckets[i])\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        if (buckets[i] === max) {\n          count += 1\n          buckets[i] -= 1\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[rows - 1][cols - 1]\n  let [rows3, cols3] = grid[rows - 1][0]\n  let [rows4, cols4] = grid[0][cols - 1]\n  let [rows5, cols5] = grid[0][0]\n  let [rows6, cols6] = grid[rows - 1][cols - 1]\n  let [rows7, cols7] = grid[rows - 1][0]\n  let [rows8, cols8] = grid[0][cols - 1]\n  let [rows9, cols9] = grid[0][0]\n  let [rows10, cols10] = grid[rows - 1][cols - 1]\n  let [rows11, cols11] = grid[rows - 1][0]\n  let [rows12, cols12] = grid[0][cols - 1]\n  let [rows13, cols13] = grid[0][0]\n  let [rows14, cols14] = grid[rows - 1][cols - 1]\n  let [rows15, cols15] = grid[rows - 1][0]\n  let [rows16, cols16] = grid[0][cols - 1]\n  let [rows17, cols17] = grid[0][0]\n  let [rows18, cols18] = grid[rows - 1][cols - 1]\n  let [rows19, cols19] = grid[rows - 1][0]\n  let [rows20, cols20] = grid[0][cols - 1]\n  let [rows21, cols21] = grid[0][0]\n  let [rows22, cols22] = grid[rows - 1][cols - 1]\n  let [rows23, cols23] = grid[rows - 1][0]\n  let [rows24, cols24] = grid[0][cols - 1]\n  let [rows25, cols",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let cur = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.map(v => v === 1))\n  let [wells_left, buckets_left] = wells.map(row => row.map(v => v === 1))\n  let [wells_right, buckets_right] = wells.map(row => row.map(v => v === 0))\n  let [wells_down, buckets_down] = wells.map(row => row.map(v => v === 0))\n  let [wells_up, buckets_up] = wells.map(row => row.map(v => v === 1))\n  let [wells_up_left, buckets_up_left] = wells.map(row => row.map(v => v === 0))\n  let [wells_up_right, buckets_up_right] = wells.map(row => row.map(v => v === 0))\n  let [wells_down_left, buckets_down_left] = wells.map(row => row.map(v => v === 0))\n  let [wells_down_right, buckets_down_right] = wells.map(row => row.map(v => v === 0))\n  let [wells_left_up, buckets_left_up] = wells.map(row => row.map(v => v === 0))\n  let [wells_left_down, buckets_left_down] = wells.map(row => row.map(v => v === 0))\n  let [wells_right_up, buckets_right_up] = wells.map(row => row.map(v => v === 0))\n  let [wells_right_down, buckets_right_down] = wells.map(row => row.map(v => v === 0))\n  let [wells_up_left_up, buckets_up_left_up] = wells.map(row => row.map(v => v === 0))\n  let [wells_up_left_down, buckets_up_left_down] = wells.map(row => row.map(v => v === 0))\n  let [wells",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_per_row, buckets_per_row] = grid.map(row => row.length)\n  let [wells_per_col, buckets_per_col] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [0, 0];\n    let [wells_max_count, buckets_max_count] = [0, 0];\n    let [wells_min_count, buckets_min_count] = [0, 0];\n    let [wells_max_count_count, buckets_max_count_count] = [0, 0];\n    let [wells_min_count_count, buckets_min_count_count] = [0, 0];\n    let [wells_max_count_count_count, buckets_max_count_count_count] = [0, 0];\n    let [wells_min_count_count_count, buckets_min_count_count_count] = [0, 0];\n    let [wells_max_count_count_count_count, buckets_max_count_count_count_count] = [0, 0];\n    let [wells_min_count_count_count_count_count, buckets_min_count_count_count_count_count] = [0, 0];\n    let [wells_max_count_count_count_count_count_count, buckets_max_count_count_count_count_count_count] = [0, 0];\n    let [wells_min_count_count_count_count_count_count_count, buckets_min_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_max_count_count_count_count_count_count_count_count, buckets_max_count_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_min_count_count_count_count_count_count_count_count_count, buckets_min_count_count_count_count_count_count_count_count_count] = [0,",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map((row) => row.length)\n  let [wells_per_row, buckets_per_row] = grid.map((row) => row.length)\n  let [wells_per_col, buckets_per_col] = grid.map((col) => col.length)\n  let [wells_per_well, buckets_per_well] = grid.map((row) => row.length)\n  let [wells_per_bucket, buckets_per_bucket] = grid.map((row) => row.length)\n\n  let max_fill = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let well_index = i * wells_per_row + j\n      let bucket_index = i * buckets_per_row + j\n      let well_capacity = wells_per_well[well_index]\n      let bucket_capacity = buckets_per_well[well_index]\n      let bucket_fill = buckets_per_bucket[bucket_index]\n      let well_fill = wells_per_well[well_index]\n      if (well_fill > well_capacity) {\n        well_fill = well_capacity\n      }\n      if (bucket_fill > bucket_capacity) {\n        bucket_fill = bucket_capacity\n      }\n      if (well_fill > 0) {\n        max_fill += Math.min(well_fill, bucket_fill)\n      }\n    }\n  }\n  return max_fill\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let n = grid.length\n  let m = grid[0].length\n  let dp = new Array(n).fill(0)\n  let result = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        dp[i] = Math.max(dp[i], dp[i - 1] + 1)\n        if (dp[i] === capacity) {\n          result++\n        }\n      }\n    }\n  }\n  return result\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = capacity\n    }\n  }\n  let count = 0\n  while (wells.every(well => well.every(well => well))) {\n    let [i, j] = wells.find(well => !well)\n    let [well_i, well_j] = wells[i][j]\n    let [bucket_i, bucket_j] = buckets[i][j]\n    wells[i][j] = 0\n    buckets[i][j] = 0\n    count += 1\n    if (well_i > 0) {\n      wells[i][j] = well_i - 1\n      buckets[i][j] = bucket_i - 1\n    }\n    if (well_j > 0) {\n      wells[i][j] = well_j - 1\n      buckets[i][j] = bucket_j - 1\n    }\n    if (well_i < rows - 1) {\n      wells[i][j] = well_i + 1\n      buckets[i][j] = bucket_i + 1\n    }\n    if (well_j < cols - 1) {\n      wells[i][j] = well_j + 1\n      buckets[i][j] = bucket_j + 1\n    }\n  }\n  return count\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_per_row, wells_per_col] = [rows, cols];\n    let [buckets_per_row, buckets_per_col] = [rows, cols];\n    let [wells_per_row_filled, wells_per_col_filled] = [0, 0];\n    let [buckets_per_row_filled, buckets_per_col_filled] = [0, 0];\n    let [wells_per_row_filled_count, wells_per_col_filled_count] = [0, 0];\n    let [buckets_per_row_filled_count, buckets_per_col_filled_count] = [0, 0];\n    let [wells_per_row_filled_count_max, wells_per_col_filled_count_max] = [0, 0];\n    let [buckets_per_row_filled_count_max, buckets_per_col_filled_count_max] = [0, 0];\n    let [wells_per_row_filled_count_min, wells_per_col_filled_count_min] = [0, 0];\n    let [buckets_per_row_filled_count_min, buckets_per_col_filled_count_min] = [0, 0];\n    let [wells_per_row_filled_count_min_max, wells_per_col_filled_count_min_max] = [0, 0];\n    let [buckets_per_row_filled_count_min_max, buckets_per_col_filled_count_min_max] = [0, 0];\n    let [wells_per_row_filled_count_min_min, wells_per_col_filled_count_min_min] = [0, 0];\n    let [buckets_per_row_filled_count_min_min, buckets_per_col_filled_count_min_min] = [0, 0];\n    let [wells_per_row_filled_count_min_min_max, wells_per_col_",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_max, buckets_filled_max] = [0, 0];\n    let [wells_filled_min, buckets_filled_min] = [rows, cols];\n    let [wells_filled_min_max, buckets_filled_min_max] = [rows, cols];\n    let [wells_filled_min_min, buckets_filled_min_min] = [rows, cols];\n    let [wells_filled_max_max, buckets_filled_max_max] = [rows, cols];\n    let [wells_filled_max_min, buckets_filled_max_min] = [rows, cols];\n    let [wells_filled_min_max_max, buckets_filled_min_max_max] = [rows, cols];\n    let [wells_filled_min_max_min, buckets_filled_min_max_min] = [rows, cols];\n    let [wells_filled_max_max_max, buckets_filled_max_max_max] = [rows, cols];\n    let [wells_filled_max_max_min, buckets_filled_max_max_min] = [rows, cols];\n    let [wells_filled_min_max_max_max, buckets_filled_min_max_max_max] = [rows, cols];\n    let [wells_filled_min_max_max_min, buckets_filled_min_max_max_min] = [rows, cols];\n    let [wells_filled_max_max_max_max, buckets_filled_max_max_max_max] = [rows, cols];\n    let [wells_filled_max_max_max_min, buckets_filled_max_max_max_min] = [rows, cols];\n    let [wells_filled_min_max_max_max_",
    "  const n = grid.length\n  const m = grid[0].length\n  const buckets = new Array(n).fill(0)\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[i] === max) {\n        count += 1\n        buckets[i] -= 1\n        if (buckets[i] === 0) {\n          buckets[i] = capacity\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let curr = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                curr += 1;\n            }\n            if (curr > max) {\n                max = curr;\n            }\n            if (curr === capacity) {\n                curr = 0;\n            }\n        }\n    }\n    return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [rows2, cols2] = grid[0].length;\n    let [rows3, cols3] = grid[0][0].length;\n    let [rows4, cols4] = grid[0][0][0].length;\n    let [rows5, cols5] = grid[0][0][0][0].length;\n    let [rows6, cols6] = grid[0][0][0][0][0].length;\n    let [rows7, cols7] = grid[0][0][0][0][0][0].length;\n    let [rows8, cols8] = grid[0][0][0][0][0][0][0].length;\n    let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length;\n    let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows17, cols17] = grid[0][0][0",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_used, buckets_used] = [[0] * cols, [0] * cols];\n    let [wells_filled, buckets_filled] = [[0] * cols, [0] * cols];\n    let [wells_empty, buckets_empty] = [[0] * cols, [0] * cols];\n    let [wells_full, buckets_full] = [[0] * cols, [0] * cols];\n    let [wells_full_count, buckets_full_count] = [[0] * cols, [0] * cols];\n    let [wells_empty_count, buckets_empty_count] = [[0] * cols, [0] * cols];\n    let [wells_empty_count_max, buckets_empty_count_max] = [[0] * cols, [0] * cols];\n    let [wells_full_count_max, buckets_full_count_max] = [[0] * cols, [0] * cols];\n    let [wells_full_count_min, buckets_full_count_min] = [[0] * cols, [0] * cols];\n    let [wells_empty_count_min, buckets_empty_count_min] = [[0] * cols, [0] * cols];\n    let [wells_empty_count_min_max, buckets_empty_count_min_max] = [[0] * cols, [0] * cols];\n    let [wells_full_count_min_max, buckets_full_count_min_max] = [[0] * cols, [0] * cols];\n    let [wells_full_count_min_min, buckets_full_count_min_min] = [[0] * cols, [0] * cols];\n    let [wells_empty_count_min_min, buckets_empty_count_min_min] = [[0] * cols, [0] * cols];\n    let [wells_",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [[0] * cols, [0] * cols];\n    let [wells_right, buckets_right] = [[0] * cols, [0] * cols];\n    let [wells_down, buckets_down] = [[0] * rows, [0] * rows];\n    let [wells_up, buckets_up] = [[0] * rows, [0] * rows];\n    let [wells_up_left, buckets_up_left] = [[0] * rows, [0] * rows];\n    let [wells_up_right, buckets_up_right] = [[0] * rows, [0] * rows];\n    let [wells_down_left, buckets_down_left] = [[0] * rows, [0] * rows];\n    let [wells_down_right, buckets_down_right] = [[0] * rows, [0] * rows];\n    let [wells_left_up, buckets_left_up] = [[0] * rows, [0] * rows];\n    let [wells_left_down, buckets_left_down] = [[0] * rows, [0] * rows];\n    let [wells_right_up, buckets_right_up] = [[0] * rows, [0] * rows];\n    let [wells_right_down, buckets_right_down] = [[0] * rows, [0] * rows];\n    let [wells_up_left_up, buckets_up_left_up] = [[0] * rows, [0] * rows];\n    let [wells_up_left_down, buckets_up_left_down] = [[0] * rows, [0] * rows];\n    let [wells_up_right_up, buckets_up_right_up] = [[0] * rows, [0] * rows];\n    let [wells_up_right_down, buckets_up_right_down] = [[0] * rows, [0] * rows];\n    let",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.map(c => c === 1))\n  let [wells_len, buckets_len] = wells.length\n  let [wells_cap, buckets_cap] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_fill, buckets_fill] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_empty, buckets_empty] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_full, buckets_full] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_max, buckets_max] = wells.map(row => row.reduce((a, b) => Math.max(a, b)))\n  let [wells_min, buckets_min] = wells.map(row => row.reduce((a, b) => Math.min(a, b)))\n  let [wells_sum, buckets_sum] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_avg, buckets_avg] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_max_fill, buckets_max_fill] = wells.map(row => row.reduce((a, b) => Math.max(a, b)))\n  let [wells_min_fill, buckets_min_fill] = wells.map(row => row.reduce((a, b) => Math.min(a, b)))\n  let [wells_sum_fill, buckets_sum_fill] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_avg_fill, buckets_avg_fill] = wells.map(row => row.reduce((a, b) => a + b))\n  let [wells_max_empty, buckets_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_per_row, buckets_per_row] = grid.map(row => row.length)\n  let [wells_per_col, buckets_per_col] = grid.map(row => row.length)\n  let [wells_per_well, buckets_per_well] = grid.map(row => row.length)\n  let [wells_per_bucket, buckets_per_bucket] = grid.map(row => row.length)\n  let [wells_per_row_per_well, buckets_per_row_per_well] = grid.map(row => row.length)\n  let [wells_per_col_per_well, buckets_per_col_per_well] = grid.map(row => row.length)\n  let [wells_per_well_per_row, buckets_per_well_per_row] = grid.map(row => row.length)\n  let [wells_per_well_per_col, buckets_per_well_per_col] = grid.map(row => row.length)\n  let [wells_per_well_per_bucket, buckets_per_well_per_bucket] = grid.map(row => row.length)\n  let [wells_per_well_per_row_per_col, buckets_per_well_per_row_per_col] = grid.map(row => row.length)\n  let [wells_per_well_per_col_per_row, buckets_per_well_per_col_per_row] = grid.map(row => row.length)\n  let [wells_per_well_per_well, buckets_per_well_per_well] = grid.map(row => row.length)\n  let [wells_per_well_per_well_per_row, buckets_per_well_per_well_per_row] = grid.map(row => row.length)\n  let [wells_per_well_per_well_per",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [[0] * cols, [0] * cols];\n    let [wells_right, buckets_right] = [[0] * cols, [0] * cols];\n    let [wells_up, buckets_up] = [[0] * rows, [0] * rows];\n    let [wells_down, buckets_down] = [[0] * rows, [0] * rows];\n    let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * cols];\n    let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * cols];\n    let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * cols];\n    let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * cols];\n    let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * cols];\n    let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * cols];\n    let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * cols];\n    let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * cols];\n    let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * cols];\n    let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * cols];\n    let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * cols];\n    let [wells_up_right_down, buckets_",
    "  let [rows, cols] = grid.length\n  let [rows2, cols2] = grid[0].length\n  let [rows3, cols3] = grid[0][0].length\n  let [rows4, cols4] = grid[0][0][0].length\n  let [rows5, cols5] = grid[0][0][0][0].length\n  let [rows6, cols6] = grid[0][0][0][0][0].length\n  let [rows7, cols7] = grid[0][0][0][0][0][0].length\n  let [rows8, cols8] = grid[0][0][0][0][0][0][0].length\n  let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length\n  let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length\n  let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length\n  let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows17, cols17] = grid[0][0][0][0][0][0][0][0][0][0][0",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n        if (cur > max) {\n          max = cur\n        }\n      }\n    }\n  }\n  let res = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        res += max\n      }\n    }\n  }\n  return res\n}\n",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = [[] for _ in range(rows)]\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i].push(j)\n      }\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        let curr = 0\n        while (curr < capacity) {\n          let next = buckets[i].pop()\n          if (next === -1) {\n            break\n          }\n          curr += 1\n        }\n        if (curr > max) {\n          max = curr\n        }\n      }\n    }\n  }\n  return max\n}\n",
    "    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [i, j] = [0, 0];\n    let [max_fill, max_fill_count] = [0, 0];\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                let [count, fill] = fill_well(grid, i, j, capacity);\n                max_fill = Math.max(max_fill, fill);\n                max_fill_count += count;\n            }\n        }\n    }\n    return max_fill_count;\n}\n\nfunction fill_well(grid: number[][], i: number, j: number, capacity: number): [number, number] {\n    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [count, fill] = [0, 0];\n    let [i_min, j_min] = [i, j];\n    let [i_max, j_max] = [i, j];\n    while (true) {\n        let [i_min, j_min] = get_min_well(grid, i_min, j_min);\n        let [i_max, j_max] = get_max_well(grid, i_max, j_max);\n        if (i_min === i_max && j_min === j_max) {\n            break;\n        }\n        let [i_min_count, i_min_fill] = fill_well(grid, i_min, j_min, capacity);\n        let [i_max_count, i_max_fill] = fill_well(grid, i_max, j_max, capacity);\n        count += Math.max(i_min_count, i_max_count);\n        fill += Math.max(i_min_fill, i_max_fill);\n    }\n    return [count, fill];\n}\n\nfunction get_min_well(grid: number[][], i: number,",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_index, buckets_index] = [0, 0];\n    let [wells_length, buckets_length] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [0, 0];\n    let [wells_max_index, buckets_max_index] = [0, 0];\n    let [wells_min_index, buckets_min_index] = [0, 0];\n    let [wells_max_length, buckets_max_length] = [0, 0];\n    let [wells_min_length, buckets_min_length] = [0, 0];\n    let [wells_max_index_length, buckets_max_index_length] = [0, 0];\n    let [wells_min_index_length, buckets_min_index_length] = [0, 0];\n    let [wells_max_length_length, buckets_max_length_length] = [0, 0];\n    let [wells_min_length_length, buckets_min_length_length] = [0, 0];\n    let [wells_max_index_length_length, buckets_max_index_length_length] = [0, 0];\n    let [wells_min_index_length_length, buckets_min_index_length_length] = [0, 0];\n    let [wells_max_length_length_length, buckets_max_length_length_length] = [0, 0];\n    let [wells_min_length_length_length, buckets_min_length_length_length] = [0, 0];\n    let [wells_max_index_length_length_length, buckets_max_index_length_length_length] = [0, 0];\n    let [wells_min_index_length_length_length, buckets_min_index_length_length_length] = [0,",
    "  let [n, m] = grid.length\n  let [x, y] = [0, 0]\n  let [max_x, max_y] = [0, 0]\n  let [max_fill, max_fill_x, max_fill_y] = [0, 0, 0]\n  let [max_fill_x_, max_fill_y_] = [0, 0]\n  let [max_fill_x_y, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0, 0]\n  let [max_fill_x_y_, max_fill_x_y_] = [0,",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid.map(row => row.map(val => val === 1));\n    let [wells_left, buckets_left] = wells.map(row => row.map(val => val === 1));\n    let [wells_right, buckets_right] = wells.map(row => row.map(val => val === 0));\n    let [wells_down, buckets_down] = wells.map(row => row.map(val => val === 0));\n    let [wells_up, buckets_up] = wells.map(row => row.map(val => val === 1));\n    let [wells_left_down, buckets_left_down] = wells_left.map(row => row.map(val => val === 1));\n    let [wells_left_up, buckets_left_up] = wells_left.map(row => row.map(val => val === 0));\n    let [wells_right_down, buckets_right_down] = wells_right.map(row => row.map(val => val === 1));\n    let [wells_right_up, buckets_right_up] = wells_right.map(row => row.map(val => val === 0));\n    let [wells_down_left, buckets_down_left] = wells_down.map(row => row.map(val => val === 1));\n    let [wells_down_right, buckets_down_right] = wells_down.map(row => row.map(val => val === 0));\n    let [wells_up_left, buckets_up_left] = wells_up.map(row => row.map(val => val === 1));\n    let [wells_up_right, buckets_up_right] = wells_up.map(row => row.map(val => val === 0));\n    let [wells_left_down_left, buckets_left_down_left] = wells_left_down.map(row => row.map(val => val === 1));\n    let [wells_left_down_right, buckets_left_down_right] = wells",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = 0\n    }\n  }\n  let max = 0\n  while (true) {\n    let [wells, buckets] = fill(wells, buckets, capacity)\n    if (wells.length === 0) {\n      break\n    }\n    max = Math.max(max, wells.length)\n  }\n  return max\n}\n\nfunction fill(wells: number[][], buckets: number[][], capacity: number): [number[], number[]] {\n  let [rows, cols] = wells.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = 0\n      buckets[i][j] = 0\n    }\n  }\n  let [wells, buckets] = fill_wells(wells, buckets, capacity)\n  return [wells, buckets]\n}\n\nfunction fill_wells(wells: number[][], buckets: number[][], capacity: number): [number[], number[]] {\n  let [rows, cols] = wells.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = 0\n      buckets[i][j] = 0\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {",
    "  let [wells, buckets] = [[], []];\n  for (let i = 0; i < grid.length; i++) {\n    wells[i] = [];\n    for (let j = 0; j < grid[i].length; j++) {\n      wells[i][j] = grid[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(i);\n      }\n    }\n  }\n  let [wells_left, buckets_left] = [[], []];\n  let max_fill = 0;\n  while (wells_left.length > 0) {\n    let [well, bucket] = [wells_left.pop(), buckets_left.pop()];\n    let well_filled = false;\n    for (let i = 0; i < wells[well].length; i++) {\n      if (wells[well][i] === 1) {\n        wells[well][i] = 0;\n        well_filled = true;\n        break;\n      }\n    }\n    if (well_filled) {\n      let bucket_filled = false;\n      for (let i = 0; i < buckets.length; i++) {\n        if (buckets[i] === bucket) {\n          buckets[i] = 0;\n          bucket_filled = true;\n          break;\n        }\n      }\n      if (bucket_filled) {\n        wells_left.push(well);\n        buckets_left.push(bucket);\n        max_fill++;\n      }\n    }\n  }\n  return max_fill;\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let cur = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                cur += 1;\n            }\n            if (cur > max) {\n                max = cur;\n            }\n        }\n    }\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count += max - cur;\n                cur = 0;\n            } else {\n                cur += 1;\n            }\n        }\n    }\n    return count;\n}\n",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_used, buckets_used] = [[0] * cols, [0] * rows];\n    let [wells_filled, buckets_filled] = [[0] * cols, [0] * rows];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_max, buckets_filled_max] = [0, 0];\n    let [wells_filled_max_count, buckets_filled_max_count] = [0, 0];\n    let [wells_filled_max_count_count, buckets_filled_max_count_count] = [0, 0];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_used[j]++;\n                wells_filled[j]++;\n                wells_filled_count++;\n                wells_filled_max_count++;\n                wells_filled_max_count_count++;\n                wells_filled_max_count_count++;\n                if (wells_filled[j] > wells_filled_max[j]) {\n                    wells_filled_max[j] = wells_filled[j];\n                    wells_filled_max_count[j] = wells_filled_count;\n                }\n                if (wells_filled_count > wells_filled_max_count_count) {\n                    wells_filled_max_count_count = wells_filled_count;\n                }\n                if (wells_filled_count > wells_filled_max_count_count) {\n                    wells_filled_max_count_count = wells_filled_count;\n                }\n                if (wells_filled[j] === capacity) {\n                    wells_filled[j] = 0;\n                    wells_used[j] = 0;\n                    wells_filled_count = 0;\n                    wells_filled_max_count = 0;\n                    ",
    "  let n = grid.length\n  let m = grid[0].length\n  let max = 0\n  let dp = new Array(n).fill(0)\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        dp[i] = Math.max(dp[i], dp[i - 1] + 1)\n        max = Math.max(max, dp[i])\n      }\n    }\n  }\n  return max\n}\n",
    "  let result = 0\n  for (let i = 0; i < grid.length; i++) {\n    let well = grid[i]\n    let buckets = well.map((x, j) => x)\n    let max_buckets = buckets.reduce((a, b) => Math.max(a, b), 0)\n    if (max_buckets < capacity) {\n      result += max_buckets\n    } else {\n      result += capacity\n    }\n  }\n  return result\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_count_max, buckets_filled_count_max] = [0, 0];\n    let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_count++;\n                wells_max = Math.max(wells_max, wells_count);\n            }\n            if (buckets[i][j] === 1) {\n                buckets_count++;\n                buckets_max = Math.max(buckets_max, buckets_count);\n            }\n        }\n    }\n    let max_fill = 0;\n    for (let i = 0; i < wells_max; i++) {\n        let buckets_left = buckets_max - buckets_count;\n        if (buckets_left >= capacity) {\n            max_fill += capacity;\n        } else {\n            max_fill += buckets_left;\n        }\n    }\n    return max_fill;\n}\n",
    "    let [n, m] = grid.length;\n    let [i, j] = [0, 0];\n    let [x, y] = [0, 0];\n    let [x_max, y_max] = [0, 0];\n    let [x_min, y_min] = [n, m];\n    let [x_max_min, y_max_min] = [0, 0];\n    let [x_min_max, y_min_max] = [0, 0];\n    let [x_max_min_max, y_max_min_max] = [0, 0];\n    let [x_min_max_min, y_min_max_min] = [0, 0];\n    let [x_max_min_max_min, y_max_min_max_min] = [0, 0];\n    let [x_min_max_min_max, y_min_max_min_max] = [0, 0];\n    let [x_max_min_min_max, y_max_min_min_max] = [0, 0];\n    let [x_min_min_max_min, y_min_min_max_min] = [0, 0];\n    let [x_min_min_min_max, y_min_min_min_max] = [0, 0];\n    let [x_min_min_min_min, y_min_min_min_min] = [0, 0];\n    let [x_min_min_min_min_min, y_min_min_min_min_min] = [0, 0];\n    let [x_min_min_min_min_min_min, y_min_min_min_min_min_min] = [0, 0];\n    let [x_min_min_min_min_min_min_min, y_min_min_min_min_min_min_min] = [0, 0];\n    let [x_min_min_min_min_min_min_min_min, y_min_min_min_min_min_min_min_min] = [0, 0];",
    "  let [wells, buckets] = [[], []];\n  for (let i = 0; i < grid.length; i++) {\n    wells[i] = [];\n    for (let j = 0; j < grid[i].length; j++) {\n      wells[i][j] = grid[i][j] === 1;\n    }\n  }\n  for (let i = 0; i < wells.length; i++) {\n    buckets[i] = [];\n    for (let j = 0; j < wells[i].length; j++) {\n      if (wells[i][j]) {\n        buckets[i][j] = 0;\n      } else {\n        buckets[i][j] = capacity;\n      }\n    }\n  }\n  let max = 0;\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      if (wells[i][j]) {\n        let count = 0;\n        for (let k = 0; k < buckets.length; k++) {\n          if (buckets[k][j] > 0) {\n            count++;\n            buckets[k][j]--;\n          }\n        }\n        max = Math.max(max, count);\n      }\n    }\n  }\n  return max;\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_count, buckets_count] = [0, 0]\n  let [wells_max, buckets_max] = [0, 0]\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      if (wells[i][j] === 1) {\n        wells_count++\n        wells_max = Math.max(wells_max, wells_count)\n      }\n    }\n  }\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      buckets[i][j] = capacity\n      if (wells[i][j] === 1) {\n        buckets_count++\n        buckets_max = Math.max(buckets_max, buckets_count)\n      }\n    }\n  }\n\n  let max_fill = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        let fill = buckets_count - wells_count\n        if (fill > max_fill) {\n          max_fill = fill\n        }\n        wells[i][j] = 0\n        buckets[i][j] = 0\n      }\n    }\n  }\n\n  return max_fill\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_left, buckets_left] = [wells, buckets]\n  let [wells_right, buckets_right] = [wells, buckets]\n  let [wells_down, buckets_down] = [wells, buckets]\n  let [wells_up, buckets_up] = [wells, buckets]\n  let [wells_left_down, buckets_left_down] = [wells, buckets]\n  let [wells_left_up, buckets_left_up] = [wells, buckets]\n  let [wells_right_down, buckets_right_down] = [wells, buckets]\n  let [wells_right_up, buckets_right_up] = [wells, buckets]\n\n  let fill = 0\n  while (wells_left > 0 || wells_right > 0 || wells_down > 0 || wells_up > 0 || wells_left_down > 0 || wells_left_up > 0 || wells_right_down > 0 || wells_right_up > 0) {\n    if (wells_left > 0) {\n      wells_left -= 1\n      buckets_left -= 1\n      if (buckets_left < 0) {\n        wells_left += 1\n        buckets_left += 1\n      }\n    }\n    if (wells_right > 0) {\n      wells_right -= 1\n      buckets_right -= 1\n      if (buckets_right < 0) {\n        wells_right += 1\n        buckets_right += 1\n      }\n    }\n    if (wells_down > 0) {\n      wells_down -= 1\n      buckets_down -= 1\n      if (buckets_down < 0) {\n        wells_down += 1\n        buckets_down += 1\n      }\n    }\n    if (wells_up > 0) {\n      wells_up -= 1\n      buckets_up -= 1\n      if (buckets_up < 0) {\n        wells_up += 1\n        ",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j - 1], wells[j - 1])\n    }\n    for (let j = 0; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j], wells[j])\n    }\n  }\n  let result = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i] > 0) {\n        wells[i]--\n        buckets[i]--\n        result++\n      }\n    }\n  }\n  return result\n}\n",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let cur = grid[i][j];\n      if (cur === 1) {\n        let cur_fill = 0;\n        let left = i - 1;\n        let right = i + 1;\n        let top = j - 1;\n        let bottom = j + 1;\n        for (let k = left; k <= right; k++) {\n          for (let l = top; l <= bottom; l++) {\n            if (grid[k][l] === 1) {\n              cur_fill++;\n            }\n          }\n        }\n        if (cur_fill > max) {\n          max = cur_fill;\n        }\n      }\n    }\n  }\n  return max;\n}\n",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [b, w] = [0, 0]\n  let [r1, c1] = [0, 0]\n  let [r2, c2] = [0, 0]\n  let [r3, c3] = [0, 0]\n  let [r4, c4] = [0, 0]\n  let [r5, c5] = [0, 0]\n  let [r6, c6] = [0, 0]\n  let [r7, c7] = [0, 0]\n  let [r8, c8] = [0, 0]\n  let [r9, c9] = [0, 0]\n  let [r10, c10] = [0, 0]\n  let [r11, c11] = [0, 0]\n  let [r12, c12] = [0, 0]\n  let [r13, c13] = [0, 0]\n  let [r14, c14] = [0, 0]\n  let [r15, c15] = [0, 0]\n  let [r16, c16] = [0, 0]\n  let [r17, c17] = [0, 0]\n  let [r18, c18] = [0, 0]\n  let [r19, c19] = [0, 0]\n  let [r20, c20] = [0, 0]\n  let [r21, c21] = [0, 0]\n  let [r22, c22] = [0, 0]\n  let [r23, c23] = [0, 0]\n  let [r24, c24] = [0, 0]\n  let [r25, c25] = [0, 0]\n  let [r26, c26] = [0, 0]\n  let [r27, c27] = [0, 0]\n  let [r28, c28] = [0, 0]\n  let [r29, c29] = [0, 0]\n  let [r30, c",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      if (wells[j] === 1) {\n        buckets[j] = Math.min(buckets[j], buckets[j - 1])\n      } else {\n        buckets[j] = Math.min(buckets[j], buckets[j - 1] + 1)\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    if (wells[i] === 1) {\n      count += buckets[i]\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_max, c_max] = [0, 0]\n  let [r_min, c_min] = [0, 0]\n  let [r_min_, c_min_] = [0, 0]\n  let [r_max_, c_max_] = [0, 0]\n  let [r_min_max, c_min_max] = [0, 0]\n  let [r_min_min, c_min_min] = [0, 0]\n  let [r_max_max, c_max_max] = [0, 0]\n  let [r_min_max_, c_min_max_] = [0, 0]\n  let [r_min_min_, c_min_min_] = [0, 0]\n  let [r_max_max_, c_max_max_] = [0, 0]\n  let [r_min_min_, c_min_min_] = [0, 0]\n  let [r_max_min_, c_max_min_] = [0, 0]\n  let [r_min_max_min_, c_min_max_min_] = [0, 0]\n  let [r_min_min_min_, c_min_min_min_] = [0, 0]\n  let [r_max_max_max_, c_max_max_max_] = [0, 0]\n  let [r_min_min_min_, c_min_min_min_] = [0, 0]\n  let [r_max_min_min_, c_max_min_min_] = [0, 0]\n  let [r_min_max_min_, c_min_max_min_] = [0, 0]\n  let [r_min_min_min_, c_min_min_min_] = [0, 0]\n  let [r_max_max_min_",
    "    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [i, j] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [i_,",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_count, buckets_count] = [0, 0]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      if (wells[i][j] === 1) {\n        wells_count++\n        buckets[i][j] = capacity\n      }\n    }\n  }\n  while (wells_count > 0) {\n    let [i, j] = find_well(wells, wells_count)\n    wells[i][j] = 0\n    buckets[i][j] -= 1\n    if (buckets[i][j] === 0) {\n      wells_count--\n    }\n    if (wells_count === 0) {\n      break\n    }\n    let [i_1, j_1] = find_well(wells, wells_count)\n    wells[i_1][j_1] = 1\n    buckets[i_1][j_1] = capacity\n  }\n  return buckets_count\n}\n\nfunction find_well(wells: number[][], wells_count: number): [number, number] {\n  let [i, j] = [0, 0]\n  let [i_1, j_1] = [0, 0]\n  let [i_2, j_2] = [0, 0]\n  let [i_3, j_3] = [0, 0]\n  let [i_4, j_4] = [0, 0]\n  let [i_5, j_5] = [0, 0]\n  let [i_6, j_6] = [0, 0]\n  let [i_7, j_7] = [0, 0]\n  let [i_8, j_8] = [0, 0]\n  let [i_9, j_9] = [0, 0]\n  let [",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let cur = 0\n      while (grid[i][j] === 1) {\n        cur += 1\n        grid[i][j] = 0\n      }\n      max = Math.max(max, cur)\n    }\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let res = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        let cur = 0\n        while (cur < max) {\n          cur += 1\n          res += 1\n        }\n      }\n    }\n  }\n  return res\n}\n",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [b, w] = [0, 0]\n  let [bk, wk] = [0, 0]\n  let [bk2, wk2] = [0, 0]\n  let [bk3, wk3] = [0, 0]\n  let [bk4, wk4] = [0, 0]\n  let [bk5, wk5] = [0, 0]\n  let [bk6, wk6] = [0, 0]\n  let [bk7, wk7] = [0, 0]\n  let [bk8, wk8] = [0, 0]\n  let [bk9, wk9] = [0, 0]\n  let [bk10, wk10] = [0, 0]\n  let [bk11, wk11] = [0, 0]\n  let [bk12, wk12] = [0, 0]\n  let [bk13, wk13] = [0, 0]\n  let [bk14, wk14] = [0, 0]\n  let [bk15, wk15] = [0, 0]\n  let [bk16, wk16] = [0, 0]\n  let [bk17, wk17] = [0, 0]\n  let [bk18, wk18] = [0, 0]\n  let [bk19, wk19] = [0, 0]\n  let [bk20, wk20] = [0, 0]\n  let [bk21, wk21] = [0, 0]\n  let [bk22, wk22] = [0, 0]\n  let [bk23, wk23] = [0, 0]\n  let [bk24, wk24] = [0, 0]\n  let [bk25, wk25] = [0, 0]\n  let [bk26, wk26] = [0, 0]\n  let [bk",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_up_left_left, buckets_up_left_left] = [[0] * cols, [0] * rows]\n  let [wells_up_left_right, buckets_up_left_right] = [[0] * cols, [0] * rows]\n  let [wells_up_right_left, buckets_up_right_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right_right, buckets_up_right_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left_left, buckets_down_left_left] = [[0] * cols, [0] * rows]\n  let [wells_down_left_right, buckets_down_left_right] = [[0] * cols, [0] * rows]\n  let [wells_down_right_left, buckets_down_right_left] = [[0] * cols, [0] * rows]",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [[0] * rows, [0] * cols];\n    let [wells_right, buckets_right] = [[0] * rows, [0] * cols];\n    let [wells_down, buckets_down] = [[0] * rows, [0] * cols];\n    let [wells_up, buckets_up] = [[0] * rows, [0] * cols];\n    let [wells_left_down, buckets_left_down] = [[0] * rows, [0] * cols];\n    let [wells_left_up, buckets_left_up] = [[0] * rows, [0] * cols];\n    let [wells_right_down, buckets_right_down] = [[0] * rows, [0] * cols];\n    let [wells_right_up, buckets_right_up] = [[0] * rows, [0] * cols];\n    let [wells_down_left, buckets_down_left] = [[0] * rows, [0] * cols];\n    let [wells_down_right, buckets_down_right] = [[0] * rows, [0] * cols];\n    let [wells_up_left, buckets_up_left] = [[0] * rows, [0] * cols];\n    let [wells_up_right, buckets_up_right] = [[0] * rows, [0] * cols];\n    let [wells_left_down_left, buckets_left_down_left] = [[0] * rows, [0] * cols];\n    let [wells_left_down_right, buckets_left_down_right] = [[0] * rows, [0] * cols];\n    let [wells_left_up_left, buckets_left_up_left] = [[0] * rows, [0] * cols];\n    let [wells_left_up_right, buckets_left_up_right] = [[0] *",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr > max) {\n        max = curr\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += max - curr\n      }\n      curr -= 1\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  let result = 0\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i]\n    let filled = 0\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        filled++\n      }\n      if (filled === capacity) {\n        result++\n        filled = 0\n      }\n    }\n  }\n  return result\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_count++;\n                wells_max = Math.max(wells_max, wells_count);\n            }\n            if (buckets[i][j] === 1) {\n                buckets_count++;\n                buckets_max = Math.max(buckets_max, buckets_count);\n            }\n        }\n    }\n    let max_fill = 0;\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_count--;\n                if (wells_count === 0) {\n                    wells_count = wells_max;\n                }\n                max_fill += wells_count;\n            }\n            if (buckets[i][j] === 1) {\n                buckets_count--;\n                if (buckets_count === 0) {\n                    buckets_count = buckets_max;\n                }\n                max_fill += buckets_count;\n            }\n        }\n    }\n    return max_fill;\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = 0\n    }\n  }\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  while (wells_filled_count < wells.length) {\n    let [wells_filled_count, buckets_filled_count] = fill(wells, buckets, wells_filled, buckets_filled, capacity)\n  }\n  return buckets_filled_count\n}\n\nfunction fill(wells: number[][], buckets: number[][], wells_filled: number[][], buckets_filled: number[][], capacity: number): [number, number] {\n  let [rows, cols] = wells.length\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        wells_filled[i][j] = 1\n        buckets_filled[i][j] = 0\n        wells_filled_count++\n        if (wells_filled_count === wells.length) {\n          return [wells_filled_count, buckets_filled_count]\n        }\n      } else {\n        let [wells_filled_count, buckets_filled_count] = fill_well(wells, buckets, wells_filled, buckets_filled, i, j, capacity)\n      }\n    }\n  }\n  return [wells_filled_count, buckets_filled_count]\n}\n\nfunction fill_well(wells: number[][], buckets: number[][], wells_filled: number[",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[], []]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = []\n    for (let j = 0; j < cols; j++) {\n      wells[i].push(grid[i][j])\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    buckets[i] = []\n    for (let j = 0; j < cols; j++) {\n      buckets[i].push(0)\n    }\n  }\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        let cur = 0\n        for (let k = 0; k < rows; k++) {\n          for (let l = 0; l < cols; l++) {\n            if (wells[k][l] === 1) {\n              cur += buckets[k][l]\n            }\n          }\n        }\n        if (cur > max) {\n          max = cur\n        }\n      }\n    }\n  }\n  let res = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        let cur = 0\n        for (let k = 0; k < rows; k++) {\n          for (let l = 0; l < cols; l++) {\n            if (wells[k][l] === 1) {\n              cur += buckets[k][l]\n            }\n          }\n        }\n        if (cur < max) {\n          res += max - cur\n        }\n      }\n    }\n  }\n  return res\n}\n",
    "  const n = grid.length\n  const m = grid[0].length\n  const dp = new Array(n).fill(0)\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        dp[i] = Math.max(dp[i], dfs(grid, i, j, capacity))\n      }\n    }\n  }\n  return dp.reduce((a, b) => a + b)\n}\n\nfunction dfs(grid: number[][], i: number, j: number, capacity: number): number {\n  if (i === 0 || j === 0) {\n    return 0\n  }\n  if (grid[i][j] === 0) {\n    return 0\n  }\n  if (grid[i][j] === 1) {\n    return 1\n  }\n  return Math.max(\n    dfs(grid, i - 1, j, capacity),\n    dfs(grid, i, j - 1, capacity),\n    dfs(grid, i - 1, j - 1, capacity)\n  )\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur === max) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * rows, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * rows, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * rows, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * rows, [0] * rows]\n  let [wells_diag, buckets_diag] = [[0] * rows, [0] * rows]\n  let [wells_diag_left, buckets_diag_left] = [[0] * rows, [0] * rows]\n  let [wells_diag_right, buckets_diag_right] = [[0] * rows, [0] * rows]\n  let [wells_diag_down, buckets_diag_down] = [[0] * rows, [0] * rows]\n  let [wells_diag_up, buckets_diag_up] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag, buckets_diag_diag] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag_left, buckets_diag_diag_left] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag_right, buckets_diag_diag_right] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag_down, buckets_diag_diag_down] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag_up, buckets_diag_diag_up] = [[0] * rows, [0] * rows]\n  let [wells_diag_diag_diag, buckets_diag_diag_diag] = [[0] *",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j - 1], Math.min(wells[j - 1], wells[j]))\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    wells[i] = buckets[i]\n    count += wells[i]\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "  let [rows, cols] = grid.length\n  let [rows2, cols2] = grid[0].length\n  let [rows3, cols3] = grid[0][0].length\n  let [rows4, cols4] = grid[0][0][0].length\n  let [rows5, cols5] = grid[0][0][0][0].length\n  let [rows6, cols6] = grid[0][0][0][0][0].length\n  let [rows7, cols7] = grid[0][0][0][0][0][0].length\n  let [rows8, cols8] = grid[0][0][0][0][0][0][0].length\n  let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length\n  let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length\n  let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length\n  let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows17, cols17] = grid[0][0][0][0][0][0][0][0][0][0][0",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid\n  let [wells_len, buckets_len] = wells.length\n  let [wells_rows, wells_cols] = wells\n  let [buckets_rows, buckets_cols] = buckets\n  let [wells_rows_len, wells_cols_len] = wells_len\n  let [buckets_rows_len, buckets_cols_len] = buckets_len\n  let [wells_rows_len_1, wells_cols_len_1] = wells_rows_len - 1\n  let [buckets_rows_len_1, buckets_cols_len_1] = buckets_rows_len - 1\n  let [wells_rows_len_2, wells_cols_len_2] = wells_rows_len - 2\n  let [buckets_rows_len_2, buckets_cols_len_2] = buckets_rows_len - 2\n  let [wells_rows_len_3, wells_cols_len_3] = wells_rows_len - 3\n  let [buckets_rows_len_3, buckets_cols_len_3] = buckets_rows_len - 3\n  let [wells_rows_len_4, wells_cols_len_4] = wells_rows_len - 4\n  let [buckets_rows_len_4, buckets_cols_len_4] = buckets_rows_len - 4\n  let [wells_rows_len_5, wells_cols_len_5] = wells_rows_len - 5\n  let [buckets_rows_len_5, buckets_cols_len_5] = buckets_rows_len - 5\n  let [wells_rows_len_6, wells_cols_len_6] = wells_rows_len - 6\n  let [buckets_rows_len_6, buckets_cols_len_6] = buckets_rows_len - 6\n  let [wells_rows_len_7, wells_cols_len_7] = wells_rows_len - 7\n  let [buckets",
    "    let [rows, cols] = grid.length;\n    let [r, c] = [0, 0];\n    let [r_max, c_max] = [0, 0];\n    let [r_min, c_min] = [rows, cols];\n    let [r_min_max, c_min_max] = [rows, cols];\n    let [r_min_min, c_min_min] = [rows, cols];\n    let [r_max_max, c_max_max] = [rows, cols];\n    let [r_max_min, c_max_min] = [rows, cols];\n    let [r_min_max_max, c_min_max_max] = [rows, cols];\n    let [r_min_min_max, c_min_min_max] = [rows, cols];\n    let [r_max_max_max, c_max_max_max] = [rows, cols];\n    let [r_max_min_max, c_max_min_max] = [rows, cols];\n    let [r_min_max_min, c_min_max_min] = [rows, cols];\n    let [r_min_min_min, c_min_min_min] = [rows, cols];\n    let [r_max_max_min, c_max_max_min] = [rows, cols];\n    let [r_max_min_min, c_max_min_min] = [rows, cols];\n    let [r_min_max_min_min, c_min_max_min_min] = [rows, cols];\n    let [r_min_min_min_min, c_min_min_min_min] = [rows, cols];\n    let [r_max_max_min_min, c_max_max_min_min] = [rows, cols];\n    let [r_max_min_min_min, c_max_min_min_min] = [rows, cols];\n    let [r_min_max_min_min_min,",
    "  let [rows, cols] = grid.length\n  let [rows2, cols2] = grid[0].length\n  let [rows3, cols3] = grid[0][0].length\n  let [rows4, cols4] = grid[0][0][0].length\n  let [rows5, cols5] = grid[0][0][0][0].length\n  let [rows6, cols6] = grid[0][0][0][0][0].length\n  let [rows7, cols7] = grid[0][0][0][0][0][0].length\n  let [rows8, cols8] = grid[0][0][0][0][0][0][0].length\n  let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length\n  let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length\n  let [rows11, cols11] = grid[0][0][0][0][0][0][0][0][0][0].length\n  let [rows12, cols12] = grid[0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows17, cols17] = grid[0][0][0][0][0][0][0][0][0][0][0",
    "  let [rows, cols] = grid.length\n  let [row, col] = [0, 0]\n  let [max_fill, max_fill_row, max_fill_col] = [0, 0, 0]\n  let [max_fill_row_col, max_fill_row_col_row, max_fill_row_col_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col, max_fill_row_col_row_col_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row, max_fill_row_col_row_col_row_col_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0]\n  let [max_fill_row_col_row_col_row_col_row_",
    "    let [rows, cols] = grid.length;\n    let [row, col] = [0, 0];\n    let [max_fill, max_fill_row, max_fill_col] = [0, 0, 0];\n    let [max_fill_row_col, max_fill_row_col_row, max_fill_row_col_row_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row, max_fill_row_col_row_col_row_col_row_col_row] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_used, buckets_used] = [[0] * rows, [0] * cols];\n    let max_fill = 0;\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (wells[i][j] === 1) {\n                wells_used[i][j] = 1;\n                buckets_used[i][j] = 0;\n                while (wells_used[i][j] < wells[i][j]) {\n                    let [well_used, bucket_used] = max_fill_well(wells, buckets, i, j, capacity);\n                    wells_used[i][j] += well_used;\n                    buckets_used[i][j] += bucket_used;\n                    max_fill += well_used;\n                }\n            }\n        }\n    }\n    return max_fill;\n}\n\nfunction max_fill_well(wells: number[][], buckets: number[][], i: number, j: number, capacity: number): [number, number] {\n    let [well_used, bucket_used] = [0, 0];\n    let [wells_used, buckets_used] = [wells[i][j] - wells_used, buckets[i][j] - buckets_used];\n    while (wells_used < wells[i][j] && buckets_used < capacity) {\n        let [well_used, bucket_used] = max_fill_bucket(wells, buckets, i, j, capacity);\n        wells_used += well_used;\n        buckets_used += bucket_used;\n    }\n    return [well_used, bucket_used];\n}\n\nfunction max_fill_bucket(wells: number[][], buckets: number[][], i: number, j: number, capacity: number): [number, number] {\n    let [well_used, bucket_used] = [0, 0];\n    let [wells_used, buckets_used]",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr > max) {\n        max = curr\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr === max) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let well = grid[i]\n    let buckets = []\n    for (let j = 0; j < well.length; j++) {\n      if (well[j] === 1) {\n        buckets.push(0)\n      } else {\n        buckets.push(capacity)\n      }\n    }\n    let filled = 0\n    while (filled < well.length) {\n      let bucket = buckets.shift()\n      if (bucket === 0) {\n        filled++\n      } else {\n        filled += bucket\n      }\n      max = Math.max(max, filled)\n    }\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[], []]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = []\n    for (let j = 0; j < cols; j++) {\n      wells[i].push(grid[i][j])\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    buckets[i] = []\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        buckets[i].push(capacity)\n      }\n    }\n  }\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    let cur = 0\n    for (let j = 0; j < cols; j++) {\n      let left = buckets[i][j]\n      let right = buckets[i][j + 1]\n      if (left > right) {\n        cur += left - right\n      } else {\n        cur += left\n      }\n    }\n    max = Math.max(max, cur)\n  }\n  return max\n}\n",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n      }\n      if (buckets[i] > max) {\n        max = buckets[i]\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        count += max - buckets[i]\n      }\n      buckets[i] = 0\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[1].length\n  let [rows3, cols3] = grid[2].length\n  let [rows4, cols4] = grid[3].length\n  let [rows5, cols5] = grid[4].length\n  let [rows6, cols6] = grid[5].length\n  let [rows7, cols7] = grid[6].length\n  let [rows8, cols8] = grid[7].length\n  let [rows9, cols9] = grid[8].length\n  let [rows10, cols10] = grid[9].length\n  let [rows11, cols11] = grid[10].length\n  let [rows12, cols12] = grid[11].length\n  let [rows13, cols13] = grid[12].length\n  let [rows14, cols14] = grid[13].length\n  let [rows15, cols15] = grid[14].length\n  let [rows16, cols16] = grid[15].length\n  let [rows17, cols17] = grid[16].length\n  let [rows18, cols18] = grid[17].length\n  let [rows19, cols19] = grid[18].length\n  let [rows20, cols20] = grid[19].length\n  let [rows21, cols21] = grid[20].length\n  let [rows22, cols22] = grid[21].length\n  let [rows23, cols23] = grid[22].length\n  let [rows24, cols24] = grid[23].length\n  let [rows25, cols25] = grid[24].length\n  let [rows26, cols26] = grid[25].length\n  let [rows27, cols27] = grid[26].length\n  let [rows28, cols28] = grid[27].length\n  let [rows29, cols29] = grid[28].length\n  let [rows30,",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid.map(row => row.map(v => v === 1));\n    let [wells_left, buckets_left] = wells.map(row => row.map(v => v === 1));\n    let [wells_right, buckets_right] = wells.map(row => row.map(v => v === 0));\n    let [wells_up, buckets_up] = wells.map(row => row.map(v => v === 0));\n    let [wells_down, buckets_down] = wells.map(row => row.map(v => v === 1));\n    let [wells_left_up, buckets_left_up] = wells_left.map(row => row.map(v => v === 1));\n    let [wells_left_down, buckets_left_down] = wells_left.map(row => row.map(v => v === 0));\n    let [wells_right_up, buckets_right_up] = wells_right.map(row => row.map(v => v === 1));\n    let [wells_right_down, buckets_right_down] = wells_right.map(row => row.map(v => v === 0));\n    let [wells_up_left, buckets_up_left] = wells_up.map(row => row.map(v => v === 1));\n    let [wells_up_right, buckets_up_right] = wells_up.map(row => row.map(v => v === 0));\n    let [wells_down_left, buckets_down_left] = wells_down.map(row => row.map(v => v === 1));\n    let [wells_down_right, buckets_down_right] = wells_down.map(row => row.map(v => v === 0));\n    let [wells_left_up_left, buckets_left_up_left] = wells_left_up.map(row => row.map(v => v === 1));\n    let [wells_left_up_right, buckets_left_up_right] = wells",
    "  const [rows, cols] = grid.length\n  const [wells, buckets] = grid.map(row => row.length)\n  const [wells_per_bucket, buckets_per_well] = [wells / buckets, buckets / wells]\n  const [wells_per_row, cols_per_well] = [wells_per_bucket, cols / wells]\n  const [wells_per_col, rows_per_well] = [wells_per_row, rows / wells]\n  const [wells_per_well, wells_per_row] = [wells_per_col, rows_per_well]\n  const [wells_per_bucket, buckets_per_well] = [wells_per_well, buckets / wells]\n  const [wells_per_row, cols_per_well] = [wells_per_bucket, cols / wells]\n  const [wells_per_col, rows_per_well] = [wells_per_row, rows / wells]\n  const [wells_per_well, wells_per_row] = [wells_per_col, rows_per_well]\n  const [wells_per_bucket, buckets_per_well] = [wells_per_well, buckets / wells]\n  const [wells_per_row, cols_per_well] = [wells_per_bucket, cols / wells]\n  const [wells_per_col, rows_per_well] = [wells_per_row, rows / wells]\n  const [wells_per_well, wells_per_row] = [wells_per_col, rows_per_well]\n  const [wells_per_bucket, buckets_per_well] = [wells_per_well, buckets / wells]\n  const [wells_per_row, cols_per_well] = [wells_per_bucket, cols / wells]\n  const [wells_per_col, rows_per_well] = [wells_per_row, rows / wells]\n  const [wells_per_well",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_",
    "    let [n, m] = grid.length;\n    let [m, n] = grid[0].length;\n    let [i, j] = [0, 0];\n    let [i_, j_] = [0, 0];\n    let [max_fill, max_fill_] = [0, 0];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                i_ = i;\n                j_ = j;\n            }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                let [i_, j_] = [i, j];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_];\n                let [i_, j_] = [i_, j_",
    "  let [rows, cols] = grid.length\n  let [rows_, cols_] = grid[0].length\n  let [buckets, wells] = [[0] * cols, [0] * rows]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n  let [wells_, buckets_] = [[0] * cols_, [0] * rows_]\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [rows, cols];\n    let [wells_max_index, buckets_max_index] = [0, 0];\n    let [wells_min_index, buckets_min_index] = [0, 0];\n    let [wells_max_index_count, buckets_max_index_count] = [0, 0];\n    let [wells_min_index_count, buckets_min_index_count] = [0, 0];\n    let [wells_max_index_count_count, buckets_max_index_count_count] = [0, 0];\n    let [wells_min_index_count_count, buckets_min_index_count_count] = [0, 0];\n    let [wells_max_index_count_count_count, buckets_max_index_count_count_count] = [0, 0];\n    let [wells_min_index_count_count_count, buckets_min_index_count_count_count] = [0, 0];\n    let [wells_max_index_count_count_count_count, buckets_max_index_count_count_count_count] = [0, 0];\n    let [wells_min_index_count_count_count_count, buckets_min_index_count_count_count_count] = [0, 0];\n    let [wells_max_index_count_count_count_count_count, buckets_max_index_count_count_count_count_count] = [0, 0];\n    let [wells_min_index_count_count_count_count_count_count, buckets_min_index_count_count_count_count_count_count] = [0, 0];\n    let [wells_max_index_count_count_count_count_count_count_count, buckets_max_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid\n  let [wells_per_row, wells_per_col] = [rows, cols]\n  let [wells_per_row_per_well, wells_per_col_per_well] = [wells_per_row, wells_per_col]\n  let [wells_per_row_per_well_per_well, wells_per_col_per_well_per_well] = [wells_per_row_per_well, wells_per_col_per_well]\n  let [wells_per_row_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well] = [wells_per_row_per_well_per_well, wells_per_col_per_well_per_well]\n  let [wells_per_row_per_well_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well_per_well] = [wells_per_row_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well]\n  let [wells_per_row_per_well_per_well_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well_per_well_per_well] = [wells_per_row_per_well_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well_per_well]\n  let [wells_per_row_per_well_per_well_per_well_per_well_per_well_per_well, wells_per_col_per_well_per_well_per_well_per_well_per_well_per_well] = [wells_per_row_per_well_per_well_per_well_per_well_per_well, wells_per_col_per_well_per",
    "    let [n, m] = grid.length\n    let [i, j] = [0, 0]\n    let [x, y] = [0, 0]\n    let [s, t] = [0, 0]\n    let [a, b] = [0, 0]\n    let [c, d] = [0, 0]\n    let [e, f] = [0, 0]\n    let [g, h] = [0, 0]\n    let [i1, j1] = [0, 0]\n    let [i2, j2] = [0, 0]\n    let [i3, j3] = [0, 0]\n    let [i4, j4] = [0, 0]\n    let [i5, j5] = [0, 0]\n    let [i6, j6] = [0, 0]\n    let [i7, j7] = [0, 0]\n    let [i8, j8] = [0, 0]\n    let [i9, j9] = [0, 0]\n    let [i10, j10] = [0, 0]\n    let [i11, j11] = [0, 0]\n    let [i12, j12] = [0, 0]\n    let [i13, j13] = [0, 0]\n    let [i14, j14] = [0, 0]\n    let [i15, j15] = [0, 0]\n    let [i16, j16] = [0, 0]\n    let [i17, j17] = [0, 0]\n    let [i18, j18] = [0, 0]\n    let [i19, j19] = [0, 0]\n    let [i20, j20] = [0, 0]\n    let [i21, j21] = [0, 0]\n    let [i22, j22] = [0, 0]\n    let [i23, j23] = [0, 0]\n    let [i24, j24] = [0, 0]\n    let [i25, j25] = [0, 0]\n    let",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr > max) {\n        max = curr\n      }\n    }\n  }\n  let curr = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n        if (curr > max) {\n          max = curr\n        }\n        if (curr === capacity) {\n          curr = 0\n        }\n      }\n    }\n  }\n  return max\n}\n",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_, c_] = [0, 0]\n  let [r_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * rows, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * rows, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * rows, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * rows, [0] * rows]\n  let [wells_diag, buckets_diag] = [[0] * rows, [0] * rows]\n  let [wells_diag_left, buckets_diag_left] = [[0] * rows, [0] * rows]\n  let [wells_diag_right, buckets_diag_right] = [[0] * rows, [0] * rows]\n  let [wells_diag_down, buckets_diag_down] = [[0] * rows, [0] * rows]\n  let [wells_diag_up, buckets_diag_up] = [[0] * rows, [0] * rows]\n  let [wells_diag_left_down, buckets_diag_left_down] = [[0] * rows, [0] * rows]\n  let [wells_diag_right_down, buckets_diag_right_down] = [[0] * rows, [0] * rows]\n  let [wells_diag_left_up, buckets_diag_left_up] = [[0] * rows, [0] * rows]\n  let [wells_diag_right_up, buckets_diag_right_up] = [[0] * rows, [0] * rows]\n  let [wells_diag_down_left, buckets_diag_down_left] = [[0] * rows, [0] * rows]\n  let [wells_diag_down_right, buckets_diag_down_right] = [[0] * rows, [0] * rows]\n  ",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_len, buckets_len] = grid[0].length;\n    let [wells_len_2, buckets_len_2] = grid[0][0].length;\n    let [wells_len_3, buckets_len_3] = grid[0][0][0].length;\n    let [wells_len_4, buckets_len_4] = grid[0][0][0][0].length;\n    let [wells_len_5, buckets_len_5] = grid[0][0][0][0][0].length;\n    let [wells_len_6, buckets_len_6] = grid[0][0][0][0][0][0].length;\n    let [wells_len_7, buckets_len_7] = grid[0][0][0][0][0][0][0].length;\n    let [wells_len_8, buckets_len_8] = grid[0][0][0][0][0][0][0][0].length;\n    let [wells_len_9, buckets_len_9] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [wells_len_10, buckets_len_10] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [wells_len_11, buckets_len_11] = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [wells_len_12, buckets_len_12] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [wells_len_13, buckets_len_13] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [wells_len_14, buckets_len_14] = grid[0][0",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let count = 0;\n      while (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n      max = Math.max(max, count);\n    }\n  }\n  return max;\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_per_bucket, buckets_per_well] = [wells / buckets, buckets / wells]\n  let [wells_per_row, buckets_per_row] = [wells_per_bucket, buckets_per_well]\n  let [wells_per_col, buckets_per_col] = [wells_per_row, buckets_per_row]\n  let [wells_per_well, buckets_per_well] = [wells_per_row, buckets_per_row]\n  let [wells_per_bucket, buckets_per_well] = [wells_per_row, buckets_per_row]\n  let [wells_per_row, buckets_per_row] = [wells_per_well, buckets_per_well]\n  let [wells_per_col, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_bucket, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_row, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_col, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_well, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_bucket, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_row, buckets_per_well] = [wells_per_well, buckets_per_well]\n  let [wells_per_col, buckets_per_well] = [wells_per_well, buckets_per_well",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let cur = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                cur += capacity;\n            }\n            if (cur > max) {\n                max = cur;\n            }\n        }\n    }\n    return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [rows, cols];\n    let [wells_max_count, buckets_max_count] = [0, 0];\n    let [wells_min_count, buckets_min_count] = [0, 0];\n    let [wells_max_max, buckets_max_max] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_min, buckets_max_min] = [0, 0];\n    let [wells_min_max, buckets_min_max] = [0, 0];\n    let [wells_max_min, buckets_max_min] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_max, buckets_max_max] = [0, 0];\n    let [wells_min_max, buckets_min_max] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_min, buckets_max_min] = [0, 0];\n    let [wells_min_max, buckets_min_max] = [0, 0];\n    let [wells_max_min, buckets_max_min] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_max, buckets_max_max] = [0, 0];\n    let [wells_min_max, buckets_min_max] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_max, buckets_max_",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  const visited = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] === capacity) {\n          max += 1\n          visited[i] = 1\n        }\n      }\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    if (visited[i] === 0) {\n      buckets[i] -= 1\n    }\n  }\n  return max\n}\n",
    "  const n = grid.length\n  const m = grid[0].length\n  let i = 0\n  let j = 0\n  let count = 0\n  while (i < n && j < m) {\n    if (grid[i][j] === 1) {\n      count += 1\n      i += 1\n      j += 1\n    } else {\n      count += 1\n      i += 1\n    }\n  }\n  return count\n}\n",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = 0\n    }\n  }\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let cur = wells[i][j]\n      let next = wells[i][j] + 1\n      while (next > 0) {\n        let cur_bucket = buckets[i][j]\n        let next_bucket = buckets[i][j] + 1\n        if (next_bucket <= capacity) {\n          next_bucket = Math.min(next_bucket, capacity - cur_bucket)\n          next -= 1\n          cur_bucket += next_bucket\n          if (cur_bucket > max) max = cur_bucket\n        } else {\n          break\n        }\n      }\n    }\n  }\n  return max\n}\n",
    "    let [rows, cols] = grid.length;\n    let [r, c] = [0, 0];\n    let [max_fill, max_fill_row, max_fill_col] = [0, 0, 0];\n    let [max_fill_row_cnt, max_fill_col_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt, max_fill_col_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt_cnt_cnt_cnt_cnt] = [0, 0];\n    let [max_fill_row_cnt_cnt_cnt_cnt_cnt_cnt_cnt_cnt_cnt, max_fill_col_cnt_cnt_cnt_cnt_cnt_cnt_cnt_c",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      if (wells[j] === 1) {\n        buckets[j] = Math.min(buckets[j], buckets[j - 1])\n      } else {\n        buckets[j] = Math.min(buckets[j], buckets[j - 1] + 1)\n      }\n    }\n  }\n  let result = 0\n  for (let i = 0; i < rows; i++) {\n    if (wells[i] === 1) {\n      result += buckets[i]\n    }\n  }\n  return result\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr > max) {\n        max = curr\n      }\n    }\n  }\n  let curr = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        curr += 1\n      }\n      if (curr > max) {\n        max = curr\n      }\n    }\n  }\n  return max\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let cur = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                cur += 1;\n            }\n            if (cur > max) {\n                max = cur;\n            }\n        }\n    }\n    return max;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_count_max, buckets_filled_count_max] = [0, 0];\n    let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_max, buckets_max] = [0, 0];\n    let [wells_min, buckets_min] = [0, 0];\n    let [wells_max_count, buckets_max_count] = [0, 0];\n    let [wells_min_count, buckets_min_count] = [0, 0];\n    let [wells_max_filled, buckets_max_filled] = [0, 0];\n    let [wells_min_filled, buckets_min_filled] = [0, 0];\n    let [wells_max_max, buckets_max_max] = [0, 0];\n    let [wells_min_min, buckets_min_min] = [0, 0];\n    let [wells_max_min, buckets_max_min] = [0, 0];\n    let [wells_max_max_count, buckets_max_max_count] = [0, 0];\n    let [wells_min_min_count, buckets_min_min_count] = [0, 0];\n    let [wells_max_min_count, buckets_max_min_count] = [0, 0];\n    let [wells_max_max_filled, buckets_max_max_filled] = [0, 0];\n    let [wells_min_min_filled, buckets_min_min_filled] = [0, 0];\n    let [wells_max_min_filled, buckets_max_min_filled] = [0, 0];\n    let [wells_max_max_max, buckets_max_max_max] = [0, 0];\n    let [wells_min_min_min, buckets_min_min_min] = [0, 0];\n    let [wells_max_max_min, buckets_max_max_min] = [0, 0];\n    let [wells_",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1 && buckets[i] === max) {\n        count += 1\n        buckets[i] -= 1\n        if (buckets[i] === 0) {\n          buckets[i] = capacity\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "  const buckets = new Array(grid.length).fill(0);\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += capacity;\n      }\n      if (buckets[i] > max) {\n        max = buckets[i];\n      }\n    }\n  }\n  return max;\n}",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] = grid[i][j]\n      buckets[i][j] = 0\n    }\n  }\n  let filled = 0\n  while (filled < rows * cols) {\n    let [i, j] = find_well(wells, capacity)\n    if (wells[i][j] === 0) {\n      break\n    }\n    wells[i][j] = 0\n    buckets[i][j]++\n    filled++\n  }\n  let result = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 0) {\n        result += buckets[i][j]\n      }\n    }\n  }\n  return result\n}\n\nfunction find_well(wells: number[][], capacity: number): [number, number] {\n  let [rows, cols] = wells.length\n  let [i, j] = [0, 0]\n  while (wells[i][j] !== 0) {\n    i = (i + 1) % rows\n    j = (j + 1) % cols\n  }\n  while (wells[i][j] === 0) {\n    i = (i + 1) % rows\n    j = (j + 1) % cols\n  }\n  while (wells[i][j] !== 0) {\n    i = (i + 1) % rows\n    j = (j + 1) % cols\n  }\n  while (wells[i][j] === 0) {\n    i = (i + 1) % rows\n    j = (j + 1) % cols\n  }\n  while (wells[i][j] !== 0) {\n    i = (i + 1) % rows\n    j",
    "  let [wells, buckets] = [[], []];\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      wells[i][j] = grid[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(0);\n      }\n    }\n  }\n  let [wells, buckets] = [[], []];\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      wells[i][j] = wells[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(0);\n      }\n    }\n  }\n  let [wells, buckets] = [[], []];\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      wells[i][j] = wells[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(0);\n      }\n    }\n  }\n  let [wells, buckets] = [[], []];\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      wells[i][j] = wells[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(0);\n      }\n    }\n  }\n  let [wells, buckets] = [[], []];\n  for (let i = 0; i < wells.length; i++) {\n    for (let j = 0; j < wells[i].length; j++) {\n      wells[i][j] = wells[i][j];\n      if (wells[i][j] === 1) {\n        buckets.push(0);\n      }\n    }\n  }\n  let [wells, buckets",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_max, buckets_filled_max] = [0, 0];\n    let [wells_filled_max_count, buckets_filled_max_count] = [0, 0];\n    let [wells_filled_max_count_count, buckets_filled_max_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count, buckets_filled_max_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count, buckets_filled_max_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count, buckets_filled_max_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count_count, buckets_filled_max_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count_count_count, buckets_filled_max_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count_count_count_count, buckets_filled_max_count_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count_count_count_count_count, buckets_filled_max_count_count_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * rows, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * rows, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * rows, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * rows, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * rows, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * rows, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * rows, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * rows, [0] * rows]\n  let [wells_up_left_left, buckets_up_left_left] = [[0] * rows, [0] * rows]\n  let [wells_up_left_right, buckets_up_left_right] = [[0] * rows, [0] * rows]\n  let [wells_up_right_left, buckets_up_right_left] = [[0] * rows, [0] * rows]\n  let [wells_up_right_right, buckets_up_right_right] = [[0] * rows, [0] * rows]\n  let [wells_down_left_left, buckets_down_left_left] = [[0] * rows, [0] * rows]\n  let [wells_down_left_right, buckets_down_left_right] = [[0] * rows, [0] * rows]\n  let [wells_down_right_left, buckets_down_right_left] = [[0] * rows, [0] * rows]\n  let [wells_down_right_right, buckets_down",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_filled, buckets_filled] = [[0] * rows, [0] * cols];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_count_max, buckets_filled_count_max] = [0, 0];\n    let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let count = 0;\n      while (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n        if (count === capacity) {\n          max++;\n          count = 0;\n        }\n      }\n    }\n  }\n  return max;\n}\n",
    "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let buckets = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        let bucket = {\n          water: 0,\n          capacity: capacity\n        };\n        buckets.push(bucket);\n      }\n    }\n    let max = 0;\n    for (let j = 0; j < buckets.length; j++) {\n      let bucket = buckets[j];\n      if (bucket.water > max) {\n        max = bucket.water;\n      }\n    }\n    result += max;\n    for (let j = 0; j < buckets.length; j++) {\n      let bucket = buckets[j];\n      bucket.water -= max;\n    }\n  }\n  return result;\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      } else {\n        cur = 0\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += max\n      }\n    }\n  }\n  return count\n}\n",
    "    let max = 0;\n    let max_well = 0;\n    let max_bucket = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            let well = grid[i][j];\n            let bucket = 0;\n            while (well > 0) {\n                if (well >= capacity) {\n                    well -= capacity;\n                    bucket += capacity;\n                } else {\n                    well = 0;\n                }\n            }\n            if (bucket > max_bucket) {\n                max_bucket = bucket;\n                max_well = i;\n            }\n        }\n    }\n    return max_bucket;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_right, buckets_right] = [rows, cols];\n    let [wells_up, buckets_up] = [rows, cols];\n    let [wells_down, buckets_down] = [rows, cols];\n    let [wells_left_up, buckets_left_up] = [rows, cols];\n    let [wells_left_down, buckets_left_down] = [rows, cols];\n    let [wells_right_up, buckets_right_up] = [rows, cols];\n    let [wells_right_down, buckets_right_down] = [rows, cols];\n    let [wells_up_left, buckets_up_left] = [rows, cols];\n    let [wells_up_right, buckets_up_right] = [rows, cols];\n    let [wells_down_left, buckets_down_left] = [rows, cols];\n    let [wells_down_right, buckets_down_right] = [rows, cols];\n    let [wells_left_up_left, buckets_left_up_left] = [rows, cols];\n    let [wells_left_up_right, buckets_left_up_right] = [rows, cols];\n    let [wells_left_down_left, buckets_left_down_left] = [rows, cols];\n    let [wells_left_down_right, buckets_left_down_right] = [rows, cols];\n    let [wells_right_up_left, buckets_right_up_left] = [rows, cols];\n    let [wells_right_up_right, buckets_right_up_right] = [rows, cols];\n    let [wells_right_down_left, buckets_right_down_left] = [rows, cols];\n    let [wells_right_down_right, buckets_right_down_",
    "  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = new Array(rows).fill(0)\n  let max = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1 && buckets[i] === max) {\n        count += 1\n        buckets[i] -= 1\n        if (buckets[i] === 0) {\n          buckets[i] = capacity\n        }\n      }\n    }\n  }\n  return count\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_index, buckets_index] = [0, 0];\n    let [wells_capacity, buckets_capacity] = [0, 0];\n    let [wells_full, buckets_full] = [0, 0];\n    let [wells_empty, buckets_empty] = [0, 0];\n    let [wells_full_count, buckets_full_count] = [0, 0];\n    let [wells_empty_count, buckets_empty_count] = [0, 0];\n    let [wells_full_index, buckets_full_index] = [0, 0];\n    let [wells_empty_index, buckets_empty_index] = [0, 0];\n    let [wells_full_capacity, buckets_full_capacity] = [0, 0];\n    let [wells_empty_capacity, buckets_empty_capacity] = [0, 0];\n    let [wells_full_full, buckets_full_full] = [0, 0];\n    let [wells_full_empty, buckets_full_empty] = [0, 0];\n    let [wells_empty_full, buckets_empty_full] = [0, 0];\n    let [wells_empty_empty, buckets_empty_empty] = [0, 0];\n    let [wells_full_full_count, buckets_full_full_count] = [0, 0];\n    let [wells_full_empty_count, buckets_full_empty_count] = [0, 0];\n    let [wells_empty_full_count, buckets_empty_full_count] = [0, 0];\n    let [wells_empty_empty_count, buckets_empty_empty_count] = [0, 0];\n    let [wells_full_full_index, buckets_full_full_index] = [0, 0];\n    let [wells_full_empty_index, buckets_full_empty_index] = [0, 0];",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_max, buckets_filled_max] = [0, 0];\n    let [wells_filled_min, buckets_filled_min] = [rows, cols];\n    let [wells_filled_max_count, buckets_filled_max_count] = [0, 0];\n    let [wells_filled_min_count, buckets_filled_min_count] = [rows, cols];\n    let [wells_filled_max_count_count, buckets_filled_max_count_count] = [0, 0];\n    let [wells_filled_min_count_count, buckets_filled_min_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count, buckets_filled_max_count_count_count] = [0, 0];\n    let [wells_filled_min_count_count_count, buckets_filled_min_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count, buckets_filled_max_count_count_count_count] = [0, 0];\n    let [wells_filled_min_count_count_count_count_count, buckets_filled_min_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_count_count_count_count_count_count, buckets_filled_max_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_min_count_count_count_count_count_count_count, buckets_filled_min_count_count_count_count_count_count_count] = [0, 0];\n    let [wells_filled_max_",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let cur = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                cur += 1;\n            }\n            if (cur > max) {\n                max = cur;\n            }\n            if (cur === capacity) {\n                cur = 0;\n            }\n        }\n    }\n    return max;\n}\n",
    "  let max = 0;\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        let left = 0;\n        let right = 0;\n        let top = 0;\n        let bottom = 0;\n        if (i > 0) {\n          left = grid[i - 1][j];\n        }\n        if (i < grid.length - 1) {\n          right = grid[i + 1][j];\n        }\n        if (j > 0) {\n          top = grid[i][j - 1];\n        }\n        if (j < grid[i].length - 1) {\n          bottom = grid[i][j + 1];\n        }\n        if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n          max = Math.max(max, count);\n        } else if (left === 0 && right === 0 && top === 0 && bottom === 1) {\n          count--;\n        } else if (left === 0 && right === 1 && top === 0 && bottom === 0) {\n          count--;\n        } else if (left === 0 && right === 0 && top === 1 && bottom === 0) {\n          count--;\n        } else if (left === 0 && right === 0 && top === 0 && bottom === 1) {\n          count--;\n        } else if (left === 1 && right === 0 && top === 0 && bottom === 0) {\n          count--;\n        } else if (left === 0 && right === 1 && top === 1 && bottom === 0) {\n          count--;\n        } else if (left === 0 && right === 0 && top === 0 && bottom === 1) {\n          count--;\n        } else if (left === 1 && right === 0 && top === 1 && bottom === 0) {\n          count--;\n        } else if (left === 0 && right === 1 && top === 0 && bottom === 1) {\n          count--;\n        } else if (left === 1 && right === 1 && top === 0 && bottom === 1) {\n",
    "  let n = grid.length\n  let m = grid[0].length\n  let buckets = []\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets.push(0)\n      }\n    }\n  }\n  let max = 0\n  let count = 0\n  while (buckets.length > 0) {\n    let max_bucket = buckets.shift()\n    let max_well = buckets.shift()\n    let max_well_index = 0\n    let max_well_count = 0\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        if (grid[i][j] === 1 && buckets[i] === 0) {\n          buckets[i] = max_bucket\n          max_well_index = i\n          max_well_count = 1\n        } else if (grid[i][j] === 1 && buckets[i] === max_bucket && j === max_well) {\n          max_well_count += 1\n        }\n      }\n    }\n    if (max_well_count > max) {\n      max = max_well_count\n    }\n    count += max_well_count\n  }\n  return count\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_per_row, wells_per_col] = [rows, cols];\n    let [buckets_per_row, buckets_per_col] = [rows, cols];\n    let [wells_per_row_filled, wells_per_col_filled] = [0, 0];\n    let [buckets_per_row_filled, buckets_per_col_filled] = [0, 0];\n    let [wells_per_row_filled_count, wells_per_col_filled_count] = [0, 0];\n    let [buckets_per_row_filled_count, buckets_per_col_filled_count] = [0, 0];\n    let [wells_per_row_filled_count_max, wells_per_col_filled_count_max] = [0, 0];\n    let [buckets_per_row_filled_count_max, buckets_per_col_filled_count_max] = [0, 0];\n    let [wells_per_row_filled_count_max_max, wells_per_col_filled_count_max_max] = [0, 0];\n    let [buckets_per_row_filled_count_max_max, buckets_per_col_filled_count_max_max] = [0, 0];\n    let [wells_per_row_filled_count_max_max_max, wells_per_col_filled_count_max_max_max] = [0, 0];\n    let [buckets_per_row_filled_count_max_max_max, buckets_per_col_filled_count_max_max_max] = [0, 0];\n    let [wells_per_row_filled_count_max_max_max_max, wells_per_col_filled_count_max_max_max_max] = [0, 0];\n    let [buckets_per_row_filled_count_max_max_max_max, buckets_per_col_filled_count_max_max_max_max] =",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [max_fill, max_fill_row, max_fill_col] = [0, 0, 0]\n  let [max_fill_row_cnt, max_fill_col_cnt] = [0, 0]\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        let [r_cnt, c_cnt] = [0, 0]\n        let [r_cnt_row, r_cnt_col] = [0, 0]\n        let [r_cnt_row_cnt, r_cnt_col_cnt] = [0, 0]\n\n        for (let k = i - 1; k <= i + 1; k++) {\n          for (let l = j - 1; l <= j + 1; l++) {\n            if (k >= 0 && k < rows && l >= 0 && l < cols) {\n              if (grid[k][l] === 1) {\n                r_cnt += 1\n                r_cnt_row += 1\n                r_cnt_row_cnt += 1\n              }\n            }\n          }\n        }\n\n        for (let k = i - 1; k <= i + 1; k++) {\n          for (let l = j - 1; l <= j + 1; l++) {\n            if (k >= 0 && k < rows && l >= 0 && l < cols) {\n              if (grid[k][l] === 0) {\n                c_cnt += 1\n                c_cnt_col += 1\n                c_cnt_col_cnt += 1\n              }\n            }\n          }\n        }\n\n        if (r_cnt_row_cnt > max_fill_row_cnt) {\n          max_fill_row = i\n          max_fill_row_cnt = r_cnt_row_cnt\n        }\n\n        if (c_cnt_col_cnt > max",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [[0] * cols, [0] * cols];\n    let [wells_right, buckets_right] = [[0] * cols, [0] * cols];\n    let [wells_up, buckets_up] = [[0] * rows, [0] * rows];\n    let [wells_down, buckets_down] = [[0] * rows, [0] * rows];\n    let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * cols];\n    let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * cols];\n    let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * cols];\n    let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * cols];\n    let [wells_left_up, buckets_left_up] = [[0] * rows, [0] * rows];\n    let [wells_left_down, buckets_left_down] = [[0] * rows, [0] * rows];\n    let [wells_right_up, buckets_right_up] = [[0] * rows, [0] * rows];\n    let [wells_right_down, buckets_right_down] = [[0] * rows, [0] * rows];\n    let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * cols];\n    let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * cols];\n    let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * cols];\n    let [wells_up_right_down, buckets_up_right_down] = [[",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_count, buckets_count] = [0, 0];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_empty, buckets_empty] = [0, 0];\n    let [wells_full, buckets_full] = [0, 0];\n    let [wells_empty_count, buckets_empty_count] = [0, 0];\n    let [wells_full_count, buckets_full_count] = [0, 0];\n    let [wells_full_count_2, buckets_full_count_2] = [0, 0];\n    let [wells_full_count_3, buckets_full_count_3] = [0, 0];\n    let [wells_full_count_4, buckets_full_count_4] = [0, 0];\n    let [wells_full_count_5, buckets_full_count_5] = [0, 0];\n    let [wells_full_count_6, buckets_full_count_6] = [0, 0];\n    let [wells_full_count_7, buckets_full_count_7] = [0, 0];\n    let [wells_full_count_8, buckets_full_count_8] = [0, 0];\n    let [wells_full_count_9, buckets_full_count_9] = [0, 0];\n    let [wells_full_count_10, buckets_full_count_10] = [0, 0];\n    let [wells_full_count_11, buckets_full_count_11] = [0, 0];\n    let [wells_full_count_12, buckets_full_count_12] = [0, 0];\n    let [wells_full_count_13, buckets_full_count_13] = [0, 0];\n    let [wells_full_count_14, buckets_full_count_14] = [0, 0];\n    let [wells_full_count_15, buckets",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.length)\n  let [wells_left, buckets_left] = [[0] * wells, [0] * buckets]\n  let [wells_right, buckets_right] = [[0] * wells, [0] * buckets]\n  let [wells_up, buckets_up] = [[0] * wells, [0] * buckets]\n  let [wells_down, buckets_down] = [[0] * wells, [0] * buckets]\n  let [wells_left_up, buckets_left_up] = [[0] * wells, [0] * buckets]\n  let [wells_left_down, buckets_left_down] = [[0] * wells, [0] * buckets]\n  let [wells_right_up, buckets_right_up] = [[0] * wells, [0] * buckets]\n  let [wells_right_down, buckets_right_down] = [[0] * wells, [0] * buckets]\n  let [wells_up_left, buckets_up_left] = [[0] * wells, [0] * buckets]\n  let [wells_up_right, buckets_up_right] = [[0] * wells, [0] * buckets]\n  let [wells_down_left, buckets_down_left] = [[0] * wells, [0] * buckets]\n  let [wells_down_right, buckets_down_right] = [[0] * wells, [0] * buckets]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * wells, [0] * buckets]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * wells, [0] * buckets]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * wells, [0] * buckets]\n  let [wells_up_right_down, buckets_up_right_down] = [[0] * wells, [0] * buckets]",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid.map(row => row.length);\n    let [wells_filled, buckets_filled] = grid.map(row => row.reduce((acc, val) => acc + val === 1 ? 1 : 0, 0));\n    let max_fill = 0;\n    for (let i = 0; i < wells; i++) {\n        let [well_filled, bucket_filled] = grid[i].reduce((acc, val) => acc + val === 1 ? 1 : 0, 0);\n        if (well_filled === wells_filled && bucket_filled === buckets_filled) {\n            max_fill += 1;\n        }\n    }\n    return max_fill;\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_left, buckets_left] = [rows, cols];\n    let [wells_filled, buckets_filled] = [0, 0];\n    let [wells_filled_count, buckets_filled_count] = [0, 0];\n    let [wells_filled_count_max, buckets_filled_count_max] = [0, 0];\n    let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0];\n    let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[0][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j - 1], wells[j - 1])\n    }\n    for (let j = 0; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j], wells[j])\n    }\n  }\n  let count = 0\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][cols - 1]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[rows - 1][i]\n    buckets[0] = capacity\n    for (let j = 1; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j - 1], wells[j - 1])\n    }\n    for (let j = 0; j < rows; j++) {\n      wells[j] = grid[j][i]\n      buckets[j] = Math.min(buckets[j], wells[j])\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n  }\n  for (let i = 1; i < cols; i++) {\n    wells[0] = grid[rows - 1][",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_filled, buckets_filled] = [[0] * cols, [0] * rows]\n  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  let [wells_filled_count_max, buckets_filled_count_max] = [0, 0]\n  let [wells_filled_count_max_index, buckets_filled_count_max_index] = [0, 0]\n  let [wells_filled_count_max_index_max, buckets_filled_count_max_index_max] = [0, 0]\n  let [wells_filled_count_max_index_max_index, buckets_filled_count_max_index_max_index] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max, buckets_filled_count_max_index_max_index_max] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max_index_max_index, buckets_filled_count_max_index_max_index_max_index_max_index] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max_index_max_index_max, buckets_filled_count_max_index_max_index_max_index_max_index_max] = [0, 0]\n  let [wells_filled_count_max_index_max_index_max_index_max_index_max_index, buckets_filled_count_max_index",
    "  const n = grid.length\n  const m = grid[0].length\n  const buckets = new Array(n).fill(0)\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i] += 1\n        if (buckets[i] > max) {\n          max = buckets[i]\n        }\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        if (buckets[i] === max) {\n          count += 1\n        }\n        buckets[i] -= 1\n      }\n    }\n  }\n  return count\n}\n",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let [wells_per_row, wells_per_col] = [rows, cols];\n    let [buckets_per_row, buckets_per_col] = [rows, cols];\n    let [wells_per_bucket, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_bucket, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [wells_per_well, buckets_per_well] = [cols, rows];\n    let [well",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = grid.map(row => row.map(v => v === 1))\n  let [wells_len, buckets_len] = wells.length, buckets_cap = capacity\n\n  let [wells_left, buckets_left] = wells.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_left_len, buckets_left_len] = wells_left.length, buckets_left_cap = capacity\n\n  let [wells_right, buckets_right] = wells.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_right_len, buckets_right_len] = wells_right.length, buckets_right_cap = capacity\n\n  let [wells_down, buckets_down] = wells.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_down_len, buckets_down_len] = wells_down.length, buckets_down_cap = capacity\n\n  let [wells_up, buckets_up] = wells.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_up_len, buckets_up_len] = wells_up.length, buckets_up_cap = capacity\n\n  let [wells_left_down, buckets_left_down] = wells_left.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_left_down_len, buckets_left_down_len] = wells_left_down.length, buckets_left_down_cap = capacity\n\n  let [wells_left_up, buckets_left_up] = wells_left.map(row => row.reduce((acc, v, i) => acc + v, 0))\n  let [wells_left_up_len, buckets_left_up_len] = wells_left_up.length, buckets_left_up_cap = capacity\n\n  let [wells_right_",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[], []]\n  for (let i = 0; i < rows; i++) {\n    wells[i] = []\n    for (let j = 0; j < cols; j++) {\n      wells[i].push(grid[i][j])\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    buckets[i] = []\n    for (let j = 0; j < cols; j++) {\n      buckets[i].push(0)\n    }\n  }\n  let filled = 0\n  let max_fill = 0\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (wells[i][j] === 1) {\n        let bucket = buckets[i][j]\n        let well = wells[i][j]\n        let max_fill = 0\n        let max_well = 0\n        let max_bucket = 0\n        for (let k = 0; k < rows; k++) {\n          for (let l = 0; l < cols; l++) {\n            if (wells[k][l] === 1) {\n              let bucket_ = buckets[k][l]\n              if (bucket_ > max_bucket) {\n                max_bucket = bucket_\n                max_well = wells[k][l]\n              }\n            }\n          }\n        }\n        if (max_well === 1) {\n          max_fill = max_fill + max_bucket\n          filled = filled + 1\n          wells[i][j] = 0\n          buckets[i][j] = 0\n        }\n      }\n    }\n  }\n  return max_fill\n}\n",
    "  let [rows, cols] = grid.length\n  let [rows1, cols1] = grid[0].length\n  let [rows2, cols2] = grid[rows - 1][cols - 1]\n  let [rows3, cols3] = grid[rows - 1][0]\n  let [rows4, cols4] = grid[0][cols - 1]\n  let [rows5, cols5] = grid[0][0]\n  let [rows6, cols6] = grid[rows - 1][cols - 1]\n  let [rows7, cols7] = grid[rows - 1][0]\n  let [rows8, cols8] = grid[0][cols - 1]\n  let [rows9, cols9] = grid[0][0]\n  let [rows10, cols10] = grid[rows - 1][cols - 1]\n  let [rows11, cols11] = grid[rows - 1][0]\n  let [rows12, cols12] = grid[0][cols - 1]\n  let [rows13, cols13] = grid[0][0]\n  let [rows14, cols14] = grid[rows - 1][cols - 1]\n  let [rows15, cols15] = grid[rows - 1][0]\n  let [rows16, cols16] = grid[0][cols - 1]\n  let [rows17, cols17] = grid[0][0]\n  let [rows18, cols18] = grid[rows - 1][cols - 1]\n  let [rows19, cols19] = grid[rows - 1][0]\n  let [rows20, cols20] = grid[0][cols - 1]\n  let [rows21, cols21] = grid[0][0]\n  let [rows22, cols22] = grid[rows - 1][cols - 1]\n  let [rows23, cols23] = grid[rows - 1][0]\n  let [rows24, cols24] = grid[0][cols - 1]\n  let [rows25, cols",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid.map(row => row.map(v => v === 1));\n    let [wells_used, buckets_used] = buckets.map(row => row.reduce((acc, v, i) => acc + wells[i][0] * v, 0));\n    let [wells_full, buckets_full] = wells.map(row => row.reduce((acc, v, i) => acc + v, 0));\n    let [wells_empty, buckets_empty] = wells.map(row => row.reduce((acc, v, i) => acc + (wells_full[i] - wells_used[i]), 0));\n    let [wells_full_capacity, buckets_full_capacity] = wells.map(row => row.reduce((acc, v, i) => acc + capacity * v, 0));\n    let [wells_empty_capacity, buckets_empty_capacity] = wells.map(row => row.reduce((acc, v, i) => acc + (wells_full_capacity[i] - wells_used[i]), 0));\n    let [wells_full_capacity_buckets_full_capacity, buckets_full_capacity_buckets_full_capacity] = wells.map(row => row.reduce((acc, v, i) => acc + (wells_full_capacity[i] - wells_used[i]) * (buckets_full[i] - buckets_used[i]), 0));\n    let [wells_full_capacity_buckets_full_capacity_buckets_full_capacity, buckets_full_capacity_buckets_full_capacity_buckets_full_capacity] = wells.map(row => row.reduce((acc, v, i) => acc + (wells_full_capacity[i] - wells_used[i]) * (buckets_full[i] - buckets_used[i]) * (buckets_full[i] - buckets_used[i]), 0));\n    let [wells_full_capacity_buckets_full_capacity_buckets_full_capacity_buckets_full_capacity, buckets_",
    "  let [rows, cols] = grid.length\n  let [r, c] = [0, 0]\n  let [max_fill, max_fill_cnt] = [0, 0]\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        let [r_, c_] = [i, j]\n        let [r_max_fill, c_max_fill] = [0, 0]\n        let [r_max_fill_cnt, c_max_fill_cnt] = [0, 0]\n        let [r_max_fill_cnt_, c_max_fill_cnt_] = [0, 0]\n        while (r_ < rows && grid[r_][c_] === 1) {\n          r_++\n        }\n        while (c_ < cols && grid[r_][c_] === 1) {\n          c_++\n        }\n        r_max_fill = r_ - i\n        c_max_fill = c_ - j\n        r_max_fill_cnt = r_max_fill - r_max_fill_cnt\n        c_max_fill_cnt = c_max_fill - c_max_fill_cnt\n        r_max_fill_cnt_ = r_max_fill_cnt - r_max_fill_cnt_\n        c_max_fill_cnt_ = c_max_fill_cnt - c_max_fill_cnt\n        if (r_max_fill_cnt > max_fill_cnt) {\n          max_fill_cnt = r_max_fill_cnt\n          max_fill = r_max_fill\n          max_fill_cnt_ = r_max_fill_cnt_\n          max_fill_ = r_max_fill_\n        }\n        if (c_max_fill_cnt > max_fill_cnt) {\n          max_fill_cnt = c_max_fill_cnt\n          max_fill = c_",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i]\n    let buckets = []\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        buckets.push(capacity)\n      } else {\n        buckets.push(0)\n      }\n    }\n    let filled = 0\n    while (buckets.length > 0) {\n      let bucket = buckets.shift()\n      if (bucket > 0) {\n        filled += bucket\n        buckets.push(0)\n      }\n    }\n    max = Math.max(max, filled)\n  }\n  return max\n}\n",
    "  let max = 0\n  for (let i = 0; i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  let cur = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max) {\n        max = cur\n      }\n    }\n  }\n  return max\n}\n",
    "    let [rows, cols] = grid.length;\n    let [rows1, cols1] = grid[0].length;\n    let [rows2, cols2] = grid[1].length;\n    let [rows3, cols3] = grid[2].length;\n    let [rows4, cols4] = grid[3].length;\n    let [rows5, cols5] = grid[4].length;\n    let [rows6, cols6] = grid[5].length;\n    let [rows7, cols7] = grid[6].length;\n    let [rows8, cols8] = grid[7].length;\n    let [rows9, cols9] = grid[8].length;\n    let [rows10, cols10] = grid[9].length;\n    let [rows11, cols11] = grid[10].length;\n    let [rows12, cols12] = grid[11].length;\n    let [rows13, cols13] = grid[12].length;\n    let [rows14, cols14] = grid[13].length;\n    let [rows15, cols15] = grid[14].length;\n    let [rows16, cols16] = grid[15].length;\n    let [rows17, cols17] = grid[16].length;\n    let [rows18, cols18] = grid[17].length;\n    let [rows19, cols19] = grid[18].length;\n    let [rows20, cols20] = grid[19].length;\n    let [rows21, cols21] = grid[20].length;\n    let [rows22, cols22] = grid[21].length;\n    let [rows23, cols23] = grid[22].length;\n    let [rows24, cols24] = grid[23].length;\n    let [rows25, cols25] = grid[24].length;\n    let [rows26, cols26] = grid[25].length;\n    let [rows27, cols27] = grid[26].length;\n    let [rows28, cols28] = grid",
    "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid.map(row => row.map(v => v === 1));\n    let [wells_left, buckets_left] = wells.map(row => row.map(v => v === 1));\n    let [wells_right, buckets_right] = wells.map(row => row.map(v => v === 0));\n    let [wells_down, buckets_down] = wells.map(row => row.map(v => v === 0));\n    let [wells_up, buckets_up] = wells.map(row => row.map(v => v === 1));\n    let [wells_left_down, buckets_left_down] = wells_left.map(row => row.map(v => v === 1));\n    let [wells_left_up, buckets_left_up] = wells_left.map(row => row.map(v => v === 0));\n    let [wells_right_down, buckets_right_down] = wells_right.map(row => row.map(v => v === 1));\n    let [wells_right_up, buckets_right_up] = wells_right.map(row => row.map(v => v === 0));\n    let [wells_down_left, buckets_down_left] = wells_down.map(row => row.map(v => v === 1));\n    let [wells_down_right, buckets_down_right] = wells_down.map(row => row.map(v => v === 0));\n    let [wells_up_left, buckets_up_left] = wells_up.map(row => row.map(v => v === 1));\n    let [wells_up_right, buckets_up_right] = wells_up.map(row => row.map(v => v === 0));\n    let [wells_left_down_left, buckets_left_down_left] = wells_left_down.map(row => row.map(v => v === 1));\n    let [wells_left_down_right, buckets_left_down_right] = wells",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            let count = 0;\n            while (grid[i][j] === 1) {\n                count++;\n                grid[i][j] = 0;\n            }\n            max = Math.max(max, count);\n        }\n    }\n    return max;\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                let cur = 0;\n                for (let k = i - 1; k >= 0; k--) {\n                    if (grid[k][j] === 1) {\n                        cur += 1;\n                    }\n                    if (cur === capacity) {\n                        break;\n                    }\n                }\n                for (let k = i + 1; k < grid.length; k++) {\n                    if (grid[k][j] === 1) {\n                        cur += 1;\n                    }\n                    if (cur === capacity) {\n                        break;\n                    }\n                }\n                for (let k = j - 1; k >= 0; k--) {\n                    if (grid[i][k] === 1) {\n                        cur += 1;\n                    }\n                    if (cur === capacity) {\n                        break;\n                    }\n                }\n                for (let k = j + 1; k < grid[i].length; k++) {\n                    if (grid[i][k] === 1) {\n                        cur += 1;\n                    }\n                    if (cur === capacity) {\n                        break;\n                    }\n                }\n                max = Math.max(max, cur);\n            }\n        }\n    }\n    return max;\n}\n",
    "  let [n, m] = grid.length\n  let [i, j] = [0, 0]\n  let [s, t] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0, 0]\n  let [u, d] = [0, 0]\n  let [c, d] = [0, 0]\n  let [l, r] = [0",
    "    let [n, m] = grid.length;\n    let [x, y] = grid[0];\n    let [bx, by] = [0, 0];\n    let [b, c] = [0, 0];\n    let [s, t] = [0, 0];\n    let [sx, sy] = [0, 0];\n    let [bx_, by_] = [0, 0];\n    let [bx_2, by_2] = [0, 0];\n    let [sx_, sy_] = [0, 0];\n    let [sx_2, sy_2] = [0, 0];\n    let [bx_3, by_3] = [0, 0];\n    let [sx_3, sy_3] = [0, 0];\n    let [bx_4, by_4] = [0, 0];\n    let [sx_4, sy_4] = [0, 0];\n    let [bx_5, by_5] = [0, 0];\n    let [sx_5, sy_5] = [0, 0];\n    let [bx_6, by_6] = [0, 0];\n    let [sx_6, sy_6] = [0, 0];\n    let [bx_7, by_7] = [0, 0];\n    let [sx_7, sy_7] = [0, 0];\n    let [bx_8, by_8] = [0, 0];\n    let [sx_8, sy_8] = [0, 0];\n    let [bx_9, by_9] = [0, 0];\n    let [sx_9, sy_9] = [0, 0];\n    let [bx_10, by_10] = [0, 0];\n    let [sx_10, sy_10] = [0, 0];\n    let [bx_11, by_11] = [0, 0];\n    let [sx_11, sy_11] = [0, 0];\n    let [bx_12, by_12] = [",
    "  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * cols, [0] * rows]\n  let [wells_left, buckets_left] = [[0] * cols, [0] * rows]\n  let [wells_right, buckets_right] = [[0] * cols, [0] * rows]\n  let [wells_up, buckets_up] = [[0] * cols, [0] * rows]\n  let [wells_down, buckets_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left, buckets_up_left] = [[0] * cols, [0] * rows]\n  let [wells_up_right, buckets_up_right] = [[0] * cols, [0] * rows]\n  let [wells_down_left, buckets_down_left] = [[0] * cols, [0] * rows]\n  let [wells_down_right, buckets_down_right] = [[0] * cols, [0] * rows]\n  let [wells_left_up, buckets_left_up] = [[0] * cols, [0] * rows]\n  let [wells_left_down, buckets_left_down] = [[0] * cols, [0] * rows]\n  let [wells_right_up, buckets_right_up] = [[0] * cols, [0] * rows]\n  let [wells_right_down, buckets_right_down] = [[0] * cols, [0] * rows]\n  let [wells_up_left_up, buckets_up_left_up] = [[0] * cols, [0] * rows]\n  let [wells_up_left_down, buckets_up_left_down] = [[0] * cols, [0] * rows]\n  let [wells_up_right_up, buckets_up_right_up] = [[0] * cols, [0] * rows]\n  let [wells_up_right_down, buckets_up",
    "  let n = grid.length\n  let m = grid[0].length\n  let count = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        count += max_fill_well(grid, i, j, capacity)\n      }\n    }\n  }\n  return count\n}\n\nfunction max_fill_well(grid: number[][], i: number, j: number, capacity: number): number {\n  let n = grid.length\n  let m = grid[0].length\n  let count = 0\n  let left = 0\n  let right = 0\n  let up = 0\n  let down = 0\n  if (i > 0) {\n    left = grid[i - 1][j]\n  }\n  if (i < n - 1) {\n    right = grid[i + 1][j]\n  }\n  if (j > 0) {\n    up = grid[i][j - 1]\n  }\n  if (j < m - 1) {\n    down = grid[i][j + 1]\n  }\n  if (left === 0 && right === 0 && up === 0 && down === 0) {\n    count += 1\n  } else if (left === 0 && right === 0 && up === 0) {\n    count += max_fill_well(grid, i - 1, j, capacity)\n  } else if (left === 0 && right === 0 && down === 0) {\n    count += max_fill_well(grid, i + 1, j, capacity)\n  } else if (left === 0 && up === 0 && down === 0) {\n    count += max_fill_well(grid, i, j - 1, capacity)\n  } else if (left === 0 && up === 0 && right === 0) {\n    count += max_fill_well(grid, i, j + 1, capacity)\n  } else if (left === 0 && right === 0 && up === 0) {\n    count += max_fill_well(grid, i - 1, j - 1, capacity)\n  } else if (left === 0 &&",
    "  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        let cur = 0;\n        for (let k = i - 1; k >= 0; k--) {\n          if (grid[k][j] === 1) {\n            cur += 1;\n          } else {\n            break;\n          }\n        }\n        for (let k = i + 1; k < grid.length; k++) {\n          if (grid[k][j] === 1) {\n            cur += 1;\n          } else {\n            break;\n          }\n        }\n        for (let k = j - 1; k >= 0; k--) {\n          if (grid[i][k] === 1) {\n            cur += 1;\n          } else {\n            break;\n          }\n        }\n        for (let k = j + 1; k < grid[i].length; k++) {\n          if (grid[i][k] === 1) {\n            cur += 1;\n          } else {\n            break;\n          }\n        }\n        max = Math.max(max, cur);\n      }\n    }\n  }\n  return max;\n}\n",
    "    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n                if (filled === capacity) {\n                    max++;\n                    filled = 0;\n                }\n            }\n        }\n    }\n    return max;\n}\n"
  ],
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ]
}