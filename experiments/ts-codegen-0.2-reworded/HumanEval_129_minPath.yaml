name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let n = grid.length;\n    let m = grid[0].length;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i === 0\
    \ && j === 0) {\n                dp[i] = grid[i][j];\n                lst[i] =\
    \ grid[i][j];\n            } else if (i === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n                lst[i] = dp[i];\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst[i] = dp[i];\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n                lst[i] = Math.min(lst[i\
    \ - 1], dp[i]);\n            }\n        }\n    }\n    let ans = new Array(k).fill(0);\n\
    \    for (let i = 0; i < k; i++) {\n        ans[i] = lst[n - 1];\n    }\n    return\
    \ ans;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] =\
    \ Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length]\
    \ + grid[i][j]);\n        }\n    }\n    let result = [];\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (dp[i * grid[0].length + j] === dp[i * grid[0].length + j - 1]\
    \ + grid[i][j]) {\n                result.push(grid[i][j]);\n            }\n \
    \       }\n    }\n    return result;\n}\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = Array(m).fill(0);\n    let lst = [];\n    for (let i = 0; i < m;\
    \ i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 && j\
    \ === 0) {\n                dp[i] = grid[i][j];\n                lst.push(grid[i][j]);\n\
    \            } else if (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n                lst.push(dp[i]);\n            } else if\
    \ (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst.push(dp[i]);\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n          \
    \      lst.push(dp[i]);\n            }\n        }\n    }\n    return lst.slice(0,\
    \ k).sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev_next = new Array(grid.length *\
    \ grid[0].length).fill(Number.POSITIVE_INFINITY);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev_next_prev_next = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i - 1][j] >\
    \ grid[i][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[(i\
    \ - 1) * grid[0].length + j], Math.min(dp[i * grid[0].length + j - 1], dp[(i -\
    \ 1) * grid[0].length + j - 1]) + grid[i][j]);\n            }\n        }\n   \
    \ }\n    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[0].length; j++) {\n            if (i > 0 && dp[i\
    \ * grid[0].length + j] == dp[(i - 1) * grid[0].length + j]) {\n             \
    \   result.push(grid[i][j]);\n            }\n        }\n    }\n    return result;\n\
    }\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let n = grid.length;\n    let m = grid[0].length;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i] = dp[i]\
    \ || [];\n            dp[i][j] = grid[i][j];\n            lst[i] = lst[i] || [];\n\
    \            lst[i][j] = i * m + j;\n        }\n    }\n    let ans = dfs(dp, lst,\
    \ 0, k);\n    return ans;\n}\n\nfunction dfs(dp: number[][], lst: number[][],\
    \ i: number, k: number): number[] {\n    if (i === k) return lst;\n    let n =\
    \ dp.length;\n    let m = dp[0].length;\n    let ans = [];\n    for (let j = 0;\
    \ j < m; j++) {\n        if (dp[i][j] === 0) continue;\n        let next = dfs(dp,\
    \ lst, i + 1, k);\n        if (next.length > 0) {\n            let lst_i = lst[i];\n\
    \            for (let l = 0; l < next.length; l++) {\n                if (lst_i[l]\
    \ === next[l]) continue;\n                lst_i[l] = next[l];\n              \
    \  ans.push(dp[i][j]);\n                break;\n            }\n        }\n   \
    \ }\n    return ans;\n}\n", "    let dp = new Array(grid.length).fill(0);\n  \
    \  let lst = new Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], grid[i][j]);\n            lst[i]\
    \ = Math.max(lst[i], grid[i][j]);\n        }\n    }\n    for (let i = 0; i < k;\
    \ i++) {\n        for (let j = 0; j < grid.length; j++) {\n            if (dp[j]\
    \ === lst[j]) {\n                res[i + 1] = Math.max(res[i + 1], grid[j][i]);\n\
    \            }\n        }\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let res = new Array(k + 1).fill(0);\n    let m = grid.length;\n    let n\
    \ = grid[0].length;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                res[0] = grid[i][j];\n            } else if (i\
    \ === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n           \
    \     res[0] = Math.min(res[0], grid[i][j]);\n            } else if (j === 0)\
    \ {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n                res[0]\
    \ = Math.min(res[0], grid[i][j]);\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], grid[i][j]);\n                res[0] = Math.min(res[0], grid[i][j]);\n\
    \            }\n        }\n    }\n    for (let i = 1; i <= k; i++) {\n       \
    \ for (let j = 0; j < n; j++) {\n            if (i === 1) {\n                dp[j]\
    \ = grid[j][j];\n                res[i] = grid[j][j];\n            } else if (j\
    \ === 0) {\n                dp[j] = Math.min(dp[j], grid[j][j]);\n           \
    \     res[i] = Math.min(res[i], grid[j][j]);\n            } else {\n         \
    \       dp[j] = Math.min(dp[j], grid[j][j]);\n                res[i] = Math.min(res[i],\
    \ grid[j][j]);\n            }\n        }\n        for (let j = 0; j < n; j++)\
    \ {\n            if (i === 1) {\n                dp[j] = grid[j][j];\n       \
    \         res[i] = grid[j][j];\n            }", "    const rows = grid.length;\n\
    \    const cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n \
    \   for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n\
    \            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n        }\n   \
    \ }\n    let res = new Array(k + 1);\n    for (let i = 0; i < k + 1; i++) {\n\
    \        res[i] = dp[rows - 1 - i];\n    }\n    return res;\n}\n", "    let dp\
    \ = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    let result = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j - 1])\
    \ + grid[i][j];\n            } else if (j === 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j\
    \ - 1]) + grid[i][j];\n            } else {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], Math.min(dp[(i - 1) * grid[0].length\
    \ + j - 1], dp[i * grid[0].length + j - 1])) + grid[i][j];\n            }\n  \
    \      }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               result.push(dp[i * grid[0].length + j]);\n            } else if\
    \ (i === 0) {\n                result.push(Math.min(dp[(i - 1) * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1]));\n            } else if (j === 0) {\n\
    \                result.push(Math.min(dp[(i - 1) * grid[0].length + j], dp[i *\
    \ grid"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
