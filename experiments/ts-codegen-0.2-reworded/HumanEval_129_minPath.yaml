name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let n = grid.length;\n    let m = grid[0].length;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i === 0\
    \ && j === 0) {\n                dp[i] = grid[i][j];\n                lst[i] =\
    \ grid[i][j];\n            } else if (i === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n                lst[i] = dp[i];\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst[i] = dp[i];\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n                lst[i] = Math.min(lst[i\
    \ - 1], dp[i]);\n            }\n        }\n    }\n    let ans = new Array(k).fill(0);\n\
    \    for (let i = 0; i < k; i++) {\n        ans[i] = lst[n - 1];\n    }\n    return\
    \ ans;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] =\
    \ Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length]\
    \ + grid[i][j]);\n        }\n    }\n    let result = [];\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (dp[i * grid[0].length + j] === dp[i * grid[0].length + j - 1]\
    \ + grid[i][j]) {\n                result.push(grid[i][j]);\n            }\n \
    \       }\n    }\n    return result;\n}\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = Array(m).fill(0);\n    let lst = [];\n    for (let i = 0; i < m;\
    \ i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 && j\
    \ === 0) {\n                dp[i] = grid[i][j];\n                lst.push(grid[i][j]);\n\
    \            } else if (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n                lst.push(dp[i]);\n            } else if\
    \ (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst.push(dp[i]);\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n          \
    \      lst.push(dp[i]);\n            }\n        }\n    }\n    return lst.slice(0,\
    \ k).sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev_next = new Array(grid.length *\
    \ grid[0].length).fill(Number.POSITIVE_INFINITY);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_prev_next_prev_next_prev_next_prev_next_prev_next = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i - 1][j] >\
    \ grid[i][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[(i\
    \ - 1) * grid[0].length + j], Math.min(dp[i * grid[0].length + j - 1], dp[(i -\
    \ 1) * grid[0].length + j - 1]) + grid[i][j]);\n            }\n        }\n   \
    \ }\n    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[0].length; j++) {\n            if (i > 0 && dp[i\
    \ * grid[0].length + j] == dp[(i - 1) * grid[0].length + j]) {\n             \
    \   result.push(grid[i][j]);\n            }\n        }\n    }\n    return result;\n\
    }\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let n = grid.length;\n    let m = grid[0].length;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i] = dp[i]\
    \ || [];\n            dp[i][j] = grid[i][j];\n            lst[i] = lst[i] || [];\n\
    \            lst[i][j] = i * m + j;\n        }\n    }\n    let ans = dfs(dp, lst,\
    \ 0, k);\n    return ans;\n}\n\nfunction dfs(dp: number[][], lst: number[][],\
    \ i: number, k: number): number[] {\n    if (i === k) return lst;\n    let n =\
    \ dp.length;\n    let m = dp[0].length;\n    let ans = [];\n    for (let j = 0;\
    \ j < m; j++) {\n        if (dp[i][j] === 0) continue;\n        let next = dfs(dp,\
    \ lst, i + 1, k);\n        if (next.length > 0) {\n            let lst_i = lst[i];\n\
    \            for (let l = 0; l < next.length; l++) {\n                if (lst_i[l]\
    \ === next[l]) continue;\n                lst_i[l] = next[l];\n              \
    \  ans.push(dp[i][j]);\n                break;\n            }\n        }\n   \
    \ }\n    return ans;\n}\n", "    let dp = new Array(grid.length).fill(0);\n  \
    \  let lst = new Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], grid[i][j]);\n            lst[i]\
    \ = Math.max(lst[i], grid[i][j]);\n        }\n    }\n    for (let i = 0; i < k;\
    \ i++) {\n        for (let j = 0; j < grid.length; j++) {\n            if (dp[j]\
    \ === lst[j]) {\n                res[i + 1] = Math.max(res[i + 1], grid[j][i]);\n\
    \            }\n        }\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let res = new Array(k + 1).fill(0);\n    let m = grid.length;\n    let n\
    \ = grid[0].length;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                res[0] = grid[i][j];\n            } else if (i\
    \ === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n           \
    \     res[0] = Math.min(res[0], grid[i][j]);\n            } else if (j === 0)\
    \ {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n                res[0]\
    \ = Math.min(res[0], grid[i][j]);\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], grid[i][j]);\n                res[0] = Math.min(res[0], grid[i][j]);\n\
    \            }\n        }\n    }\n    for (let i = 1; i <= k; i++) {\n       \
    \ for (let j = 0; j < n; j++) {\n            if (i === 1) {\n                dp[j]\
    \ = grid[j][j];\n                res[i] = grid[j][j];\n            } else if (j\
    \ === 0) {\n                dp[j] = Math.min(dp[j], grid[j][j]);\n           \
    \     res[i] = Math.min(res[i], grid[j][j]);\n            } else {\n         \
    \       dp[j] = Math.min(dp[j], grid[j][j]);\n                res[i] = Math.min(res[i],\
    \ grid[j][j]);\n            }\n        }\n        for (let j = 0; j < n; j++)\
    \ {\n            if (i === 1) {\n                dp[j] = grid[j][j];\n       \
    \         res[i] = grid[j][j];\n            }", "    const rows = grid.length;\n\
    \    const cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n \
    \   for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n\
    \            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n        }\n   \
    \ }\n    let res = new Array(k + 1);\n    for (let i = 0; i < k + 1; i++) {\n\
    \        res[i] = dp[rows - 1 - i];\n    }\n    return res;\n}\n", "    let dp\
    \ = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    let result = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j - 1])\
    \ + grid[i][j];\n            } else if (j === 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j\
    \ - 1]) + grid[i][j];\n            } else {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], Math.min(dp[(i - 1) * grid[0].length\
    \ + j - 1], dp[i * grid[0].length + j - 1])) + grid[i][j];\n            }\n  \
    \      }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               result.push(dp[i * grid[0].length + j]);\n            } else if\
    \ (i === 0) {\n                result.push(Math.min(dp[(i - 1) * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1]));\n            } else if (j === 0) {\n\
    \                result.push(Math.min(dp[(i - 1) * grid[0].length + j], dp[i *\
    \ grid", "    let dp = [[0] * grid[0].length for _ in range(grid.length)]\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j]\n            } else {\n                dp[i][j]\
    \ = grid[i][j]\n            }\n        }\n    }\n    let lst = []\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                if (dp[i][j] == dp[i\
    \ - 1][j]) {\n                    lst.push(grid[i][j])\n                } else\
    \ if (dp[i][j] == dp[i][j - 1]) {\n                    lst.push(grid[i][j])\n\
    \                }\n            } else {\n                lst.push(grid[i][j])\n\
    \            }\n        }\n    }\n    return lst.sort((a, b) => a - b)\n     \
    \   .slice(0, k)\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n        }\n    }\n    let res = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                res.push(dp[i * grid[0].length + j] - dp[(i\
    \ - 1) * grid[0].length + j - 1] - grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                res.push(dp[i * grid[0].length + j] - dp[(i - 1)\
    \ * grid[0].length + j] - grid[i][j]);\n            }\n            if (j > 0)\
    \ {\n                res.push(dp[i * grid[0].length + j] - dp[i * grid[0].length\
    \ + j - grid[0].length] - grid[i][j]);\n            }\n        }\n    }\n", " \
    \   let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let res = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                res.push(dp[i * grid[0].length + j] - dp[i\
    \ * grid[0].length + j - 1] - grid[i][j]);\n            }\n            if (i >\
    \ 0) {\n                res.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length\
    \ + j] - grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   res.push(dp[i * grid[0].length + j] - dp[i * grid[0].length + j - 1] - grid[i][j]);\n\
    \            }\n        }\n    }\n    return res.sort((a, b) => a", "    let m\
    \ = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0);\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n         \
    \   } else if (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] +\
    \ grid[i][j]);\n            } else if (j === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j], dp[i - 1] + grid[i][j - 1]);\n            }\n      \
    \  }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n        res.push(dp[i]);\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    let res = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n\
    \            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1]) + grid[i][j]);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < k; i++) {\n        res.push(dp[i * grid[0].length + grid[0].length -\
    \ 1]);\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n        }\n    }\n    let res = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                res.push(dp[i * grid[0].length + j] - dp[i\
    \ * grid[0].length + j - 1] - grid[i][j]);\n            }\n            if (i >\
    \ 0) {\n                res.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length\
    \ + j] - grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   res.push(dp[i * grid[0].length + j] - dp[i * grid[0].length + j - grid[0].length]\
    \ - grid[i][j]);\n            }\n        }\n    }\n    res.sort", "    let m =\
    \ grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0);\n    let\
    \ lst = new Array(m).fill(0);\n    for (let i = 0; i < m; i++) {\n        for\
    \ (let j = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n         \
    \       dp[i] = grid[i][j];\n                lst[i] = grid[i][j];\n          \
    \  } else if (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] +\
    \ grid[i][j]);\n                lst[i] = dp[i];\n            } else if (j ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n   \
    \             lst[i] = dp[i];\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1 + 1]) + grid[i][j]);\n                lst[i] =\
    \ dp[i];\n            }\n        }\n    }\n    let res = [];\n    for (let i =\
    \ 0; i < k; i++) {\n        res.push(lst[i]);\n    }\n    return res;\n}\n", " \
    \   let dp = new Array(grid.length).fill(0);\n    let result = [];\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = dp[i] || [];\n            dp[i][j] = grid[i][j];\n\
    \        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            for (let k = 1; k <= k; k++)\
    \ {\n                if (i - k >= 0 && j - k >= 0) {\n                    dp[i][j]\
    \ = Math.min(dp[i][j], dp[i - k][j - k] + grid[i][j]);\n                }\n  \
    \              if (i + k < grid.length && j - k >= 0) {\n                    dp[i][j]\
    \ = Math.min(dp[i][j], dp[i + k][j - k] + grid[i][j]);\n                }\n  \
    \              if (i - k >= 0 && j + k < grid[i].length) {\n                 \
    \   dp[i][j] = Math.min(dp[i][j], dp[i - k][j + k] + grid[i][j]);\n          \
    \      }\n                if (i + k < grid.length && j + k < grid[i].length) {\n\
    \                    dp[i][j] = Math.min(dp[i][j], dp[i + k][j + k] + grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            result.push(dp[i][j]);\n\
    \        }\n    }\n    return result;\n}\n", "    const n = grid.length;\n   \
    \ const m = grid[0].length;\n    const dp = Array(n).fill(0).map(() => Array(m).fill(0));\n\
    \    const dp_prev = Array(n).fill(0).map(() => Array(m).fill(0));\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if\
    \ (i === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n           \
    \     dp_prev[i][j] = grid[i][j];\n            } else if (i === 0) {\n       \
    \         dp[i][j] = Math.min(dp[i][j - 1], dp_prev[i][j]);\n                dp_prev[i][j]\
    \ = dp[i][j];\n            } else if (j === 0) {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp_prev[i][j]);\n                dp_prev[i][j] = dp[i][j];\n      \
    \      } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1],\
    \ dp_prev[i][j]);\n                dp_prev[i][j] = dp[i][j];\n            }\n\
    \        }\n    }\n    const result = [];\n    for (let i = 0; i < k; i++) {\n\
    \        result.push(dp[n - 1][m - 1]);\n    }\n    return result;\n}\n", "  \
    \  let m = grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0);\n\
    \    let res = new Array(k + 1).fill(0);\n    for (let i = 0; i < m; i++) {\n\
    \        for (let j = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n\
    \                dp[i] = grid[i][j];\n            } else if (i === 0) {\n    \
    \            dp[i] = Math.min(dp[i], grid[i][j]);\n            } else if (j ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n            } else\
    \ {\n                dp[i] = Math.min(dp[i], grid[i][j], dp[i - 1], dp[i]);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < k + 1; i++) {\n    \
    \    res[i] = dp[m - 1];\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_i = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_j = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_k = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_lst_i = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_lst_j = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_lst_k = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let dp_lst_lst_i = new\
    \ Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let\
    \ dp_lst_lst_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst_lst_i", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let result = new Array(k + 1).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    let i = 0;\n    for (let j\
    \ = 0; j < grid.length; j++) {\n        lst[j] = grid[j][0];\n        dp[j] =\
    \ 1;\n    }\n    for (let j = 0; j < grid.length; j++) {\n        for (let i =\
    \ 0; i < grid.length; i++) {\n            if (i === j) {\n                continue;\n\
    \            }\n            if (grid[i][j] < lst[i]) {\n                lst[i]\
    \ = grid[i][j];\n                dp[i] = dp[i] + 1;\n            }\n        }\n\
    \    }\n    for (let i = 0; i < k; i++) {\n        result[i] = lst[0];\n     \
    \   for (let j = 0; j < grid.length; j++) {\n            if (dp[j] === i + 1)\
    \ {\n                result[i] = Math.min(result[i], lst[j]);\n            }\n\
    \        }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid[0].length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            lst[j] = Math.min(lst[j],\
    \ dp[i - 1] + grid[i][j]);\n        }\n    }\n    let res = new Array(k).fill(0);\n\
    \    for (let i = 0; i < k; i++) {\n        res[i] = lst[i];\n    }\n    return\
    \ res;\n}\n", "    let m = grid.length, n = grid[0].length;\n    let dp = new\
    \ Array(m).fill(0);\n    let ans = new Array(k + 1).fill(0);\n    for (let i =\
    \ 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n            }\n        }\n  \
    \  }\n    for (let i = 0; i < k + 1; i++) {\n        ans[i] = dp[m - 1];\n   \
    \ }\n    return ans;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let res = [];\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            dp[i] = dp[i] || [];\n            dp[i][j] = grid[i][j] + Math.min(dp[i\
    \ - 1] || [], dp[i][j - 1] || []);\n            res.push(dp[i][j]);\n        }\n\
    \    }\n    return res.sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] +\
    \ grid[i][j]);\n            }\n            if (i > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length\
    \ + j] + grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let\
    \ res = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j =\
    \ 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n         \
    \       res[i * grid[0].length + j] = dp[i * grid[0].length + j] - dp[(i - 1)\
    \ * grid[0].length + j - 1];\n            }\n            if (i > 0) {\n      \
    \          res[i * grid[0].length + j] = dp[i * grid[0].length + j] - dp[(i -\
    \ 1) * grid[0].length + j];\n            }\n            if (j > 0) {\n       \
    \         res[i * grid[0].length + j] = dp[i * grid[0].length + j] - dp[i * grid[0].length\
    \ + j - grid[0].length];\n", "    let m = grid.length, n = grid[0].length;\n \
    \   let dp = Array(m).fill(0);\n    let lst = Array(m).fill(0);\n    for (let\
    \ i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if\
    \ (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n              \
    \  lst[i] = grid[i][j];\n            } else if (i === 0) {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n                lst[i] = dp[i];\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n                lst[i] = dp[i];\n            } else {\n\
    \                dp[i] = Math.min(dp[i], Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n\
    \                lst[i] = dp[i];\n            }\n        }\n    }\n    let ans\
    \ = [];\n    for (let i = 0; i < k; i++) {\n        ans.push(lst[i]);\n    }\n\
    \    return ans;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n        }\n    }\n    let result = [];\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (i > 0 && j > 0) {\n                result.push(dp[i * grid[0].length\
    \ + j] - dp[i * grid[0].length + j - 1] - grid[i][j]);\n            }\n      \
    \      if (i > 0) {\n                result.push(dp[i * grid[0].length + j] -\
    \ dp[(i - 1) * grid[0].length + j] - grid[i][j]);\n            }\n           \
    \ if (j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[i\
    \ * grid[0].length + j - grid[0].length] - grid[i][j]);\n            }\n     \
    \   }\n    }\n    return result.", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let result = [];\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n\
    \                result.push(dp[i]);\n            } else if (i === 0) {\n    \
    \            dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n                result.push(dp[i]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[j]\
    \ + grid[i][j]);\n                result.push(dp[i]);\n            } else {\n\
    \                dp[i] = Math.min(dp[i], Math.min(dp[j] + grid[i][j], dp[i - 1]\
    \ + grid[i][j]));\n                result.push(dp[i]);\n            }\n      \
    \  }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid[0].length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n \
    \           }\n            if (j > 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i] + grid[i][j - 1]);\n            }\n            lst[j] = Math.min(lst[j],\
    \ dp[i]);\n        }\n    }\n    let res = new Array(k).fill(0);\n    for (let\
    \ i = 0; i < k; i++) {\n        res[i] = lst[i];\n    }\n    return res;\n}\n",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 1; i <= grid.length * grid[0].length; i++) {\n\
    \        for (let j = 0; j < grid.length; j++) {\n            for (let k = 0;\
    \ k < grid[0].length; k++) {\n                if (i - grid[j][k] === k) {\n  \
    \                  dp[i] = Math.min(dp[i], dp[i - grid[j][k]] + 1);\n        \
    \        }\n            }\n        }\n    }\n    let result = [];\n    for (let\
    \ i = 0; i <= k; i++) {\n        result.push(dp[i]);\n    }\n    return result;\n\
    }\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "  const n = grid.length\n  const m = grid[0].length\n  const dp = Array(n + 1).fill(0)\n\
    \  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i - 1][j - 1])\n    }\n  }\n  const result\
    \ = []\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n\
    \      if (dp[i] === k) {\n        result.push(grid[i - 1][j - 1])\n      }\n\
    \    }\n  }\n  return result\n}\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = Array(m).fill(0);\n    let lst = Array(m).fill(0);\n    for (let\
    \ i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if\
    \ (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n              \
    \  lst[i] = grid[i][j];\n            } else if (i === 0) {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n                lst[i] = dp[i];\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n                lst[i] = dp[i];\n            } else {\n\
    \                dp[i] = Math.min(dp[i], Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n\
    \                lst[i] = dp[i];\n            }\n        }\n    }\n    let res\
    \ = [];\n    for (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n    }\n\
    \    return res;\n}\n", "    let m = grid.length, n = grid[0].length;\n    let\
    \ dp = Array(m).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let\
    \ j = 0; j < n; j++) {\n            if (i > 0 && j > 0) {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            }\n            if (i\
    \ > 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n \
    \           }\n            if (j > 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i] + grid[i][j]);\n            }\n        }\n    }\n    let res = [];\n \
    \   for (let i = k - 1; i >= 0; i--) {\n        res.push(dp[i]);\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    let res = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n\
    \            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1]) + grid[i][j]);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++)\
    \ {\n            res.push(dp[i * grid[0].length + j]);\n        }\n    }\n   \
    \ return res;\n}\n", "    const N = grid.length;\n    const M = grid[0].length;\n\
    \    const dp = Array(N + 1).fill(0);\n    for (let i = 1; i <= N; i++) {\n  \
    \      for (let j = 1; j <= M; j++) {\n            if (i === 1 && j === 1) {\n\
    \                dp[i] = grid[i - 1][j - 1];\n            } else if (i === 1)\
    \ {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i - 1][j]);\n  \
    \          } else if (j === 1) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j - 1]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1]) + grid[i - 1][j - 1]);\n            }\n     \
    \   }\n    }\n    const result = [];\n    for (let i = 1; i <= N; i++) {\n   \
    \     for (let j = 1; j <= M; j++) {\n            if (i === 1 && j === 1) {\n\
    \                result.push(dp[i]);\n            } else if (i === 1) {\n    \
    \            result.push(Math.min(dp[i], dp[i - 1] + grid[i - 1][j]));\n     \
    \       } else if (j === 1) {\n                result.push(Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j - 1]));\n            } else {\n                result.push(Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1]) + grid[i - 1][j - 1]));\n            }\n    \
    \    }\n    }\n    return result.sort((a, b) => a - b);\n}\n", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let\
    \ dp_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_lst_lst_i = new Array(grid.length * grid[0].length).fill(Number.",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n     \
    \       lst[i] = Math.min(lst[i], dp[i] + grid[i][j]);\n        }\n    }\n   \
    \ return lst.slice(k - 1);\n}\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = new Array(m).fill(0);\n    let lst = new Array(m).fill(0);\n   \
    \ for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n     \
    \       if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n     \
    \           lst[i] = grid[i][j];\n            } else if (i === 0) {\n        \
    \        dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n                lst[i]\
    \ = Math.min(lst[i], grid[i][j] + dp[i]);\n            } else if (j === 0) {\n\
    \                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n              \
    \  lst[i] = Math.min(lst[i], grid[i][j] + dp[i]);\n            } else {\n    \
    \            dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n                lst[i]\
    \ = Math.min(lst[i], grid[i][j] + dp[i]);\n            }\n        }\n    }\n \
    \   let res = new Array(k + 1).fill(0);\n    for (let i = 0; i < k; i++) {\n \
    \       res[i + 1] = lst[i];\n    }\n    return res;\n}\n", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    let\
    \ result = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               dp[i * grid[0].length + j] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n            } else if (j\
    \ === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            } else {\n\
    \                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length +\
    \ j], Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j - 1])\
    \ + grid[i][j]);\n            }\n        }\n    }\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ === 0 && j === 0) {\n                result.push(dp[i * grid[0].length + j]);\n\
    \            } else if (i === 0) {\n                result.push(Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1]));\n            } else\
    \ if (j === 0) {\n                result.push(Math.min(dp[i * grid[0].length +\
    \ j], dp[(i - 1) * grid[0].length + j]));\n            } else {\n            \
    \    result.push(Math.min(dp[", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let m = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0).map(()\
    \ => Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j\
    \ = 0; j < n; j++) {\n            if (i > 0 && grid[i - 1][j] > grid[i][j]) {\n\
    \                dp[i][j] = dp[i - 1][j];\n            } else {\n            \
    \    dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1]))\
    \ + 1;\n            }\n        }\n    }\n    let res = [];\n    for (let i = 0;\
    \ i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i > 0\
    \ && grid[i - 1][j] > grid[i][j]) {\n                res.push(dp[i][j]);\n   \
    \         } else {\n                res.push(Math.min(dp[i][j], Math.min(dp[i\
    \ - 1][j], dp[i - 1][j - 1])));\n            }\n        }\n    }\n    return res.slice(0,\
    \ k);\n}\n", "  const dp = new Array(grid.length).fill(0);\n  const dp_cache =\
    \ new Map();\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      dp[i][j] = grid[i][j] + Math.min(\n        dp[i\
    \ - 1][j],\n        dp[i][j - 1],\n        dp[i - 1][j - 1]\n      );\n      dp_cache.set(dp[i][j],\
    \ [i, j]);\n    }\n  }\n  const result = [];\n  for (let i = 0; i < k; i++) {\n\
    \    const [i_, j_] = dp_cache.get(dp[grid.length - 1][grid[grid.length - 1].length\
    \ - 1]);\n    result.push(grid[i_][j_]);\n    for (let j = grid[i_].length - 1;\
    \ j > j_; j--) {\n      dp[i_][j] = grid[i_][j] + Math.min(\n        dp[i_ - 1][j],\n\
    \        dp[i_][j - 1],\n        dp[i_ - 1][j - 1]\n      );\n      dp_cache.set(dp[i_][j],\
    \ [i_, j]);\n    }\n  }\n  return result;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && grid[i][j] < dp[i - 1]) {\n               \
    \ dp[i] = dp[i - 1];\n            } else if (j > 0 && grid[i][j] < dp[i]) {\n\
    \                dp[i] = dp[i];\n            } else {\n                dp[i] =\
    \ grid[i][j];\n            }\n        }\n    }\n    let result = [];\n    for\
    \ (let i = 0; i < k; i++) {\n        result.push(dp[k - i - 1]);\n    }\n    return\
    \ result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let res =\
    \ [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (i === 0 && j === 0) {\n          \
    \      dp[i] = grid[i][j];\n            } else if (i === 0) {\n              \
    \  dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n            } else if (j ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n       \
    \     } else {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        res.push(dp[i]);\n\
    \    }\n    return res;\n}\n", "    const N = grid.length;\n    const M = grid[0].length;\n\
    \    const dp = new Array(N * M + 1).fill(0);\n    for (let i = 0; i < N; i++)\
    \ {\n        for (let j = 0; j < M; j++) {\n            dp[i * M + j + 1] = Math.min(dp[i\
    \ * M + j + 1], dp[i * M + j] + grid[i][j]);\n        }\n    }\n    let res =\
    \ [];\n    for (let i = 1; i <= k; i++) {\n        res.push(dp[i * M + k]);\n\
    \    }\n    return res;\n}\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = new Array(m * n).fill(0);\n    let lst = new Array(m * n).fill(0);\n\
    \    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          if (i === 0 && j === 0) {\n                dp[i * n + j] = grid[i][j];\n\
    \                lst[i * n + j] = i * n + j;\n            } else if (i === 0)\
    \ {\n                dp[i * n + j] = Math.min(dp[(i - 1) * n + j], grid[i][j]);\n\
    \                lst[i * n + j] = (i - 1) * n + j;\n            } else if (j ===\
    \ 0) {\n                dp[i * n + j] = Math.min(dp[i * n + (j - 1)], grid[i][j]);\n\
    \                lst[i * n + j] = i * n + (j - 1);\n            } else {\n   \
    \             dp[i * n + j] = Math.min(dp[i * n + (j - 1)], Math.min(dp[(i - 1)\
    \ * n + j], grid[i][j]));\n                lst[i * n + j] = Math.min(lst[(i -\
    \ 1) * n + j], Math.min(lst[i * n + (j - 1)], grid[i][j]));\n            }\n \
    \       }\n    }\n    let result = [];\n    for (let i = 0; i < k; i++) {\n  \
    \      result.push(lst[i * n + n - 1]);\n    }\n    return result;\n}\n", "  \
    \  let dp = new Array(grid.length).fill(0);\n    let result = [];\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = dp[i] || [];\n            dp[i][j] = grid[i][j]\
    \ + Math.min(dp[i - 1] || [], dp[i][j - 1] || []);\n            result.push(dp[i][j]);\n\
    \        }\n    }\n    return result.slice(0, k);\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (i === 0 && j === 0)\
    \ {\n                dp[i] = grid[i][j];\n            } else if (i === 0) {\n\
    \                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < dp.length; i++) {\n\
    \        if (dp[i] === k) {\n            result.push(grid[i][0]);\n        }\n\
    \    }\n    return result;\n}\n", "    let m = grid.length,\n        n = grid[0].length,\n\
    \        dp = Array(m).fill(0),\n        path = Array(k + 1).fill(0);\n\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   let value = grid[i][j];\n            if (value === 0) continue;\n        \
    \    let lst = dp.slice();\n            if (i > 0) lst[0] = grid[i - 1][j];\n\
    \            if (j > 0) lst[1] = grid[i][j - 1];\n            if (i > 0 && j >\
    \ 0) lst[2] = grid[i - 1][j - 1];\n            let min = Math.min.apply(null,\
    \ lst);\n            if (min === value) {\n                path[0] = value;\n\
    \                for (let i = 1; i <= k; i++) {\n                    path[i] =\
    \ path[i - 1];\n                }\n                path[k + 1] = value;\n    \
    \            break;\n            }\n        }\n    }\n    return path;\n}\n",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[0].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[0].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_i = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_l = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_i_j = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_i_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_i_l = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_j_k = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_lst_j_l = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let i = 0;\n    for (let j = 0; j < grid.length; j++) {\n        for (let\
    \ k = 0; k < grid[j].length; k++) {\n            dp[j] = Math.min(dp[j], dp[k]\
    \ + grid[j][k]);\n            lst[j] = Math.min(lst[j], lst[k] + grid[j][k]);\n\
    \        }\n    }\n    let res = [];\n    for (let j = 0; j < grid.length; j++)\
    \ {\n        for (let k = 0; k < grid[j].length; k++) {\n            if (dp[j]\
    \ === lst[j]) {\n                res.push(grid[j][k]);\n                break;\n\
    \            }\n        }\n    }\n    return res.sort((a, b) => a - b);\n}\n",
  "  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n\
    \ * m).fill(0);\n  const dp_prev = new Array(n * m).fill(0);\n  for (let i = 0;\
    \ i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i * m + j] = grid[i][j]\
    \ + Math.min(dp_prev[(i - 1) * m + j], dp_prev[i * m + (j - 1)], dp_prev[(i -\
    \ 1) * m + (j - 1)]);\n      dp_prev[i * m + j] = dp[i * m + j];\n    }\n  }\n\
    \  const result = [];\n  for (let i = 0; i < k; i++) {\n    result.push(dp[i *\
    \ m + m - 1]);\n  }\n  return result;\n}\n", "    const N = grid.length;\n   \
    \ const M = grid[0].length;\n    const dp = Array(N + 1).fill(0);\n    dp[0] =\
    \ 1;\n    for (let i = 1; i <= N; i++) {\n        for (let j = 1; j <= M; j++)\
    \ {\n            if (i > 1 && grid[i - 1][j] > grid[i][j]) {\n               \
    \ dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n            }\n            if (j >\
    \ 1 && grid[i][j - 1] > grid[i][j]) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i] + 1);\n            }\n        }\n    }\n    let res = [];\n    for (let\
    \ i = k; i > 0; i--) {\n        res.unshift(dp[N] - dp[i - 1]);\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new\
    \ Array(grid[0].length).fill(0);\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (i === 0 &&\
    \ j === 0) {\n                dp[i] = grid[i][j];\n                lst[j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n\
    \                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n            }\n\
    \        }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n    \
    \    res.push(lst[i]);\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + (j - 1)] + grid[i][j]);\n        }\n    }\n  \
    \  let result = [];\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (dp[i * grid[0].length\
    \ + j] === k) {\n                result.push(grid[i][j]);\n            }\n   \
    \     }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let dp_i = new Array(grid.length).fill(0);\n    let dp_j = new Array(grid.length).fill(0);\n\
    \    let dp_k = new Array(grid.length).fill(0);\n    let dp_l = new Array(grid.length).fill(0);\n\
    \    let dp_m = new Array(grid.length).fill(0);\n    let dp_n = new Array(grid.length).fill(0);\n\
    \    let dp_o = new Array(grid.length).fill(0);\n    let dp_p = new Array(grid.length).fill(0);\n\
    \    let dp_q = new Array(grid.length).fill(0);\n    let dp_r = new Array(grid.length).fill(0);\n\
    \    let dp_s = new Array(grid.length).fill(0);\n    let dp_t = new Array(grid.length).fill(0);\n\
    \    let dp_u = new Array(grid.length).fill(0);\n    let dp_v = new Array(grid.length).fill(0);\n\
    \    let dp_w = new Array(grid.length).fill(0);\n    let dp_x = new Array(grid.length).fill(0);\n\
    \    let dp_y = new Array(grid.length).fill(0);\n    let dp_z = new Array(grid.length).fill(0);\n\
    \    let dp_a = new Array(grid.length).fill(0);\n    let dp_b = new Array(grid.length).fill(0);\n\
    \    let dp_c = new Array(grid.length).fill(0);\n    let dp_d = new Array(grid.length).fill(0);\n\
    \    let dp_e = new Array(grid.length).fill(0);\n    let dp_f = new Array(grid.length).fill(0);\n\
    \    let dp_g = new Array(grid.length).fill(0);\n    let dp_h = new Array(grid.length).fill(0);\n\
    \    ", "    let dp = new Array(grid.length).fill(0);\n    let dp_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next = new Array(grid.length).fill(0);\n    let dp_prev_next = new\
    \ Array(grid.length).fill(0);\n    let dp_prev_next_next = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i][j] = grid[i][j];\n            dp_prev[i][j] = grid[i][j];\n\
    \            dp_next[i][j] = grid[i][j];\n            dp_prev_next[i][j] = grid[i][j];\n\
    \            dp_prev_next_next[i][j] = grid[i][j];\n        }\n    }\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            for (let k = 1; k <= k; k++) {\n                if (i -\
    \ k >= 0 && j - k >= 0) {\n                    dp_prev_next[i][j] = Math.min(dp_prev_next[i][j],\
    \ dp[i - k][j - k] + dp_prev[i][j]);\n                }\n                if (i\
    \ + k < grid.length && j + k < grid[i].length) {\n                    dp_prev_next_next[i][j]\
    \ = Math.min(dp_prev_next_next[i][j], dp[i + k][j + k] + dp_prev_next[i][j]);\n\
    \                }\n                if (i - k >= 0 && j + k < grid[i].length)\
    \ {\n                    dp_prev_next_next[i][j] = Math.min(dp_prev_next_next[i][j],\
    \ dp[i - k][j + k] + dp_prev[i][j]);\n                }\n                if",
  "    let m = grid.length, n = grid[0].length,\n        visited = new Array(m).fill(0),\n\
    \        min = new Array(m).fill(0),\n        min_index = new Array(m).fill(0);\n\
    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n \
    \           if (visited[i] === 0) {\n                min[i] = grid[i][j];\n  \
    \              min_index[i] = j;\n            }\n        }\n    }\n\n    let dfs\
    \ = function(i, j, k) {\n        if (visited[i] === 0) {\n            visited[i]\
    \ = 1;\n            for (let j = 0; j < n; j++) {\n                if (visited[i]\
    \ === 0 && grid[i][j] < min[i]) {\n                    min[i] = grid[i][j];\n\
    \                    min_index[i] = j;\n                }\n            }\n   \
    \     }\n        if (k === 0) {\n            return;\n        }\n        for (let\
    \ j = 0; j < n; j++) {\n            if (visited[i] === 0 && grid[i][j] < min[i])\
    \ {\n                min[i] = grid[i][j];\n                min_index[i] = j;\n\
    \            }\n        }\n        for (let j = 0; j < n; j++) {\n           \
    \ if (visited[i] === 0 && grid[i][j] === min[i] && j !== min_index[i]) {\n   \
    \             dfs(i, j, k - 1);\n            }\n        }\n    };\n\n    dfs(0,\
    \ 0, k);\n\n    return min_index;\n}\n", "    const rows = grid.length;\n    const\
    \ cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n    for (let\
    \ i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n        \
    \    if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n        \
    \    } else if (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1]\
    \ + grid[i][j]);\n            } else if (j === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n            }\n        }\n  \
    \  }\n    let result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(dp[i]);\n\
    \    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let m = grid.length;\n    let n = grid[0].length;\n    let i = 0;\n    let\
    \ j = 0;\n    let path = [];\n    let min = Number.MAX_SAFE_INTEGER;\n    for\
    \ (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            if (i\
    \ === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n            } else\
    \ if (i === 0) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] +\
    \ grid[i][j]);\n            } else if (j === 0) {\n                dp[i][j] =\
    \ Math.min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            } else {\n     \
    \           dp[i][j] = Math.min(dp[i][j], Math.min(dp[i - 1][j], dp[i][j - 1])\
    \ + grid[i][j]);\n            }\n            if (dp[i][j] < min) {\n         \
    \       min = dp[i][j];\n                path = [];\n            }\n         \
    \   if (dp[i][j] === min) {\n                path.push(grid[i][j]);\n        \
    \    }\n        }\n    }\n    return path.slice(0, k);\n}\n", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = new Array(m).fill(0);\n    for (let i = 0;\
    \ i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1]) + grid[i][j]);\n            }\n        }\n  \
    \  }\n    let res = [];\n    for (let i = 0; i < m; i++) {\n        for (let j\
    \ = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n                res.push(dp[i]);\n\
    \            } else if (i === 0) {\n                res.push(Math.min(dp[i], dp[i\
    \ - 1]));\n            } else if (j === 0) {\n                res.push(Math.min(dp[i],\
    \ dp[i - 1]));\n            } else {\n                res.push(Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1])));\n            }\n        }\n    }\n    return\
    \ res.sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j\
    \ - 1] + grid[i][j]);\n            }\n        }\n    }\n    let result = [];\n\
    \    for (let i = 0; i < k; i++) {\n        result.push(dp[i * grid[0].length\
    \ + k]);\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] +\
    \ grid[i][j]);\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + (j - 1)] + grid[i][j]);\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + (j - 1)] + grid[i][j]);\n\
    \            }\n            if (i > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n            }\n            if (j > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + (j - 1)] + grid[i][j]);\n            }\n        }\n    }\n    let result =\
    \ [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[0].length; j++) {\n            if (dp[i * grid[0].length + j]", "   \
    \ let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[(i\
    \ - 1) * grid[0].length + j - 1]);\n            }\n            if (i > 0) {\n\
    \                result.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length\
    \ + j]);\n            }\n            if (j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j] - dp[i * grid[0].length + j - 1]);\n            }\n  \
    \      }\n    }\n    return result.sort((a, b) => a - b);\n}\n", "    let dp =\
    \ new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let m = grid.length;\n    let n = grid[0].length;\n    let i = 0;\n    let\
    \ j = 0;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n \
    \           dp[i] = dp[i] || [];\n            dp[i][j] = grid[i][j];\n       \
    \     lst[i] = lst[i] || [];\n            lst[i][j] = i * n + j;\n        }\n\
    \    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n        let min\
    \ = Number.MAX_SAFE_INTEGER;\n        let min_i = -1;\n        let min_j = -1;\n\
    \        for (let j = 0; j < n; j++) {\n            let min_j_i = -1;\n      \
    \      for (let i_ = 0; i_ < m; i_++) {\n                if (dp[i_][j] < min)\
    \ {\n                    min = dp[i_][j];\n                    min_i = i_;\n \
    \                   min_j = j;\n                    min_j_i = i_ * n + j;\n  \
    \              }\n            }\n            if (min_j_i !== -1) {\n         \
    \       dp[min_i][min_j] = min + 1;\n                lst[min_i][min_j] = min_j_i;\n\
    \            }\n        }\n        res.push(lst[min_i][min_j]);\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    let res = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i * grid[0].length + j]\
    \ = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n\
    \            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1]) + grid[i][j]);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < k; i++) {\n        res.push(dp[i * grid[0].length + grid[0].length -\
    \ 1]);\n    }\n    return res;\n}\n", "    let m = grid.length, n = grid[0].length,\n\
    \        dp = Array(m).fill(0),\n        visited = Array(m).fill(0);\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   if (i === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n      \
    \      } else if (i === 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \            } else if (j === 0) {\n                dp[i][j] = dp[i - 1][j] +\
    \ grid[i][j];\n            } else {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let\
    \ result = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j <\
    \ n; j++) {\n            if (dp[i][j] === k) {\n                result.push(grid[i][j]);\n\
    \            }\n        }\n    }\n    return result;\n}\n", "    const rows =\
    \ grid.length;\n    const cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n\
    \    const dp_next = new Array(rows).fill(0);\n    for (let i = 0; i < rows; i++)\
    \ {\n        for (let j = 0; j < cols; j++) {\n            dp[i] = dp[i] || [];\n\
    \            dp[i][j] = grid[i][j];\n            dp_next[i] = dp_next[i] || [];\n\
    \            dp_next[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1, dp[i - 1][j]\
    \ + 1, dp[i - 1][j - 1] + 1);\n        }\n    }\n    let result = [];\n    for\
    \ (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n   \
    \         if (dp_next[i][j] === k) {\n                result.push(grid[i][j]);\n\
    \            }\n        }\n    }\n    return result;\n}\n", "  const rows = grid.length\n\
    \  const cols = grid[0].length\n  const dp = new Array(rows).fill(0)\n  for (let\
    \ i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      dp[i] =\
    \ Math.min(dp[i], dp[i - 1] + grid[i][j])\n    }\n  }\n  let result = []\n  for\
    \ (let i = 0; i < k; i++) {\n    result.push(dp[rows - 1 - i])\n  }\n  return\
    \ result\n}\n", "    let m = grid.length, n = grid[0].length,\n        visited\
    \ = new Array(m).fill(0),\n        min = new Array(m).fill(Number.MAX_VALUE),\n\
    \        min_index = new Array(m).fill(0);\n    \n    for (let i = 0; i < m; i++)\
    \ {\n        for (let j = 0; j < n; j++) {\n            if (visited[i] === 0 &&\
    \ min[i] === Number.MAX_VALUE) {\n                min[i] = grid[i][j];\n     \
    \           min_index[i] = j;\n            } else if (visited[i] === 0 && grid[i][j]\
    \ < min[i]) {\n                min[i] = grid[i][j];\n                min_index[i]\
    \ = j;\n            }\n        }\n        visited[i] = 1;\n    }\n    \n    let\
    \ lst = [];\n    for (let i = 0; i < m; i++) {\n        lst.push(min[i]);\n  \
    \      if (i === k - 1) {\n            break;\n        }\n        let j = min_index[i];\n\
    \        for (let jj = 0; jj < n; jj++) {\n            if (jj !== j) {\n     \
    \           min[i] = grid[i][jj];\n                min_index[i] = jj;\n      \
    \          break;\n            }\n        }\n    }\n    \n    return lst;\n}\n",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n     \
    \       lst[i] = Math.min(lst[i], dp[i] + grid[i][j]);\n        }\n    }\n   \
    \ let ans = new Array(k + 1).fill(0);\n    for (let i = 0; i < k; i++) {\n   \
    \     ans[i + 1] = lst[k - i];\n    }\n    return ans;\n}\n", "    const rows\
    \ = grid.length;\n    const cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n\
    \    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++)\
    \ {\n            if (i > 0 && dp[i - 1] + 1 < dp[i]) {\n                dp[i]\
    \ = dp[i - 1] + 1;\n            }\n            if (j > 0 && dp[i] + 1 < dp[i +\
    \ 1]) {\n                dp[i] = dp[i + 1] + 1;\n            }\n        }\n  \
    \  }\n    let result = [];\n    for (let i = 0; i < rows; i++) {\n        for\
    \ (let j = 0; j < cols; j++) {\n            if (i > 0 && dp[i - 1] + 1 < dp[i])\
    \ {\n                result.push(grid[i - 1][j]);\n            }\n           \
    \ if (j > 0 && dp[i] + 1 < dp[i + 1]) {\n                result.push(grid[i][j\
    \ - 1]);\n            }\n        }\n    }\n    return result.sort((a, b) => a\
    \ - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[0].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[0].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               dp[i * grid[0].length + j] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n            } else if (j\
    \ === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            } else {\n\
    \                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length +\
    \ j], Math.min(dp[(i - 1) * grid[0].length + j], dp[i * grid[0].length + j - 1])\
    \ + grid[i][j]);\n            }\n        }\n    }\n    let result = [];\n    for\
    \ (let i = 0; i < k; i++) {\n        result.push(dp[i * grid[0].length + grid[0].length\
    \ - 1]);\n    }\n    return result;\n}\n", "    const rows = grid.length;\n  \
    \  const cols = grid[0].length;\n    const dp = Array(rows).fill(0).map(() =>\
    \ Array(cols).fill(0));\n    \n    for (let i = 0; i < rows; i++) {\n        for\
    \ (let j = 0; j < cols; j++) {\n            if (i === 0 && j === 0) {\n      \
    \          dp[i][j] = grid[i][j];\n            } else if (i === 0) {\n       \
    \         dp[i][j] = Math.min(dp[i][j - 1], dp[i][j]) + grid[i][j];\n        \
    \    } else if (j === 0) {\n                dp[i][j] = Math.min(dp[i - 1][j],\
    \ dp[i][j]) + grid[i][j];\n            } else {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    \n\
    \    let result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(dp[rows\
    \ - 1][cols - 1]);\n        for (let j = cols - 2; j >= 0; j--) {\n          \
    \  if (dp[rows - 1][j] < dp[rows - 1][j + 1]) {\n                result.push(dp[rows\
    \ - 1][j]);\n            } else {\n                result.push(dp[rows - 1][j\
    \ + 1]);\n            }\n        }\n        for (let j = rows - 2; j >= 0; j--)\
    \ {\n            if (dp[j][cols - 1] < dp[j + 1][cols - 1]) {\n              \
    \  result.push(dp[j][cols - 1]);\n            } else {\n                result.push(dp[j\
    \ + 1][cols - 1]);\n            }\n        }\n    }\n    \n    return result;\n\
    }\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_row = new Array(grid.length).fill(Number.POSITIVE_INFINITY);\n   \
    \ let dp_col = new Array(grid[0].length).fill(Number.POSITIVE_INFINITY);\n   \
    \ dp[0] = 0;\n    dp_row[0] = 0;\n    dp_col[0] = 0;\n    for (let i = 1; i <\
    \ grid.length; i++) {\n        for (let j = 1; j < grid[0].length; j++) {\n  \
    \          dp[i * grid.length + j] = Math.min(dp[i * grid.length + j], dp[i *\
    \ grid.length + j - 1] + grid[i - 1][j - 1]);\n            dp_row[i] = Math.min(dp_row[i],\
    \ dp[i * grid.length + j - 1] + grid[i - 1][j]);\n            dp_col[j] = Math.min(dp_col[j],\
    \ dp[i - 1 + j * grid.length] + grid[i][j - 1]);\n        }\n    }\n    let result\
    \ = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0;\
    \ j < grid[0].length; j++) {\n            if (dp[i * grid.length + j] === dp[i\
    \ * grid.length + j]) {\n                result.push(grid[i][j]);\n          \
    \  }\n        }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] +\
    \ grid[i][j]);\n            }\n            if (i > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length\
    \ + j] + grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let\
    \ result = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           result.push(dp[i * grid[0].length + j] - dp[i * grid[0].length + j\
    \ - 1] - grid[i][j]);\n            }\n            if (i > 0) {\n             \
    \   result.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length + j]\
    \ - grid[i][j]);\n            }\n            if (j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j] - dp[i * grid[0].length + j - grid[0].length] - grid[i][j]);\n\
    \            }\n        }\n    }\n    return result", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    let result\
    \ = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0;\
    \ j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n            \
    \    dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i *\
    \ grid[0].length + j - 1] + grid[i][j]);\n            }\n            if (i > 0)\
    \ {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j\
    \ - 1] + grid[i][j]);\n            }\n        }\n    }\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n\
    \            if (i > 0 && j > 0) {\n                result.push(dp[i * grid[0].length\
    \ + j] - 1);\n            }\n            if (i > 0) {\n                result.push(dp[(i\
    \ - 1) * grid[0].length + j] - 1);\n            }\n            if (j > 0) {\n\
    \                result.push(dp[i * grid[0].length + j - grid[0].length]", " \
    \   let dp = new Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j -\
    \ 1]);\n        }\n    }\n    for (let i = 0; i < k + 1; i++) {\n        res[i]\
    \ = dp[grid.length - 1][i];\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            lst[i] = Math.min(lst[i],\
    \ dp[i] + grid[i][j]);\n        }\n    }\n    let res = [];\n    for (let i =\
    \ 0; i < k; i++) {\n        res.push(lst[k]);\n    }\n    return res;\n}\n", " \
    \   let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < k;\
    \ i++) {\n        result.push(dp[i * grid[0].length + k]);\n    }\n    return\
    \ result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let lst =\
    \ new Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n \
    \   let i = 0;\n    for (let j = 0; j < grid.length; j++) {\n        for (let\
    \ k = 0; k < grid[j].length; k++) {\n            if (grid[j][k] === 0) {\n   \
    \             continue;\n            }\n            dp[j] = dp[j] || [];\n   \
    \         dp[j][k] = grid[j][k];\n            lst[j] = lst[j] || [];\n       \
    \     lst[j][k] = grid[j][k];\n        }\n    }\n    for (let j = 0; j < grid.length;\
    \ j++) {\n        for (let k = 0; k < grid[j].length; k++) {\n            if (grid[j][k]\
    \ === 0) {\n                continue;\n            }\n            for (let i =\
    \ 1; i <= k; i++) {\n                if (dp[j][k - i] < dp[j][k]) {\n        \
    \            dp[j][k] = dp[j][k - i];\n                    lst[j][k] = lst[j][k\
    \ - i];\n                }\n            }\n        }\n    }\n    for (let j =\
    \ 0; j < grid.length; j++) {\n        for (let k = 0; k < grid[j].length; k++)\
    \ {\n            if (grid[j][k] === 0) {\n                continue;\n        \
    \    }\n            for (let i = 1; i <= k; i++) {\n                if (dp[j][k\
    \ - i] < dp[j][k]) {\n                    dp[j][k] = dp[j][k - i];\n         \
    \           lst[j][k] = lst[j][k - i];\n                }\n            }\n   \
    \     }\n    }\n    for (let j = 0; j < grid.length; j++) {\n        for (let\
    \ k = 0; k < grid[j].length; k++) {\n            if", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            lst[i] = Math.min(lst[i],\
    \ dp[i] + grid[i][j]);\n        }\n    }\n    let res = [];\n    for (let i =\
    \ 0; i < k; i++) {\n        res.push(lst[k - i]);\n    }\n    return res;\n}\n",
  "    let dp = new Array(grid.length * grid[0].length);\n    for (let i = 0; i <\
    \ dp.length; i++) {\n        dp[i] = Number.MAX_VALUE;\n    }\n    dp[0] = 0;\n\
    \    let min = Number.MAX_VALUE;\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 0) {\n                continue;\n            }\n            let cur = dp[i\
    \ * grid[0].length + j];\n            let next = dp[i * grid[0].length + j + 1]\
    \ + grid[i][j];\n            if (next < cur) {\n                dp[i * grid[0].length\
    \ + j + 1] = next;\n            }\n            if (next < min) {\n           \
    \     min = next;\n            }\n        }\n    }\n    let res = [];\n    let\
    \ cur = 0;\n    while (cur < dp.length) {\n        if (dp[cur] === min) {\n  \
    \          res.push(grid[cur / grid[0].length][cur % grid[0].length]);\n     \
    \       cur++;\n        } else {\n            cur++;\n        }\n    }\n    return\
    \ res;\n}\n", "    const N = grid.length;\n    const M = grid[0].length;\n   \
    \ const dp = Array(N + 1).fill(0);\n    for (let i = 1; i <= N; i++) {\n     \
    \   for (let j = 1; j <= M; j++) {\n            if (i === 1 && j === 1) {\n  \
    \              dp[i] = grid[i - 1][j - 1];\n            } else if (i === 1) {\n\
    \                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i - 1][j]);\n      \
    \      } else if (j === 1) {\n                dp[i] = Math.min(dp[i], dp[i - 1]\
    \ + grid[i][j - 1]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i]) + grid[i][j]);\n            }\n        }\n    }\n\
    \    const res = [];\n    for (let i = k; i > 0; i--) {\n        res.push(dp[i]);\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let res = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               dp[i * grid[0].length + j] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[(i - 1)\
    \ * grid[0].length + j], grid[i][j]);\n            } else if (j === 0) {\n   \
    \             dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + (j\
    \ - 1)], grid[i][j]);\n            } else {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], Math.min(dp[i * grid[0].length\
    \ + (j - 1)], grid[i][j]));\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (dp[i * grid[0].length + j] === Number.MAX_SAFE_INTEGER) {\n\
    \                continue;\n            }\n            if (k === 1) {\n      \
    \          res.push(dp[i * grid[0].length + j]);\n            } else {\n     \
    \           let lst = [];\n                for (let k = 1; k <= k; k++) {\n  \
    \                  lst.push(dp[i * grid[0].length + j]);\n                }\n\
    \                let lst_sorted = lst.sort((a, b) => a - b);\n               \
    \ let lst_sorted_index = [];\n                for (let k = 0; k < lst_sorted.length;\
    \ k++) {\n                    lst_sorted_index.push(lst_", "    const N = grid.length;\n\
    \    const M = grid[0].length;\n    const dp = new Array(N * M + 1).fill(0);\n\
    \    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n  \
    \          dp[i * M + j + 1] = Math.min(dp[i * M + j + 1], dp[i * M + j] + grid[i][j]);\n\
    \        }\n    }\n    let result = [];\n    for (let i = 1; i <= k; i++) {\n\
    \        result.push(dp[i * M + k]);\n    }\n    return result;\n}\n", "    let\
    \ dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && grid[i][j] < dp[i\
    \ * grid[0].length + j]) {\n                dp[i * grid[0].length + j] = grid[i][j];\n\
    \            }\n            if (j > 0 && grid[i][j] < dp[i * grid[0].length +\
    \ j - 1]) {\n                dp[i * grid[0].length + j - 1] = grid[i][j];\n  \
    \          }\n            if (i > 0 && j > 0 && grid[i][j] < dp[(i - 1) * grid[0].length\
    \ + j - 1]) {\n                dp[(i - 1) * grid[0].length + j - 1] = grid[i][j];\n\
    \            }\n        }\n    }\n    let res = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && j > 0 && dp[(i - 1) * grid[0].length + j - 1] === k) {\n            \
    \    res.push(grid[i][j]);\n            }\n        }\n    }\n    return res;\n\
    }\n", "    let m = grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0);\n\
    \    let lst = new Array(m).fill(0);\n    for (let i = 0; i < m; i++) {\n    \
    \    for (let j = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n  \
    \              dp[i] = grid[i][j];\n                lst[i] = grid[i][j];\n   \
    \         } else if (i === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                lst[i] = grid[i][j];\n            } else if (j ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n       \
    \         lst[i] = grid[i][j];\n            } else {\n                dp[i] =\
    \ Math.min(dp[i], grid[i][j] + dp[i]);\n                lst[i] = Math.min(lst[i],\
    \ grid[i][j] + dp[i]);\n            }\n        }\n    }\n    let res = [];\n \
    \   for (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    let dp_row = new Array(grid.length).fill(Number.POSITIVE_INFINITY);\n   \
    \ let dp_col = new Array(grid[0].length).fill(Number.POSITIVE_INFINITY);\n   \
    \ dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n       \
    \         dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if (i >\
    \ 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp_row[i - 1] + grid[i][j]);\n            }\n            if (j > 0) {\n\
    \                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length +\
    \ j], dp_col[j - 1] + grid[i][j]);\n            }\n        }\n    }\n    let res\
    \ = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0;\
    \ j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n            \
    \    res.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length + (j -\
    \ 1)]);\n            }\n            if (i > 0) {\n                res.push(dp_row[i\
    \ - 1] - dp[i * grid[0].length + j]);\n            }\n            if (j > 0) {\n\
    \                res.push(dp_col[j - 1] - dp[i * grid[0].length + j]);\n     \
    \       }\n        }\n    }", "    let dp = new Array(grid.length).fill(0).map(()\
    \ => new Array(grid[0].length).fill(0));\n    let dp_prev = new Array(grid.length).fill(0).map(()\
    \ => new Array(grid[0].length).fill(0));\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i\
    \ === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n              \
    \  dp_prev[i][j] = grid[i][j];\n            } else if (i === 0) {\n          \
    \      dp[i][j] = dp_prev[i][j] + grid[i][j];\n                dp_prev[i][j] =\
    \ dp[i][j];\n            } else if (j === 0) {\n                dp[i][j] = dp_prev[i][j]\
    \ + grid[i][j];\n                dp_prev[i][j] = dp[i][j];\n            } else\
    \ {\n                dp[i][j] = Math.min(dp_prev[i][j], dp_prev[i][j - 1]) + grid[i][j];\n\
    \                dp_prev[i][j] = dp[i][j];\n            }\n        }\n    }\n\
    \    let result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(dp[0][0]);\n\
    \        for (let j = 0; j < dp.length - 1; j++) {\n            if (dp[j + 1][0]\
    \ < dp[j][0]) {\n                result.push(dp[j + 1][0]);\n            } else\
    \ {\n                result.push(dp[j][0]);\n            }\n        }\n    }\n\
    \    return result;\n}\n", "    let m = grid.length, n = grid[0].length;\n   \
    \ let dp = Array(m).fill(0);\n    let lst = Array(m).fill(0);\n    for (let i\
    \ = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i\
    \ === 0 && j === 0) {\n                dp[i] = grid[i][j];\n                lst[i]\
    \ = grid[i][j];\n            } else if (i === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n                lst[i] = dp[i];\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst[i] = dp[i];\n            } else {\n                dp[i]\
    \ = Math.min(dp[i], Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n          \
    \      lst[i] = dp[i];\n            }\n        }\n    }\n    let res = [];\n \
    \   for (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let dp_prev =\
    \ new Array(grid.length).fill(0);\n    let dp_curr = new Array(grid.length).fill(0);\n\
    \    let dp_next = new Array(grid.length).fill(0);\n    let dp_prev_next = new\
    \ Array(grid.length).fill(0);\n    let dp_curr_next = new Array(grid.length).fill(0);\n\
    \    let dp_prev_next_next = new Array(grid.length).fill(0);\n    let dp_curr_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next = new Array(grid.length).fill(0);\n\
    \    let dp_curr_next_next_next = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_curr_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_curr_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_curr_next_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_curr_next_next_next_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_next_next_next_next_next_next",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n\
    \                lst[i] = grid[i][j];\n            } else if (i === 0) {\n   \
    \             dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n                lst[i]\
    \ = dp[i];\n            } else if (j === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[j] + grid[i][j]);\n                lst[i] = dp[i];\n            } else {\n\
    \                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n              \
    \  lst[i] = dp[i];\n            }\n        }\n    }\n    let res = [];\n    for\
    \ (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n    }\n    return res;\n\
    }\n", "    let m = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0);\n\
    \    let lst = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                lst.push(dp[i]);\n            } else if (i ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n               \
    \ lst.push(dp[i]);\n            } else if (j === 0) {\n                dp[i] =\
    \ Math.min(dp[i], grid[i][j]);\n                lst.push(dp[i]);\n           \
    \ } else {\n                dp[i] = Math.min(dp[i], grid[i][j], dp[i - 1], dp[i]);\n\
    \                lst.push(dp[i]);\n            }\n        }\n    }\n    return\
    \ lst.slice(0, k);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] =\
    \ Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + (j - 1)]\
    \ + grid[i][j]);\n        }\n    }\n    let result = [];\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (dp[i * grid[0].length + j] === dp[i * grid[0].length + j]) {\n\
    \                result.push(grid[i][j]);\n            }\n        }\n    }\n \
    \   return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let\
    \ lst = new Array(grid.length).fill(0);\n    let mx = grid.length * grid[0].length;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i][j] = mx;\n            lst[i][j] = mx;\n        }\n\
    \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            for (let n = 0; n < 4; n++) {\n      \
    \          let x = i + dx[n];\n                let y = j + dy[n];\n          \
    \      if (x >= 0 && x < grid.length && y >= 0 && y < grid[i].length) {\n    \
    \                let d = dp[i][j] + grid[x][y];\n                    if (d < dp[x][y])\
    \ {\n                        dp[x][y] = d;\n                        lst[x][y]\
    \ = lst[i][j];\n                    }\n                }\n            }\n    \
    \    }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n        let\
    \ min = dp[0][0];\n        let min_i = 0;\n        let min_j = 0;\n        for\
    \ (let j = 0; j < grid.length; j++) {\n            for (let n = 0; n < 4; n++)\
    \ {\n                let x = j + dy[n];\n                let y = i + dx[n];\n\
    \                if (x >= 0 && x < grid.length && y >= 0 && y < grid[i].length)\
    \ {\n                    let d = dp[j][i] + grid[x][y];\n                    if\
    \ (d < min) {\n                        min = d;\n                        min_i\
    \ = j;\n                        min_j = i;\n                    }\n          \
    \      }\n            }\n        }\n        res.push(grid[min_i][min_j]);\n  \
    \      ", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j\
    \ - 1] + grid[i][j]);\n            }\n        }\n    }\n    let res = [];\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                res.push(dp[i * grid[0].length\
    \ + j] - dp[(i - 1) * grid[0].length + j - 1] - grid[i][j]);\n            }\n\
    \            if (i > 0) {\n                res.push(dp[i * grid[0].length + j]\
    \ - dp[(i - 1) * grid[0].length + j]);\n", "    let m = grid.length, n = grid[0].length;\n\
    \    let dp = new Array(m).fill(0);\n    let dp_prev = new Array(m).fill(0);\n\
    \    let dp_next = new Array(m).fill(0);\n    let dp_prev_next = new Array(m).fill(0);\n\
    \    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j] + Math.min(dp_prev[i][j], dp_next[i][j]);\n \
    \           dp_prev[i][j] = dp[i][j];\n            dp_next[i][j] = Math.min(dp_prev[i][j],\
    \ dp_next[i][j]);\n            dp_prev_next[i][j] = Math.min(dp_prev[i][j], dp_next[i][j]);\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i < m; i++) {\n \
    \       for (let j = 0; j < n; j++) {\n            if (dp_prev_next[i][j] ===\
    \ k) {\n                result.push(grid[i][j]);\n            }\n        }\n \
    \   }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    let i = 0;\n    for (let j\
    \ = 0; j < grid.length; j++) {\n        for (let k = 0; k < grid[j].length; k++)\
    \ {\n            dp[j] = Math.min(dp[j], dp[j - 1] + grid[j][k]);\n          \
    \  lst[j] = Math.min(lst[j], dp[j] + grid[j][k]);\n        }\n    }\n    let res\
    \ = [];\n    for (let j = k - 1; j >= 0; j--) {\n        res.unshift(lst[j]);\n\
    \    }\n    return res;\n}\n", "    let m = grid.length, n = grid[0].length,\n\
    \        path = [],\n        visited = new Set();\n    \n    for (let i = 0; i\
    \ < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (visited.has(i\
    \ * n + j)) continue;\n            \n            path.push(grid[i][j]);\n    \
    \        visited.add(i * n + j);\n            \n            if (k === 1) break;\n\
    \            \n            let neighbors = [\n                [i - 1, j],\n  \
    \              [i + 1, j],\n                [i, j - 1],\n                [i, j\
    \ + 1]\n            ];\n            \n            for (let neighbor of neighbors)\
    \ {\n                if (neighbor[0] >= 0 && neighbor[0] < m &&\n            \
    \        neighbor[1] >= 0 && neighbor[1] < n &&\n                    !visited.has(neighbor[0]\
    \ * n + neighbor[1])) {\n                    path.push(grid[neighbor[0]][neighbor[1]]);\n\
    \                    visited.add(neighbor[0] * n + neighbor[1]);\n           \
    \     }\n            }\n        }\n    }\n    \n    return path.sort((a, b) =>\
    \ a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length);\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            dp[i * grid[0].length + j] = grid[i][j];\n        }\n  \
    \  }\n    let lst = [];\n    for (let i = 0; i < grid.length; i++) {\n       \
    \ for (let j = 0; j < grid[0].length; j++) {\n            let cur = dp[i * grid[0].length\
    \ + j];\n            let next = dp[(i + 1) * grid[0].length + j];\n          \
    \  let left = dp[i * grid[0].length + j - 1];\n            let right = dp[i *\
    \ grid[0].length + j + 1];\n            if (cur < next && cur < left && cur <\
    \ right) {\n                lst.push(cur);\n            } else if (left < right)\
    \ {\n                lst.push(left);\n            } else {\n                lst.push(right);\n\
    \            }\n        }\n    }\n    return lst.slice(0, k);\n}\n", "    let\
    \ dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    const n = grid.length;\n    const m = grid[0].length;\n    const dp = new Array(m).fill(0);\n\
    \    let min = dp[0];\n    for (let i = 0; i < m; i++) {\n        for (let j =\
    \ 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[j][i];\n            } else if (i === 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[j] + grid[j][i]);\n            } else if (j === 0) {\n                dp[i]\
    \ = Math.min(dp[i], dp[j] + grid[j][i]);\n            } else {\n             \
    \   dp[i] = Math.min(dp[i], dp[j] + grid[j][i]);\n            }\n            min\
    \ = Math.min(min, dp[i]);\n        }\n    }\n    return dp.slice(0, k).sort((a,\
    \ b) => a - b);\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let\
    \ res = new Array(k + 1).fill(0);\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            dp[i] = Math.max(dp[i],\
    \ grid[i][j]);\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            for (let l =\
    \ 1; l <= k; l++) {\n                if (i - l >= 0 && j - l >= 0 && i + l < grid.length\
    \ && j + l < grid[i].length) {\n                    dp[i] = Math.min(dp[i], dp[i\
    \ - l] + dp[j - l] + grid[i][j]);\n                }\n            }\n        }\n\
    \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            res[0] = Math.min(res[0], dp[i] + dp[j]);\n\
    \        }\n    }\n    for (let i = 0; i < k; i++) {\n        res[i + 1] = Math.min(res[i\
    \ + 1], res[i]);\n    }\n    return res;\n}\n", "    const n = grid.length;\n\
    \    const m = grid[0].length;\n    const dp = Array(n + 1).fill(0);\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   if (i === 0 && j === 0) {\n                dp[i + 1] = grid[i][j];\n     \
    \       } else if (i === 0) {\n                dp[i + 1] = Math.min(dp[i + 1],\
    \ dp[i] + grid[i][j]);\n            } else if (j === 0) {\n                dp[i\
    \ + 1] = Math.min(dp[i + 1], dp[i] + grid[i][j]);\n            } else {\n    \
    \            dp[i + 1] = Math.min(dp[i + 1], dp[i] + Math.min(grid[i][j], grid[i][j\
    \ - 1]));\n            }\n        }\n    }\n    const result = [];\n    for (let\
    \ i = 1; i <= k; i++) {\n        result.push(dp[i]);\n    }\n    return result;\n\
    }\n", "    const N = grid.length;\n    const M = grid[0].length;\n    const dp\
    \ = Array(N + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= N; i++) {\n\
    \        for (let j = 1; j <= M; j++) {\n            if (i > 1 && grid[i - 1][j]\
    \ > grid[i][j]) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n \
    \           }\n            if (j > 1 && grid[i][j - 1] > grid[i][j]) {\n     \
    \           dp[i] = Math.min(dp[i], dp[i] + 1);\n            }\n        }\n  \
    \  }\n    let result = [];\n    for (let i = k; i > 0; i--) {\n        result.unshift(dp[N]\
    \ - dp[i - 1]);\n    }\n    return result;\n}\n", "    let m = grid.length, n\
    \ = grid[0].length;\n    let dp = Array(m).fill(0);\n    for (let i = 0; i < m;\
    \ i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 && j\
    \ === 0) {\n                dp[i] = grid[i][j];\n            } else if (i ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n   \
    \         } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j], dp[i - 1] + grid[i][j - 1]);\n            }\n      \
    \  }\n    }\n    let result = [];\n    for (let i = 0; i < m; i++) {\n       \
    \ result.push(dp[i]);\n    }\n    return result.sort((a, b) => a - b);\n}\n",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + 1);\n            }\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (dp[i\
    \ * grid[0].length + j] === k) {\n                result.push(grid[i][j]);\n \
    \           }\n        }\n    }\n    return result;\n}\n", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = new Array(m).fill(0);\n    let dp_i = new\
    \ Array(m).fill(0);\n    let dp_j = new Array(m).fill(0);\n    for (let i = 0;\
    \ i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i] = grid[i][j];\n                dp_i[i]\
    \ = 0;\n                dp_j[i] = 0;\n            } else if (i === 0) {\n    \
    \            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n              \
    \  dp_i[i] = dp_i[i - 1] + 1;\n                dp_j[i] = dp_j[i - 1];\n      \
    \      } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1]\
    \ + grid[i][j]);\n                dp_i[i] = dp_i[i - 1];\n                dp_j[i]\
    \ = dp_j[i - 1] + 1;\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n                dp_i[i] = Math.min(dp_i[i\
    \ - 1], dp_i[i - 1] + 1);\n                dp_j[i] = Math.min(dp_j[i - 1], dp_j[i\
    \ - 1] + 1);\n            }\n        }\n    }\n    let result = [];\n    for (let\
    \ i = 0; i < k; i++) {\n        result.push(dp[m - 1 - i]);\n    }\n    return\
    \ result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let dp_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next = new Array(grid.length).fill(0);\n\
    \    let dp_prev_next = new Array(grid.length).fill(0);\n    let dp_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next_next_next = new Array(grid.length).fill(0);\n    let dp_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next = new Array(grid.length).fill(0);\n\
    \    let dp_next_next_next_next_prev = new Array(grid.length).fill(0);\n    let\
    \ dp_next_next_next_next_next = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = new Array(m).fill(0);\n    for (let i = 0;\
    \ i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i - 1] + grid[i][j]));\n            }\n        }\n  \
    \  }\n    let res = [];\n    for (let i = 0; i < m; i++) {\n        res.push(dp[i]);\n\
    \    }\n    return res.sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.max(dp[i], grid[i][j]);\n            lst[i]\
    \ = Math.max(lst[i], grid[i][j]);\n        }\n    }\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            for\
    \ (let k = 1; k <= k; k++) {\n                if (dp[i] + k > dp[i + 1]) {\n \
    \                   break;\n                }\n                if (lst[i] + k\
    \ > lst[i + 1]) {\n                    break;\n                }\n           \
    \     if (dp[i] + k > dp[i + 1] || lst[i] + k > lst[i + 1]) {\n              \
    \      continue;\n                }\n                res[k] = Math.max(res[k],\
    \ grid[i][j]);\n            }\n        }\n    }\n    return res;\n}\n", "    let\
    \ dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], grid[i][j] + 1);\n            lst[i]\
    \ = Math.max(lst[i], grid[i][j] + 1);\n        }\n    }\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (i - 1 >= 0 && j - 1 >= 0 && grid[i - 1][j - 1] + 1 === lst[i])\
    \ {\n                dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n            }\n\
    \            if (i - 1 >= 0 && grid[i - 1][j] + 1 === lst[i]) {\n            \
    \    dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n            }\n            if (i\
    \ - 1 >= 0 && j + 1 < grid[i].length && grid[i - 1][j + 1] + 1 === lst[i]) {\n\
    \                dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n            }\n    \
    \        if (j - 1 >= 0 && grid[i][j - 1] + 1 === lst[i]) {\n                dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + 1);\n            }\n            if (j + 1 < grid[i].length\
    \ && grid[i][j + 1] + 1 === lst[i]) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + 1);\n            }\n        }\n    }\n    let result = [];\n   \
    \ for (let i = 0; i < k; i++) {\n        result.push(lst[k]);\n    }\n    return\
    \ result;\n", "    let m = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0);\n\
    \    let dp_i = Array(m).fill(0);\n    let dp_j = Array(m).fill(0);\n    let dp_k\
    \ = Array(m).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j =\
    \ 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                dp_i[i] = i;\n                dp_j[i] = j;\n\
    \                dp_k[i] = k;\n            } else if (i === 0) {\n           \
    \     dp[i] = Math.min(dp[i], grid[i][j]);\n                dp_i[i] = i;\n   \
    \             dp_j[i] = j;\n                dp_k[i] = k;\n            } else if\
    \ (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n        \
    \        dp_i[i] = i;\n                dp_j[i] = j;\n                dp_k[i] =\
    \ k;\n            } else {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n\
    \                dp_i[i] = i;\n                dp_j[i] = j;\n                dp_k[i]\
    \ = k;\n            }\n        }\n    }\n    let lst = [];\n    for (let i = 0;\
    \ i < m; i++) {\n        if (dp_i[i] === i) {\n            lst.push(dp[i]);\n\
    \        }\n    }\n    return lst;\n}\n", "    const N = grid.length;\n    const\
    \ M = grid[0].length;\n    const dp = Array(N + 1).fill(0);\n    dp[0] = 0;\n\
    \    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n  \
    \          if (i > 0 && grid[i - 1][j] > grid[i][j]) {\n                dp[i +\
    \ 1] = Math.min(dp[i + 1], dp[i] + 1);\n            }\n            if (j > 0 &&\
    \ grid[i][j - 1] > grid[i][j]) {\n                dp[i + 1] = Math.min(dp[i +\
    \ 1], dp[i] + 1);\n            }\n        }\n    }\n    return dp[N] === 0 ? []\
    \ : dp[N] === k ? grid[N - 1].slice(0, k) : dp[N] - k;\n}\n", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0]\
    \ = 0;\n    let res = [];\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[0].length; j++) {\n            if (i === 0 && j ===\
    \ 0) {\n                dp[i * grid[0].length + j] = grid[i][j];\n           \
    \ } else if (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j - 1], grid[i][j]);\n            } else if (j === 0) {\n\
    \                dp[i * grid[0].length + j] = Math.min(dp[(i - 1) * grid[0].length\
    \ + j], grid[i][j]);\n            } else {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j - 1], Math.min(dp[(i - 1) *\
    \ grid[0].length + j], dp[i * grid[0].length + j - 1]));\n            }\n    \
    \    }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n   \
    \             res.push(dp[i * grid[0].length + j]);\n            } else if (i\
    \ === 0) {\n                res.push(Math.min(dp[i * grid[0].length + j - 1],\
    \ grid[i][j]));\n            } else if (j === 0) {\n                res.push(Math.min(dp[(i\
    \ - 1) * grid[0].length + j], grid[i][j]));\n            } else {\n          \
    \      res.push(Math.min(dp[(i - 1) * grid[0].length + j - 1], Math.min(dp[(i\
    \ - 1) * grid[0].length +", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    let lst = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i > 0\
    \ && j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n       \
    \     if (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j > 0) {\n                dp[i * grid[0].length +\
    \ j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + 1] + grid[i][j]);\n            }\n            if (i < grid.length", " \
    \ const rows = grid.length\n  const cols = grid[0].length\n  const dp = new Array(rows).fill(0)\n\
    \  const dp_cache = new Map()\n\n  for (let i = 0; i < rows; i++) {\n    for (let\
    \ j = 0; j < cols; j++) {\n      if (i === 0 && j === 0) {\n        dp[i][j] =\
    \ grid[i][j]\n      } else if (i === 0) {\n        dp[i][j] = Math.min(dp[i][j\
    \ - 1], dp[i][j])\n      } else if (j === 0) {\n        dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j])\n      } else {\n        const key = i * cols + j\n     \
    \   if (!dp_cache.has(key)) {\n          dp_cache.set(key, Math.min(dp[i - 1][j],\
    \ dp[i][j - 1]))\n        }\n        dp[i][j] = dp_cache.get(key)\n      }\n \
    \   }\n  }\n\n  const result = []\n  for (let i = 0; i < rows; i++) {\n    for\
    \ (let j = 0; j < cols; j++) {\n      if (i === 0 && j === 0) {\n        result.push(grid[i][j])\n\
    \      } else if (i === 0) {\n        result.push(Math.min(dp[i][j], grid[i][j]))\n\
    \      } else if (j === 0) {\n        result.push(Math.min(dp[i][j], grid[i][j]))\n\
    \      } else {\n        result.push(Math.min(dp[i][j], grid[i][j]))\n      }\n\
    \    }\n  }\n\n  return result\n}\n", "    let dp = new Array(grid.length * grid[0].length);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            dp[i * grid[0].length + j] = grid[i][j];\n        }\n  \
    \  }\n    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n    \
    \    for (let j = 0; j < grid[0].length; j++) {\n            let min = dp[i *\
    \ grid[0].length + j];\n            for (let m = 0; m < grid.length; m++) {\n\
    \                for (let n = 0; n < grid[0].length; n++) {\n                \
    \    if (i != m && j != n && grid[m][n] < min) {\n                        min\
    \ = grid[m][n];\n                    }\n                }\n            }\n   \
    \         result.push(min);\n            dp[i * grid[0].length + j] = min + 1;\n\
    \        }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid.length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            dp[i]\
    \ = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            lst[i] = Math.max(lst[i],\
    \ dp[i]);\n        }\n    }\n    let result = [];\n    for (let i = lst.length\
    \ - 1; i >= 0; i--) {\n        if (lst[i] >= k) {\n            result.push(grid[i][lst[i]\
    \ - k]);\n        }\n    }\n    return result;\n}\n", "    const n = grid.length;\n\
    \    const m = grid[0].length;\n    const dp = new Array(n * m).fill(0);\n   \
    \ for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n     \
    \       dp[i * m + j] = Math.min(dp[i * m + j], dp[i * m + j - 1] + grid[i][j]);\n\
    \            dp[i * m + j] = Math.min(dp[i * m + j], dp[(i - 1) * m + j] + grid[i][j]);\n\
    \            dp[i * m + j] = Math.min(dp[i * m + j], dp[i * m + (j - 1)] + grid[i][j]);\n\
    \        }\n    }\n    const result = [];\n    for (let i = 0; i < n * m; i++)\
    \ {\n        result.push(dp[i]);\n    }\n    return result.sort((a, b) => a -\
    \ b);\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new\
    \ Array(grid.length).fill(0);\n    for (let i = 0; i < grid.length; i++) {\n \
    \       for (let j = 0; j < grid[i].length; j++) {\n            dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i][j]);\n            lst[i] = Math.max(lst[i], dp[i]);\n  \
    \      }\n    }\n    let ans = new Array(k + 1).fill(0);\n    for (let i = lst.length\
    \ - 1; i >= 0; i--) {\n        for (let j = 0; j < k; j++) {\n            if (lst[i]\
    \ == dp[i]) {\n                ans[j + 1] = grid[i][j];\n            }\n     \
    \   }\n    }\n    return ans;\n}\n", "    let dp = [[0] * grid[0].length for _\
    \ in range(grid.length)]\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  for (let j = 0; j < grid[i].length; j++) {\n            dp[i][j] = grid[i][j]\
    \ + Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1]))\n       \
    \ }\n    }\n    let res = []\n    for (let i = 0; i < k; i++) {\n        res.push(dp[grid.length\
    \ - 1][i])\n    }\n    return res\n}\n", "    const N = grid.length;\n    const\
    \ M = grid[0].length;\n    const dp = Array(N + 1).fill(0);\n    for (let i =\
    \ 0; i <= N; i++) {\n        dp[i] = Array(M + 1).fill(0);\n    }\n    for (let\
    \ i = 0; i <= N; i++) {\n        for (let j = 0; j <= M; j++) {\n            if\
    \ (i === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n           \
    \ } else if (i === 0) {\n                dp[i][j] = Math.min(dp[i][j - 1], dp[i][j])\
    \ + grid[i][j];\n            } else if (j === 0) {\n                dp[i][j] =\
    \ Math.min(dp[i - 1][j], dp[i][j]) + grid[i][j];\n            } else {\n     \
    \           dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n  \
    \          }\n        }\n    }\n    let result = [];\n    for (let i = 0; i <=\
    \ N; i++) {\n        for (let j = 0; j <= M; j++) {\n            if (i === 0 &&\
    \ j === 0) {\n                result.push(dp[i][j]);\n            } else if (i\
    \ === 0) {\n                result.push(Math.min(dp[i][j], dp[i][j - 1]));\n \
    \           } else if (j === 0) {\n                result.push(Math.min(dp[i -\
    \ 1][j], dp[i][j]));\n            } else {\n                result.push(Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]));\n            }\n        }\n    }\n    return result.sort((a,\
    \ b) => a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let min = new Array(grid.length).fill(0);\n    let i = 0;\n    for (let j\
    \ = 0; j < grid.length; j++) {\n        for (let k = 0; k < grid[j].length; k++)\
    \ {\n            dp[j] = Math.min(dp[j], dp[j - 1] + grid[j][k]);\n          \
    \  lst[j] = Math.min(lst[j], dp[j]);\n        }\n        dp[j] = Math.min(dp[j],\
    \ lst[j]);\n        min[j] = Math.min(min[j], dp[j]);\n    }\n    let res = new\
    \ Array(k + 1).fill(0);\n    for (let j = grid.length - 1; j >= 0; j--) {\n  \
    \      for (let k = 0; k < grid[j].length; k++) {\n            if (min[j] == dp[j])\
    \ {\n                res[k] = grid[j][k];\n            }\n        }\n    }\n \
    \   return res;\n}\n", "    let m = grid.length, n = grid[0].length,\n       \
    \ visited = new Set(),\n        min = [],\n        min_index = 0,\n        min_value\
    \ = Infinity,\n        min_path = [];\n\n    for (let i = 0; i < m; i++) {\n \
    \       for (let j = 0; j < n; j++) {\n            if (visited.has(i * n + j))\
    \ continue;\n            visited.add(i * n + j);\n            let value = grid[i][j];\n\
    \            if (value < min_value) {\n                min_value = value;\n  \
    \              min_index = i * n + j;\n                min = [...min];\n     \
    \       }\n            min.push(value);\n        }\n    }\n\n    let lst = [];\n\
    \    for (let i = 0; i < k; i++) {\n        lst.push(min[i]);\n    }\n\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   if (i * n + j === min_index) continue;\n            let value = grid[i][j];\n\
    \            if (value < min_value) {\n                min_value = value;\n  \
    \              min_index = i * n + j;\n                min = [...min];\n     \
    \       }\n            min.push(value);\n        }\n    }\n\n    for (let i =\
    \ 0; i < k; i++) {\n        lst.push(min[i]);\n    }\n\n    return lst;\n}\n",
  "    let dp = new Array(grid.length).fill(0);\n    let result = [];\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n\
    \                result.push(dp[i]);\n            } else if (i === 0) {\n    \
    \            dp[i] = Math.min(dp[i], grid[i][j] + dp[j]);\n                result.push(dp[i]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                result.push(dp[i]);\n            } else {\n     \
    \           dp[i] = Math.min(dp[i], grid[i][j] + Math.min(dp[i - 1], dp[j - 1]));\n\
    \                result.push(dp[i]);\n            }\n        }\n    }\n    return\
    \ result;\n}\n", "  const n = grid.length\n  const m = grid[0].length\n  const\
    \ dp = new Array(n).fill(0)\n  const dp_ = new Array(n).fill(0)\n  for (let i\
    \ = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i] = dp[i] ||\
    \ Infinity\n      dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j])\n      dp_[i]\
    \ = dp_[i] || Infinity\n      dp_[i] = Math.min(dp_[i], dp_[i - 1] + grid[i][j])\n\
    \    }\n  }\n  const res = []\n  for (let i = 0; i < k; i++) {\n    res.push(Math.min(dp[n\
    \ - 1], dp_[0]))\n    dp_[0] = dp[0]\n    dp[0] = Infinity\n  }\n  return res\n\
    }\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n     \
    \       lst[i] = Math.min(lst[i], dp[i] + grid[i][j]);\n        }\n    }\n   \
    \ let res = [];\n    for (let i = k - 1; i >= 0; i--) {\n        res.unshift(lst[i]);\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < k;\
    \ i++) {\n        result.push(dp[i * grid[0].length + grid[0].length - 1]);\n\
    \    }\n    return result;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_VALUE);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n                dp[i * grid[0].length + j] = Math.min(dp[i *\
    \ grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n            }\n            if (j > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n        }\n    }\n    let result = [];\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j] - dp[(i - 1) * grid[0].length + j - 1] - grid[i][j]);\n\
    \            }\n            if (i > 0) {\n                result.push(", "   \
    \ let m = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0);\n \
    \   let lst = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                lst.push(grid[i][j]);\n            } else if\
    \ (i === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n        \
    \    } else if (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], grid[i][j], dp[i\
    \ - 1], dp[i]);\n            }\n        }\n    }\n    let res = [];\n    for (let\
    \ i = k - 1; i >= 0; i--) {\n        res.push(lst[i]);\n    }\n    return res;\n\
    }\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + 1);\n            }\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && grid[i][j] < grid[i - 1][j]) {\n                result.push(grid[i -\
    \ 1][j]);\n            } else {\n                result.push(grid[i][j]);\n  \
    \          }\n        }\n    }\n    return result.sort((a, b) => a - b);\n}\n",
  "    let m = grid.length, n = grid[0].length,\n        visited = new Array(m).fill(0),\n\
    \        path = new Array(k + 1).fill(0);\n    \n    for (let i = 0; i < m; i++)\
    \ {\n        for (let j = 0; j < n; j++) {\n            if (visited[i] === 0 &&\
    \ visited[j] === 0) {\n                path[0] = grid[i][j];\n               \
    \ dfs(grid, i, j, k, visited, path);\n            }\n        }\n    }\n    \n\
    \    return path;\n}\n\nfunction dfs(grid, i, j, k, visited, path) {\n    visited[i]\
    \ = 1;\n    visited[j] = 1;\n    path[k] = grid[i][j];\n    \n    let m = grid.length,\
    \ n = grid[0].length;\n    \n    for (let ii = i - 1; ii <= i + 1; ii++) {\n \
    \       for (let jj = j - 1; jj <= j + 1; jj++) {\n            if (ii >= 0 &&\
    \ ii < m && jj >= 0 && jj < n && visited[ii] === 0 && visited[jj] === 0) {\n \
    \               dfs(grid, ii, jj, k, visited, path);\n            }\n        }\n\
    \    }\n}", "  const rows = grid.length\n  const cols = grid[0].length\n  const\
    \ dp = Array(rows).fill(0).map(() => Array(cols).fill(0))\n  for (let i = 0; i\
    \ < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (i === 0 && j\
    \ === 0) {\n        dp[i][j] = grid[i][j]\n      } else if (i === 0) {\n     \
    \   dp[i][j] = Math.min(dp[i][j - 1], dp[i][j])\n      } else if (j === 0) {\n\
    \        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j])\n      } else {\n       \
    \ dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1])\n      }\n    }\n  }\n  let\
    \ result = []\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols;\
    \ j++) {\n      if (i === 0 && j === 0) {\n        result.push(dp[i][j])\n   \
    \   } else if (i === 0) {\n        result.push(Math.min(dp[i][j], dp[i][j - 1]))\n\
    \      } else if (j === 0) {\n        result.push(Math.min(dp[i - 1][j], dp[i][j]))\n\
    \      } else {\n        result.push(Math.min(dp[i - 1][j], dp[i][j - 1]))\n \
    \     }\n    }\n  }\n  return result.sort((a, b) => a - b)\n    .slice(0, k)\n\
    }\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + 1);\n            }\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (dp[i\
    \ * grid[0].length + j] === k) {\n                result.push(grid[i][j]);\n \
    \           }\n        }\n    }\n    return result;\n}\n", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = Array(m).fill(0);\n    for (let i = 0; i <\
    \ m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 &&\
    \ j === 0) {\n                dp[i] = grid[i][j];\n            } else if (i ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n   \
    \         } else if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i]) + grid[i][j]);\n            }\n        }\n    }\n\
    \    let res = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                res.push(dp[i]);\n\
    \            } else if (i === 0) {\n                res.push(Math.min(dp[i], dp[i\
    \ - 1]));\n            } else if (j === 0) {\n                res.push(Math.min(dp[i],\
    \ dp[i - 1]));\n            } else {\n                res.push(Math.min(dp[i],\
    \ Math.min(dp[i - 1], dp[i])));\n            }\n        }\n    }\n    return res.sort((a,\
    \ b) => a - b);\n}\n", "    let dp = [[0] * grid[0].length for _ in range(grid.length)]\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j]\n            } else if (i > 0) {\n     \
    \           dp[i][j] = dp[i - 1][j] + grid[i][j]\n            } else if (j > 0)\
    \ {\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            }\n   \
    \     }\n    }\n    let result = []\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i > 0\
    \ && j > 0) {\n                result.push(dp[i][j])\n            } else if (i\
    \ > 0) {\n                result.push(dp[i - 1][j])\n            } else if (j\
    \ > 0) {\n                result.push(dp[i][j - 1])\n            }\n        }\n\
    \    }\n    return result.sort((a, b) => a - b)\n        .slice(0, k)\n}\n", " \
    \   let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + 1);\n            }\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && grid[i][j] < grid[i - 1][j]) {\n                result.push(grid[i -\
    \ 1][j]);\n            } else {\n                result.push(grid[i][j]);\n  \
    \          }\n        }\n    }\n    return result.sort((a, b) => a - b);\n}\n",
  "    let m = grid.length, n = grid[0].length;\n    let dp = Array(m).fill(0);\n\
    \    let lst = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                lst.push(grid[i][j]);\n            } else if\
    \ (i === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \                lst.push(dp[i]);\n            } else if (j === 0) {\n       \
    \         dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n                lst.push(dp[i]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], Math.min(dp[i -\
    \ 1], dp[i - 1] + grid[i][j]));\n                lst.push(dp[i]);\n          \
    \  }\n        }\n    }\n    return lst.slice(0, k).sort((a, b) => a - b);\n}\n",
  "    let dp = new Array(grid.length).fill(0);\n    let dp_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next = new Array(grid.length).fill(0);\n    let dp_prev_next = new\
    \ Array(grid.length).fill(0);\n    let dp_prev_next_prev = new Array(grid.length).fill(0);\n\
    \    let dp_prev_next_prev_next = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next",
  "    let m = grid.length, n = grid[0].length,\n        visited = new Array(m).fill(0),\n\
    \        path = new Array(k + 1).fill(0);\n\n    for (let i = 0; i < m; i++) {\n\
    \        for (let j = 0; j < n; j++) {\n            if (visited[i] === 0 && grid[i][j]\
    \ === 1) {\n                path[0] = i + 1;\n                path[1] = j + 1;\n\
    \                visited[i] = 1;\n                dfs(grid, i, j, k, path);\n\
    \                visited[i] = 0;\n            }\n        }\n    }\n\n    return\
    \ path;\n}\n\nfunction dfs(grid, i, j, k, path) {\n    let m = grid.length, n\
    \ = grid[0].length,\n        visited = new Array(m).fill(0),\n        path = new\
    \ Array(k + 1).fill(0);\n\n    if (i < 0 || i >= m || j < 0 || j >= n || visited[i]\
    \ === 1 || grid[i][j] !== 1) {\n        return;\n    }\n\n    path[0] = i + 1;\n\
    \    path[1] = j + 1;\n    visited[i] = 1;\n    dfs(grid, i - 1, j, k, path);\n\
    \    dfs(grid, i + 1, j, k, path);\n    dfs(grid, i, j - 1, k, path);\n    dfs(grid,\
    \ i, j + 1, k, path);\n    visited[i] = 0;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && grid[i][j] < grid[i - 1][j]) {\n          \
    \      dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length + j];\n      \
    \      } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i *\
    \ grid[0].length + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i\
    \ === 0 && j === 0) {\n                result.push(grid[i][j]);\n            }\
    \ else if (i > 0 && j > 0 && dp[i * grid[0].length + j] === dp[(i - 1) * grid[0].length\
    \ + j - 1] + grid[i][j]) {\n                result.push(grid[i][j]);\n       \
    \     }\n        }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (i === 0 && j === 0)\
    \ {\n                dp[i] = grid[i][j];\n            } else if (i === 0) {\n\
    \                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], Math.min(dp[i -\
    \ 1], dp[j]) + grid[i][j]);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < dp.length; i++) {\n        if (dp[i] === k) {\n            result.push(grid[i][0]);\n\
    \        }\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length\
    \ * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] +\
    \ grid[i][j]);\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - grid[0].length] + grid[i][j]);\n            }\n            if (i > 0)\
    \ {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[(i\
    \ - 1) * grid[0].length + j] - grid[i][j]);\n            } else {\n          \
    \      result.push(dp[i * grid", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    ",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0 && j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[(i\
    \ - 1) * grid[0].length + j] - grid[i][j]);\n            }\n            if (i\
    \ > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[(i - 1)\
    \ * grid[0].length + j]);\n            }\n            if (j > 0) {\n         \
    \       result.push(dp[i * grid[0].length + j] - dp[i * grid[0].length + j - 1]);\n\
    \            }\n        }\n    }\n    return result.sort((a, b) => a - b);\n}\n",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] =\
    \ Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length]\
    \ + grid[i][j]);\n        }\n    }\n    let result = [];\n    for (let i = 0;\
    \ i < k; i++) {\n        result.push(dp[i * grid[0].length + grid[0].length -\
    \ 1]);\n    }\n    return result;\n}\n", "    let dp = new Array(grid.length *\
    \ grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0] = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] +\
    \ grid[i][j]);\n            }\n            if (i > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length\
    \ + j] + grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n        }\n    }\n    let result = [];\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j] - dp[(i - 1) * grid[0].length + j - 1] - grid[i][j]);\n\
    \            }\n            if (i > 0) {\n                result.push(dp[i * grid[0].length\
    \ + j] - dp[(i - 1) * grid[0].length + j]);\n            }\n            if (j\
    \ > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[i * grid[0].length\
    \ + j - 1]);\n            }\n        }\n    }\n    return result.sort((a, b) =>\
    \ a - b);\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let result\
    \ = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0;\
    \ j < grid[i].length; j++) {\n            if (i === 0 && j === 0) {\n        \
    \        dp[i] = grid[i][j];\n            } else if (i === 0) {\n            \
    \    dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n            } else if (j ===\
    \ 0) {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n       \
    \     } else {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i][j]);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        result.push(dp[i]);\n\
    \    }\n    return result;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i - 1] + grid[i - 1][j - 1]);\n            }\n            if (i > 0) {\n\
    \                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i - 1][j]);\n      \
    \      }\n            if (j > 0) {\n                dp[i] = Math.min(dp[i], dp[i]\
    \ + grid[i][j - 1]);\n            }\n            lst[i] = Math.min(lst[i], dp[i]);\n\
    \        }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n    \
    \    res.push(lst[k - i - 1]);\n    }\n    return res;\n}\n", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0]\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n              \
    \  dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n            if (i > 0) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i\
    \ - 1) * grid[0].length + j] + grid[i][j]);\n            }\n            if (j\
    \ > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n       \
    \ }\n    }\n    let result = [];\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (i > 0 &&\
    \ j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[(i - 1)\
    \ * grid[0].length + j - 1]);\n            }\n            if (i > 0) {\n     \
    \           result.push(dp[i * grid[0].length + j] - dp[(i - 1) * grid[0].length\
    \ + j]);\n            }\n            if (j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j] - dp[i * grid[0].length + j - 1]);\n            }\n  \
    \      }\n    }\n    return result.sort((a, b) => a - b);\n}\n", "    let dp =\
    \ new Array(grid.length).fill(0).map(() => new Array(grid[0].length).fill(0));\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n            } else {\n               \
    \ dp[i][j] = grid[i][j];\n            }\n        }\n    }\n    let result = [];\n\
    \    for (let i = 0; i < k; i++) {\n        result.push(dp[grid.length - 1][grid[0].length\
    \ - 1]);\n        for (let j = grid[0].length - 2; j >= 0; j--) {\n          \
    \  if (j > 0) {\n                dp[grid.length - 1][j] = Math.min(dp[grid.length\
    \ - 1][j], dp[grid.length - 1][j + 1]) + grid[grid.length - 1][j];\n         \
    \   } else {\n                dp[grid.length - 1][j] = grid[grid.length - 1][j];\n\
    \            }\n        }\n        for (let j = grid.length - 2; j >= 0; j--)\
    \ {\n            if (j > 0) {\n                dp[j][grid[0].length - 1] = Math.min(dp[j][grid[0].length\
    \ - 1], dp[j + 1][grid[0].length - 1]) + grid[j][grid[0].length - 1];\n      \
    \      } else {\n                dp[j][grid[0].length - 1] = grid[j][grid[0].length\
    \ - 1];\n            }\n        }\n    }\n    return result;\n}\n", "    let m\
    \ = grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0);\n   \
    \ let ans = new Array(k + 1).fill(0);\n    for (let i = 0; i < m; i++) {\n   \
    \     for (let j = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n \
    \               dp[i] = grid[i][j];\n            } else if (i === 0) {\n     \
    \           dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], Math.min(dp[i -\
    \ 1], dp[i - 1] + grid[i][j]));\n            }\n        }\n    }\n    for (let\
    \ i = 0; i < k + 1; i++) {\n        ans[i] = dp[m - 1];\n    }\n    return ans;\n\
    }\n", "    let m = grid.length, n = grid[0].length;\n    let dp = new Array(m\
    \ * n).fill(0);\n    let lst = new Array(m * n).fill(0);\n    for (let i = 0;\
    \ i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i * n + j] = grid[i][j];\n             \
    \   lst[i * n + j] = grid[i][j];\n            } else if (i === 0) {\n        \
    \        dp[i * n + j] = Math.min(dp[i * n + j - 1], grid[i][j]);\n          \
    \      lst[i * n + j] = dp[i * n + j];\n            } else if (j === 0) {\n  \
    \              dp[i * n + j] = Math.min(dp[(i - 1) * n + j], grid[i][j]);\n  \
    \              lst[i * n + j] = dp[i * n + j];\n            } else {\n       \
    \         dp[i * n + j] = Math.min(dp[(i - 1) * n + j], Math.min(dp[i * n + j\
    \ - 1], grid[i][j]));\n                lst[i * n + j] = dp[i * n + j];\n     \
    \       }\n        }\n    }\n    let result = [];\n    for (let i = 0; i < m;\
    \ i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 && j\
    \ === 0) {\n                result.push(lst[i * n + j]);\n            } else if\
    \ (i === 0) {\n                result.push(lst[i * n + j]);\n            } else\
    \ if (j === 0) {\n                result.push(lst[i * n + j]);\n            }\
    \ else {\n                result.push(lst[i * n + j]);\n            }\n      \
    \  }\n    }\n    return result;\n}\n", "    let dp = [[0] * grid[0].length for\
    \ _ in range(grid.length)]\n    for (let i = 0; i < grid.length; i++) {\n    \
    \    for (let j = 0; j < grid[i].length; j++) {\n            dp[i][j] = grid[i][j]\
    \ + Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1]))\n       \
    \ }\n    }\n    let lst = []\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (dp[i][j] ===\
    \ k) {\n                lst.push(grid[i][j])\n            }\n        }\n    }\n\
    \    return lst\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n        }\n    }\n    let result = [];\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (i > 0 && j > 0) {\n                result.push(dp[i * grid[0].length\
    \ + j] - dp[i * grid[0].length + j - 1] - grid[i][j]);\n            }\n      \
    \      if (i > 0) {\n                result.push(dp[i * grid[0].length + j] -\
    \ dp[(i - 1) * grid[0].length + j] - grid[i][j]);\n            }\n           \
    \ if (j > 0) {\n                result.push(dp[i * grid[0].length + j] - dp[i\
    \ * grid[0].length + j - grid[0].length] - grid[i][j]);\n            }\n     \
    \   }\n    }\n    return result.", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[0].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[0].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "    let dp = new Array(grid.length).fill(0);\n    let lst = new Array(grid[0].length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0) {\n                dp[i] = Math.min(dp[i], dp[i\
    \ - 1] + grid[i][j]);\n            }\n            if (j > 0) {\n             \
    \   dp[i] = Math.min(dp[i], dp[i] + grid[i][j - 1]);\n            }\n        \
    \    lst[j] = Math.min(lst[j], dp[i]);\n        }\n    }\n    let res = new Array(k).fill(0);\n\
    \    for (let i = 0; i < k; i++) {\n        res[i] = lst[i];\n    }\n    return\
    \ res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let lst = new\
    \ Array(grid[0].length).fill(0);\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (i === 0 &&\
    \ j === 0) {\n                dp[i] = grid[i][j];\n                lst[j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n\
    \            } else if (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j]\
    \ + dp[i]);\n                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n\
    \                lst[j] = Math.min(lst[j], grid[i][j] + dp[i]);\n            }\n\
    \        }\n    }\n    let ans = new Array(k).fill(0);\n    for (let i = 0; i\
    \ < k; i++) {\n        for (let j = 0; j < lst.length; j++) {\n            if\
    \ (lst[j] === dp[i]) {\n                ans[i] = j + 1;\n                break;\n\
    \            }\n        }\n    }\n    return ans;\n}\n", "    const N = grid.length;\n\
    \    const M = grid[0].length;\n    const dp = new Array(N * M + 1).fill(0);\n\
    \    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n  \
    \          dp[i * M + j + 1] = Math.min(dp[i * M + j + 1], dp[i * M + j] + grid[i][j]);\n\
    \        }\n    }\n    let result = [];\n    for (let i = 0; i <= k; i++) {\n\
    \        result.push(dp[i * M + k]);\n    }\n    return result;\n}\n", "    const\
    \ m = grid.length;\n    const n = grid[0].length;\n    const dp = Array(m).fill(0).map(()\
    \ => Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j\
    \ = 0; j < n; j++) {\n            if (i === 0 && j === 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            } else if (i === 0) {\n                dp[i][j] =\
    \ Math.min(dp[i][j - 1], dp[i][j]) + grid[i][j];\n            } else if (j ===\
    \ 0) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j]) + grid[i][j];\n\
    \            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j\
    \ - 1], dp[i][j]) + grid[i][j];\n            }\n        }\n    }\n    let result\
    \ = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++)\
    \ {\n            if (i === 0 && j === 0) {\n                result.push(dp[i][j]);\n\
    \            } else if (i === 0) {\n                result.push(Math.min(dp[i][j],\
    \ dp[i][j - 1]));\n            } else if (j === 0) {\n                result.push(Math.min(dp[i\
    \ - 1][j], dp[i][j]));\n            } else {\n                result.push(Math.min(dp[i\
    \ - 1][j], dp[i][j - 1], dp[i][j]));\n            }\n        }\n    }\n    return\
    \ result.sort((a, b) => a - b);\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n            }\n            if\
    \ (i > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0 && j < grid[i].length - 1) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i\
    \ * grid[0].length + j + 1] + grid[i][j]);\n            }\n            if (i <\
    \ grid.length - 1) {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n   \
    \         }\n            if (j < grid[i].length - 1) {\n                dp[i *\
    \ grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + grid[0].length] + grid[i][j]);\n            }\n        }\n    }\n    let",
  "  const N = grid.length\n  const M = grid[0].length\n  const dp = Array(N + 1).fill(0)\n\
    \  for (let i = 1; i <= N; i++) {\n    for (let j = 1; j <= M; j++) {\n      if\
    \ (i === 1 && j === 1) {\n        dp[i] = grid[i - 1][j - 1]\n      } else if\
    \ (i === 1) {\n        dp[i] = Math.min(dp[i], dp[i - 1] + grid[i - 1][j])\n \
    \     } else if (j === 1) {\n        dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j\
    \ - 1])\n      } else {\n        dp[i] = Math.min(dp[i], Math.min(dp[i - 1], dp[i\
    \ - 1] + grid[i - 1][j - 1]))\n      }\n    }\n  }\n  const result = []\n  for\
    \ (let i = k; i >= 1; i--) {\n    result.unshift(dp[i])\n  }\n  return result\n\
    }\n", "    let dp = [[0] * grid[0].length for _ in range(grid.length)]\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j]\n            } else {\n                dp[i][j]\
    \ = grid[i][j]\n            }\n        }\n    }\n    let result = []\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                if (dp[i][j] == dp[i\
    \ - 1][j]) {\n                    result.push(grid[i][j])\n                } else\
    \ if (dp[i][j] == dp[i][j - 1]) {\n                    result.push(grid[i][j])\n\
    \                }\n            } else {\n                result.push(grid[i][j])\n\
    \            }\n        }\n    }\n    return result.sort((a, b) => a - b)\n  \
    \      .slice(0, k)\n}\n", "    let m = grid.length, n = grid[0].length;\n   \
    \ let dp = Array(m).fill(0);\n    let dp_prev = Array(m).fill(0);\n    for (let\
    \ i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if\
    \ (i === 0 && j === 0) {\n                dp[i] = grid[i][j];\n              \
    \  dp_prev[i] = grid[i][j];\n            } else if (i === 0) {\n             \
    \   dp[i] = Math.min(dp[i], dp_prev[i] + grid[i][j]);\n            } else if (j\
    \ === 0) {\n                dp[i] = Math.min(dp[i], dp_prev[i - 1] + grid[i][j]);\n\
    \            } else {\n                dp[i] = Math.min(dp[i], dp_prev[i - 1]\
    \ + grid[i][j], dp_prev[i] + grid[i][j]);\n            }\n            dp_prev[i]\
    \ = dp[i];\n        }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++)\
    \ {\n        res.push(dp[i]);\n    }\n    return res;\n}\n", "    let dp = new\
    \ Array(grid.length).fill(0);\n    let res = new Array(k + 1).fill(0);\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j -\
    \ 1]);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        res[i] =\
    \ dp[grid.length - 1][i];\n    }\n    for (let i = grid.length - 1; i >= 0; i--)\
    \ {\n        for (let j = grid[i].length - 1; j >= 0; j--) {\n            if (i\
    \ > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j -\
    \ 1]);\n            }\n            res[k - i] = Math.min(res[k - i], dp[i][j]);\n\
    \        }\n    }\n    return res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n\
    \    let lst = new Array(grid[0].length).fill(0);\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (i\
    \ > 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n \
    \           }\n            if (j > 0) {\n                dp[i] = Math.min(dp[i],\
    \ dp[i] + grid[i][j - 1]);\n            }\n            if (i > 0 && j > 0) {\n\
    \                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j - 1]);\n      \
    \      }\n            lst[j] = Math.min(lst[j], dp[i]);\n        }\n    }\n  \
    \  let res = [];\n    for (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length\
    \ + j];\n            } else {\n                dp[i * grid[0].length + j] = Math.min(dp[i\
    \ * grid[0].length + j], dp[(i - 1) * grid[0].length + j] + 1);\n            }\n\
    \        }\n    }\n    let res = new Array(k + 1).fill(Number.POSITIVE_INFINITY);\n\
    \    res[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i > 0 && grid[i][j] < grid[i\
    \ - 1][j]) {\n                res[0] = Math.min(res[0], dp[i * grid[0].length\
    \ + j]);\n            } else {\n                res[0] = Math.min(res[0], dp[i\
    \ * grid[0].length + j] + 1);\n            }\n        }\n    }\n    let res2 =\
    \ new Array(k + 1).fill(Number.POSITIVE_INFINITY);\n    res2[0] = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i > 0 && grid[i][j] < grid[i - 1][j]) {\n          \
    \      res2[0] = Math.min(res2[0], dp[i * grid[0].length + j]);\n            }\
    \ else {\n                res2[0] = Math.min(res2", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\
    \    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          if (i === 0 && j === 0) {\n                dp[i][j] = grid[i][j];\n\
    \            } else if (i === 0) {\n                dp[i][j] = Math.min(dp[i][j\
    \ - 1], dp[i][j]) + grid[i][j];\n            } else if (j === 0) {\n         \
    \       dp[i][j] = Math.min(dp[i - 1][j], dp[i][j]) + grid[i][j];\n          \
    \  } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) +\
    \ grid[i][j];\n            }\n        }\n    }\n    let lst = dp[m - 1][n - 1];\n\
    \    let res = [];\n    for (let i = 0; i < k; i++) {\n        res.push(lst[i]);\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_last = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_next = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    let dp_next_last = new Array(grid.length * grid[0].length).fill(Number.MAX_SAFE_INTEGER);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            if (i === 0 && j === 0) {\n                dp[i * grid[0].length\
    \ + j] = grid[i][j];\n                dp_last[i * grid[0].length + j] = grid[i][j];\n\
    \                dp_next[i * grid[0].length + j] = grid[i][j];\n             \
    \   dp_next_last[i * grid[0].length + j] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[(i - 1)\
    \ * grid[0].length + j], dp[i * grid[0].length + j]);\n                dp_last[i\
    \ * grid[0].length + j] = Math.min(dp_last[(i - 1) * grid[0].length + j], dp_last[i\
    \ * grid[0].length + j]);\n                dp_next[i * grid[0].length + j] = Math.min(dp_next[(i\
    \ - 1) * grid[0].length + j], dp_next[i * grid[0].length + j]);\n            \
    \    dp_next_last[i * grid[0].length + j] = Math.min(dp_next_last[(i - 1) * grid[0].length\
    \ + j], dp_next_last[i * grid[0].length + j]);\n            } else if (j", " \
    \   let dp = new Array(grid.length).fill(0);\n    let min = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            dp[i] = Math.max(dp[i], dp[i - 1] + grid[i][j]);\n          \
    \  min = Math.min(min, dp[i]);\n        }\n    }\n    let res = [];\n    for (let\
    \ i = min; i < dp.length; i++) {\n        res.push(grid[i][k - 1]);\n    }\n \
    \   return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n     \
    \           dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[i * grid[0].length + j - 1] + grid[i][j]);\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n                dp[i * grid[0].length + j] = Math.min(dp[i *\
    \ grid[0].length + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n\
    \            }\n            if (i > 0) {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[(i - 1) * grid[0].length + j]\
    \ + grid[i][j]);\n            }\n            if (j > 0) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n        }\n    }\n    let result = [];\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (i > 0 && j > 0) {\n                result.push(dp[i\
    \ * grid[0].length + j]);\n            }\n            if (i > 0) {\n         \
    \       result.push(dp[(i - 1) * grid[0].length + j]);\n            }\n      \
    \      if (", "    let dp = new Array(grid.length).fill(0);\n    let dp_prev =\
    \ new Array(grid.length).fill(0);\n    let dp_next = new Array(grid.length).fill(0);\n\
    \    let dp_prev_next = new Array(grid.length).fill(0);\n    let dp_prev_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_prev_next_prev_next = new Array(grid.length).fill(0);\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            dp[i][j] = grid[i][j];\n            dp_prev[i][j] = grid[i][j];\n\
    \            dp_next[i][j] = grid[i][j];\n            dp_prev_next[i][j] = grid[i][j];\n\
    \            dp_prev_next_prev[i][j] = grid[i][j];\n            dp_prev_next_prev_next[i][j]\
    \ = grid[i][j];\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            for (let k =\
    \ 1; k <= k; k++) {\n                if (i - k >= 0 && j - k >= 0) {\n       \
    \             dp[i][j] = Math.min(dp[i][j], dp[i - k][j - k] + grid[i][j]);\n\
    \                    dp_prev[i][j] = Math.min(dp_prev[i][j], dp_prev[i - k][j\
    \ - k] + grid[i][j]);\n                    dp_next[i][j] = Math.min(dp_next[i][j],\
    \ dp_next[i - k][j - k] + grid[i][j]);\n                    dp_prev_next[i][j]\
    \ = Math.min(dp_prev_next[i][j], dp_prev_next[i - k][j", "    let dp = new Array(grid.length).fill(0);\n\
    \    let res = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i] = Math.max(dp[i], grid[i][j]\
    \ + dp[i - 1]);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n       \
    \ let min = dp[grid.length - 1];\n        for (let j = grid.length - 1; j >= 0;\
    \ j--) {\n            if (dp[j] < min) {\n                min = dp[j];\n     \
    \           res = [grid[j][0]];\n            } else if (dp[j] === min) {\n   \
    \             res.push(grid[j][0]);\n            }\n        }\n        for (let\
    \ j = 0; j < grid.length; j++) {\n            dp[j] = grid[j][0];\n        }\n\
    \    }\n    return res;\n}\n", "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n \
    \               dp[i * grid[0].length + j] = grid[i][j];\n            } else if\
    \ (i === 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[(i - 1)\
    \ * grid[0].length + j], grid[i][j]);\n            } else if (j === 0) {\n   \
    \             dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + (j\
    \ - 1)], grid[i][j]);\n            } else {\n                dp[i * grid[0].length\
    \ + j] = Math.min(dp[(i - 1) * grid[0].length + j], Math.min(dp[i * grid[0].length\
    \ + (j - 1)], grid[i][j]));\n            }\n        }\n    }\n    let result =\
    \ [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[0].length; j++) {\n            if (i === 0 && j === 0) {\n          \
    \      result.push(dp[i * grid[0].length + j]);\n            } else if (i ===\
    \ 0) {\n                result.push(Math.min(dp[(i - 1) * grid[0].length + j],\
    \ dp[i * grid[0].length + j]));\n            } else if (j === 0) {\n         \
    \       result.push(Math.min(dp[i * grid[0].length + (j - 1)], dp[i * grid[0].length\
    \ + j]));\n            } else {\n                result.push(Math.min(dp[(i -\
    \ 1) * grid[0].length + j], Math.min(dp[i * grid[0].length", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0]\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n              \
    \  dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n            if (i > 0) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i\
    \ - 1) * grid[0].length + j] + grid[i][j]);\n            }\n            if (j\
    \ > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n         \
    \   }\n            if (i > 0 && j < grid[0].length - 1) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + 1] + grid[i][j]);\n            }\n            if (i < grid.length - 1)\
    \ {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j < grid[0].length - 1) {\n                dp[i * grid[0].length +\
    \ j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j + grid[0].length]\
    \ + grid[i][j]);\n            }\n        }\n    }\n    let", "    let dp = new\
    \ Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n    dp[0]\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (i > 0 && j > 0) {\n              \
    \  dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j - 1] + grid[i][j]);\n            }\n            if (i > 0) {\n         \
    \       dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[(i\
    \ - 1) * grid[0].length + j] + grid[i][j]);\n            }\n            if (j\
    \ > 0) {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[i * grid[0].length + j - grid[0].length] + grid[i][j]);\n         \
    \   }\n            if (i > 0 && j < grid[i].length - 1) {\n                dp[i\
    \ * grid[0].length + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length\
    \ + j + 1] + grid[i][j]);\n            }\n            if (i < grid.length - 1)\
    \ {\n                dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length\
    \ + j], dp[(i + 1) * grid[0].length + j] + grid[i][j]);\n            }\n     \
    \       if (j < grid[i].length - 1) {\n                dp[i * grid[0].length +\
    \ j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j + grid[0].length]\
    \ + grid[i][j]);\n            }\n        }\n    }\n    let", "    let dp = new\
    \ Array(grid.length).fill(0);\n    let dp_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next = new Array(grid.length).fill(0);\n    let dp_prev_next = new\
    \ Array(grid.length).fill(0);\n    let dp_next_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next_next_prev = new Array(grid.length).fill(0);\n    let dp_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_prev = new Array(grid.length).fill(0);\n\
    \    let dp_next_next_next_next = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next = new\
    \ Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_prev = new\
    \ Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next = new\
    \ Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_prev =\
    \ new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next_prev\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_next_next_next_next_next_next_next\
    \ = new Array(grid.length).fill(0);\n    let dp_next_next_", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\
    \    let dp_i = Array(m).fill(0).map(() => Array(n).fill(0));\n    let dp_j =\
    \ Array(m).fill(0).map(() => Array(n).fill(0));\n    for (let i = 0; i < m; i++)\
    \ {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 && j === 0)\
    \ {\n                dp[i][j] = grid[i][j];\n            } else if (i === 0) {\n\
    \                dp[i][j] = Math.min(dp[i][j - 1], grid[i][j]);\n            }\
    \ else if (j === 0) {\n                dp[i][j] = Math.min(dp[i - 1][j], grid[i][j]);\n\
    \            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j\
    \ - 1], grid[i][j]);\n            }\n        }\n    }\n    for (let i = 0; i <\
    \ m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === 0 &&\
    \ j === 0) {\n                dp_i[i][j] = dp[i][j];\n            } else if (i\
    \ === 0) {\n                dp_i[i][j] = Math.min(dp_i[i][j - 1], dp[i][j]);\n\
    \            } else if (j === 0) {\n                dp_i[i][j] = Math.min(dp_i[i\
    \ - 1][j], dp[i][j]);\n            } else {\n                dp_i[i][j] = Math.min(dp_i[i\
    \ - 1][j], dp_i[i][j - 1], dp[i][j]);\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j", "    const rows = grid.length;\n\
    \    const cols = grid[0].length;\n    const dp = new Array(rows).fill(0);\n \
    \   for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n\
    \            dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            if\
    \ (i > 0 && j > 0) {\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]\
    \ - grid[i - 1][j - 1]);\n            }\n        }\n    }\n    let res = [];\n\
    \    for (let i = 0; i < k; i++) {\n        res.push(dp[rows - 1]);\n    }\n \
    \   return res;\n}\n", "    let dp = new Array(grid.length).fill(0);\n    let\
    \ lst = new Array(grid.length).fill(0);\n    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            if (i === 0 && j === 0) {\n                dp[i]\
    \ = grid[i][j];\n                lst[i] = grid[i][j];\n            } else if (i\
    \ === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n   \
    \             lst[i] = Math.min(lst[i], grid[i][j] + dp[i]);\n            } else\
    \ if (j === 0) {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n\
    \                lst[i] = Math.min(lst[i], grid[i][j] + dp[i]);\n            }\
    \ else {\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i]);\n     \
    \           lst[i] = Math.min(lst[i], grid[i][j] + dp[i]);\n            }\n  \
    \      }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n      \
    \  res.push(lst[i]);\n    }\n    return res;\n}\n", "    let m = grid.length,\
    \ n = grid[0].length;\n    let dp = new Array(m).fill(0);\n    let min = dp.fill(0);\n\
    \    let i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++)\
    \ {\n            if (i > 0 && dp[i - 1] + 1 < min[i]) {\n                min[i]\
    \ = dp[i - 1] + 1;\n            }\n            if (j > 0 && dp[i] + grid[i][j\
    \ - 1] < min[i]) {\n                min[i] = dp[i] + grid[i][j - 1];\n       \
    \     }\n            if (i > 0 && j > 0 && dp[i - 1] + grid[i][j - 1] < min[i])\
    \ {\n                min[i] = dp[i - 1] + grid[i][j - 1];\n            }\n   \
    \         if (i > 0 && j < n - 1 && dp[i - 1] + grid[i][j + 1] < min[i]) {\n \
    \               min[i] = dp[i - 1] + grid[i][j + 1];\n            }\n        \
    \    dp[i] = min[i];\n        }\n    }\n    let result = [];\n    for (i = 0;\
    \ i < m; i++) {\n        result.push(min[i]);\n    }\n    return result;\n}\n",
  "    let dp = new Array(grid.length * grid[0].length).fill(Number.POSITIVE_INFINITY);\n\
    \    dp[0] = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] =\
    \ Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - 1] + grid[i][j]);\n\
    \            dp[i * grid[0].length + j] = Math.min(dp[i * grid[0].length + j],\
    \ dp[(i - 1) * grid[0].length + j] + grid[i][j]);\n            dp[i * grid[0].length\
    \ + j] = Math.min(dp[i * grid[0].length + j], dp[i * grid[0].length + j - grid[0].length]\
    \ + grid[i][j]);\n        }\n    }\n    let result = [];\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (dp[i * grid[0].length + j] === k) {\n                result.push(grid[i][j]);\n\
    \            }\n        }\n    }\n    return result;\n}\n", "    let dp = new\
    \ Array(grid.length).fill(0);\n    let lst = new Array(grid.length).fill(0);\n\
    \    let n = grid.length;\n    let m = grid[0].length;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i === 0\
    \ && j === 0) {\n                dp[i] = grid[i][j];\n                lst[i] =\
    \ grid[i][j];\n            } else if (i === 0) {\n                dp[i] = Math.min(dp[i],\
    \ grid[i][j] + dp[i + 1]);\n                lst[i] = Math.min(lst[i], grid[i][j]\
    \ + dp[i + 1]);\n            } else if (j === 0) {\n                dp[i] = Math.min(dp[i],\
    \ grid[i][j] + dp[i - 1]);\n                lst[i] = Math.min(lst[i], grid[i][j]\
    \ + dp[i - 1]);\n            } else {\n                dp[i] = Math.min(dp[i],\
    \ grid[i][j] + dp[i - 1]);\n                lst[i] = Math.min(lst[i], grid[i][j]\
    \ + dp[i - 1]);\n                dp[i] = Math.min(dp[i], grid[i][j] + dp[i + 1]);\n\
    \                lst[i] = Math.min(lst[i], grid[i][j] + dp[i + 1]);\n        \
    \    }\n        }\n    }\n    let ans = new Array(k + 1).fill(0);\n    for (let\
    \ i = 0; i < k + 1; i++) {\n        ans[i] = lst[0];\n    }\n    return ans;\n\
    }\n", "    let dp = new Array(grid.length).fill(0);\n    let m = new Array(grid.length).fill(0);\n\
    \    let n = new Array(grid.length).fill(0);\n    let i = 0;\n    let j = 0;\n\
    \    let l = 0;\n    let r = 0;\n    let c = 0;\n    let d = 0;\n    let f = 0;\n\
    \    let g = 0;\n    let h = 0;\n    let p = 0;\n    let q = 0;\n    let s = 0;\n\
    \    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n\
    \    let y = 0;\n    let z = 0;\n    let a = 0;\n    let b = 0;\n    let c1 =\
    \ 0;\n    let c2 = 0;\n    let c3 = 0;\n    let c4 = 0;\n    let c5 = 0;\n   \
    \ let c6 = 0;\n    let c7 = 0;\n    let c8 = 0;\n    let c9 = 0;\n    let c10\
    \ = 0;\n    let c11 = 0;\n    let c12 = 0;\n    let c13 = 0;\n    let c14 = 0;\n\
    \    let c15 = 0;\n    let c16 = 0;\n    let c17 = 0;\n    let c18 = 0;\n    let\
    \ c19 = 0;\n    let c20 = 0;\n    let c21 = 0;\n    let c22 = 0;\n    let c23\
    \ = 0;\n    let c24 = 0;\n    let c25 = 0;\n    let c26 = 0;\n    let c27 = 0;\n\
    \    let c28 = 0;\n    let c29 = 0;\n    let c30 = 0;\n    let c31 = 0;\n    let\
    \ c32 = 0;\n    let c33 = 0;\n    let c34 = 0;\n    let c35 = 0;\n    let c36\
    \ = 0;\n    let c37 = 0;\n    let c38 = 0;\n    let c39 = 0;\n    let c40", " \
    \   let m = grid.length, n = grid[0].length;\n    let dp = new Array(m * n).fill(0);\n\
    \    let lst = new Array(m * n).fill(0);\n    for (let i = 0; i < m; i++) {\n\
    \        for (let j = 0; j < n; j++) {\n            let val = grid[i][j];\n  \
    \          if (val === 0) continue;\n            let idx = i * n + j;\n      \
    \      dp[idx] = val;\n            lst[idx] = val;\n        }\n    }\n    for\
    \ (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   let idx = i * n + j;\n            let left = i > 0 ? dp[idx - 1] : 0;\n  \
    \          let right = i < m - 1 ? dp[idx + 1] : 0;\n            let up = j >\
    \ 0 ? dp[idx - n] : 0;\n            let down = j < n - 1 ? dp[idx + n] : 0;\n\
    \            if (left === 0 && right === 0 && up === 0 && down === 0) continue;\n\
    \            if (left === 0) {\n                dp[idx] = right;\n           \
    \     lst[idx] = right;\n            } else if (right === 0) {\n             \
    \   dp[idx] = left;\n                lst[idx] = left;\n            } else if (up\
    \ === 0) {\n                dp[idx] = down;\n                lst[idx] = down;\n\
    \            } else if (down === 0) {\n                dp[idx] = up;\n       \
    \         lst[idx] = up;\n            } else {\n                dp[idx] = Math.min(left,\
    \ right, up, down);\n                lst[idx] = dp[idx];\n            }\n    \
    \    }\n    }\n    let res = [];\n    for (let i = 0; i < k; i++) {\n        let\
    \ idx = lst[i];\n        res.push(idx);\n    }", "  const N = grid.length\n  const\
    \ M = grid[0].length\n  const d = new Array(N).fill(0)\n  const p = new Array(N).fill(0)\n\
    \  const q = new Array(N).fill(0)\n  const r = new Array(N).fill(0)\n  const s\
    \ = new Array(N).fill(0)\n  const t = new Array(N).fill(0)\n  const u = new Array(N).fill(0)\n\
    \  const v = new Array(N).fill(0)\n  const w = new Array(N).fill(0)\n  const x\
    \ = new Array(N).fill(0)\n  const y = new Array(N).fill(0)\n  const z = new Array(N).fill(0)\n\
    \  const a = new Array(N).fill(0)\n  const b = new Array(N).fill(0)\n  const c\
    \ = new Array(N).fill(0)\n  const d1 = new Array(N).fill(0)\n  const d2 = new\
    \ Array(N).fill(0)\n  const e = new Array(N).fill(0)\n  const f = new Array(N).fill(0)\n\
    \  const g = new Array(N).fill(0)\n  const h = new Array(N).fill(0)\n  const i\
    \ = new Array(N).fill(0)\n  const j = new Array(N).fill(0)\n  const k = new Array(N).fill(0)\n\
    \  const l = new Array(N).fill(0)\n  const m = new Array(N).fill(0)\n  const n\
    \ = new Array(N).fill(0)\n  const o = new Array(N).fill(0)\n  const p1 = new Array(N).fill(0)\n\
    \  const p2 = new Array(N).fill(0)\n  const q1 = new Array(N).fill(0)\n  const\
    \ q2 = new Array(N).fill(0)\n  const r1 = new Array(N).fill(0)\n  const r2 = new\
    \ Array(N).fill(0)\n  const s1 = new Array(N)."]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
