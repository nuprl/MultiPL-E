{
  "name": "mbpp_407_rearrange_bigger",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // Write a function to create the next bigger number by rearranging the digits of a given number.\n    public static Object rearrangeBigger(long n) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(rearrangeBigger((12l)).equals((Object(21l))));\n    assert(rearrangeBigger((10l)).equals((Object(false))));\n    assert(rearrangeBigger((102l)).equals((Object(120l))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        // Find the largest index l greater than k such that a[k] < a[l].\n        // Swap the value of a[k] with that of a[l].\n        // Reverse the sequence from a[k + 1] up to and including the final element a[n].\n        // https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\n        char[] chars = Long.toString(n).toCharArray();\n        int k = -1;\n        for (int i = 0; i < chars.length - 1; i++) {\n            if (chars[i] < chars[i + 1]) {\n                k = i;\n            }\n        }\n        if (k == -1) {\n            return -1;\n        }\n        int l = k + 1;\n        for (int i = k + 1; i < chars.length; i++) {\n            if (chars[k] < chars[i]) {\n                l = i;\n            }\n        }\n        char temp = chars[k];\n        chars[k] = chars[l];\n        chars[l] = temp;\n        for (int i = k + 1; i < chars.length; i++) {\n            for (int j = i + 1; j < chars.length; j++) {\n                if (chars[i] > chars[j]) {\n                    temp = chars[i];\n                    chars[i] = chars[j];\n                    chars[j] = temp;\n                }\n            }\n        }\n        return Long.parseLong(new String(chars));",
    "        // If the number is a single digit, then it can't be rearranged to be bigger.\n        if (n < 10) {\n            return null;\n        }\n        // Convert the number to a string.\n        String s = Long.toString(n);\n        // Convert the string to a char array.\n        char[] c = s.toCharArray();\n        // Find the first index where the digit is less than the digit to its right.\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If no such index exists, then the number can't be rearranged to be bigger.\n        if (i == 0) {\n            return null;\n        }\n        // Find the smallest digit to the right of the index that is greater than the digit at the index.\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the digits at the index and the smallest digit to its right.\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the index.\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a string.\n        s = new String(c);\n        // Convert the string to a long.\n        return Long.parseLong(s);",
    "        String s = Long.toString(n);\n        char[] a = s.toCharArray();\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        char temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(a));",
    "        char[] chars = String.valueOf(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, no answer is possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i-1)'th digit that is greater than number[i-1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i-1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Sort the digits after (i-1) in ascending order\n        Arrays.sort(c, i, c.length);\n        // Convert char array to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the pivot with the smallest digit greater than the pivot\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the suffix\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = String.valueOf(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is smaller than the one to its right\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If no such index exists, return -1\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is bigger than c[i]\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap c[i] and c[j]\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the numbers to the right of i\n        int left = i + 1;\n        int right = c.length - 1;\n        while (left < right) {\n            temp = c[left];\n            c[left] = c[right];\n            c[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert char array to string\n        s = new String(c);\n        // Convert string to long\n        return Long.parseLong(s);",
    "        // get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n = n / 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the digit to its right\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) >= digits.get(i + 1)) {\n            i++;\n        }\n        // if no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the pivot that is larger than the pivot\n        int j = i + 1;\n        while (j < digits.size() && digits.get(j) > digits.get(i)) {\n            j++;\n        }\n        // swap the pivot with the smallest digit to the right of the pivot\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j - 1));\n        digits.set(j - 1, temp);\n        // sort the digits to the right of the pivot in ascending order\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // find the first digit that is smaller than the digit to its right\n        // find the smallest digit to the right of the digit found in the previous step that is greater than it\n        // swap the digits\n        // sort the digits to the right of the digit found in the first step\n        // return the number\n        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // get digits\n        ArrayList<Long> digits = new ArrayList<Long>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        // find the first digit that is smaller than the digit to its right\n        int i = digits.size() - 1;\n        while (i > 0 && digits.get(i) <= digits.get(i - 1)) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        // find the smallest digit to the right of the pivot that is bigger than the pivot\n        int j = digits.size() - 1;\n        while (digits.get(j) <= digits.get(i - 1)) {\n            j--;\n        }\n        // swap the pivot with the smallest digit to its right\n        long temp = digits.get(i - 1);\n        digits.set(i - 1, digits.get(j));\n        digits.set(j, temp);\n        // reverse the digits to the right of the pivot\n        j = digits.size() - 1;\n        while (i < j) {\n            temp = digits.get(i);\n            digits.set(i, digits.get(j));\n            digits.set(j, temp);\n            i++;\n            j--;\n        }\n        // convert the digits back to a number\n        long result = 0;\n        for (i = 0; i < digits.size(); i++) {\n            result = result * 10 + digits.get(i);\n        }\n        return result;",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first index from the right that is smaller than the next\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no such index exists, the digits are in descending order and no bigger number exists\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of (i - 1) that is greater than chars[i - 1]\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap chars[i - 1] and chars[j]\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits from position i to the end\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a long\n        return Long.parseLong(new String(chars));",
    "        // Find the first digit that is smaller than the digit to its right.\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step.\n        // Swap the digits found in the previous two steps.\n        // Reverse the digits to the right of the digit found in the first step.\n        // If no such digit exists, return -1.\n        // If the number is already the largest possible number, return -1.\n        // If the number is the largest possible number with the same number of digits, return -1.\n        // If the number is the largest possible number with one fewer digit, return the number with a 0 appended to the end.\n        // If the number is the largest possible number with two fewer digits, return the number with a 00 appended to the end.\n        // If the number is the largest possible number with three fewer digits, return the number with a 000 appended to the end.\n        // If the number is the largest possible number with four fewer digits, return the number with a 0000 appended to the end.\n        // If the number is the largest possible number with five fewer digits, return the number with a 00000 appended to the end.\n        // If the number is the largest possible number with six fewer digits, return the number with a 000000 appended to the end.\n        // If the number is the largest possible number with seven fewer digits, return the number with a 0000000 appended to the end.\n        // If the number is the largest possible number with eight fewer digits, return the number with a 00000000 appended to the end.\n        // If the number is the largest possible number with nine fewer digits, return the number with a 000000000 appended to the end.\n        // If the number is the largest possible number with ten fewer digits, return the number with a 0000000000 appended to the end.\n        // If the number is the largest possible number with eleven fewer digits, return the number with a 00000000000 appended to the end.\n        // If the number is the largest possible number with twelve fewer digits, return the number with a 000000000000 appended to the end.\n        // If the number is the largest possible number with thirteen fewer digits, return the number with a 0000000000000 appended to the end.\n        // If the number is the largest possible number",
    "        // find the first digit that is smaller than the digit to its right\n        // find the smallest digit to the right of the pivot that is greater than the pivot\n        // swap the pivot and the smallest digit\n        // sort the digits to the right of the pivot\n        // return the new number\n        String s = Long.toString(n);\n        int pivot = -1;\n        for (int i = s.length() - 2; i >= 0; i--) {\n            if (s.charAt(i) < s.charAt(i + 1)) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot == -1) {\n            return -1;\n        }\n        int smallest = pivot + 1;\n        for (int i = pivot + 1; i < s.length(); i++) {\n            if (s.charAt(i) > s.charAt(pivot) && s.charAt(i) < s.charAt(smallest)) {\n                smallest = i;\n            }\n        }\n        char[] a = s.toCharArray();\n        char temp = a[pivot];\n        a[pivot] = a[smallest];\n        a[smallest] = temp;\n        Arrays.sort(a, pivot + 1, a.length);\n        return Long.parseLong(new String(a));",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int len = chars.length;\n        int i = len - 1;\n        while (i > 0 && chars[i] <= chars[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = len - 1;\n        while (j > i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        Arrays.sort(chars, i, len);\n        return Long.valueOf(String.valueOf(chars));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is larger than it\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit to the right of the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(s.substring(i, i + 1));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to a string\n        String s = String.valueOf(n);\n        // Convert to a char array\n        char[] chars = s.toCharArray();\n        // Convert to a list\n        List<Character> list = new ArrayList<Character>();\n        for (char c : chars) {\n            list.add(c);\n        }\n        // Find the first decreasing digit\n        int i = list.size() - 1;\n        while (i > 0 && list.get(i - 1) >= list.get(i)) {\n            i--;\n        }\n        // If the number is already the largest possible, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = list.size() - 1;\n        while (list.get(j) <= list.get(i - 1)) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right\n        char temp = list.get(i - 1);\n        list.set(i - 1, list.get(j));\n        list.set(j, temp);\n        // Reverse the digits to the right of the first decreasing digit\n        j = list.size() - 1;\n        while (i < j) {\n            temp = list.get(i);\n            list.set(i, list.get(j));\n            list.set(j, temp);\n            i++;\n            j--;\n        }\n        // Convert the list back to a string\n        StringBuilder sb = new StringBuilder(list.size());\n        for (char c : list) {\n            sb.append(c);\n        }\n        // Convert the string to a long\n        return Long.parseLong(sb.toString());",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the first digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the two digits\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to string and return\n        return Long.parseLong(new String(chars));",
    "        // Get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, then the number is already the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is larger than it\n        int j = i + 1;\n        for (int k = i + 1; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Create the new number\n        long newNumber = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            newNumber = newNumber * 10 + digits.get(k);\n        }\n        return newNumber;",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] arr = s.toCharArray();\n        // sort the array\n        Arrays.sort(arr);\n        // convert back to string\n        String sorted = new String(arr);\n        // convert to long\n        long sortedLong = Long.parseLong(sorted);\n        // if sortedLong is greater than n, return sortedLong\n        if (sortedLong > n) {\n            return sortedLong;\n        }\n        // if sortedLong is not greater than n, return -1\n        return -1;",
    "        // Convert the number to a string\n        String s = Long.toString(n);\n        // Convert the string to a char array\n        char[] c = s.toCharArray();\n        // Find the first index where the number is smaller than the number to the right\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If i is 0, then the number is in descending order and there is no bigger number\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is bigger than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the numbers to the right of i\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array back to a string\n        s = new String(c);\n        // Convert the string to a long\n        return Long.parseLong(s);",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // Find the rightmost non-increasing digit\n        // Find the smallest digit to the right of the rightmost non-increasing digit\n        // Swap the two digits\n        // Sort the digits to the right of the rightmost non-increasing digit\n        // If no such digit exists, return -1\n        // If the number is already the largest possible, return -1\n        // If the number is the largest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return -1\n        // If the number is the smallest possible, return",
    "        // Convert to string\n        String s = String.valueOf(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the two digits\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        // Convert long to array of digits\n        int[] digits = Long.toString(n).chars().map(c -> c-'0').toArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = digits.length-2;\n        while (i >= 0 && digits[i] >= digits[i+1]) {\n            i--;\n        }\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = digits.length-1;\n        while (j >= 0 && digits[j] <= digits[i]) {\n            j--;\n        }\n        // Swap digits[i] and digits[j]\n        int temp = digits[i];\n        digits[i] = digits[j];\n        digits[j] = temp;\n        // Reverse the digits to the right of i\n        int left = i+1;\n        int right = digits.length-1;\n        while (left < right) {\n            temp = digits[left];\n            digits[left] = digits[right];\n            digits[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert array of digits to long\n        return Long.parseLong(Arrays.stream(digits).mapToObj(Integer::toString).collect(Collectors.joining()));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // sort the array\n        Arrays.sort(c);\n        // reverse the array\n        for (int i = 0; i < c.length / 2; i++) {\n            char temp = c[i];\n            c[i] = c[c.length - i - 1];\n            c[c.length - i - 1] = temp;\n        }\n        // convert back to string\n        String s2 = new String(c);\n        // convert back to long\n        long l = Long.parseLong(s2);\n        // return the long\n        return l;",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit with the smallest digit greater than it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to string\n        s = new String(c);\n        // convert to long\n        return Long.parseLong(s);",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first index from the right where the digit is less than the digit to the right\n        int index = -1;\n        for (int i = c.length - 1; i > 0; i--) {\n            if (c[i] > c[i - 1]) {\n                index = i - 1;\n                break;\n            }\n        }\n        // if no such index exists, return -1\n        if (index == -1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the index that is greater than the digit at the index\n        int min = index + 1;\n        for (int i = index + 2; i < c.length; i++) {\n            if (c[i] > c[index] && c[i] < c[min]) {\n                min = i;\n            }\n        }\n        // swap the digits at the index and the min\n        char temp = c[index];\n        c[index] = c[min];\n        c[min] = temp;\n        // sort the digits to the right of the index\n        Arrays.sort(c, index + 1, c.length);\n        // convert the char array back to a string\n        s = new String(c);\n        // convert the string to a long\n        return Long.parseLong(s);",
    "        // Convert to char array\n        char[] chars = Long.toString(n).toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit, then no bigger number\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the first digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit with the greater digit\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(chars));",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(String.valueOf(s.charAt(i)));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to array\n        char[] arr = Long.toString(n).toCharArray();\n        // Find the first decreasing digit\n        int i = arr.length - 2;\n        while (i >= 0 && arr[i] >= arr[i + 1]) {\n            i--;\n        }\n        // If no such digit, return -1\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = arr.length - 1;\n        while (arr[j] <= arr[i]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right of it\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        i++;\n        j = arr.length - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(arr));",
    "        // TODO: Implement\n        return null;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first digit that is smaller than the digit after it\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If we didn't find a digit that is smaller than the digit after it, then the number is already the biggest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the digit at i\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap the digits at i and j\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the digits after i\n        int left = i + 1;\n        int right = c.length - 1;\n        while (left < right) {\n            temp = c[left];\n            c[left] = c[right];\n            c[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert back to long\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit after it\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If we didn't find a digit that is smaller than the digit after it, then there is no bigger number\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than digits.get(i)\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // Swap digits.get(i) and digits.get(j)\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits after digits.get(i)\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert the number to a string\n        String s = Long.toString(n);\n        // Convert the string to a char array\n        char[] c = s.toCharArray();\n        // Find the first index where the digit is less than the digit to the right of it\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If the index is 0, then the number is already the largest possible number\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the index that is greater than the digit at the index\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the digits at the index and the smallest digit to the right of the index\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the index\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a string\n        s = new String(c);\n        // Convert the string to a long\n        return Long.parseLong(s);",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit from the right\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If all digits are in descending order, no bigger number is possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i-1)th digit that is greater than number[i-1]\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i-1]\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Sort the digits after (i-1) in ascending order\n        Arrays.sort(chars, i, chars.length);\n        // Convert to string\n        String result = new String(chars);\n        // Convert to long\n        return Long.parseLong(result);",
    "        // 1. Convert to char array\n        char[] chars = Long.toString(n).toCharArray();\n        // 2. Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // 3. If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // 4. Find the smallest digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // 5. Swap the digits\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // 6. Reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // 7. Return the number\n        return Long.parseLong(new String(chars));",
    "        // Find the largest index i such that array[i \u2212 1] < array[i].\n        // (If no such i exists, then this is already the last permutation.)\n        // Find the largest index j greater than i such that array[j] > array[i \u2212 1].\n        // Swap array[j] and array[i \u2212 1].\n        // Reverse the suffix starting at array[i].\n        // return the new number\n        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j > 0 && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to char array\n        char[] chars = String.valueOf(n).toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to list\n        List<Character> l = s.chars().mapToObj(c -> (char) c).collect(Collectors.toList());\n        // Find the first decreasing digit\n        int i = l.size() - 1;\n        while (i > 0 && l.get(i - 1) >= l.get(i)) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = i;\n        while (j < l.size() && l.get(j) > l.get(i - 1)) {\n            j++;\n        }\n        // Swap the decreasing digit with the smallest digit greater than it\n        char temp = l.get(i - 1);\n        l.set(i - 1, l.get(j - 1));\n        l.set(j - 1, temp);\n        // Reverse the digits after the decreasing digit\n        Collections.reverse(l.subList(i, l.size()));\n        // Convert to string\n        StringBuilder sb = new StringBuilder();\n        l.forEach(sb::append);\n        // Convert to long\n        return Long.parseLong(sb.toString());",
    "        // Convert the number to a string.\n        String s = Long.toString(n);\n        // Convert the string to a list of characters.\n        List<Character> l = s.chars().mapToObj(c -> (char)c).collect(Collectors.toList());\n        // Find the first character that is smaller than the character after it.\n        int i = 0;\n        while (i < l.size() - 1 && l.get(i) >= l.get(i + 1)) {\n            i++;\n        }\n        // If no such character exists, then the number is the largest possible.\n        if (i == l.size() - 1) {\n            return -1;\n        }\n        // Find the smallest character that is larger than the character at i.\n        int j = i + 1;\n        while (j < l.size() && l.get(j) > l.get(i)) {\n            j++;\n        }\n        // Swap the characters at i and j.\n        char temp = l.get(i);\n        l.set(i, l.get(j - 1));\n        l.set(j - 1, temp);\n        // Sort the characters after i.\n        Collections.sort(l.subList(i + 1, l.size()));\n        // Convert the list of characters to a string.\n        String t = l.stream().map(Object::toString).collect(Collectors.joining());\n        // Convert the string to a number.\n        return Long.parseLong(t);",
    "        // Convert to array of digits\n        int[] digits = Long.toString(n).chars().map(c -> c-'0').toArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = digits.length-2;\n        while (i >= 0 && digits[i] >= digits[i+1]) {\n            i--;\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = digits.length-1;\n        while (j > i && digits[j] <= digits[i]) {\n            j--;\n        }\n        // Swap digits[i] and digits[j]\n        int temp = digits[i];\n        digits[i] = digits[j];\n        digits[j] = temp;\n        // Reverse the digits to the right of i\n        int left = i+1;\n        int right = digits.length-1;\n        while (left < right) {\n            temp = digits[left];\n            digits[left] = digits[right];\n            digits[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert the array back to a number\n        return Long.parseLong(Arrays.stream(digits).mapToObj(Integer::toString).collect(Collectors.joining()));",
    "        // 1. Convert the number to a string\n        String s = Long.toString(n);\n        // 2. Convert the string to a list of chars\n        List<Character> chars = s.chars().mapToObj(c -> (char) c).collect(Collectors.toList());\n        // 3. Find the first index where the next char is greater than the current char\n        int i = chars.size() - 1;\n        while (i > 0 && chars.get(i - 1) >= chars.get(i)) {\n            i--;\n        }\n        // 4. If i is 0, then the number is in descending order, so no bigger number can be made\n        if (i <= 0) {\n            return -1;\n        }\n        // 5. Find the smallest char in the suffix that is greater than the char at index i - 1\n        int j = chars.size() - 1;\n        while (j >= i && chars.get(j) <= chars.get(i - 1)) {\n            j--;\n        }\n        // 6. Swap the chars at index i - 1 and j\n        char temp = chars.get(i - 1);\n        chars.set(i - 1, chars.get(j));\n        chars.set(j, temp);\n        // 7. Reverse the suffix\n        Collections.reverse(chars.subList(i, chars.size()));\n        // 8. Convert the list of chars to a string\n        String result = chars.stream().map(Object::toString).collect(Collectors.joining());\n        // 9. Convert the string to a long\n        return Long.parseLong(result);",
    "        // Get the digits of the number\n        List<Long> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first decreasing digit\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) <= digits.get(i + 1)) {\n            i++;\n        }\n        // If there is no decreasing digit, then the number is already the largest\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit that is larger than it\n        int j = i + 1;\n        while (j < digits.size() - 1 && digits.get(j + 1) < digits.get(i)) {\n            j++;\n        }\n        // Swap the two digits\n        long temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the decreasing digit\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for (long digit : digits) {\n            result = result * 10 + digit;\n        }\n        return result;",
    "        // Convert to array of digits\n        int[] digits = Long.toString(n).chars().map(c -> c-'0').toArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = digits.length-2;\n        while (i >= 0 && digits[i] >= digits[i+1]) i--;\n        // If no such digit exists, then the number is the largest possible\n        if (i < 0) return -1;\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = digits.length-1;\n        while (j > i && digits[j] <= digits[i]) j--;\n        // Swap digits[i] and digits[j]\n        int temp = digits[i];\n        digits[i] = digits[j];\n        digits[j] = temp;\n        // Reverse the digits to the right of i\n        int left = i+1, right = digits.length-1;\n        while (left < right) {\n            temp = digits[left];\n            digits[left] = digits[right];\n            digits[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert back to long\n        return Long.parseLong(Arrays.stream(digits).mapToObj(Integer::toString).collect(Collectors.joining()));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit greater than the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array back to a string\n        s = new String(c);\n        // Convert the string to a long\n        return Long.parseLong(s);",
    "        // find the first digit that is less than the digit to its right\n        // find the smallest digit to its right that is greater than the digit\n        // swap the two digits\n        // sort the digits to the right of the swapped digits\n        // return the new number\n        char[] digits = Long.toString(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        char[] digits = Long.toString(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(s.substring(i, i + 1));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the two digits\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to long\n        return Long.parseLong(new String(chars));",
    "        char[] digits = Long.toString(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first digit that is smaller than the digit to the right\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than c[i]\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap the two digits\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of i\n        i++;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to string\n        s = new String(c);\n        // Convert back to long\n        return Long.parseLong(s);",
    "        // Convert to array of digits\n        int[] digits = Long.toString(n).chars().map(c -> c-'0').toArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = digits.length-2;\n        while (i >= 0 && digits[i] >= digits[i+1]) {\n            i--;\n        }\n        // If no such digit exists, then the number is already the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = digits.length-1;\n        while (j >= 0 && digits[j] <= digits[i]) {\n            j--;\n        }\n        // Swap digits[i] and digits[j]\n        int temp = digits[i];\n        digits[i] = digits[j];\n        digits[j] = temp;\n        // Reverse the digits to the right of i\n        int left = i+1;\n        int right = digits.length-1;\n        while (left < right) {\n            temp = digits[left];\n            digits[left] = digits[right];\n            digits[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert the array of digits back to a number\n        return Long.parseLong(Arrays.stream(digits).mapToObj(Integer::toString).collect(Collectors.joining()));",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // convert to string\n        String s = String.valueOf(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first decreasing digit from the right\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if no decreasing digit is found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest digit to the right of the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit with the smallest digit to the right\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits to the right of the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to long\n        return Long.parseLong(new String(c));",
    "        // Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        // Find the largest index l greater than k such that a[k] < a[l].\n        // Swap the value of a[k] with that of a[l].\n        // Reverse the sequence from a[k + 1] up to and including the final element a[n].\n        char[] chars = String.valueOf(n).toCharArray();\n        int k = -1;\n        for (int i = 0; i < chars.length - 1; i++) {\n            if (chars[i] < chars[i + 1]) {\n                k = i;\n            }\n        }\n        if (k == -1) {\n            return -1;\n        }\n        int l = k + 1;\n        for (int i = k + 1; i < chars.length; i++) {\n            if (chars[k] < chars[i]) {\n                l = i;\n            }\n        }\n        char temp = chars[k];\n        chars[k] = chars[l];\n        chars[l] = temp;\n        for (int i = k + 1; i < chars.length; i++) {\n            for (int j = i + 1; j < chars.length; j++) {\n                if (chars[i] > chars[j]) {\n                    temp = chars[i];\n                    chars[i] = chars[j];\n                    chars[j] = temp;\n                }\n            }\n        }\n        return Long.parseLong(new String(chars));",
    "        // get the digits of the number\n        List<Long> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // if no such digit exists, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the digit found above that is greater than it\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // swap the two digits\n        long temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, no bigger number is possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i-1)'th digit that is greater than number[i-1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i-1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Sort the digits after (i-1) in ascending order\n        Arrays.sort(c, i, c.length);\n        // Convert back to long\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest digit larger than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the digits\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert back to long\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // find the smallest digit larger than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit and the smallest digit larger than the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to long\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = digits.size() - 1; i > 0; i--) {\n            if (digits.get(i) > digits.get(i - 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, the number is already the largest possible\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is larger than the pivot\n        int pivot = digits.get(i - 1);\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int j = i; j < digits.size(); j++) {\n            if (digits.get(j) > pivot && digits.get(j) < min) {\n                min = digits.get(j);\n                minIndex = j;\n            }\n        }\n        // Swap the pivot with the smallest digit to its right that is larger than the pivot\n        digits.set(i - 1, min);\n        digits.set(minIndex, pivot);\n        // Sort the digits to the right of the pivot\n        Collections.sort(digits.subList(i, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int j = digits.size() - 1; j >= 0; j--) {\n            result = result * 10 + digits.get(j);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index i where c[i] < c[i+1]\n        int i = -1;\n        for (int j = 0; j < c.length - 1; j++) {\n            if (c[j] < c[j+1]) {\n                i = j;\n            }\n        }\n        // If no such index exists, return -1\n        if (i == -1) {\n            return -1;\n        }\n        // Find the first index j where c[j] > c[i]\n        int j = -1;\n        for (int k = 0; k < c.length; k++) {\n            if (c[k] > c[i]) {\n                j = k;\n            }\n        }\n        // Swap c[i] and c[j]\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the substring c[i+1] to c[n-1]\n        for (int k = i+1; k < c.length; k++) {\n            for (int l = k+1; l < c.length; l++) {\n                if (c[k] > c[l]) {\n                    temp = c[k];\n                    c[k] = c[l];\n                    c[l] = temp;\n                }\n            }\n        }\n        // Convert back to string\n        s = new String(c);\n        // Convert back to long\n        return Long.parseLong(s);",
    "        // Convert the number to a string.\n        String s = Long.toString(n);\n        // Convert the string to a char array.\n        char[] c = s.toCharArray();\n        // Create a list of integers from the char array.\n        List<Integer> l = new ArrayList<>();\n        for (char x : c) {\n            l.add(Character.getNumericValue(x));\n        }\n        // Create a list of tuples of integers.\n        List<Pair<Integer, Integer>> t = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            t.add(new Pair<>(l.get(i), i));\n        }\n        // Sort the list of tuples.\n        Collections.sort(t, new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {\n                return o1.getValue0().compareTo(o2.getValue0());\n            }\n        });\n        // Create a list of integers from the sorted list of tuples.\n        List<Integer> l2 = new ArrayList<>();\n        for (Pair<Integer, Integer> x : t) {\n            l2.add(x.getValue0());\n        }\n        // Create a list of integers from the sorted list of tuples.\n        List<Integer> l3 = new ArrayList<>();\n        for (Pair<Integer, Integer> x : t) {\n            l3.add(x.getValue1());\n        }\n        // Create a list of tuples of integers.\n        List<Pair<Integer, Integer>> t2 = new ArrayList<>();\n        for (int i = 0; i < l2.size(); i++) {\n            t2.add(new Pair<>(l2.get(i), l3.get(i)));\n        }\n        // Sort the list of tuples.\n        Collections.sort(t2, new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer",
    "        // Find the first digit that is smaller than the digit to its right.\n        // Find the smallest digit to the right of that digit that is larger than it.\n        // Swap those digits.\n        // Reverse all the digits to the right of the digit that was swapped.\n        // If no such digit exists, return -1.\n        String s = Long.toString(n);\n        int i = s.length() - 1;\n        while (i > 0 && s.charAt(i) <= s.charAt(i - 1)) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = i;\n        while (j < s.length() && s.charAt(j) > s.charAt(i - 1)) {\n            j++;\n        }\n        j--;\n        StringBuilder sb = new StringBuilder(s);\n        sb.setCharAt(i - 1, s.charAt(j));\n        sb.setCharAt(j, s.charAt(i - 1));\n        StringBuilder sb2 = new StringBuilder(sb.substring(i));\n        sb2.reverse();\n        sb.replace(i, sb.length(), sb2.toString());\n        return Long.parseLong(sb.toString());",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) i--;\n        // if no decreasing digit, return -1\n        if (i <= 0) return -1;\n        // find the smallest digit larger than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) j--;\n        // swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse c[i, ..., c.length - 1]\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to long and return\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to array\n        char[] arr = s.toCharArray();\n        // get length\n        int len = arr.length;\n        // find the first index from the right that is less than the next index\n        int i = len - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) {\n            i--;\n        }\n        // if i is 0, then the number is in descending order, so there is no bigger number\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest number that is greater than arr[i - 1]\n        int j = len - 1;\n        while (arr[j] <= arr[i - 1]) {\n            j--;\n        }\n        // swap arr[i - 1] and arr[j]\n        char temp = arr[i - 1];\n        arr[i - 1] = arr[j];\n        arr[j] = temp;\n        // reverse the array from i to the end\n        j = len - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        // convert back to string\n        s = new String(arr);\n        // convert back to long\n        return Long.parseLong(s);",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        String s = Long.toString(n);\n        int[] arr = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            arr[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = arr.length - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = arr.length - 1;\n        while (arr[j] <= arr[i - 1]) {\n            j--;\n        }\n        int temp = arr[i - 1];\n        arr[i - 1] = arr[j];\n        arr[j] = temp;\n        j = arr.length - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < arr.length; k++) {\n            sb.append(arr[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to array\n        char[] arr = Long.toString(n).toCharArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = arr.length - 2;\n        while (i >= 0 && arr[i] >= arr[i + 1]) {\n            i--;\n        }\n        // If no such digit exists, the number is already the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is larger than the pivot\n        int j = arr.length - 1;\n        while (arr[j] <= arr[i]) {\n            j--;\n        }\n        // Swap the pivot with the smallest digit to its right that is larger than the pivot\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        // Reverse the digits to the right of the pivot\n        i++;\n        j = arr.length - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(arr));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, no answer\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the first digit that is greater than the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the pivot with the first digit that is greater than the pivot\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the suffix\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to long\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If the number is decreasing, then there is no bigger number\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the first decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit greater than it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the first decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to string\n        s = new String(c);\n        // Convert to long\n        return Long.parseLong(s);",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is less than the next index\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If no such index exists, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest index from the right that is greater than the index found above\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the two indices\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the array from the index found above to the end\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a string and return the string\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first digit that is less than the digit to its right\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If we didn't find a digit that is less than the digit to its right, then the number is already the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap the digits found in the previous two steps\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the digit found in the first step\n        i++;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to string\n        s = new String(c);\n        // Convert back to long\n        return Long.parseLong(s);",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = 0;\n        for (i = c.length - 1; i > 0; i--) {\n            if (c[i] > c[i - 1]) {\n                break;\n            }\n        }\n        // If no decreasing digit, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than c[i - 1]\n        int j = i;\n        for (j = i; j < c.length; j++) {\n            if (c[j] <= c[i - 1]) {\n                break;\n            }\n        }\n        // Swap c[i - 1] and c[j - 1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j - 1];\n        c[j - 1] = temp;\n        // Sort the digits after c[i - 1]\n        Arrays.sort(c, i, c.length);\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = String.valueOf(n);\n        // convert to char array\n        char[] chars = s.toCharArray();\n        // find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit and the smallest digit greater than the decreasing digit\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // convert back to long\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) >= digits.get(i + 1)) {\n            i++;\n        }\n        // If there is no such digit, then the number is already the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is larger than it\n        int j = i + 1;\n        while (j < digits.size() - 1 && digits.get(j + 1) < digits.get(i)) {\n            j++;\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Reverse the digits to the right of the digit found above\n        Collections.reverse(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // 1. Convert number to array of digits\n        // 2. Find the first digit from the right that is smaller than the digit to its right\n        // 3. Find the smallest digit to the right of the pivot that is larger than the pivot\n        // 4. Swap the pivot with the smallest digit\n        // 5. Reverse the digits to the right of the pivot\n        // 6. Convert the array of digits back to a number\n        // 7. Return the number\n        int[] digits = Long.toString(n).chars().map(c -> c-'0').toArray();\n        int pivot = -1;\n        for (int i = digits.length-2; i >= 0; i--) {\n            if (digits[i] < digits[i+1]) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot == -1) return -1;\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = pivot+1; i < digits.length; i++) {\n            if (digits[i] > digits[pivot] && digits[i] < min) {\n                min = digits[i];\n                minIndex = i;\n            }\n        }\n        int temp = digits[pivot];\n        digits[pivot] = digits[minIndex];\n        digits[minIndex] = temp;\n        for (int i = pivot+1; i < (digits.length+pivot+1)/2; i++) {\n            temp = digits[i];\n            digits[i] = digits[digits.length-1+pivot-i];\n            digits[digits.length-1+pivot-i] = temp;\n        }\n        return Arrays.stream(digits).mapToObj(Integer::toString).collect(Collectors.joining());",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        int[] arr = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            arr[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = arr.length - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = arr.length - 1;\n        while (arr[j] <= arr[i - 1]) {\n            j--;\n        }\n        int temp = arr[i - 1];\n        arr[i - 1] = arr[j];\n        arr[j] = temp;\n        j = arr.length - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < arr.length; k++) {\n            sb.append(arr[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If all digits are in descending order, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the first digit greater than the digit at index i - 1\n        int j = chars.length - 1;\n        while (chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the digits at index i - 1 and j\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits from index i to the end of the array\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a long\n        return Long.parseLong(new String(chars));",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first index where the next number is greater than the current number\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if i is 0 then the number is in descending order\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest number greater than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the numbers after i - 1\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert back to long\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Find the first decreasing digit\n        int firstDecreasing = -1;\n        for (int i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) > digits.get(i + 1)) {\n                firstDecreasing = i;\n                break;\n            }\n        }\n        // If no decreasing digit is found, then the number is already the largest\n        if (firstDecreasing == -1) {\n            return -1;\n        }\n        // Find the smallest digit larger than the first decreasing digit\n        int smallestLarger = firstDecreasing + 1;\n        for (int i = firstDecreasing + 1; i < digits.size(); i++) {\n            if (digits.get(i) < digits.get(smallestLarger) && digits.get(i) > digits.get(firstDecreasing)) {\n                smallestLarger = i;\n            }\n        }\n        // Swap the first decreasing digit with the smallest larger digit\n        int temp = digits.get(firstDecreasing);\n        digits.set(firstDecreasing, digits.get(smallestLarger));\n        digits.set(smallestLarger, temp);\n        // Sort the digits after the first decreasing digit\n        Collections.sort(digits.subList(firstDecreasing + 1, digits.size()));\n        // Return the new number\n        long newNumber = 0;\n        for (int i = 0; i < digits.size(); i++) {\n            newNumber += digits.get(i) * Math.pow(10, i);\n        }\n        return newNumber;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Sort the array\n        Arrays.sort(c);\n        // Convert back to string\n        String sorted = new String(c);\n        // Convert to long\n        long sortedLong = Long.parseLong(sorted);\n        // Check if the sorted number is equal to the original number\n        if (sortedLong == n) {\n            // If so, return -1\n            return -1;\n        }\n        // Otherwise, return the next bigger number\n        return sortedLong;",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // get length\n        int len = c.length;\n        // loop through the array\n        for (int i = len - 1; i > 0; i--) {\n            // if the current element is greater than the previous element\n            if (c[i] > c[i - 1]) {\n                // get the current element\n                char temp = c[i];\n                // set the current element to the previous element\n                c[i] = c[i - 1];\n                // set the previous element to the current element\n                c[i - 1] = temp;\n                // return the new number\n                return Long.parseLong(new String(c));\n            }\n        }\n        // return -1 if no bigger number can be made\n        return -1;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in decreasing order, no answer\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the first digit greater than the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the pivot with the first digit greater than the pivot\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the suffix\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the result\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the next digit\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the current digit\n        int j = i + 1;\n        for (int k = i + 1; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // Swap the two digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits after the current digit\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        String s = String.valueOf(n);\n        int len = s.length();\n        int[] arr = new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i] = s.charAt(i) - '0';\n        }\n        int i = len - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = len - 1;\n        while (arr[j] <= arr[i - 1]) {\n            j--;\n        }\n        int temp = arr[i - 1];\n        arr[i - 1] = arr[j];\n        arr[j] = temp;\n        j = len - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        long res = 0;\n        for (int k = 0; k < len; k++) {\n            res = res * 10 + arr[k];\n        }\n        return res;",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit from the right\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If we didn't find a decreasing digit, then the number is already the largest possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit that is larger than the decreasing digit\n        int j = chars.length - 1;\n        while (j > i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit to the right of it\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to string and return\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If there is no decreasing digit, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after c[i - 1]\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit larger than the decreasing digit\n        int j = chars.length - 1;\n        while (j > 0 && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit larger than the decreasing digit\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (int k = 0; k < a.length; k++) {\n            result = result * 10 + a[k];\n        }\n        return result;",
    "        // Convert to array of digits\n        int[] digits = new int[(int)Math.log10(n) + 1];\n        for (int i = digits.length - 1; i >= 0; i--) {\n            digits[i] = (int)(n % 10);\n            n /= 10;\n        }\n        // Find the first digit that can be swapped with a digit to its right\n        int i = digits.length - 1;\n        while (i > 0 && digits[i] <= digits[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is greater than the pivot\n        int j = i;\n        while (j < digits.length && digits[j] > digits[i - 1]) {\n            j++;\n        }\n        // Swap the pivot with the smallest digit to its right\n        int temp = digits[i - 1];\n        digits[i - 1] = digits[j - 1];\n        digits[j - 1] = temp;\n        // Sort the digits to the right of the pivot\n        Arrays.sort(digits, i, digits.length);\n        // Convert to long\n        long result = 0;\n        for (int k = 0; k < digits.length; k++) {\n            result = result * 10 + digits[k];\n        }\n        return result;",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the digits\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        char[] digits = String.valueOf(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        // Convert to array of digits\n        int[] digits = new int[String.valueOf(n).length()];\n        for (int i = 0; i < digits.length; i++) {\n            digits[i] = (int) (n % 10);\n            n /= 10;\n        }\n        // Find the first digit that is smaller than the digit to its right\n        int index = -1;\n        for (int i = digits.length - 1; i > 0; i--) {\n            if (digits[i] > digits[i - 1]) {\n                index = i - 1;\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (index == -1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = index + 1; i < digits.length; i++) {\n            if (digits[i] > digits[index] && digits[i] < min) {\n                min = digits[i];\n                minIndex = i;\n            }\n        }\n        // Swap the digit found in the previous step with the digit found in this step\n        int temp = digits[index];\n        digits[index] = digits[minIndex];\n        digits[minIndex] = temp;\n        // Sort the digits to the right of the digit found in step 1 in ascending order\n        Arrays.sort(digits, index + 1, digits.length);\n        // Convert array of digits back to long\n        long result = 0;\n        for (int i = digits.length - 1; i >= 0; i--) {\n            result = result * 10 + digits[i];\n        }\n        return result;",
    "        // if n is negative, return -1\n        if (n < 0) {\n            return -1;\n        }\n        // if n is a single digit, return -1\n        if (n < 10) {\n            return -1;\n        }\n        // convert n to a string\n        String s = Long.toString(n);\n        // convert string to a char array\n        char[] c = s.toCharArray();\n        // create a list of integers from the char array\n        List<Integer> l = new ArrayList<Integer>();\n        for (int i = 0; i < c.length; i++) {\n            l.add(Character.getNumericValue(c[i]));\n        }\n        // create a list of tuples of integers\n        List<Pair<Integer, Integer>> t = new ArrayList<Pair<Integer, Integer>>();\n        for (int i = 0; i < l.size() - 1; i++) {\n            t.add(new Pair<Integer, Integer>(l.get(i), l.get(i + 1)));\n        }\n        // create a list of tuples of integers\n        List<Pair<Integer, Integer>> t2 = new ArrayList<Pair<Integer, Integer>>();\n        // iterate through the list of tuples\n        for (int i = 0; i < t.size(); i++) {\n            // if the first element of the tuple is less than the second element\n            if (t.get(i).getValue0() < t.get(i).getValue1()) {\n                // add the tuple to the list of tuples\n                t2.add(t.get(i));\n            }\n        }\n        // if the list of tuples is empty, return -1\n        if (t2.isEmpty()) {\n            return -1;\n        }\n        // create a list of integers\n        List<Integer> l2 = new ArrayList<Integer>();\n        // iterate through the list of tuples\n        for (int i = 0; i < t2.size(); i++) {\n            // add the first element of the tuple to the list of integers\n            l2.add(t2.get(i).",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit to the right\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = String.valueOf(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in decreasing order, then no bigger number is possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i-1)'th digit that is greater than number[i-1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i-1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Sort the digits after (i-1) in ascending order\n        Arrays.sort(c, i, c.length);\n        // Convert to long\n        return Long.parseLong(String.valueOf(c));",
    "        char[] chars = String.valueOf(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.valueOf(new String(chars));",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(s.substring(i, i + 1));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        char[] digits = String.valueOf(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.valueOf(new String(digits));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        char[] chars = String.valueOf(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 2;\n        while (i >= 0 && chars[i] >= chars[i + 1]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= 0 && chars[j] <= chars[i]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit greater than the decreasing digit\n        char temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        int left = i + 1;\n        int right = chars.length - 1;\n        while (left < right) {\n            temp = chars[left];\n            chars[left] = chars[right];\n            chars[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(chars));",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] chars = s.toCharArray();\n        // find the first decreasing digit from the right\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // if all digits are in descending order, no answer\n        if (i <= 0) {\n            return -1;\n        }\n        // find the first digit greater than the pivot from the right\n        int j = chars.length - 1;\n        while (j > 0 && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // swap the pivot with the first digit greater than the pivot\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // reverse the suffix\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to string\n        s = new String(chars);\n        // convert to long\n        return Long.parseLong(s);",
    "        // convert to string\n        String s = String.valueOf(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first index of the first digit that is less than the digit to its right\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if there is no such index, then the number is the largest possible\n        if (i <= 0) {\n            return -1;\n        }\n        // find the first index of the first digit that is greater than the digit at index i - 1\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the digits at index i - 1 and j\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits from index i to the end\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // return the new number\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found in the previous step\n        int j = i + 1;\n        for (j = i + 1; j < digits.size(); j++) {\n            if (digits.get(j) < digits.get(i)) {\n                break;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found in the first step\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = 10 * result + digits.get(k);\n        }\n        return result;",
    "        // Convert number to array of digits\n        int[] digits = Arrays.stream(String.valueOf(n).split(\"\")).mapToInt(Integer::parseInt).toArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = digits.length - 2;\n        while (i >= 0 && digits[i] >= digits[i + 1]) {\n            i--;\n        }\n        // If no such digit exists, then the number is in descending order, so no bigger number exists\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = digits.length - 1;\n        while (j >= 0 && digits[j] <= digits[i]) {\n            j--;\n        }\n        // Swap digits[i] and digits[j]\n        int temp = digits[i];\n        digits[i] = digits[j];\n        digits[j] = temp;\n        // Reverse the digits to the right of i\n        int left = i + 1;\n        int right = digits.length - 1;\n        while (left < right) {\n            temp = digits[left];\n            digits[left] = digits[right];\n            digits[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert the array of digits back to a number\n        return Long.parseLong(Arrays.stream(digits).mapToObj(String::valueOf).collect(Collectors.joining()));",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long num = 0;\n        for (i = 0; i < a.length; i++) {\n            num = num * 10 + a[i];\n        }\n        return num;",
    "        // Convert to string\n        String s = String.valueOf(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the pivot\n        int pivot = -1;\n        for (int i = chars.length - 1; i > 0; i--) {\n            if (chars[i] > chars[i - 1]) {\n                pivot = i - 1;\n                break;\n            }\n        }\n        // If pivot is -1, then no bigger number can be made\n        if (pivot == -1) {\n            return -1;\n        }\n        // Find the smallest number greater than the pivot\n        int smallest = pivot + 1;\n        for (int i = pivot + 1; i < chars.length; i++) {\n            if (chars[i] > chars[pivot] && chars[i] < chars[smallest]) {\n                smallest = i;\n            }\n        }\n        // Swap the pivot and the smallest\n        char temp = chars[pivot];\n        chars[pivot] = chars[smallest];\n        chars[smallest] = temp;\n        // Sort the rest of the array\n        Arrays.sort(chars, pivot + 1, chars.length);\n        // Return the new number\n        return Long.parseLong(new String(chars));",
    "        // Get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while(n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit after it\n        int i = 0;\n        for(i = 0; i < digits.size() - 1; i++) {\n            if(digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, then the number is the largest possible\n        if(i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the digit at i\n        int min = i + 1;\n        for(int j = i + 1; j < digits.size(); j++) {\n            if(digits.get(j) < digits.get(min) && digits.get(j) > digits.get(i)) {\n                min = j;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(min));\n        digits.set(min, temp);\n        // Sort the digits after i\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for(int j = 0; j < digits.size(); j++) {\n            result = result * 10 + digits.get(j);\n        }\n        return result;",
    "        // Convert to array of digits\n        int[] digits = new int[(int)Math.log10(n) + 1];\n        int i = digits.length - 1;\n        while (n > 0) {\n            digits[i--] = (int)n % 10;\n            n /= 10;\n        }\n        // Find the first digit that is smaller than the digit to its right\n        int first = -1;\n        for (i = 0; i < digits.length - 1; i++) {\n            if (digits[i] < digits[i + 1]) {\n                first = i;\n                break;\n            }\n        }\n        if (first == -1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first digit that is larger than the first digit\n        int second = first + 1;\n        for (i = first + 2; i < digits.length; i++) {\n            if (digits[i] < digits[second] && digits[i] > digits[first]) {\n                second = i;\n            }\n        }\n        // Swap the first and second digits\n        int temp = digits[first];\n        digits[first] = digits[second];\n        digits[second] = temp;\n        // Sort the digits to the right of the first digit\n        Arrays.sort(digits, first + 1, digits.length);\n        // Convert to number\n        long result = 0;\n        for (i = 0; i < digits.length; i++) {\n            result = result * 10 + digits[i];\n        }\n        return result;",
    "        String s = String.valueOf(n);\n        int len = s.length();\n        char[] arr = s.toCharArray();\n        int i = len - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = len - 1;\n        while (arr[j] <= arr[i - 1]) {\n            j--;\n        }\n        char temp = arr[i - 1];\n        arr[i - 1] = arr[j];\n        arr[j] = temp;\n        j = len - 1;\n        while (i < j) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(String.valueOf(arr));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit with the smallest digit greater than it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        long[] digits = new long[(int)Math.log10(n) + 1];\n        int i = 0;\n        while (n > 0) {\n            digits[i++] = n % 10;\n            n /= 10;\n        }\n        for (i = digits.length - 1; i > 0; i--) {\n            if (digits[i] > digits[i - 1]) {\n                long temp = digits[i];\n                digits[i] = digits[i - 1];\n                digits[i - 1] = temp;\n                break;\n            }\n        }\n        long result = 0;\n        for (i = 0; i < digits.length; i++) {\n            result += digits[i] * Math.pow(10, i);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits from c[i] to the end\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long and return\n        return Long.parseLong(new String(c));",
    "        char[] digits = String.valueOf(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        // 1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        // 2. Find the largest index l greater than k such that a[k] < a[l].\n        // 3. Swap the value of a[k] with that of a[l].\n        // 4. Reverse the sequence from a[k + 1] up to and including the final element a[n].\n        String s = String.valueOf(n);\n        int k = -1;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) < s.charAt(i + 1)) {\n                k = i;\n            }\n        }\n        if (k == -1) {\n            return -1;\n        }\n        int l = -1;\n        for (int i = k + 1; i < s.length(); i++) {\n            if (s.charAt(k) < s.charAt(i)) {\n                l = i;\n            }\n        }\n        char[] chars = s.toCharArray();\n        char temp = chars[k];\n        chars[k] = chars[l];\n        chars[l] = temp;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k + 1; i++) {\n            sb.append(chars[i]);\n        }\n        for (int i = chars.length - 1; i > k; i--) {\n            sb.append(chars[i]);\n        }\n        return Long.parseLong(sb.toString());",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j > 0 && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (i = 0; i < a.length; i++) {\n            result = result * 10 + a[i];\n        }\n        return result;",
    "        // Convert to array of digits\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that can be swapped with a digit to its right\n        int swapIndex = -1;\n        for (int i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                swapIndex = i;\n            }\n        }\n        if (swapIndex == -1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of swapIndex that is larger than digits[swapIndex]\n        int minIndex = swapIndex + 1;\n        for (int i = swapIndex + 1; i < digits.size(); i++) {\n            if (digits.get(i) < digits.get(minIndex) && digits.get(i) > digits.get(swapIndex)) {\n                minIndex = i;\n            }\n        }\n        // Swap digits[swapIndex] and digits[minIndex]\n        int temp = digits.get(swapIndex);\n        digits.set(swapIndex, digits.get(minIndex));\n        digits.set(minIndex, temp);\n        // Sort the digits to the right of swapIndex\n        ArrayList<Integer> right = new ArrayList<Integer>();\n        for (int i = swapIndex + 1; i < digits.size(); i++) {\n            right.add(digits.get(i));\n        }\n        Collections.sort(right);\n        for (int i = swapIndex + 1; i < digits.size(); i++) {\n            digits.set(i, right.get(i - swapIndex - 1));\n        }\n        // Convert back to number\n        long result = 0;\n        for (int i = 0; i < digits.size(); i++) {\n            result += digits.get(i) * Math.pow(10, i);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (int k = 0; k < a.length; k++) {\n            result = result * 10 + a[k];\n        }\n        return result;",
    "        // get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the pivot that is larger than the pivot\n        int pivot = digits.get(i);\n        int min = digits.get(i + 1);\n        int minIndex = i + 1;\n        for (int j = i + 2; j < digits.size(); j++) {\n            if (digits.get(j) > pivot && digits.get(j) < min) {\n                min = digits.get(j);\n                minIndex = j;\n            }\n        }\n        // swap the pivot and the min\n        digits.set(i, min);\n        digits.set(minIndex, pivot);\n        // sort the digits to the right of the pivot\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the new number\n        long newNum = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            newNum = newNum * 10 + digits.get(j);\n        }\n        return newNum;",
    "        String s = String.valueOf(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (int k = 0; k < a.length; k++) {\n            result = result * 10 + a[k];\n        }\n        return result;",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (i = 0; i < a.length; i++) {\n            result = result * 10 + a[i];\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit greater than the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit is found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long and return\n        return Long.parseLong(new String(c));",
    "        // Find the first digit that is smaller than the digit to its right.\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step.\n        // Swap the two digits found in the previous two steps.\n        // Reverse all the digits to the right of the digit found in step 1.\n        // If no such digit exists, return -1.\n        String s = Long.toString(n);\n        int[] digits = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            digits[i] = s.charAt(i) - '0';\n        }\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        int temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (int k = 0; k < digits.length; k++) {\n            result = result * 10 + digits[k];\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Create a list of the chars\n        List<Character> l = new ArrayList<Character>();\n        for (char x : c) {\n            l.add(x);\n        }\n        // Create a list of the indices\n        List<Integer> i = new ArrayList<Integer>();\n        for (int j = 0; j < l.size(); j++) {\n            i.add(j);\n        }\n        // Create a list of the pairs\n        List<Pair<Character, Integer>> p = new ArrayList<Pair<Character, Integer>>();\n        for (int j = 0; j < l.size(); j++) {\n            p.add(new Pair<Character, Integer>(l.get(j), i.get(j)));\n        }\n        // Sort the pairs\n        Collections.sort(p, new Comparator<Pair<Character, Integer>>() {\n            @Override\n            public int compare(Pair<Character, Integer> p1, Pair<Character, Integer> p2) {\n                return p1.getValue0().compareTo(p2.getValue0());\n            }\n        });\n        // Create a list of the sorted chars\n        List<Character> l2 = new ArrayList<Character>();\n        for (Pair<Character, Integer> x : p) {\n            l2.add(x.getValue0());\n        }\n        // Create a list of the sorted indices\n        List<Integer> i2 = new ArrayList<Integer>();\n        for (Pair<Character, Integer> x : p) {\n            i2.add(x.getValue1());\n        }\n        // Create a list of the sorted pairs\n        List<Pair<Character, Integer>> p2 = new ArrayList<Pair<Character, Integer>>();\n        for (int j = 0; j < l2.size(); j++) {\n            p2.add(new Pair<Character, Integer>(l2.get(j), i2.get(j)));\n        }\n        // Create a list of the sorted",
    "        // get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // reverse the digits\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // if no such digit exists, the number is the largest possible number\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the digit that is smaller than the digit to its right\n        int j = i + 1;\n        for (; j < digits.size(); j++) {\n            if (digits.get(j) < digits.get(i)) {\n                break;\n            }\n        }\n        // swap the two digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j - 1));\n        digits.set(j - 1, temp);\n        // sort the digits to the right of the digit that is smaller than the digit to its right\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the number\n        long result = 0;\n        for (int k = digits.size() - 1; k >= 0; k--) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string and sort in reverse order\n        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        Arrays.sort(chars);\n        String sorted = new String(chars);\n        sorted = new StringBuilder(sorted).reverse().toString();\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < sorted.length() - 1; i++) {\n            if (sorted.charAt(i) > sorted.charAt(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (i == sorted.length() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is greater than sorted[i]\n        int j = i + 1;\n        for (j = i + 1; j < sorted.length(); j++) {\n            if (sorted.charAt(j) > sorted.charAt(i)) {\n                break;\n            }\n        }\n        // Swap sorted[i] and sorted[j]\n        char temp = sorted.charAt(i);\n        sorted = sorted.substring(0, i) + sorted.charAt(j) + sorted.substring(i + 1, j) + temp + sorted.substring(j + 1);\n        // Sort the digits to the right of i in ascending order\n        chars = sorted.substring(i + 1).toCharArray();\n        Arrays.sort(chars);\n        sorted = sorted.substring(0, i + 1) + new String(chars);\n        return Long.parseLong(sorted);",
    "        // if n is a single digit, return -1\n        if (n < 10) {\n            return -1;\n        }\n        // convert n to a list of digits\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // reverse the list\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the next\n        int index = -1;\n        for (int i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                index = i;\n            }\n        }\n        // if no such digit exists, return -1\n        if (index == -1) {\n            return -1;\n        }\n        // find the smallest digit that is larger than the digit at index\n        int min = index + 1;\n        for (int i = index + 1; i < digits.size(); i++) {\n            if (digits.get(i) > digits.get(index) && digits.get(i) < digits.get(min)) {\n                min = i;\n            }\n        }\n        // swap the digits at index and min\n        int temp = digits.get(index);\n        digits.set(index, digits.get(min));\n        digits.set(min, temp);\n        // sort the digits after index\n        Collections.sort(digits.subList(index + 1, digits.size()));\n        // convert the list back to a number\n        long result = 0;\n        for (int i = 0; i < digits.size(); i++) {\n            result = result * 10 + digits.get(i);\n        }\n        return result;",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // find the first digit that is smaller than the digit to its right\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // if we found a digit that is smaller than the digit to its right\n        if (i > 0) {\n            // find the smallest digit to the right of the digit that is smaller than the digit to its right\n            int j = c.length - 1;\n            while (c[j] <= c[i - 1]) {\n                j--;\n            }\n            // swap the two digits\n            char temp = c[i - 1];\n            c[i - 1] = c[j];\n            c[j] = temp;\n            // reverse the digits to the right of the digit that is smaller than the digit to its right\n            j = c.length - 1;\n            while (i < j) {\n                temp = c[i];\n                c[i] = c[j];\n                c[j] = temp;\n                i++;\n                j--;\n            }\n        }\n        // convert char array to long\n        return Long.parseLong(new String(c));",
    "        // 1. Convert to string\n        String s = Long.toString(n);\n        // 2. Convert to char array\n        char[] c = s.toCharArray();\n        // 3. Find the first decreasing digit from the right\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // 4. If no such digit exists, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // 5. Find the smallest digit on the right side of (i - 1)th digit that is greater than number[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // 6. Swap the above found digit with number[i - 1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // 7. Sort the digits after (i - 1) in ascending order\n        Arrays.sort(c, i, c.length);\n        // 8. Convert to long and return\n        return Long.parseLong(new String(c));",
    "        // Convert the number to a string\n        String s = Long.toString(n);\n        // Convert the string to a char array\n        char[] c = s.toCharArray();\n        // Convert the char array to a list\n        List<Character> l = new ArrayList<Character>();\n        for (char ch : c) {\n            l.add(ch);\n        }\n        // Find the first index from the right where the number is less than the number to its right\n        int i = l.size() - 1;\n        while (i > 0 && l.get(i) <= l.get(i - 1)) {\n            i--;\n        }\n        // If i is 0, then the number is already the largest possible number\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is greater than l[i - 1]\n        int j = l.size() - 1;\n        while (l.get(j) <= l.get(i - 1)) {\n            j--;\n        }\n        // Swap l[i - 1] and l[j]\n        char temp = l.get(i - 1);\n        l.set(i - 1, l.get(j));\n        l.set(j, temp);\n        // Reverse the list from i to the end\n        Collections.reverse(l.subList(i, l.size()));\n        // Convert the list to a string\n        StringBuilder sb = new StringBuilder();\n        for (char ch : l) {\n            sb.append(ch);\n        }\n        // Convert the string to a long\n        return Long.parseLong(sb.toString());",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Sort in descending order\n        Arrays.sort(c);\n        // Convert back to string\n        String s1 = new String(c);\n        // Convert back to long\n        long n1 = Long.parseLong(s1);\n        // Return the next bigger number\n        return n1;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit with the smallest digit greater than it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        String s = String.valueOf(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.valueOf(new String(c));",
    "        // get the digits of the number\n        List<Long> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        // reverse the digits\n        Collections.reverse(digits);\n        // find the first digit that is less than the digit after it\n        int index = -1;\n        for (int i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                index = i;\n            }\n        }\n        // if no such digit exists, return -1\n        if (index == -1) {\n            return -1;\n        }\n        // find the smallest digit that is greater than the digit at index\n        int index2 = index + 1;\n        for (int i = index + 1; i < digits.size(); i++) {\n            if (digits.get(i) < digits.get(index2) && digits.get(i) > digits.get(index)) {\n                index2 = i;\n            }\n        }\n        // swap the digits at index and index2\n        long temp = digits.get(index);\n        digits.set(index, digits.get(index2));\n        digits.set(index2, temp);\n        // sort the digits after index\n        Collections.sort(digits.subList(index + 1, digits.size()));\n        // convert the digits to a number\n        long result = 0;\n        for (int i = 0; i < digits.size(); i++) {\n            result += digits.get(i) * Math.pow(10, i);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int[] ints = new int[chars.length];\n        for(int i = 0; i < chars.length; i++) {\n            ints[i] = Character.getNumericValue(chars[i]);\n        }\n        int i = ints.length - 1;\n        while(i > 0 && ints[i - 1] >= ints[i]) {\n            i--;\n        }\n        if(i <= 0) {\n            return -1;\n        }\n        int j = ints.length - 1;\n        while(ints[j] <= ints[i - 1]) {\n            j--;\n        }\n        int temp = ints[i - 1];\n        ints[i - 1] = ints[j];\n        ints[j] = temp;\n        j = ints.length - 1;\n        while(i < j) {\n            temp = ints[i];\n            ints[i] = ints[j];\n            ints[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int k = 0; k < ints.length; k++) {\n            sb.append(ints[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If all digits are sorted in descending order, no answer\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i - 1)'th digit that is greater than number[i - 1]\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i - 1]\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Sort the digits after (i - 1) in ascending order\n        Arrays.sort(chars, i, chars.length);\n        // Convert to long\n        return Long.parseLong(new String(chars));",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to array of digits\n        int[] digits = new int[(int)Math.log10(n) + 1];\n        int i = 0;\n        while (n > 0) {\n            digits[i++] = (int)n % 10;\n            n /= 10;\n        }\n        // Find the first digit that is smaller than the digit to its right\n        int pivot = -1;\n        for (i = 0; i < digits.length - 1; i++) {\n            if (digits[i] < digits[i + 1]) {\n                pivot = i;\n                break;\n            }\n        }\n        // If no such digit exists, the number is already the largest possible\n        if (pivot == -1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is larger than the pivot\n        int min = pivot + 1;\n        for (i = pivot + 1; i < digits.length; i++) {\n            if (digits[i] > digits[pivot] && digits[i] < digits[min]) {\n                min = i;\n            }\n        }\n        // Swap the pivot and min\n        int temp = digits[pivot];\n        digits[pivot] = digits[min];\n        digits[min] = temp;\n        // Sort the digits to the right of the pivot\n        Arrays.sort(digits, pivot + 1, digits.length);\n        // Convert back to number\n        long result = 0;\n        for (i = 0; i < digits.length; i++) {\n            result = result * 10 + digits[i];\n        }\n        return result;",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) n % 10);\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit after it\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the digit at i\n        int j = i + 1;\n        for (int k = i + 1; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // Swap the digits at i and j\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits after i\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is less than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // if no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the digit that is greater than it\n        int min = i + 1;\n        for (int j = i + 1; j < digits.size(); j++) {\n            if (digits.get(j) > digits.get(i) && digits.get(j) < digits.get(min)) {\n                min = j;\n            }\n        }\n        // swap the two digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(min));\n        digits.set(min, temp);\n        // sort the digits to the right of the swapped digit\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the new number\n        long result = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            result = result * 10 + digits.get(j);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (int k = 0; k < a.length; k++) {\n            result = result * 10 + a[k];\n        }\n        return result;",
    "        // We need to find the next biggest number that can be made by rearranging the digits of the given number.\n        // We can do this by finding the next permutation of the digits of the given number.\n        // We can find the next permutation by finding the first digit that is smaller than the digit to its right.\n        // We then swap that digit with the smallest digit to its right that is larger than it.\n        // We then reverse the digits to the right of the digit we swapped.\n        // If we can't find a digit that is smaller than the digit to its right, then we can't find a bigger number.\n        // We can find the next permutation in O(n) time and O(1) space.\n        // We can find the first digit that is smaller than the digit to its right in O(n) time and O(1) space.\n        // We can find the smallest digit to its right that is larger than it in O(n) time and O(1) space.\n        // We can reverse the digits to the right of the digit we swapped in O(n) time and O(1) space.\n        // We can swap the digits in O(1) time and O(1) space.\n        // We can convert the number to a list of digits in O(n) time and O(n) space.\n        // We can convert the list of digits back to a number in O(n) time and O(1) space.\n        // Overall, this takes O(n) time and O(n) space.\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        int j = i + 1;\n        for (j = i + 1; j < digits.size(); j++) {\n            if (",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // get the length of the array\n        int len = c.length;\n        // loop through the array\n        for (int i = len - 1; i > 0; i--) {\n            // if the current element is greater than the previous element\n            if (c[i] > c[i - 1]) {\n                // get the index of the current element\n                int index = i;\n                // loop through the array from the current index\n                for (int j = i; j < len; j++) {\n                    // if the current element is less than the next element\n                    if (c[j] < c[index] && c[j] > c[i - 1]) {\n                        // set the index to the current element\n                        index = j;\n                    }\n                }\n                // swap the current element with the next element\n                char temp = c[i - 1];\n                c[i - 1] = c[index];\n                c[index] = temp;\n                // sort the array from the current index\n                Arrays.sort(c, i, len);\n                // convert the array to a string\n                String str = new String(c);\n                // return the string\n                return str;\n            }\n        }\n        // return -1 if no bigger number exists\n        return -1;",
    "        // Convert to string\n        String str = String.valueOf(n);\n        // Convert to char array\n        char[] arr = str.toCharArray();\n        // Find the first index from the right where the digit is less than the digit to the right\n        int index = -1;\n        for (int i = arr.length - 1; i > 0; i--) {\n            if (arr[i] > arr[i - 1]) {\n                index = i - 1;\n                break;\n            }\n        }\n        // If no such index exists, return -1\n        if (index == -1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the index that is greater than the digit at the index\n        int minIndex = index + 1;\n        for (int i = index + 2; i < arr.length; i++) {\n            if (arr[i] > arr[index] && arr[i] < arr[minIndex]) {\n                minIndex = i;\n            }\n        }\n        // Swap the digits at the index and the minIndex\n        char temp = arr[index];\n        arr[index] = arr[minIndex];\n        arr[minIndex] = temp;\n        // Sort the digits to the right of the index\n        Arrays.sort(arr, index + 1, arr.length);\n        // Convert the char array to a string\n        String result = new String(arr);\n        // Convert the string to a long\n        long resultLong = Long.parseLong(result);\n        // Return the long\n        return resultLong;",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Find the first digit that is smaller than the digit after it\n        int i = digits.size() - 2;\n        while (i >= 0 && digits.get(i) >= digits.get(i + 1)) {\n            i--;\n        }\n        // If no such digit exists, the number is the biggest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the digit at i\n        int j = digits.size() - 1;\n        while (digits.get(j) <= digits.get(i)) {\n            j--;\n        }\n        // Swap the digits at i and j\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Reverse the digits after i\n        Collections.reverse(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the one after it\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit larger than the one at i\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // swap the digits at i and j\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // sort the digits after i\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // 1. Convert n to a string\n        String s = Long.toString(n);\n        // 2. Convert string to a char array\n        char[] c = s.toCharArray();\n        // 3. Find the first non-increasing digit from the right\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // 4. If no such digit exists, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // 5. Find the smallest digit to the right of the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // 6. Swap the pivot with the smallest digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // 7. Reverse the digits to the right of the pivot\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // 8. Return the result\n        return Long.parseLong(new String(c));",
    "        // Convert to array of digits\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the one after it\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, then the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the one at i\n        int j = i + 1;\n        for (; j < digits.size(); j++) {\n            if (digits.get(j) > digits.get(i)) {\n                break;\n            }\n        }\n        // Swap the digits at i and j\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Reverse the digits after i\n        Collections.reverse(digits.subList(i + 1, digits.size()));\n        // Convert the array back to a number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is larger than it\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to array of digits\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) >= digits.get(i + 1)) {\n            i++;\n        }\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of i that is larger than digits[i]\n        int j = i + 1;\n        while (j < digits.size() && digits.get(j) > digits.get(i)) {\n            j++;\n        }\n        j--;\n        // Swap digits[i] and digits[j]\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Reverse the digits to the right of i\n        Collections.reverse(digits.subList(i + 1, digits.size()));\n        // Convert back to long\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is less than the digit to its right\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, then the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is greater than the pivot\n        int pivot = digits.get(i);\n        int j = i + 1;\n        for (; j < digits.size(); j++) {\n            if (digits.get(j) > pivot) {\n                break;\n            }\n        }\n        // Swap the pivot with the smallest digit to the right of the pivot\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the pivot\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        long result = 0;\n        for (i = 0; i < a.length; i++) {\n            result = result * 10 + a[i];\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If all digits are in increasing order, no answer\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = i;\n        while (j < c.length && c[j] > c[i - 1]) {\n            j++;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right\n        char temp = c[i - 1];\n        c[i - 1] = c[j - 1];\n        c[j - 1] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        int k = i;\n        int l = c.length - 1;\n        while (k < l) {\n            temp = c[k];\n            c[k] = c[l];\n            c[l] = temp;\n            k++;\n            l--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the smallest digit to the right of the decreasing digit with the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to string\n        s = new String(c);\n        // Convert to long\n        return Long.parseLong(s);",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is less than the next index\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If i is 0, then the number is in descending order, so no bigger number exists\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is greater than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the string from i to the end\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to string\n        s = new String(c);\n        // Convert back to long\n        return Long.parseLong(s);",
    "        // convert number to array of digits\n        int[] digits = new int[(int)Math.log10(n) + 1];\n        int i = digits.length - 1;\n        while (n > 0) {\n            digits[i--] = (int)n % 10;\n            n /= 10;\n        }\n        // find the first digit that is smaller than the digit to its right\n        int first = -1;\n        for (i = 0; i < digits.length - 1; i++) {\n            if (digits[i] < digits[i + 1]) {\n                first = i;\n                break;\n            }\n        }\n        // if no such digit exists, then the number is the largest possible\n        if (first == -1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the first digit that is larger than the first digit\n        int second = first + 1;\n        for (i = first + 1; i < digits.length; i++) {\n            if (digits[i] > digits[first] && digits[i] < digits[second]) {\n                second = i;\n            }\n        }\n        // swap the first and second digits\n        int temp = digits[first];\n        digits[first] = digits[second];\n        digits[second] = temp;\n        // sort the digits to the right of the first digit\n        Arrays.sort(digits, first + 1, digits.length);\n        // convert the array of digits back to a number\n        long result = 0;\n        for (i = 0; i < digits.length; i++) {\n            result = result * 10 + digits[i];\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Get the index of the first digit that is less than the digit to its right\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If no such digit exists, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is greater than the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the pivot and the smallest digit to the right of the pivot\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the pivot\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long and return\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing element\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing element, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the first element greater than the decreasing element\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing element with the greater element\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the array from the decreasing element\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to string and return\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first digit that is smaller than the digit to its right\n        int i = chars.length - 2;\n        while (i >= 0 && chars[i] >= chars[i + 1]) {\n            i--;\n        }\n        // If no such digit is found, the number is the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is larger than the pivot\n        int j = chars.length - 1;\n        while (j >= 0 && chars[j] <= chars[i]) {\n            j--;\n        }\n        // Swap the pivot with the smallest digit to its right\n        char temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits to the right of the pivot\n        i++;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to long\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit greater than it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // convert to string\n        String s = String.valueOf(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // sort the array\n        Arrays.sort(c);\n        // convert back to string\n        String sorted = new String(c);\n        // convert to long\n        long sortedLong = Long.parseLong(sorted);\n        // check if sortedLong is greater than n\n        if (sortedLong > n) {\n            return sortedLong;\n        }\n        return -1;",
    "        // 1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        // 2. Find the largest index l greater than k such that a[k] < a[l].\n        // 3. Swap the value of a[k] with that of a[l].\n        // 4. Reverse the sequence from a[k + 1] up to and including the final element a[n].\n        char[] arr = Long.toString(n).toCharArray();\n        int k = -1;\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] < arr[i + 1]) {\n                k = i;\n            }\n        }\n        if (k == -1) {\n            return -1;\n        }\n        int l = k + 1;\n        for (int i = k + 1; i < arr.length; i++) {\n            if (arr[k] < arr[i]) {\n                l = i;\n            }\n        }\n        char temp = arr[k];\n        arr[k] = arr[l];\n        arr[l] = temp;\n        int start = k + 1;\n        int end = arr.length - 1;\n        while (start < end) {\n            temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n        return Long.parseLong(new String(arr));",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j > 0 && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        if (n < 10) {\n            return -1;\n        }\n        char[] digits = String.valueOf(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.valueOf(new String(digits));",
    "        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be positive\");\n        }\n        if (n < 10) {\n            return -1;\n        }\n        char[] digits = Long.toString(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char tmp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = tmp;\n        j = digits.length - 1;\n        while (i < j) {\n            tmp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = tmp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        char[] digits = Long.toString(n).toCharArray();\n        int i = digits.length - 1;\n        while (i > 0 && digits[i - 1] >= digits[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = digits.length - 1;\n        while (digits[j] <= digits[i - 1]) {\n            j--;\n        }\n        char temp = digits[i - 1];\n        digits[i - 1] = digits[j];\n        digits[j] = temp;\n        j = digits.length - 1;\n        while (i < j) {\n            temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(digits));",
    "        // Convert to a list of digits\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is less than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, then the number is already the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is greater than the pivot\n        int pivot = digits.get(i);\n        int min = digits.get(i + 1);\n        int minIndex = i + 1;\n        for (int j = i + 1; j < digits.size(); j++) {\n            if (digits.get(j) > pivot && digits.get(j) < min) {\n                min = digits.get(j);\n                minIndex = j;\n            }\n        }\n        // Swap the pivot and the min\n        digits.set(i, min);\n        digits.set(minIndex, pivot);\n        // Sort the digits to the right of the pivot\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Convert back to a number\n        long result = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            result = result * 10 + digits.get(j);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is smaller than the next index\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If no such index exists, then the number is the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is larger than i\n        int j = c.length - 1;\n        while (j > i && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap i and j\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the string from i + 1 to the end\n        int k = i + 1;\n        int l = c.length - 1;\n        while (k < l) {\n            temp = c[k];\n            c[k] = c[l];\n            c[l] = temp;\n            k++;\n            l--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        // Reverse the digits\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is greater than the digit found above\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Create the new number\n        long newNumber = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            newNumber = newNumber * 10 + digits.get(k);\n        }\n        return newNumber;",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Character.getNumericValue(s.charAt(i));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] c = s.toCharArray();\n        // get length\n        int l = c.length;\n        // get last index\n        int i = l - 1;\n        // loop through the array\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // if i is 0 then there is no bigger number\n        if (i <= 0) {\n            return -1;\n        }\n        // get the index of the next smallest digit\n        int j = l - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // swap the digits\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // reverse the digits\n        j = l - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to string\n        s = new String(c);\n        // convert to long\n        return Long.parseLong(s);",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] chars = s.toCharArray();\n        // find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the smallest digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit and the smallest digit greater than it\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to long\n        return Long.parseLong(new String(chars));"
  ]
}