{
  "name": "mbpp_407_rearrange_bigger",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // Write a function to create the next bigger number by rearranging the digits of a given number.\n    public static Object rearrangeBigger(long n) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(rearrangeBigger((12l)).equals((Object(21l))));\n    assert(rearrangeBigger((10l)).equals((Object(false))));\n    assert(rearrangeBigger((102l)).equals((Object(120l))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        // Find the largest index l greater than k such that a[k] < a[l].\n        // Swap the value of a[k] with that of a[l].\n        // Reverse the sequence from a[k + 1] up to and including the final element a[n].\n        // https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\n        char[] chars = Long.toString(n).toCharArray();\n        int k = -1;\n        for (int i = 0; i < chars.length - 1; i++) {\n            if (chars[i] < chars[i + 1]) {\n                k = i;\n            }\n        }\n        if (k == -1) {\n            return -1;\n        }\n        int l = k + 1;\n        for (int i = k + 1; i < chars.length; i++) {\n            if (chars[k] < chars[i]) {\n                l = i;\n            }\n        }\n        char temp = chars[k];\n        chars[k] = chars[l];\n        chars[l] = temp;\n        for (int i = k + 1; i < chars.length; i++) {\n            for (int j = i + 1; j < chars.length; j++) {\n                if (chars[i] > chars[j]) {\n                    temp = chars[i];\n                    chars[i] = chars[j];\n                    chars[j] = temp;\n                }\n            }\n        }\n        return Long.parseLong(new String(chars));",
    "        // If the number is a single digit, then it can't be rearranged to be bigger.\n        if (n < 10) {\n            return null;\n        }\n        // Convert the number to a string.\n        String s = Long.toString(n);\n        // Convert the string to a char array.\n        char[] c = s.toCharArray();\n        // Find the first index where the digit is less than the digit to its right.\n        int i = c.length - 1;\n        while (i > 0 && c[i] <= c[i - 1]) {\n            i--;\n        }\n        // If no such index exists, then the number can't be rearranged to be bigger.\n        if (i == 0) {\n            return null;\n        }\n        // Find the smallest digit to the right of the index that is greater than the digit at the index.\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the digits at the index and the smallest digit to its right.\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the index.\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a string.\n        s = new String(c);\n        // Convert the string to a long.\n        return Long.parseLong(s);",
    "        String s = Long.toString(n);\n        char[] a = s.toCharArray();\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        char temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(a));",
    "        char[] chars = String.valueOf(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, no answer is possible\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit on the right side of (i-1)'th digit that is greater than number[i-1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the above found smallest digit with number[i-1]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Sort the digits after (i-1) in ascending order\n        Arrays.sort(c, i, c.length);\n        // Convert char array to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If all digits are in descending order, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than the pivot\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the pivot with the smallest digit greater than the pivot\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the suffix\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = String.valueOf(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is smaller than the one to its right\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If no such index exists, return -1\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is bigger than c[i]\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap c[i] and c[j]\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the numbers to the right of i\n        int left = i + 1;\n        int right = c.length - 1;\n        while (left < right) {\n            temp = c[left];\n            c[left] = c[right];\n            c[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert char array to string\n        s = new String(c);\n        // Convert string to long\n        return Long.parseLong(s);",
    "        // get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n = n / 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the digit to its right\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) >= digits.get(i + 1)) {\n            i++;\n        }\n        // if no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the pivot that is larger than the pivot\n        int j = i + 1;\n        while (j < digits.size() && digits.get(j) > digits.get(i)) {\n            j++;\n        }\n        // swap the pivot with the smallest digit to the right of the pivot\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j - 1));\n        digits.set(j - 1, temp);\n        // sort the digits to the right of the pivot in ascending order\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = s.charAt(i) - '0';\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        // find the first digit that is smaller than the digit to its right\n        // find the smallest digit to the right of the digit found in the previous step that is greater than it\n        // swap the digits\n        // sort the digits to the right of the digit found in the first step\n        // return the number\n        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // get digits\n        ArrayList<Long> digits = new ArrayList<Long>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        // find the first digit that is smaller than the digit to its right\n        int i = digits.size() - 1;\n        while (i > 0 && digits.get(i) <= digits.get(i - 1)) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        // find the smallest digit to the right of the pivot that is bigger than the pivot\n        int j = digits.size() - 1;\n        while (digits.get(j) <= digits.get(i - 1)) {\n            j--;\n        }\n        // swap the pivot with the smallest digit to its right\n        long temp = digits.get(i - 1);\n        digits.set(i - 1, digits.get(j));\n        digits.set(j, temp);\n        // reverse the digits to the right of the pivot\n        j = digits.size() - 1;\n        while (i < j) {\n            temp = digits.get(i);\n            digits.set(i, digits.get(j));\n            digits.set(j, temp);\n            i++;\n            j--;\n        }\n        // convert the digits back to a number\n        long result = 0;\n        for (i = 0; i < digits.size(); i++) {\n            result = result * 10 + digits.get(i);\n        }\n        return result;",
    "        char[] chars = Long.toString(n).toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first index from the right that is smaller than the next\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no such index exists, the digits are in descending order and no bigger number exists\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of (i - 1) that is greater than chars[i - 1]\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap chars[i - 1] and chars[j]\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits from position i to the end\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert the char array to a long\n        return Long.parseLong(new String(chars));",
    "        // Find the first digit that is smaller than the digit to its right.\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step.\n        // Swap the digits found in the previous two steps.\n        // Reverse the digits to the right of the digit found in the first step.\n        // If no such digit exists, return -1.\n        // If the number is already the largest possible number, return -1.\n        // If the number is the largest possible number with the same number of digits, return -1.\n        // If the number is the largest possible number with one fewer digit, return the number with a 0 appended to the end.\n        // If the number is the largest possible number with two fewer digits, return the number with a 00 appended to the end.\n        // If the number is the largest possible number with three fewer digits, return the number with a 000 appended to the end.\n        // If the number is the largest possible number with four fewer digits, return the number with a 0000 appended to the end.\n        // If the number is the largest possible number with five fewer digits, return the number with a 00000 appended to the end.\n        // If the number is the largest possible number with six fewer digits, return the number with a 000000 appended to the end.\n        // If the number is the largest possible number with seven fewer digits, return the number with a 0000000 appended to the end.\n        // If the number is the largest possible number with eight fewer digits, return the number with a 00000000 appended to the end.\n        // If the number is the largest possible number with nine fewer digits, return the number with a 000000000 appended to the end.\n        // If the number is the largest possible number with ten fewer digits, return the number with a 0000000000 appended to the end.\n        // If the number is the largest possible number with eleven fewer digits, return the number with a 00000000000 appended to the end.\n        // If the number is the largest possible number with twelve fewer digits, return the number with a 000000000000 appended to the end.\n        // If the number is the largest possible number with thirteen fewer digits, return the number with a 0000000000000 appended to the end.\n        // If the number is the largest possible number",
    "        // find the first digit that is smaller than the digit to its right\n        // find the smallest digit to the right of the pivot that is greater than the pivot\n        // swap the pivot and the smallest digit\n        // sort the digits to the right of the pivot\n        // return the new number\n        String s = Long.toString(n);\n        int pivot = -1;\n        for (int i = s.length() - 2; i >= 0; i--) {\n            if (s.charAt(i) < s.charAt(i + 1)) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot == -1) {\n            return -1;\n        }\n        int smallest = pivot + 1;\n        for (int i = pivot + 1; i < s.length(); i++) {\n            if (s.charAt(i) > s.charAt(pivot) && s.charAt(i) < s.charAt(smallest)) {\n                smallest = i;\n            }\n        }\n        char[] a = s.toCharArray();\n        char temp = a[pivot];\n        a[pivot] = a[smallest];\n        a[smallest] = temp;\n        Arrays.sort(a, pivot + 1, a.length);\n        return Long.parseLong(new String(a));",
    "        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n        int len = chars.length;\n        int i = len - 1;\n        while (i > 0 && chars[i] <= chars[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return -1;\n        }\n        int j = len - 1;\n        while (j > i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        Arrays.sort(chars, i, len);\n        return Long.valueOf(String.valueOf(chars));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)(n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit to its right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If no such digit exists, the number is the largest possible\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found above that is larger than it\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // Swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found above\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the decreasing digit and the smallest digit to the right of the decreasing digit\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(c));",
    "        String s = Long.toString(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(s.substring(i, i + 1));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());"
  ]
}