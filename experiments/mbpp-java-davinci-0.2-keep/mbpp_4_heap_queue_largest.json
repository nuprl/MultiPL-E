{
  "name": "mbpp_4_heap_queue_largest",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    public static ArrayList<Long> heapQueueLargest(ArrayList<Long> nums, long n) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(heapQueueLargest((new ArrayList<Long>(Arrays.asList((long)25l, (long)35l, (long)22l, (long)85l, (long)14l, (long)65l, (long)75l, (long)22l, (long)58l))), (3l)).equals((new ArrayList<Long>(Arrays.asList((long)85l, (long)75l, (long)65l)))));\n    assert(heapQueueLargest((new ArrayList<Long>(Arrays.asList((long)25l, (long)35l, (long)22l, (long)85l, (long)14l, (long)65l, (long)75l, (long)22l, (long)58l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)85l, (long)75l)))));\n    assert(heapQueueLargest((new ArrayList<Long>(Arrays.asList((long)25l, (long)35l, (long)22l, (long)85l, (long)14l, (long)65l, (long)75l, (long)22l, (long)58l))), (5l)).equals((new ArrayList<Long>(Arrays.asList((long)85l, (long)75l, (long)65l, (long)58l, (long)35l)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for(long num : nums) {\n            heap.add(num);\n            if(heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while(!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (pq.size() > 0) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> res = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.remove();\n            }\n        }\n        while (!pq.isEmpty()) {\n            res.add(pq.remove());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (int i = 0; i < nums.size(); i++) {\n            heap.add(nums.get(i));\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> largest = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            largest.add(pq.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        // Add the first n elements of the array to the heap queue\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // Iterate through the rest of the array\n        for (int i = (int)n; i < nums.size(); i++) {\n            // If the current element is larger than the smallest element in the heap queue, replace it\n            if (nums.get(i) > heap.peek()) {\n                heap.poll();\n                heap.add(nums.get(i));\n            }\n        }\n        // Return the heap queue in descending order\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.remove();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.remove());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.sort(result, Collections.reverseOrder());\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (pq.size() > 0) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // create a heap queue\n        PriorityQueue<Long> queue = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // add all the numbers to the queue\n        for (Long num : nums) {\n            queue.add(num);\n        }\n        // create a new array list\n        ArrayList<Long> result = new ArrayList<Long>();\n        // add the n largest numbers to the array list\n        for (int i = 0; i < n; i++) {\n            result.add(queue.poll());\n        }\n        // return the array list\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>(nums);\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> ret = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            ret.add(pq.poll());\n        }\n        Collections.reverse(ret);\n        return ret;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> queue = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            queue.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(queue.poll());\n        }\n        return result;",
    "        // Create a new heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        // Add the first n elements to the heap queue\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // Iterate through the rest of the elements\n        for (int i = (int) n; i < nums.size(); i++) {\n            // If the current element is larger than the smallest element in the heap queue,\n            // remove the smallest element and add the current element\n            if (nums.get(i) > heap.peek()) {\n                heap.poll();\n                heap.add(nums.get(i));\n            }\n        }\n        // Create a new array list to store the n largest elements\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the elements from the heap queue to the array list\n        while (!heap.isEmpty()) {\n            largest.add(heap.poll());\n        }\n        // Return the array list in reverse order\n        return new ArrayList<Long>(largest);",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        // Create a max heap\n        PriorityQueue<Long> heap = new PriorityQueue<>(Collections.reverseOrder());\n        // Add all the numbers to the heap\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        // Create a new arraylist to store the largest numbers\n        ArrayList<Long> largest = new ArrayList<>();\n        // Add the largest numbers to the list\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> ans = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            ans.add(pq.poll());\n        }\n        Collections.reverse(ans);\n        return ans;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        heap.addAll(nums);\n        ArrayList<Long> largest = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        // Time: O(n log n)\n        // Space: O(n)\n        // HeapQueue\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            if (heap.size() < n) {\n                heap.add(num);\n            } else {\n                if (num > heap.peek()) {\n                    heap.poll();\n                    heap.add(num);\n                }\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> largest = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            largest.add(pq.poll());\n        }\n        Collections.reverse(largest);\n        return largest;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all the numbers to the heap queue\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create a new array list to hold the n largest numbers\n        ArrayList<Long> largestNums = new ArrayList<Long>();\n        // Add the n largest numbers to the array list\n        for (long i = 0; i < n; i++) {\n            largestNums.add(heap.poll());\n        }\n        // Return the array list\n        return largestNums;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        heap.addAll(nums);\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        // Create a heap queue.\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all the numbers to the heap queue.\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create a new list to store the largest numbers.\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the largest numbers to the list.\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        // Return the list of largest numbers.\n        return largest;",
    "        // Create a priority queue with a custom comparator\n        PriorityQueue<Long> pq = new PriorityQueue<Long>(new Comparator<Long>() {\n            public int compare(Long a, Long b) {\n                return b.compareTo(a);\n            }\n        });\n        // Add all the numbers to the priority queue\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        // Create a new arraylist to store the n largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the n largest numbers to the arraylist\n        for (int i = 0; i < n; i++) {\n            largest.add(pq.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        // Create a priority queue.\n        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all numbers to the priority queue.\n        for (long num : nums) {\n            pq.add(num);\n        }\n        // Create a new list to store the n largest numbers.\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the n largest numbers to the list.\n        for (long i = 0; i < n; i++) {\n            largest.add(pq.poll());\n        }\n        // Return the list of n largest numbers.\n        return largest;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> largest = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // Create a max heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        // Add all the numbers to the heap\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create an array list to store the results\n        ArrayList<Long> results = new ArrayList<Long>();\n        // Pop the top n numbers from the heap\n        for (long i = 0; i < n; i++) {\n            results.add(heap.poll());\n        }\n        return results;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            res.add(pq.poll());\n        }\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        // Create a min heap\n        PriorityQueue<Long> minHeap = new PriorityQueue<>();\n        // Add the first n elements to the heap\n        for (int i = 0; i < n; i++) {\n            minHeap.add(nums.get(i));\n        }\n        // For each element after the first n, if it is larger than the smallest element in the heap, remove the smallest element and add the new element\n        for (int i = (int) n; i < nums.size(); i++) {\n            if (nums.get(i) > minHeap.peek()) {\n                minHeap.poll();\n                minHeap.add(nums.get(i));\n            }\n        }\n        // Create an arraylist to hold the largest n elements\n        ArrayList<Long> largest = new ArrayList<>();\n        // While the heap is not empty, add the smallest element to the list and remove it from the heap\n        while (!minHeap.isEmpty()) {\n            largest.add(minHeap.poll());\n        }\n        // Return the list in reverse order\n        Collections.reverse(largest);\n        return largest;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) heap.poll();\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!heap.isEmpty()) res.add(heap.poll());\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all numbers to the heap queue\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        // Create a new list to store the largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the largest n numbers to the list\n        for (long i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        // Return the list\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Use a heap queue to find the n largest integers.\n        // The heap queue is a min-heap, so we need to negate the numbers.\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(-num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(-heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> ret = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            ret.add(heap.poll());\n        }\n        return ret;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> queue = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            queue.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(queue.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> ans = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            ans.add(heap.poll());\n        }\n        Collections.reverse(ans);\n        return ans;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Create a max heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        // Add all the numbers to the heap\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        // Create a list to store the largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Pop the largest numbers from the heap and add them to the list\n        for (long i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        // Create a max heap\n        PriorityQueue<Long> heap = new PriorityQueue<>(Collections.reverseOrder());\n        // Add all numbers to the heap\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Pop the top n numbers from the heap\n        ArrayList<Long> largest = new ArrayList<>();\n        for (long i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> ans = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            ans.add(pq.poll());\n        }\n        return ans;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all numbers to the heap\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create a new list to store the largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the largest n numbers to the list\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (pq.size() > 0) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all numbers to the heap queue\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create a list to store the largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the largest numbers to the list\n        for (long i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        // Create a heap queue.\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        // Add the first n elements to the heap.\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // For each of the remaining elements, if the element is larger than the smallest element in the heap,\n        // remove the smallest element and add the new element.\n        for (int i = (int) n; i < nums.size(); i++) {\n            if (nums.get(i) > heap.peek()) {\n                heap.poll();\n                heap.add(nums.get(i));\n            }\n        }\n        // Create a new list to store the n largest elements.\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the elements in the heap to the list.\n        while (!heap.isEmpty()) {\n            largest.add(heap.poll());\n        }\n        // Reverse the list.\n        Collections.reverse(largest);\n        // Return the list.\n        return largest;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            res.add(pq.poll());\n        }\n        return res;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long i : nums) {\n            pq.add(i);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        // Create a heap queue of size n\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(n);\n        // Add the first n elements to the heap\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // Iterate through the rest of the list\n        for (int i = (int) n; i < nums.size(); i++) {\n            // If the current element is larger than the smallest element in the heap\n            if (nums.get(i) > heap.peek()) {\n                // Remove the smallest element from the heap\n                heap.remove();\n                // Add the current element to the heap\n                heap.add(nums.get(i));\n            }\n        }\n        // Create an array list to store the n largest elements\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Iterate through the heap\n        while (!heap.isEmpty()) {\n            // Add the elements to the array list in descending order\n            largest.add(heap.remove());\n        }\n        // Return the array list\n        return largest;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            res.add(heap.poll());\n        }\n        return res;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> ret = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            ret.add(heap.poll());\n        }\n        Collections.reverse(ret);\n        return ret;",
    "        // Create a max heap\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all numbers to the heap\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        // Pop the top n numbers from the heap\n        ArrayList<Long> largest = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> queue = new PriorityQueue<>();\n        for (long num : nums) {\n            queue.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(queue.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums);\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // Create a heap queue of size n\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(n);\n        // Add the first n elements to the heap\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // For each element in the list after the first n, if it is larger than the smallest element in the heap, remove the smallest element and add the new element\n        for (int i = n; i < nums.size(); i++) {\n            if (nums.get(i) > heap.peek()) {\n                heap.poll();\n                heap.add(nums.get(i));\n            }\n        }\n        // Create a new list to store the n largest elements\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the elements from the heap to the list in descending order\n        while (!heap.isEmpty()) {\n            largest.add(heap.poll());\n        }\n        // Return the list\n        return largest;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            res.add(pq.poll());\n        }\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> res = new ArrayList<Long>();\n        PriorityQueue<Long> q = new PriorityQueue<Long>();\n        for (long i = 0; i < nums.size(); i++) {\n            q.add(nums.get((int)i));\n        }\n        for (long i = 0; i < n; i++) {\n            res.add(q.poll());\n        }\n        return res;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (pq.size() > 0) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> ret = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            ret.add(pq.poll());\n        }\n        Collections.reverse(ret);\n        return ret;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all the numbers to the heap queue\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // Create a new array list to store the n largest numbers\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the n largest numbers to the array list\n        for (long i = 0; i < n; i++) {\n            largest.add(heap.poll());\n        }\n        // Return the array list\n        return largest;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>(nums);\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        heap.addAll(nums);\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Create a max heap\n        PriorityQueue<Long> heap = new PriorityQueue<>(Collections.reverseOrder());\n        // Add the first n elements to the heap\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // For each element after the first n, if it is greater than the smallest element in the heap, remove the smallest element and add the new element\n        for (int i = (int)n; i < nums.size(); i++) {\n            if (nums.get(i) > heap.peek()) {\n                heap.poll();\n                heap.add(nums.get(i));\n            }\n        }\n        // Return the heap as an arraylist\n        return new ArrayList<Long>(heap);",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(heap.remove());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Write your code here\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> queue = new PriorityQueue<>();\n        for (Long num : nums) {\n            queue.add(num);\n            if (queue.size() > n) {\n                queue.poll();\n            }\n        }\n        while (queue.size() > 0) {\n            result.add(queue.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> res = new ArrayList<Long>();\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> res = new ArrayList<Long>();\n        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> queue = new PriorityQueue<Long>();\n        for (long num : nums) {\n            queue.add(num);\n            if (queue.size() > n) {\n                queue.poll();\n            }\n        }\n        while (!queue.isEmpty()) {\n            result.add(queue.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), (a, b) -> (int)(b - a));\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        // Create a priority queue that will return the largest elements first.\n        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        // Add all the numbers to the priority queue.\n        for (Long num : nums) {\n            pq.add(num);\n        }\n        // Create a new list to hold the n largest numbers.\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Add the n largest numbers to the list.\n        for (int i = 0; i < n; i++) {\n            largest.add(pq.poll());\n        }\n        // Return the list of n largest numbers.\n        return largest;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (Long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n        }\n        for (long i = 0; i < n; i++) {\n            result.add(pq.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        // create a max heap\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n        // add all numbers to heap\n        for (long num : nums) {\n            heap.add(num);\n        }\n        // remove the smallest n - 1 numbers\n        for (long i = 0; i < n - 1; i++) {\n            heap.poll();\n        }\n        // return the largest n numbers\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>((int)n, Collections.reverseOrder());\n        for (long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        PriorityQueue<Long> pq = new PriorityQueue<Long>(nums.size(), Collections.reverseOrder());\n        for (long num : nums) {\n            pq.add(num);\n        }\n        ArrayList<Long> ans = new ArrayList<Long>();\n        for (long i = 0; i < n; i++) {\n            ans.add(pq.poll());\n        }\n        return ans;",
    "        // Create a heap queue\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        // Add the first n elements to the heap queue\n        for (int i = 0; i < n; i++) {\n            heap.add(nums.get(i));\n        }\n        // Iterate through the rest of the list\n        for (int i = (int) n; i < nums.size(); i++) {\n            // If the current element is greater than the smallest element in the heap queue\n            if (nums.get(i) > heap.peek()) {\n                // Remove the smallest element\n                heap.poll();\n                // Add the current element\n                heap.add(nums.get(i));\n            }\n        }\n        // Create a new list to store the largest elements\n        ArrayList<Long> largest = new ArrayList<Long>();\n        // Iterate through the heap queue\n        while (!heap.isEmpty()) {\n            // Add the largest element to the list\n            largest.add(heap.poll());\n        }\n        // Return the list in descending order\n        Collections.reverse(largest);\n        return largest;",
    "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (long num : nums) {\n            pq.add(num);\n            if (pq.size() > n) {\n                pq.poll();\n            }\n        }\n        ArrayList<Long> ans = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            ans.add(pq.poll());\n        }\n        Collections.reverse(ans);\n        return ans;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (Long num : nums) {\n            heap.add(num);\n        }\n        for (int i = 0; i < n; i++) {\n            result.add(heap.poll());\n        }\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        ArrayList<Long> result = new ArrayList<>();\n        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;",
    "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n        for (long num : nums) {\n            heap.add(num);\n            if (heap.size() > n) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n        return result;"
  ]
}