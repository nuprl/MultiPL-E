language: swift
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * 10) / 10\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpy2zndb5k.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * 10) / 10\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(trunc(number)).asInt()\n\
    \    return Double(integer) / Double(decimal)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp4pyol05q.swift:9:37: error: cannot find 'trunc' in scope\n    let\
    \ (integer, decimal) = Double(trunc(number)).asInt()\n                       \
    \             ^~~~~\n/tmp/tmp4pyol05q.swift:9:52: error: reference to member 'asInt'\
    \ cannot be resolved without a contextual type\n    let (integer, decimal) = Double(trunc(number)).asInt()\n\
    \                                                   ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpecl2agl5.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpecl2agl5.swift:12:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number).rounded(.towardZero)\n    return integerPart.truncatingRemainder(dividingBy:\
    \ 1) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpufo4w8i3.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpufo4w8i3.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmpufo4w8i3.swift:10:46: error: cannot infer contextual base\
    \ in reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpecl2agl5.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpecl2agl5.swift:12:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpecl2agl5.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpecl2agl5.swift:12:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    var decimalPart = number\n    var integerPart = number\n    var decimalsCount\
    \ = 0\n    while decimalPart > 1.0 {\n        decimalPart /= 10\n        decimalsCount\
    \ += 1\n    }\n    if decimalsCount > 0 {\n        integerPart *= 10\n       \
    \ integerPart /= decimalsCount\n    }\n    return integerPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmplrznub8s.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmplrznub8s.swift:21:24:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        integerPart /= decimalsCount\n                       ^\n            \
    \           Double(      )\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let result = Double(trunc(number))\n    if result <\
    \ number {\n        return result + 1.0\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph105_ex4.swift:9:25: error: cannot find 'trunc' in scope\n    let\
    \ result = Double(trunc(number))\n                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = trunc(number)\n    return Double(integerPart) / pow(10.0, Double(decimalPart))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_bms9_0f.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp_bms9_0f.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp_bms9_0f.swift:10:23: error: cannot\
    \ find 'trunc' in scope\n    let integerPart = trunc(number)\n               \
    \       ^~~~~\n/tmp/tmp_bms9_0f.swift:11:34: error: cannot find 'pow' in scope\n\
    \    return Double(integerPart) / pow(10.0, Double(decimalPart))\n           \
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    let whole = number -\
    \ fraction\n    return whole < 0.5 ? whole : whole - 1 + fraction\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmppwvn3rie.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(trunc(number))\n    return\
    \ number - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8jcf0oiy.swift:9:30: error: cannot find 'trunc' in scope\n    let\
    \ decimalPart = Double(trunc(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1.0 {\n        return number\n    }\n \
    \   let decimalPart = number % 1\n    return number - decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6xtbgmwu.swift:12:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpx92acuii.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number - truncate_number(Double(number))\n\
    \    return fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpg_48hkim.swift:9:45: error: missing argument label 'number:' in\
    \ call\n    let fraction = number - truncate_number(Double(number))\n        \
    \                                    ^\n                                     \
    \       number: \n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = floor(number / pow(10.0, Double(decimalPart)))\n    return Double(integerPart)\
    \ * pow(10.0, Double(decimalPart))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp2ptkgdi_.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp2ptkgdi_.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp2ptkgdi_.swift:10:23: error: cannot\
    \ find 'floor' in scope\n    let integerPart = floor(number / pow(10.0, Double(decimalPart)))\n\
    \                      ^~~~~\n/tmp/tmp2ptkgdi_.swift:10:38: error: cannot find\
    \ 'pow' in scope\n    let integerPart = floor(number / pow(10.0, Double(decimalPart)))\n\
    \                                     ^~~\n/tmp/tmp2ptkgdi_.swift:11:34: error:\
    \ cannot find 'pow' in scope\n    return Double(integerPart) * pow(10.0, Double(decimalPart))\n\
    \                                 ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5e_3hll5.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp5e_3hll5.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmp5e_3hll5.swift:11:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmp5e_3hll5.swift:11:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return truncate_number(number)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpq_gcjk5s.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpq_gcjk5s.swift:12:28:\
    \ error: missing argument label 'number:' in call\n    return truncate_number(number)\n\
    \                           ^\n                           number: \n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number).rounded(.towardZero)\n    return integerPart + decimalPart\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprq743bww.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmprq743bww.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmprq743bww.swift:10:46: error: cannot infer contextual base\
    \ in reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart < 0.5 ? 0 : 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpma327hnm.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpma327hnm.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n    return Double(integer) + Double(decimals)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdlu_f4zf.swift:9:31: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n    let integerPart = Double(number).truncatingRemainder(dividingBy: 1.0)\n\
    \    return Double(integerPart) / Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpsflu4t4w/tmpsflu4t4w.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab12d4e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab12d1dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab12d1db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab12d1da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsflu4t4w                        0x000055d52c4302f5 <unavailable> + 4853

    5    libc.so.6                          0x00002ab12d6d0460 __libc_start_main +
    245

    6    tmpsflu4t4w                        0x000055d52c42ff99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = Int(round(number))\n    let decimalPart\
    \ = number - Double(integerPart)\n    return Double(integerPart) / Double(10)\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptxnbkvve.swift:9:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart > 0 ? 1 : 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5e8p__n5.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp5e8p__n5.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart * pow(10, Double(log10(abs(number))))\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6k3m_djx.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp6k3m_djx.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmp6k3m_djx.swift:11:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(abs(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmp6k3m_djx.swift:11:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(abs(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcrva3k_f.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    let integerPart = floor(number)\n\
    \    return integerPart + fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpgd90o0nj.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpgd90o0nj.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = floor(number / pow(10.0, Double(decimalPart)))\n    return pow(10.0, Double(decimalPart))\
    \ * Double(integerPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp3r1izj3a.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp3r1izj3a.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp3r1izj3a.swift:10:23: error: cannot\
    \ find 'floor' in scope\n    let integerPart = floor(number / pow(10.0, Double(decimalPart)))\n\
    \                      ^~~~~\n/tmp/tmp3r1izj3a.swift:10:38: error: cannot find\
    \ 'pow' in scope\n    let integerPart = floor(number / pow(10.0, Double(decimalPart)))\n\
    \                                     ^~~\n/tmp/tmp3r1izj3a.swift:11:12: error:\
    \ cannot find 'pow' in scope\n    return pow(10.0, Double(decimalPart)) * Double(integerPart)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(trunc(number))\n    return\
    \ Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprlpkksxz.swift:9:30: error: cannot find 'trunc' in scope\n    let\
    \ decimalPart = Double(trunc(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpecl2agl5.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpecl2agl5.swift:12:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcrva3k_f.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpx92acuii.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpx92acuii.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpecl2agl5.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpecl2agl5.swift:12:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart < 0.5 ? 0 : 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpma327hnm.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpma327hnm.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, digits: 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpgqiv_ky_.swift:9:52: error: extra argument 'digits' in call\n \
    \   return truncate_number(number: number, digits: 1)\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * 10) / 10\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpy2zndb5k.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * 10) / 10\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, digits: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8sup4f0q.swift:9:52: error: extra argument 'digits' in call\n \
    \   return truncate_number(number: number, digits: 0)\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpx92acuii.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number / 1)\n    return integerPart * 1 + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptf7yz391.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmptf7yz391.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart < 0.5 ? 0 : 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpma327hnm.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpma327hnm.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart * pow(10, Double(log10(Double(abs(decimalPart)))\
    \ + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0jf4del5.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp0jf4del5.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmp0jf4del5.swift:11:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(abs(decimalPart)))\
    \ + 1))\n                         ^~~\n/tmp/tmp0jf4del5.swift:11:41: error: cannot\
    \ find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(abs(decimalPart)))\
    \ + 1))\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number).rounded(.towardZero)\n    return integerPart + decimalPart\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprq743bww.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmprq743bww.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmprq743bww.swift:10:46: error: cannot infer contextual base\
    \ in reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number - truncate_number(Double(number))\n\
    \    return Double(fraction)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5w8vqiww.swift:9:45: error: missing argument label 'number:' in\
    \ call\n    let fraction = number - truncate_number(Double(number))\n        \
    \                                    ^\n                                     \
    \       number: \n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n    return Double(integer) + Double(decimals)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdlu_f4zf.swift:9:31: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let result = Double(trunc(number))\n    if result <\
    \ number {\n        return result + 1.0\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph105_ex4.swift:9:25: error: cannot find 'trunc' in scope\n    let\
    \ result = Double(trunc(number))\n                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpx92acuii.swift:9:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, digits: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8sup4f0q.swift:9:52: error: extra argument 'digits' in call\n \
    \   return truncate_number(number: number, digits: 0)\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = Double.trunc(number)\n   \
    \ return Double(integer) + Double(decimal)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpvs4_rt0d.swift:9:37: error: type 'Double' has no member 'trunc'\n\
    \    let (integer, decimal) = Double.trunc(number)\n                         \
    \    ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number * 10).rounded(.towardZero)\n    return integerPart + decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5xl1sk0m.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp5xl1sk0m.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number * 10).rounded(.towardZero)\n             \
    \         ^~~~~\n/tmp/tmp5xl1sk0m.swift:10:51: error: cannot infer contextual\
    \ base in reference to member 'towardZero'\n    let integerPart = floor(number\
    \ * 10).rounded(.towardZero)\n                                               \
    \  ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number - truncate_number(Double(number))\n\
    \    return fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpg_48hkim.swift:9:45: error: missing argument label 'number:' in\
    \ call\n    let fraction = number - truncate_number(Double(number))\n        \
    \                                    ^\n                                     \
    \       number: \n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number).rounded(.towardZero)\n    return integerPart.rounded(.towardZero)\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph0fkgy3b.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmph0fkgy3b.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmph0fkgy3b.swift:10:46: error: cannot infer contextual base\
    \ in reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n/tmp/tmph0fkgy3b.swift:11:33:\
    \ error: cannot infer contextual base in reference to member 'towardZero'\n  \
    \  return integerPart.rounded(.towardZero) + decimalPart\n                   \
    \            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number) + 1)\n    let\
    \ integerPart = floor(number / pow(10.0, Double(decimalPart)))\n    return Double(integerPart)\
    \ / pow(10.0, Double(decimalPart))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpnttoxl85.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number) + 1)\n                      ^~~~~\n/tmp/tmpnttoxl85.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number)\
    \ + 1)\n                            ^~~~~\n/tmp/tmpnttoxl85.swift:10:23: error:\
    \ cannot find 'floor' in scope\n    let integerPart = floor(number / pow(10.0,\
    \ Double(decimalPart)))\n                      ^~~~~\n/tmp/tmpnttoxl85.swift:10:38:\
    \ error: cannot find 'pow' in scope\n    let integerPart = floor(number / pow(10.0,\
    \ Double(decimalPart)))\n                                     ^~~\n/tmp/tmpnttoxl85.swift:11:34:\
    \ error: cannot find 'pow' in scope\n    return Double(integerPart) / pow(10.0,\
    \ Double(decimalPart))\n                                 ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    let integerPart = Double(number).truncatingRemainder(dividingBy: Double(10).pow(Double(10)))\n\
    \    return Double(integerPart) / Double(10).pow(Double(10) - Double(decimalPart))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpip_twpo9.swift:10:81: error: value of type 'Double' has no member\
    \ 'pow'\n    let integerPart = Double(number).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(10)))\n                                              \
    \                       ~~~~~~~~~~ ^~~\n/tmp/tmpip_twpo9.swift:11:45: error: value\
    \ of type 'Double' has no member 'pow'\n    return Double(integerPart) / Double(10).pow(Double(10)\
    \ - Double(decimalPart))\n                                 ~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number) - 1\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjhxlljoa.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpjhxlljoa.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number) - 1\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    if number == 0 {\n        return 0.0\n    }\n    var decimalPart =\
    \ number % 1\n    if decimalPart < 0.5 {\n        return number\n    }\n    return\
    \ number - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8y36e1u1.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmp8y36e1u1.swift:15:30:\
    \ error: '%' is unavailable: For floating point numbers use truncatingRemainder\
    \ instead\n    var decimalPart = number % 1\n                             ^\n\
    Swift.%:2:13: note: '%' has been explicitly marked unavailable here\npublic func\
    \ % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart < 0.5 ? 0 : 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpma327hnm.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpma327hnm.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * pow(10, Double(trunc(log10(number)))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphqotroto.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * pow(10, Double(trunc(log10(number)))))\n           ^~~~~\n/tmp/tmphqotroto.swift:9:27:\
    \ error: cannot find 'pow' in scope\n    return floor(number * pow(10, Double(trunc(log10(number)))))\n\
    \                          ^~~\n/tmp/tmphqotroto.swift:9:42: error: cannot find\
    \ 'trunc' in scope\n    return floor(number * pow(10, Double(trunc(log10(number)))))\n\
    \                                         ^~~~~\n/tmp/tmphqotroto.swift:9:48:\
    \ error: cannot find 'log10' in scope\n    return floor(number * pow(10, Double(trunc(log10(number)))))\n\
    \                                               ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(number) - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpr75i9rlk/tmpr75i9rlk.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9797340c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9797037b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9797037988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97970367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr75i9rlk                        0x00005623d29422f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b979752c460 __libc_start_main +
    245

    6    tmpr75i9rlk                        0x00005623d2941f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart * pow(10, Double(log10(Double(abs(number)))))\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxw1vjwqb.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpxw1vjwqb.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpxw1vjwqb.swift:11:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(abs(number)))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpxw1vjwqb.swift:11:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(abs(number)))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimals) = truncate_number_helper(number)\n\
    \    return Double(integer) + Double(decimals)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp77dhlm_d.swift:9:31: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimals) = truncate_number_helper(number)\n   \
    \                           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, scale: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkqo7ot5i.swift:9:51: error: extra argument 'scale' in call\n  \
    \  return truncate_number(number: number, scale: 0)\n                        \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return number - fraction\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqqn0402p.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number).rounded(.towardZero)\n    return integerPart + decimalPart\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprq743bww.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmprq743bww.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmprq743bww.swift:10:46: error: cannot infer contextual base\
    \ in reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = Double(trunc(number))\n    return\
    \ number - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8jcf0oiy.swift:9:30: error: cannot find 'trunc' in scope\n    let\
    \ decimalPart = Double(trunc(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = floor(number)\n    let decimalPart\
    \ = number - integerPart\n    return decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp4cssi7k2.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029031
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + (decimalPart < 0.5 ? 0 : 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpma327hnm.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpma327hnm.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = floor(log10(number))\n    let integerPart\
    \ = number / pow(10.0, Double(decimalPart))\n    return integerPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp363yn9xr.swift:9:23: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = floor(log10(number))\n                      ^~~~~\n/tmp/tmp363yn9xr.swift:9:29:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = floor(log10(number))\n\
    \                            ^~~~~\n/tmp/tmp363yn9xr.swift:10:32: error: cannot\
    \ find 'pow' in scope\n    let integerPart = number / pow(10.0, Double(decimalPart))\n\
    \                               ^~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    return Double(number)\
    \ - fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpozckzg7v.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcy3ly39c.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    return Double(number)\
    \ - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1w00wc.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzd5ckxz.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpzzd5ckxz.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    return number - decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu9m5xz31.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n    return Double(integer) + Double(decimals)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdlu_f4zf.swift:9:31: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    let (integer, decimals) = truncate_number_with_precision(number:\
    \ number)\n                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = number % 1\n    let integerPart =\
    \ floor(number)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7c1ntdx_.swift:9:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7c1ntdx_.swift:10:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029055
