language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprja8vqew.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmprja8vqew.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmprja8vqew.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmprja8vqew.swift:19:53: note: candidate expects value of type\
    \ '(String) throws -> Bool' for parameter #1 (got 'Array<String>.Index?' (aka\
    \ 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmprja8vqew.swift:19:53: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_upper = class_name_components.filter { $0.isUppercase\
    \ }.count\n        let extension_components_count_lower = extension_components.filter\
    \ { $0.isLowercase }.count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let class_name_components_count_lower_large\
    \ = class_name_components_count_lower - class_name_components_count_upper_small\n\
    \        let extension_components_count_upper_large = extension_components_count_upper\
    \ - extension_components_count_lower_small\n        let class_name_components_count_upper_large_small\
    \ = class_name_components_count_upper_large - class_name_components_count_upper_small\n\
    \        let extension_components_count_upper_large_small_small = extension_components_count_upper_large_small\
    \ - extension_components_count_lower_small\n        let extension_components_count_upper_large_small_large\
    \ = extension_components_count_upper_large_small_small - extension_components_count_lower_large\n\
    \        let extension_components_count_upper_large_small_large_small = extension_components_count_upper_large_small_large\
    \ - extension_components_count_upper_large_small\n        let extension_components_count_upper_large_small_large_small_small\
    \ = extension_components_count_upper_large_small_large_small - extension_components_count_upper_large_small_small\n\
    \        let extension_components_count_upper_large_small_large_small_large =\
    \ extension_components_count_upper_large_small_large_small_small - extension_components_count_upper_large_small_large\n\
    \        let extension_components_count_upper_large_small_large_small_large_small\
    \ = extension_components_count_upper_large_small_large_small_large - extension_components_count_upper_large_small_large_small_small\n\
    \        let extension_components_count_upper_large_small_large_small_large_small_large\
    \ = extension_components_count_upper_large_small_large_small_large_small - extension_components_count_upper_large_small_large_small_large\n\
    \        let extension_components_count_upper_large_small_large_small_large_small_large\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ymkt_8b.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4ymkt_8b.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4ymkt_8b.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4ymkt_8b.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp4ymkt_8b.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp4ymkt_8b.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp4ymkt_8b.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp4ymkt_8b.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp4ymkt_8b.swift:63:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp4ymkt_8b.swift:18:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp4ymkt_8b.swift:43:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp4ymkt_8b.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_uppercase = class_name.uppercased()\n    var class_name_lowercase\
    \ = class_name.lowercased()\n    var class_name_length = class_name_uppercase.count\n\
    \    var extension_length = extensions.count\n    var extension_strength = extension_length\
    \ / class_name_length\n    var extension_strength_rounded = round(extension_strength)\n\
    \    var extension_strength_rounded_int = Int(extension_strength_rounded)\n  \
    \  var extension_strength_rounded_int_minus_1 = extension_strength_rounded - 1\n\
    \    var extension_strength_rounded_int_minus_2 = extension_strength_rounded -\
    \ 2\n    var extension_strength_rounded_int_minus_3 = extension_strength_rounded\
    \ - 3\n    var extension_strength_rounded_int_minus_4 = extension_strength_rounded\
    \ - 4\n    var extension_strength_rounded_int_minus_5 = extension_strength_rounded\
    \ - 5\n    var extension_strength_rounded_int_minus_6 = extension_strength_rounded\
    \ - 6\n    var extension_strength_rounded_int_minus_7 = extension_strength_rounded\
    \ - 7\n    var extension_strength_rounded_int_minus_8 = extension_strength_rounded\
    \ - 8\n    var extension_strength_rounded_int_minus_9 = extension_strength_rounded\
    \ - 9\n    var extension_strength_rounded_int_minus_10 = extension_strength_rounded\
    \ - 10\n    var extension_strength_rounded_int_minus_11 = extension_strength_rounded\
    \ - 11\n    var extension_strength_rounded_int_minus_12 = extension_strength_rounded\
    \ - 12\n    var extension_strength_rounded_int_minus_13 = extension_strength_rounded\
    \ - 13\n    var extension_strength_rounded_int_minus_14 = extension_strength_rounded\
    \ - 14\n    var extension_strength_rounded_int_minus_15 = extension_strength_rounded\
    \ - 15\n    var extension_strength_rounded_int_minus_16 = extension_strength_rounded\
    \ - 16\n    var extension_strength_rounded_int_minus_17 = extension_strength_rounded\
    \ - 17\n    var extension_strength_rounded_int_minus_18 = extension_strength_rounded\
    \ - 18\n    var extension_strength_rounded_int_minus_19 = extension_strength_rounded\
    \ - 19\n    var extension_strength_rounded_int_minus_20 = extension_strength_rounded\
    \ - 20\n    var extension_strength_rounded_int_minus_21 = extension_strength_rounded\
    \ - 21\n    var extension_strength_rounded_int_minus_22 = extension_strength_rounded\
    \ - \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnlm99v9e.swift:49:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpnlm99v9e.swift:25:38: error: cannot find 'round' in scope\n    var\
    \ extension_strength_rounded = round(extension_strength)\n                   \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_length = class_name.count\n    var extension_length = extensions.count\n\
    \    var strongest_extension_strength = -1\n    var extension_strength = -1\n\
    \    var extension_counter = 0\n    var class_name_counter = 0\n    var extension_counter\
    \ = 0\n    var class_name_length = class_name.count\n    var extension_length\
    \ = extensions.count\n    for extension in extensions {\n        class_name_counter\
    \ = class_name_length\n        extension_counter = extension_length\n        for\
    \ class_name in class_name {\n            if class_name_counter > extension_counter\
    \ {\n                class_name_counter = class_name_length - extension_counter\n\
    \            }\n            if class_name_counter == extension_counter {\n   \
    \             extension_strength = class_name_counter - extension_counter\n  \
    \              if extension_strength > strongest_extension_strength {\n      \
    \              strongest_extension_strength = extension_strength\n           \
    \         strongest_extension = class_name\n                }\n            }\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpll2ge2g7.swift:29:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpll2ge2g7.swift:29:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpll2ge2g7.swift:29:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpll2ge2g7.swift:26:9:\
    \ error: invalid redeclaration of 'extension_counter'\n    var extension_counter\
    \ = 0\n        ^\n/tmp/tmpll2ge2g7.swift:24:9: note: 'extension_counter' previously\
    \ declared here\n    var extension_counter = 0\n        ^\n/tmp/tmpll2ge2g7.swift:27:9:\
    \ error: invalid redeclaration of 'class_name_length'\n    var class_name_length\
    \ = class_name.count\n        ^\n/tmp/tmpll2ge2g7.swift:20:9: note: 'class_name_length'\
    \ previously declared here\n    var class_name_length = class_name.count\n   \
    \     ^\n/tmp/tmpll2ge2g7.swift:28:9: error: invalid redeclaration of 'extension_length'\n\
    \    var extension_length = extensions.count\n        ^\n/tmp/tmpll2ge2g7.swift:21:9:\
    \ note: 'extension_length' previously declared here\n    var extension_length\
    \ = extensions.count\n        ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let class_name_extension\
    \ = class_name + extension\n        let strength = class_name_extension.countUppercaseLetters()\
    \ - class_name_extension.countLowercaseLetters()\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = class_name_extension\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuk8aav1.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsuk8aav1.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsuk8aav1.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsuk8aav1.swift:22:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmpsuk8aav1.swift:22:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmpsuk8aav1.swift:23:9: error: expected type name\
    \ in extension declaration\n        let strength = class_name_extension.countUppercaseLetters()\
    \ - class_name_extension.countLowercaseLetters()\n        ^\n/tmp/tmpsuk8aav1.swift:22:58:\
    \ error: expected '{' in extension\n        let class_name_extension = class_name\
    \ + extension\n                                                         ^\n/tmp/tmpsuk8aav1.swift:22:49:\
    \ error: declaration is only valid at file scope\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpaw3uqsss.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpaw3uqsss.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpaw3uqsss.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpaw3uqsss.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpaw3uqsss.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpaw3uqsss.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_with_extension = class_name + extensions.joined(separator:\
    \ \".\")\n    \n    for extension in extensions {\n        let class_name_with_extension_lowercase\
    \ = class_name_with_extension.lowercased()\n        let class_name_with_extension_uppercase\
    \ = class_name_with_extension.uppercased()\n        let class_name_with_extension_lowercase_index\
    \ = class_name_with_extension_lowercase.index(class_name_with_extension_lowercase)\n\
    \        let class_name_with_extension_uppercase_index = class_name_with_extension_uppercase.index(class_name_with_extension_uppercase)\n\
    \        let class_name_with_extension_strength = class_name_with_extension_lowercase_index\
    \ - class_name_with_extension_uppercase_index\n        \n        if class_name_with_extension_strength\
    \ > 0 {\n            strongest_extension = class_name + extension\n          \
    \  break\n        }\n    }\n    \n    return strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6vuor8hf.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6vuor8hf.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6vuor8hf.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6vuor8hf.swift:30:48:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + extension\n                                               ^\n/tmp/tmp6vuor8hf.swift:31:13:\
    \ error: expected type name in extension declaration\n            break\n    \
    \        ^\n/tmp/tmp6vuor8hf.swift:30:57: error: expected '{' in extension\n \
    \           strongest_extension = class_name + extension\n                   \
    \                                     ^\n/tmp/tmp6vuor8hf.swift:30:48: error:\
    \ declaration is only valid at file scope\n            strongest_extension = class_name\
    \ + extension\n                                               ^\n/tmp/tmp6vuor8hf.swift:25:93:\
    \ error: no exact matches in call to instance method 'index'\n        let class_name_with_extension_lowercase_index\
    \ = class_name_with_extension_lowercase.index(class_name_with_extension_lowercase)\n\
    \                                                                            \
    \                ^\n/tmp/tmp6vuor8hf.swift:25:93: note: candidate expects value\
    \ of type 'String.Index' for parameter #1 (got 'String')\n        let class_name_with_extension_lowercase_index\
    \ = class_name_with_extension_lowercase.index(class_name_with_extension_lowercase)\n\
    \                                                                            \
    \                ^\n/tmp/tmp6vuor8hf.swift:25:93: note: candidate expects value\
    \ of type 'String.Index' for parameter #1 (got 'String')\n        let class_name_with_extension_lowercase_index\
    \ = class_name_with_extension_lowercase.index(class_name_with_extension_lowercase)\n\
    \                                                                            \
    \                ^\n/tmp/tmp6vuor8hf.swift:25:93: note: ca"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb7sb119.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjb7sb119.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpjb7sb119.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjb7sb119.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjb7sb119.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjb7sb119.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercased())\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp05z0bftn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp05z0bftn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp05z0bftn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp05z0bftn.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercased())\n                          \
    \                   ^\n/tmp/tmp05z0bftn.swift:22:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercased())\n                          \
    \                   ^\n                                             ;\n/tmp/tmp05z0bftn.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercased())\n                          \
    \                            ^\n                                             \
    \          <#type#>\n/tmp/tmp05z0bftn.swift:22:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercased())\n\
    \                                                      ^\n/tmp/tmp05z0bftn.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercased())\n                          \
    \                   ^\n/tmp/tmp05z0bftn.swift:25:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp05z0bftn.swift:26:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp05z0bftn.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp05z0b"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > 0 {\n            strongest_extension = class_name + extension\n \
    \       }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_nl3l7up.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_nl3l7up.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_nl3l7up.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_nl3l7up.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp_nl3l7up.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp_nl3l7up.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp_nl3l7up.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp_nl3l7up.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp_nl3l7up.swift:26:48:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + extension\n                                               ^\n/tmp/tmp_nl3l7up.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp_nl3l7up.swift:26:57:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + extension\n                                                        ^\n/tmp/tmp_nl3l7up.swift:26:48:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = class_name + extension\n                                               ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_upper = class_name.uppercased()\n\
    \    var class_name_lower = class_name.lowercased()\n    for extension in extensions\
    \ {\n        var extension_upper = extension.uppercased()\n        var extension_lower\
    \ = extension.lowercased()\n        var extension_strength = class_name_upper.distance(class_name_lower)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpp5ekxqlu.swift:23:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpp5ekxqlu.swift:23:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpp5ekxqlu.swift:23:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpp5ekxqlu.swift:24:31:\
    \ error: expected initial value after '='\n        var extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpp5ekxqlu.swift:24:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpp5ekxqlu.swift:24:40: error: expected type name in extension\
    \ declaration\n        var extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmpp5ekxqlu.swift:24:40: error: expected\
    \ '{' in extension\n        var extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmpp5ekxqlu.swift:24:31: error: declaration\
    \ is only valid at file scope\n        var extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpp5ekxqlu.swift:25:31: error: expected\
    \ initial value after '='\n        var extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmpp5ekxqlu.swift:25:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpp5ekxqlu.swift:25:40: error: expected type name in extension\
    \ declaration\n        var extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmpp5ekxqlu.swift:25:40: error: expected\
    \ '{' in extension\n        var extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmpp5ekxqlu.swift:25:31: error: declaration\
    \ is only valid at file scope\n        var extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6nc29jeg.swift:19:53: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)]\n                                                    ^\n/tmp/tmp6nc29jeg.swift:19:59:\
    \ error: extraneous argument label 'combine:' in call\n    return class_name +\
    \ \".\" + extensions[extensions.reduce(0, combine: max)]\n                   \
    \                                       ^   ~~~~~~~~~\n                      \
    \                                        \n/tmp/tmp6nc29jeg.swift:19:60: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String'\n    return\
    \ class_name + \".\" + extensions[extensions.reduce(0, combine: max)]\n      \
    \                                                     ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprwhui9bn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmprwhui9bn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmprwhui9bn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmprwhui9bn.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmprwhui9bn.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmprwhui9bn.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmprwhui9bn.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmprwhui9bn.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmprwhui9bn.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmprwhui9bn.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmprwhui9bn.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let extension_length = extension.count\n\
    \        let class_name_length = class_name.count\n        let extension_strength\
    \ = class_name_length / extension_length\n        if extension_strength > strongest_extension.count\
    \ {\n            strongest_extension = extension\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmvoo4yws.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmvoo4yws.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmvoo4yws.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmvoo4yws.swift:21:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpmvoo4yws.swift:21:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpmvoo4yws.swift:21:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpmvoo4yws.swift:21:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpmvoo4yws.swift:21:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpmvoo4yws.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmvoo4yws.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmvoo4yws.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmvoo4yws.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5272c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae526fb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae526fb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae526fb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae526fb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae526db6fc3 <unavailable> + 188355

    6    tmpz6eqy7qc                        0x000056404c7d27c8 <unavailable> + 10184

    7    tmpz6eqy7qc                        0x000056404c7d15a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ae5274ac460 __libc_start_main +
    245

    9    tmpz6eqy7qc                        0x000056404c7d11f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            strongest_extension = class_name\
    \ + \".\" + extension\n            break\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzn8de4v6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpzn8de4v6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpzn8de4v6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpzn8de4v6.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpzn8de4v6.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpzn8de4v6.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpzn8de4v6.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpzn8de4v6.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpzn8de4v6.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmpzn8de4v6.swift:27:13: error: expected type name in extension\
    \ declaration\n            break\n            ^\n/tmp/tmpzn8de4v6.swift:26:63:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + \".\" + extension\n                                                      \
    \        ^\n/tmp/tmpzn8de4v6.swift:26:54: error: declaration is only valid at\
    \ file scope\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest\
    \ = \"\"\n    for extension in extensions {\n        var count = 0\n        for\
    \ letter in extension {\n            if letter.isUpper() {\n                count\
    \ += 1\n            }\n        }\n        var strength = count - extension.count\n\
    \        if strength > 0 {\n            strongest = class_name + \".\" + extension\n\
    \        }\n    }\n    return strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpc86jswe7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpc86jswe7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpc86jswe7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpc86jswe7.swift:23:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpc86jswe7.swift:23:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmpc86jswe7.swift:28:32: error: expected expression\
    \ after operator\n        var strength = count - extension.count\n           \
    \                    ^\n/tmp/tmpc86jswe7.swift:28:31: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count - extension.count\n\
    \                              ^\n                              ;\n/tmp/tmpc86jswe7.swift:28:41:\
    \ error: expected type name in extension declaration\n        var strength = count\
    \ - extension.count\n                                        ^\n/tmp/tmpc86jswe7.swift:28:41:\
    \ error: expected '{' in extension\n        var strength = count - extension.count\n\
    \                                        ^\n/tmp/tmpc86jswe7.swift:28:32: error:\
    \ declaration is only valid at file scope\n        var strength = count - extension.count\n\
    \                               ^\n/tmp/tmpc86jswe7.swift:30:44: error: expected\
    \ expression after operator\n            strongest = class_name + \".\" + extension\n\
    \                                           ^\n/tmp/tmpc86jswe7.swift:31:9: error:\
    \ expected type name in extension declaration\n        }\n        ^\n/tmp/tmpc86jswe7.swift:30:53:\
    \ error: expected '{' in extension\n            strongest = class_name + \".\"\
    \ + extension\n                                                    ^\n/tmp/tmpc86jswe7.swift:30:44:\
    \ error: declaration is only valid at file scope\n            strongest = class_name\
    \ + \".\" + extension\n    "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1 // default value\n    for extension in extensions {\n\
    \        let cap = extension.count\n        let sm = class_name.count\n      \
    \  let strength_fraction = cap - sm\n        if strength_fraction > strength {\n\
    \            strongest_extension = extension\n            strength = strength_fraction\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpfv_4rt41.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpfv_4rt41.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpfv_4rt41.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpfv_4rt41.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpfv_4rt41.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpfv_4rt41.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpfv_4rt41.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpfv_4rt41.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpfv_4rt41.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpfv_4rt41.swift:27:22:\
    \ error: expected '{' in extension\n            strength = strength_fraction\n\
    \                     ^\n/tmp/tmpfv_4rt41.swift:26:35: error: declaration is only\
    \ valid at file scope\n            strongest_extension = extension\n         \
    \                         ^\n/tmp/tmpfv_4rt41.swift:27:13: error: cannot find\
    \ type 'strength' in scope\n            strength = strength_fraction\n       \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw63b9oi_.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmpw63b9oi_.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)].lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwwwvy7jl.swift:19:53: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)].lowercased()\n                                              \
    \      ^\n/tmp/tmpwwwvy7jl.swift:19:59: error: extraneous argument label 'combine:'\
    \ in call\n    return class_name + \".\" + extensions[extensions.reduce(0, combine:\
    \ max)].lowercased()\n                                                       \
    \   ^   ~~~~~~~~~\n                                                          \
    \    \n/tmp/tmpwwwvy7jl.swift:19:60: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String'\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)].lowercased()\n                                              \
    \             ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpaw3uqsss.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpaw3uqsss.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpaw3uqsss.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpaw3uqsss.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpaw3uqsss.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpaw3uqsss.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    let className\
    \ = class_name.lowercased()\n    var strongest = \"\"\n    for extension in extensions\
    \ {\n        let capitals = extension.lowercased().count\n        let lowercases\
    \ = extension.lowercased().count\n        let strength = capitals - lowercases\n\
    \        if strength > 0 {\n            strongest = String(format: \"%@.%@\",\
    \ className, extension)\n        }\n    }\n    return strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpovgd4sua.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpovgd4sua.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpovgd4sua.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpovgd4sua.swift:23:24:\
    \ error: expected initial value after '='\n        let capitals = extension.lowercased().count\n\
    \                       ^\n/tmp/tmpovgd4sua.swift:23:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let capitals = extension.lowercased().count\n\
    \                      ^\n                      ;\n/tmp/tmpovgd4sua.swift:23:33:\
    \ error: expected type name in extension declaration\n        let capitals = extension.lowercased().count\n\
    \                                ^\n/tmp/tmpovgd4sua.swift:23:33: error: expected\
    \ '{' in extension\n        let capitals = extension.lowercased().count\n    \
    \                            ^\n/tmp/tmpovgd4sua.swift:23:24: error: declaration\
    \ is only valid at file scope\n        let capitals = extension.lowercased().count\n\
    \                       ^\n/tmp/tmpovgd4sua.swift:24:26: error: expected initial\
    \ value after '='\n        let lowercases = extension.lowercased().count\n   \
    \                      ^\n/tmp/tmpovgd4sua.swift:24:25: error: consecutive statements\
    \ on a line must be separated by ';'\n        let lowercases = extension.lowercased().count\n\
    \                        ^\n                        ;\n/tmp/tmpovgd4sua.swift:24:35:\
    \ error: expected type name in extension declaration\n        let lowercases =\
    \ extension.lowercased().count\n                                  ^\n/tmp/tmpovgd4sua.swift:24:35:\
    \ error: expected '{' in extension\n        let lowercases = extension.lowercased().count\n\
    \                                  ^\n/tmp/tmpovgd4sua.swift:24:26: error: declaration\
    \ is only valid at file scope\n        let lowercases = extension.lowercased().count\n\
    \                         ^\n/tmp/tmpovgd4sua.swift:27:60: error: expected expr"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components[class_name_components.count\
    \ - 1]\n        let extension = extension_components[extension_components.count\
    \ - 1]\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_index = class_name_components.count - 1\n  \
    \      let extension_components_count_index = extension_components.count - 1\n\
    \        let class_name_components_count_index_minus_1 = class_name_components_count_index\
    \ - 1\n        let extension_components_count_index_minus_1 = extension_components_count_index\
    \ - 1\n        let class_name_components_count_minus_1 = class_name_components_count_index\
    \ - 1\n        let extension_components_count_minus_1 = extension_components_count_index\
    \ - 1\n        let class_name_components_count_minus_2 = class_name_components_count_index\
    \ - 2\n        let extension_components_count_minus_2 = extension_components_count_index\
    \ - 2\n        let class_name_components_count_minus_3 = class_name_components_count_index\
    \ - 3\n        let extension_components_count_minus_3 = extension_components_count_index\
    \ - 3\n        let class_name_components_count_minus_4 = class_name_components_count_index\
    \ - 4\n        let extension_components_count_minus_4 = extension_components_count_index\
    \ - 4\n        let class_name_components_count_minus_5 = class_name_components_count_index\
    \ - 5\n        let extension_components_count_minus_5 = extension_components_count_index\
    \ - 5\n        let class_name_components_count_minus_6 = class_name_components_count_index\
    \ - 6\n        let extension_components_count_minus_6 = extension_components_count_index\
    \ - 6\n        let class_name_components_count_minus_7 = class_name_components_count_index\
    \ - 7\n        let extension_components_count_minus_7 = extension_components_count_index\
    \ - 7\n        let class_name_components_count_minus_8 = class_name_components_count_index\
    \ - 8\n        let extension_components_count_minus_8 = extension_components_count_index\
    \ - 8\n        let class_name_components_count_minus_9 = class_name_components_count_index\
    \ - 9\n        let extension_components_count_minus_9 = extension_components_count_index\
    \ - 9\n        let class_name_components_count_minus_10 = class_name_components_count_index\
    \ - 10\n        let extension_components_count_minus_10 = extension_components_count_index\
    \ - 10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbpyz6ya.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmbpyz6ya.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmbpyz6ya.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmbpyz6ya.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpmbpyz6ya.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpmbpyz6ya.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpmbpyz6ya.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpmbpyz6ya.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpmbpyz6ya.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^\n/tmp/tmpmbpyz6ya.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^~~~~~~~~\n            `extension`\n/tmp/tmpmbpyz6ya.swift:74:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpmbpyz6ya.swift:18:78: note: to matc"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb7sb119.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjb7sb119.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpjb7sb119.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjb7sb119.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjb7sb119.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjb7sb119.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let extension_length = extension.count\n\
    \        let class_name_length = class_name.count\n        let extension_strength\
    \ = extension_length - class_name_length\n        let strength = extension_strength\
    \ / class_name_length\n        if strength > strongest_extension.count {\n   \
    \         strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn1wdag_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmn1wdag_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmn1wdag_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmn1wdag_.swift:21:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpmn1wdag_.swift:21:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpmn1wdag_.swift:21:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpmn1wdag_.swift:21:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpmn1wdag_.swift:21:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpmn1wdag_.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmn1wdag_.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmn1wdag_.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmn1wdag_.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + Strongest_Extension_Name(extensions)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2nmz8_md.swift:19:25: error: cannot find 'Strongest_Extension_Name'\
    \ in scope\n    return class_name + Strongest_Extension_Name(extensions)\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \     if strength > max_strength {\n            max_strength = strength\n    \
    \        strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcdcqggjd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcdcqggjd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpcdcqggjd.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpcdcqggjd.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpcdcqggjd.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpcdcqggjd.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpcdcqggjd.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.count\n        if extension_strength > max_strength {\n        \
    \    max_strength = extension_strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb9wu_9_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpfb9wu_9_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpfb9wu_9_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpfb9wu_9_.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpfb9wu_9_.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpfb9wu_9_.swift:22:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpfb9wu_9_.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpfb9wu_9_.swift:22:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpfb9wu_9_.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpfb9wu_9_.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpfb9wu_9_.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpfb9wu_9_.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_components = class_name.components(separatedBy: \".\")\n\
    \    var class_name_components_count = class_name_components.count\n    var extensions_count\
    \ = extensions.count\n    var extensions_components = extensions.components(separatedBy:\
    \ \".\")\n    var extensions_components_count = extensions_components.count\n\
    \    var extensions_components_array = [String]()\n    var extensions_components_array_count\
    \ = extensions_components.count\n    var extensions_components_array_index = -1\n\
    \    var extensions_components_array_index_count = 0\n    var extensions_components_array_index_count_minus_one\
    \ = 0\n    var extensions_components_array_index_count_minus_two = 0\n    var\
    \ extensions_components_array_index_count_minus_three = 0\n    var extensions_components_array_index_count_minus_four\
    \ = 0\n    var extensions_components_array_index_count_minus_five = 0\n    var\
    \ extensions_components_array_index_count_minus_six = 0\n    var extensions_components_array_index_count_minus_seven\
    \ = 0\n    var extensions_components_array_index_count_minus_eight = 0\n    var\
    \ extensions_components_array_index_count_minus_nine = 0\n    var extensions_components_array_index_count_minus_ten\
    \ = 0\n    var extensions_components_array_index_count_minus_eleven = 0\n    var\
    \ extensions_components_array_index_count_minus_twelve = 0\n    var extensions_components_array_index_count_minus_thirteen\
    \ = 0\n    var extensions_components_array_index_count_minus_fourteen = 0\n  \
    \  var extensions_components_array_index_count_minus_fifteen = 0\n    var extensions_components_array_index_count_minus_sixteen\
    \ = 0\n    var extensions_components_array_index_count_minus_seventeen = 0\n \
    \   var extensions_components_array_index_count_minus_eighteen = 0\n    var extensions_components_array_index_count_minus_nineteen\
    \ = 0\n    var extensions_components_array_index_count_minus_twenty = 0\n    var\
    \ extensions_components_array_index_count_minus_thirty = 0\n    var extensions_components_array_index_count_minus_forty\
    \ = 0\n    var extensions_components_array_index_count_minus_fifty = 0\n    var\
    \ extensions_components_array_index_count_minus_sixty = 0\n    var extensions_components_array_index_count_minus_seventy\
    \ = 0\n    var extensions_components_array_index_count_minus_eighty = 0\n    var\
    \ extensions_components_array_index_count_minus_ninety = 0\n    var extensions_components_array_index_count_minus_hundred\
    \ = 0\n    var extensions_components_array_index_count_minus_thousand\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxxvbw_7l.swift:20:44: error: value of type 'String' has no member\
    \ 'components'\n    var class_name_components = class_name.components(separatedBy:\
    \ \".\")\n                                ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpxxvbw_7l.swift:23:44:\
    \ error: value of type '[String]' has no member 'components'\n    var extensions_components\
    \ = extensions.components(separatedBy: \".\")\n                              \
    \  ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpxxvbw_7l.swift:57:9: error: type annotation\
    \ missing in pattern\n    var extensions_components_array_index_count_minus_thousand\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = Int()\n    for extension in extensions {\n        let extension_upper\
    \ = extension.uppercased()\n        let extension_lower = extension.lowercased()\n\
    \        let cap = extension_upper.count\n        let sm = extension_lower.count\n\
    \        let strength_fraction = cap - sm\n        strength = strength * strength_fraction\n\
    \        if strength > 0 {\n            strongest_extension = class_name + \"\
    .\" + extension\n        }\n    }\n    return strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcwi0hxah.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcwi0hxah.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcwi0hxah.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcwi0hxah.swift:22:31:\
    \ error: expected initial value after '='\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpcwi0hxah.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpcwi0hxah.swift:22:40: error: expected type name in extension\
    \ declaration\n        let extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmpcwi0hxah.swift:22:40: error: expected\
    \ '{' in extension\n        let extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmpcwi0hxah.swift:22:31: error: declaration\
    \ is only valid at file scope\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpcwi0hxah.swift:23:31: error: expected\
    \ initial value after '='\n        let extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmpcwi0hxah.swift:23:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpcwi0hxah.swift:23:40: error: expected type name in extension\
    \ declaration\n        let extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmpcwi0hxah.swift:23:40: error: expected\
    \ '{' in extension\n        let extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmpcwi0hxah.swift:23:31: error: declaration\
    \ is only valid at file scope\n        let extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \     if strength > max_strength {\n            max_strength = strength\n    \
    \        strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcdcqggjd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcdcqggjd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpcdcqggjd.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpcdcqggjd.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpcdcqggjd.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpcdcqggjd.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpcdcqggjd.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fzln87.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl6fzln87.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpl6fzln87.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpl6fzln87.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpl6fzln87.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpl6fzln87.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpl6fzln87.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpl6fzln87.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl6fzln87.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_name_components[0]\n\
    \        let extension = extension_components[0]\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_upper = class_name_components_count.filter\
    \ { $0.isUppercase }.count\n        let extension_components_count_upper = extension_components_count.filter\
    \ { $0.isUppercase }.count\n        let class_name_components_count_lower = class_name_components_count.filter\
    \ { $0.isLowercase }.count\n        let extension_components_count_lower = extension_components_count.filter\
    \ { $0.isLowercase }.count\n        let class_name_components_count_diff = class_name_components_count_upper\
    \ - class_name_components_count_lower\n        let extension_components_count_diff\
    \ = extension_components_count_upper - extension_components_count_lower\n    \
    \    let class_name_components_count_same_length = class_name_components_count_diff\
    \ == 0\n        let extension_components_count_same_length = extension_components_count_diff\
    \ == 0\n        let class_name_components_count_diff_length = class_name_components_count_diff\
    \ > 0\n        let extension_components_count_diff_length = extension_components_count_diff\
    \ > 0\n        let class_name_components_count_diff_length_upper = class_name_components_count_diff_length\
    \ && class_name_components_count_upper == class_name_components_count_lower\n\
    \        let extension_components_count_diff_length_upper = extension_components_count_diff_length\
    \ && extension_components_count_upper == extension_components_count_lower\n  \
    \      let class_name_components_count_diff_length_lower = class_name_components_count_diff_length\
    \ && class_name_components_count_lower == class_name_components_count_upper\n\
    \        let extension_components_count_diff_length_lower = extension_components_count_diff_length\
    \ && extension_components_count_lower == extension_components_count_upper\n  \
    \      let class_name_components_count_diff_length_diff = class_name_components_count_diff_length_upper\
    \ || class_name_components_count_diff_length_lower\n        let extension_components_count_diff_length_diff\
    \ = extension_components_count_diff_length_upper || extension_components_count_diff_length_lower\n\
    \        let class_name_components_count_diff_length_diff_upper = class_name_components_count_diff_length_diff\
    \ && class_name_components_count_upper == class_name_components_count_lower\n\
    \        let extension_components_count_diff_length_diff_upper = \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpk5t7iisk.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpk5t7iisk.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpk5t7iisk.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpk5t7iisk.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpk5t7iisk.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpk5t7iisk.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpk5t7iisk.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpk5t7iisk.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpk5t7iisk.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmpk5t7iisk.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpk5t7iisk.swift:45:64:\
    \ error: expected initial value after '='\n        let extension_components_count_diff_length_diff_upper\
    \ = \n                                                               ^\n/tmp/tmpk5t7iisk.swift:69:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.67"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            if strength > strength {\n    \
    \            strongest_extension = extension\n                strength = strength\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxdtmypo9.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxdtmypo9.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxdtmypo9.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxdtmypo9.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpxdtmypo9.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpxdtmypo9.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpxdtmypo9.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpxdtmypo9.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpxdtmypo9.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmpxdtmypo9.swift:28:26:\
    \ error: expected '{' in extension\n                strength = strength\n    \
    \                     ^\n/tmp/tmpxdtmypo9.swift:27:39: error: declaration is only\
    \ valid at file scope\n                strongest_extension = extension\n     \
    \                                 ^\n/tmp/tmpxdtmypo9.swift:28:17: error: cannot\
    \ find type 'strength' in scope\n                strength = strength\n       \
    \         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let extension_upper\
    \ = extension.uppercased()\n        let extension_lower = extension.lowercased()\n\
    \        let cap = extension_upper.count\n        let sm = extension_lower.count\n\
    \        let strength_fraction = cap - sm\n        if strength_fraction > strength\
    \ {\n            strongest_extension = class_name\n            strength = strength_fraction\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_5z0rq4.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl_5z0rq4.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl_5z0rq4.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl_5z0rq4.swift:22:31:\
    \ error: expected initial value after '='\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpl_5z0rq4.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpl_5z0rq4.swift:22:40: error: expected type name in extension\
    \ declaration\n        let extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmpl_5z0rq4.swift:22:40: error: expected\
    \ '{' in extension\n        let extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmpl_5z0rq4.swift:22:31: error: declaration\
    \ is only valid at file scope\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpl_5z0rq4.swift:23:31: error: expected\
    \ initial value after '='\n        let extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmpl_5z0rq4.swift:23:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpl_5z0rq4.swift:23:40: error: expected type name in extension\
    \ declaration\n        let extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmpl_5z0rq4.swift:23:40: error: expected\
    \ '{' in extension\n        let extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmpl_5z0rq4.swift:23:31: error: declaration\
    \ is only valid at file scope\n        let extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1 // default value\n    for extension in extensions {\n\
    \        let cap = extension.count\n        let sm = class_name.count\n      \
    \  let strength = cap - sm\n        if strength > strongest_extension.count {\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ykf_syx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_ykf_syx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_ykf_syx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_ykf_syx.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp_ykf_syx.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp_ykf_syx.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp_ykf_syx.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp_ykf_syx.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp_ykf_syx.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp_ykf_syx.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp_ykf_syx.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_ykf_syx.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > strongest_extension.count {\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp61gzj6vf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp61gzj6vf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp61gzj6vf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp61gzj6vf.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp61gzj6vf.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp61gzj6vf.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp61gzj6vf.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp61gzj6vf.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp61gzj6vf.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp61gzj6vf.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp61gzj6vf.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp61gzj6vf.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5272c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae526fb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae526fb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae526fb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae526fb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae526db6fc3 <unavailable> + 188355

    6    tmpz6eqy7qc                        0x000056404c7d27c8 <unavailable> + 10184

    7    tmpz6eqy7qc                        0x000056404c7d15a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ae5274ac460 __libc_start_main +
    245

    9    tmpz6eqy7qc                        0x000056404c7d11f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: +)].lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpodxfgwlx.swift:19:59: error: extraneous argument label 'combine:'\
    \ in call\n    return class_name + \".\" + extensions[extensions.reduce(0, combine:\
    \ +)].lowercased()\n                                                         \
    \ ^   ~~~~~~~~~\n                                                            \
    \  \n/tmp/tmpodxfgwlx.swift:19:72: error: cannot convert value of type '(Int)\
    \ -> Int' to expected argument type '(Int, String) throws -> Int'\n    return\
    \ class_name + \".\" + extensions[extensions.reduce(0, combine: +)].lowercased()\n\
    \                                                                       ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fzln87.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl6fzln87.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpl6fzln87.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpl6fzln87.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpl6fzln87.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpl6fzln87.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpl6fzln87.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpl6fzln87.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl6fzln87.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw63b9oi_.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmpw63b9oi_.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let extension_upper\
    \ = extension.uppercased()\n        let extension_lower = extension.lowercased()\n\
    \        let extension_length = extension_upper.count - extension_lower.count\n\
    \        let extension_strength = extension_upper.count - extension_lower.count\n\
    \        if strength < extension_strength {\n            strongest_extension =\
    \ extension\n            strength = extension_strength\n        }\n    }\n   \
    \ return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm4bd5pl7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm4bd5pl7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm4bd5pl7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm4bd5pl7.swift:22:31:\
    \ error: expected initial value after '='\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpm4bd5pl7.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpm4bd5pl7.swift:22:40: error: expected type name in extension\
    \ declaration\n        let extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmpm4bd5pl7.swift:22:40: error: expected\
    \ '{' in extension\n        let extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmpm4bd5pl7.swift:22:31: error: declaration\
    \ is only valid at file scope\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmpm4bd5pl7.swift:23:31: error: expected\
    \ initial value after '='\n        let extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmpm4bd5pl7.swift:23:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmpm4bd5pl7.swift:23:40: error: expected type name in extension\
    \ declaration\n        let extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmpm4bd5pl7.swift:23:40: error: expected\
    \ '{' in extension\n        let extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmpm4bd5pl7.swift:23:31: error: declaration\
    \ is only valid at file scope\n        let extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let strength\
    \ = extension.countUpToLowercaseLetters()\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3egwqkwz.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3egwqkwz.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3egwqkwz.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3egwqkwz.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3egwqkwz.swift:22:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmp3egwqkwz.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3egwqkwz.swift:22:33: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3egwqkwz.swift:22:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3egwqkwz.swift:25:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp3egwqkwz.swift:26:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp3egwqkwz.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3egwqkwz.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var max_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > max_strength {\n            max_strength = extension_strength\n          \
    \  strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg1n3zmpp.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg1n3zmpp.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg1n3zmpp.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg1n3zmpp.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg1n3zmpp.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg1n3zmpp.swift:23:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg1n3zmpp.swift:23:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg1n3zmpp.swift:23:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg1n3zmpp.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg1n3zmpp.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg1n3zmpp.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg1n3zmpp.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_lowercase = class_name.lowercased()\n    var extensions_lowercase\
    \ = extensions.lowercased()\n    var class_name_length = class_name_lowercase.length\n\
    \    var extensions_length = extensions_lowercase.length\n    var strongest_extension_length\
    \ = class_name_length - extensions_length\n    var strength = -1\n    var extension_index\
    \ = 0\n    var extension_strength = -1\n    var extension_found = false\n    for\
    \ extension in extensions {\n        extension_found = false\n        for index\
    \ in 0..<extensions_length {\n            if extensions_lowercase[index] == extension\
    \ {\n                extension_strength = extension.lowercased().count - extension.lowercased().lowercased().count\n\
    \                if strength < extension_strength {\n                    strength\
    \ = extension_strength\n                    extension_index = index\n        \
    \            extension_found = true\n                }\n            }\n      \
    \  }\n        if !extension_found {\n            extension_strength = extension.lowercased().count\n\
    \            if strength < extension_strength {\n                strength = extension_strength\n\
    \                extension_index = extensions_length\n                extension_found\
    \ = true\n            }\n        }\n    }\n    if strength == -1 {\n        return\
    \ class_name\n    }\n    if extension_index == 0 {\n        return class_name\
    \ + \".\" + extensions[extension_index]\n    }\n    if extension_index == extensions_length\
    \ {\n        return class_name + \".\" + extensions[extension_index - 1]\n   \
    \ }\n    return class_name + \".\" + extensions[extension_index] + \".\" + extensions[extension_index\
    \ - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpno276ulq.swift:29:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpno276ulq.swift:29:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpno276ulq.swift:29:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpno276ulq.swift:32:47:\
    \ error: expected expression after operator\n            if extensions_lowercase[index]\
    \ == extension {\n                                              ^\n/tmp/tmpno276ulq.swift:32:57:\
    \ error: expected type name in extension declaration\n            if extensions_lowercase[index]\
    \ == extension {\n                                                        ^\n\
    /tmp/tmpno276ulq.swift:33:17: error: expected 'var' keyword in property declaration\n\
    \                extension_strength = extension.lowercased().count - extension.lowercased().lowercased().count\n\
    \                ^\n                var \n/tmp/tmpno276ulq.swift:33:38: error:\
    \ expected initial value after '='\n                extension_strength = extension.lowercased().count\
    \ - extension.lowercased().lowercased().count\n                              \
    \       ^\n/tmp/tmpno276ulq.swift:33:37: error: consecutive declarations on a\
    \ line must be separated by ';'\n                extension_strength = extension.lowercased().count\
    \ - extension.lowercased().lowercased().count\n                              \
    \      ^\n                                    ;\n/tmp/tmpno276ulq.swift:33:47:\
    \ error: expected type name in extension declaration\n                extension_strength\
    \ = extension.lowercased().count - extension.lowercased().lowercased().count\n\
    \                                              ^\n/tmp/tmpno276ulq.swift:33:47:\
    \ error: expected '{' in extension\n                extension_strength = extension.lowercased().count\
    \ - extension.lowercased().lowercased().count\n                              \
    \                ^\n/tmp/tmpno276ulq.swift:33:38: error: declaration is only valid\
    \ at file scope\n                extension_strength = extension.lo"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.isEmpty {\n   \
    \     return class_name\n    }\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgz2h5lu8.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgz2h5lu8.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgz2h5lu8.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgz2h5lu8.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpgz2h5lu8.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpgz2h5lu8.swift:25:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpgz2h5lu8.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpgz2h5lu8.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpgz2h5lu8.swift:28:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpgz2h5lu8.swift:29:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpgz2h5lu8.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpgz2h5lu8.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > strongest_extension.count {\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp61gzj6vf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp61gzj6vf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp61gzj6vf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp61gzj6vf.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp61gzj6vf.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp61gzj6vf.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp61gzj6vf.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp61gzj6vf.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp61gzj6vf.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp61gzj6vf.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp61gzj6vf.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp61gzj6vf.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.isEmpty {\n   \
    \     return class_name\n    }\n    var strongest_extension = \"\"\n    var max_strength\
    \ = -1\n    for extension in extensions {\n        let strength = extension.countUpToLowercaseLetters()\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ygnauv8.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2ygnauv8.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2ygnauv8.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2ygnauv8.swift:25:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp2ygnauv8.swift:25:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmp2ygnauv8.swift:25:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp2ygnauv8.swift:25:33: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp2ygnauv8.swift:25:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp2ygnauv8.swift:28:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp2ygnauv8.swift:29:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp2ygnauv8.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp2ygnauv8.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        if\
    \ extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy22805_a.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy22805_a.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy22805_a.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy22805_a.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpy22805_a.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpy22805_a.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpy22805_a.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpy22805_a.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let strength\
    \ = extension.countUpToLowercaseLetters()\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3egwqkwz.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3egwqkwz.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3egwqkwz.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3egwqkwz.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3egwqkwz.swift:22:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmp3egwqkwz.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3egwqkwz.swift:22:33: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3egwqkwz.swift:22:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3egwqkwz.swift:25:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp3egwqkwz.swift:26:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp3egwqkwz.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3egwqkwz.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1qh6qu_p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1qh6qu_p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp1qh6qu_p.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp1qh6qu_p.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp1qh6qu_p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp1qh6qu_p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.isEmpty {\n   \
    \     return class_name\n    }\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpi64w3hbg.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpi64w3hbg.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpi64w3hbg.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpi64w3hbg.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpi64w3hbg.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpi64w3hbg.swift:25:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpi64w3hbg.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpi64w3hbg.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpi64w3hbg.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpi64w3hbg.swift:28:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpi64w3hbg.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpi64w3hbg.swift:28:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4mqxw7w7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4mqxw7w7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4mqxw7w7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4mqxw7w7.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp4mqxw7w7.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp4mqxw7w7.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp4mqxw7w7.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp4mqxw7w7.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp4mqxw7w7.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp4mqxw7w7.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp4mqxw7w7.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp4mqxw7w7.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let extension_upper\
    \ = extension.uppercased()\n        let extension_lower = extension.lowercased()\n\
    \        let extension_length = extension_upper.count - extension_lower.count\n\
    \        let extension_strength = extension_upper.count - extension_lower.count\n\
    \        if strength == -1 || strength > extension_strength {\n            strongest_extension\
    \ = class_name\n            strength = extension_strength\n        } else if strength\
    \ == extension_strength {\n            if extension_length < strongest_extension.count\
    \ {\n                strongest_extension = class_name\n                strength\
    \ = extension_strength\n            }\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7_tvdn8x.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7_tvdn8x.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7_tvdn8x.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7_tvdn8x.swift:22:31:\
    \ error: expected initial value after '='\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmp7_tvdn8x.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmp7_tvdn8x.swift:22:40: error: expected type name in extension\
    \ declaration\n        let extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmp7_tvdn8x.swift:22:40: error: expected\
    \ '{' in extension\n        let extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmp7_tvdn8x.swift:22:31: error: declaration\
    \ is only valid at file scope\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmp7_tvdn8x.swift:23:31: error: expected\
    \ initial value after '='\n        let extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmp7_tvdn8x.swift:23:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmp7_tvdn8x.swift:23:40: error: expected type name in extension\
    \ declaration\n        let extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmp7_tvdn8x.swift:23:40: error: expected\
    \ '{' in extension\n        let extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmp7_tvdn8x.swift:23:31: error: declaration\
    \ is only valid at file scope\n        let extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + Strongest_Extension_Name(extensions)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2nmz8_md.swift:19:25: error: cannot find 'Strongest_Extension_Name'\
    \ in scope\n    return class_name + Strongest_Extension_Name(extensions)\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb7sb119.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjb7sb119.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpjb7sb119.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjb7sb119.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjb7sb119.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjb7sb119.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0)\
    \ { $0 + $1.count }].sorted().first!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptpxesrwz.swift:19:41: error: no exact matches in call to subscript\
    \ \n    return class_name + \".\" + extensions[extensions.reduce(0) { $0 + $1.count\
    \ }].sorted().first!\n                                        ^\nSwift.String:2:35:\
    \ note: candidate expects value of type 'String' for parameter #2 (got 'String.Element'\
    \ (aka 'Character'))\n    @inlinable public static func + (lhs: String, rhs: String)\
    \ -> String\n                                  ^\nSwift.Array:17:23: note: candidate\
    \ expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:3:23: note: candidate expects value of\
    \ type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        if\
    \ extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy22805_a.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy22805_a.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy22805_a.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy22805_a.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpy22805_a.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpy22805_a.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpy22805_a.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpy22805_a.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpy22805_a.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fzln87.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl6fzln87.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpl6fzln87.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpl6fzln87.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpl6fzln87.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpl6fzln87.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpl6fzln87.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpl6fzln87.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl6fzln87.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strength = -1\n    for extension in extensions {\n        let\
    \ cap = extension.count\n        let sm = class_name.count\n        let strength\
    \ = cap - sm\n        if strength > strongest_extension.count {\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp829bk5_v.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp829bk5_v.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp829bk5_v.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp829bk5_v.swift:23:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp829bk5_v.swift:23:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp829bk5_v.swift:23:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp829bk5_v.swift:23:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp829bk5_v.swift:23:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp829bk5_v.swift:27:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp829bk5_v.swift:28:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp829bk5_v.swift:27:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp829bk5_v.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5272c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae526fb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae526fb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae526fb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae526fb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae526db6fc3 <unavailable> + 188355

    6    tmpz6eqy7qc                        0x000056404c7d27c8 <unavailable> + 10184

    7    tmpz6eqy7qc                        0x000056404c7d15a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ae5274ac460 __libc_start_main +
    245

    9    tmpz6eqy7qc                        0x000056404c7d11f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let strength\
    \ = class_name.characters.filter({ $0.isUppercase }).count - class_name.characters.filter({\
    \ $0.isLowercase }).count\n        if strength > max_strength {\n            max_strength\
    \ = strength\n            strongest_extension = extension\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpguwk9b6g.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpguwk9b6g.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpguwk9b6g.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpguwk9b6g.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpguwk9b6g.swift:26:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpguwk9b6g.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpguwk9b6g.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpguwk9b6g.swift:22:35: error: 'characters'\
    \ is unavailable: Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpguwk9b6g.swift:22:92: error: 'characters' is unavailable:\
    \ Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw63b9oi_.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmpw63b9oi_.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4mqxw7w7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4mqxw7w7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4mqxw7w7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4mqxw7w7.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp4mqxw7w7.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp4mqxw7w7.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp4mqxw7w7.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp4mqxw7w7.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp4mqxw7w7.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp4mqxw7w7.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp4mqxw7w7.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp4mqxw7w7.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        var class_name_extension\
    \ = class_name\n        for character in extension {\n            if character\
    \ == character.lowercased() {\n                class_name_extension = class_name_extension.lowercased()\n\
    \            }\n        }\n        if class_name_extension.hasPrefix(class_name.lowercased())\
    \ {\n            var class_name_extension_split = class_name_extension.components(separatedBy:\
    \ \".\")\n            var class_name_extension_split_count = class_name_extension_split.count\n\
    \            var class_name_extension_split_index = class_name_extension_split_count\
    \ - 1\n            var class_name_extension_split_last_index = class_name_extension_split_count\
    \ - 1\n            var class_name_extension_split_last_index_value = class_name_extension_split[class_name_extension_split_last_index].lowercased()\n\
    \            var class_name_extension_split_last_index_value_count = class_name_extension_split_last_index_value.count\n\
    \            var class_name_extension_split_last_index_value_index = class_name_extension_split_last_index_value_count\
    \ - 1\n            var class_name_extension_split_last_index_value_index_value\
    \ = class_name_extension_split_last_index_value[class_name_extension_split_last_index_value_index].lowercased()\n\
    \            var class_name_extension_split_last_index_value_index_value_count\
    \ = class_name_extension_split_last_index_value_index_value.count\n          \
    \  var class_name_extension_split_last_index_value_index_value_index = class_name_extension_split_last_index_value_index_value_count\
    \ - 1\n            var class_name_extension_split_last_index_value_index_value_index_value\
    \ = class_name_extension_split_last_index_value_index_value[class_name_extension_split_last_index_value_index_value_index].lowercased()\n\
    \            var class_name_extension_split_last_index_value_index_value_index_value_count\
    \ = class_name_extension_split_last_index_value_index_value_index_value.count\n\
    \            var class_name_extension_split_last_index_value_index_value_index_value_index\
    \ = class_name_extension_split_last_index_value_index_value_index_value_count\
    \ - 1\n            var class_name_extension_split_last_index_value_index_value_index_value_index_value\
    \ = class_name_extension_split_last_index_value_index_value_index_value[class_name_extension_split_last_index_value_index_value_index_value_index].lowercased()\n\
    \            var class_name_extension_split_last_index_value_index_value_index_value_index_value_count\
    \ = class_name_extension_split_last_index_value_index_value_index_value_index_value.count\n\
    \            var class_name_extension_split_last_index_value_index_value_index_value_index_value_index\
    \ = class_name_extension_split_last_index_value_index_value_index_value_index_value_count\
    \ - 1\n            var class_name_extension_split_last_index_value_index_value_index_value_index_value_index_value\
    \ = class_name_extension_split_last_index_value\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpukyaiokm.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpukyaiokm.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpukyaiokm.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpukyaiokm.swift:23:26:\
    \ error: expected Sequence expression for for-each loop\n        for character\
    \ in extension {\n                         ^\n/tmp/tmpukyaiokm.swift:23:26: error:\
    \ expected '{' to start the body of for-each loop\n        for character in extension\
    \ {\n                         ^\n/tmp/tmpukyaiokm.swift:69:91: error: expected\
    \ '}' at end of brace statement\nassert(Strongest_Extension(class_name: \"Sp\"\
    , extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n                      \
    \                                                                    ^\n/tmp/tmpukyaiokm.swift:21:33:\
    \ note: to match this opening '{'\n    for extension in extensions {\n       \
    \                         ^\n/tmp/tmpukyaiokm.swift:69:91: error: expected '}'\
    \ at end of brace statement\nassert(Strongest_Extension(class_name: \"Sp\", extensions:\
    \ [\"671235\", \"Bb\"]) == \"Sp.671235\")\n                                  \
    \                                                        ^\n/tmp/tmpukyaiokm.swift:18:78:\
    \ note: to match this opening '{'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n                                        \
    \                                     ^\n/tmp/tmpukyaiokm.swift:29:67: error:\
    \ value of type 'String' has no member 'components'\n            var class_name_extension_split\
    \ = class_name_extension.components(separatedBy: \".\")\n                    \
    \                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fzln87.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl6fzln87.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpl6fzln87.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpl6fzln87.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpl6fzln87.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpl6fzln87.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpl6fzln87.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpl6fzln87.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl6fzln87.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            strongest_extension = class_name\
    \ + \".\" + extension\n        }\n    }\n    return strongest_extension\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvt8mf2j.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxvt8mf2j.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxvt8mf2j.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxvt8mf2j.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpxvt8mf2j.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpxvt8mf2j.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpxvt8mf2j.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpxvt8mf2j.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpxvt8mf2j.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmpxvt8mf2j.swift:27:9: error: expected type name in extension\
    \ declaration\n        }\n        ^\n/tmp/tmpxvt8mf2j.swift:26:63: error: expected\
    \ '{' in extension\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                              ^\n/tmp/tmpxvt8mf2j.swift:26:54:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = class_name + \".\" + extension\n                                         \
    \            ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprwhui9bn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmprwhui9bn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmprwhui9bn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmprwhui9bn.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmprwhui9bn.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmprwhui9bn.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmprwhui9bn.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmprwhui9bn.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmprwhui9bn.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmprwhui9bn.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmprwhui9bn.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let strength\
    \ = class_name.components(separatedBy: extension.lowercased()).count\n       \
    \ if strength > max_strength {\n            max_strength = strength\n        \
    \    strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1overkkn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1overkkn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1overkkn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1overkkn.swift:22:59:\
    \ error: expected expression in list of expressions\n        let strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \              ^\n/tmp/tmp1overkkn.swift:22:58: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \             ^\n                                                         ;\n\
    /tmp/tmp1overkkn.swift:22:68: error: expected type name in extension declaration\n\
    \        let strength = class_name.components(separatedBy: extension.lowercased()).count\n\
    \                                                                   ^\n/tmp/tmp1overkkn.swift:22:68:\
    \ error: expected '{' in extension\n        let strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \                       ^\n/tmp/tmp1overkkn.swift:22:59: error: declaration is\
    \ only valid at file scope\n        let strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \              ^\n/tmp/tmp1overkkn.swift:25:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1overkkn.swift:26:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1overkkn.swift:25:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1overkkn.swift:25:35: error:\
    \ declaration is only valid at file scope\n    "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpogkamb9k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpogkamb9k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpogkamb9k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpogkamb9k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpogkamb9k.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpogkamb9k.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpogkamb9k.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpogkamb9k.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpogkamb9k.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpogkamb9k.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpogkamb9k.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpaw3uqsss.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpaw3uqsss.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpaw3uqsss.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpaw3uqsss.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpaw3uqsss.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpaw3uqsss.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpaw3uqsss.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpaw3uqsss.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpaw3uqsss.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + Strongest_Extension(extensions)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzpriahu4.swift:19:45: error: missing argument label 'class_name:'\
    \ in call\n    return class_name + Strongest_Extension(extensions)\n         \
    \                                   ^\n                                      \
    \      class_name: \n/tmp/tmpzpriahu4.swift:19:55: error: missing argument for\
    \ parameter 'extensions' in call\n    return class_name + Strongest_Extension(extensions)\n\
    \                                                      ^\n                   \
    \                                   , extensions: <#[String]#>\n/tmp/tmpzpriahu4.swift:18:6:\
    \ note: 'Strongest_Extension(class_name:extensions:)' declared here\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n     ^\n/tmp/tmpzpriahu4.swift:19:45:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return class_name + Strongest_Extension(extensions)\n                   \
    \                         ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            strongest_extension = class_name\
    \ + \".\" + extension\n            break\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzn8de4v6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpzn8de4v6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpzn8de4v6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpzn8de4v6.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpzn8de4v6.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpzn8de4v6.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpzn8de4v6.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpzn8de4v6.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpzn8de4v6.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmpzn8de4v6.swift:27:13: error: expected type name in extension\
    \ declaration\n            break\n            ^\n/tmp/tmpzn8de4v6.swift:26:63:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + \".\" + extension\n                                                      \
    \        ^\n/tmp/tmpzn8de4v6.swift:26:54: error: declaration is only valid at\
    \ file scope\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: +)].lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpodxfgwlx.swift:19:59: error: extraneous argument label 'combine:'\
    \ in call\n    return class_name + \".\" + extensions[extensions.reduce(0, combine:\
    \ +)].lowercased()\n                                                         \
    \ ^   ~~~~~~~~~\n                                                            \
    \  \n/tmp/tmpodxfgwlx.swift:19:72: error: cannot convert value of type '(Int)\
    \ -> Int' to expected argument type '(Int, String) throws -> Int'\n    return\
    \ class_name + \".\" + extensions[extensions.reduce(0, combine: +)].lowercased()\n\
    \                                                                       ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = class_name\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp76cmn3ah.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp76cmn3ah.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp76cmn3ah.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp76cmn3ah.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp76cmn3ah.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp76cmn3ah.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp76cmn3ah.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp76cmn3ah.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.isEmpty {\n   \
    \     return class_name\n    }\n    var max_strength = -1\n    var max_extension\
    \ = \"\"\n    for extension in extensions {\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           max_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + max_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6oqqinvz.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6oqqinvz.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6oqqinvz.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6oqqinvz.swift:28:29:\
    \ error: expected expression in assignment\n            max_extension = extension\n\
    \                            ^\n/tmp/tmp6oqqinvz.swift:29:9: error: expected type\
    \ name in extension declaration\n        }\n        ^\n/tmp/tmp6oqqinvz.swift:28:38:\
    \ error: expected '{' in extension\n            max_extension = extension\n  \
    \                                   ^\n/tmp/tmp6oqqinvz.swift:28:29: error: declaration\
    \ is only valid at file scope\n            max_extension = extension\n       \
    \                     ^\n/tmp/tmp6oqqinvz.swift:25:35: error: 'characters' is\
    \ unavailable: Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6oqqinvz.swift:25:92: error: 'characters' is unavailable:\
    \ Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            strongest_extension = class_name\
    \ + extension\n            break\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbsf1xmgy.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbsf1xmgy.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbsf1xmgy.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbsf1xmgy.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpbsf1xmgy.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpbsf1xmgy.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpbsf1xmgy.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpbsf1xmgy.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpbsf1xmgy.swift:26:48:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + extension\n                                               ^\n/tmp/tmpbsf1xmgy.swift:27:13:\
    \ error: expected type name in extension declaration\n            break\n    \
    \        ^\n/tmp/tmpbsf1xmgy.swift:26:57: error: expected '{' in extension\n \
    \           strongest_extension = class_name + extension\n                   \
    \                                     ^\n/tmp/tmpbsf1xmgy.swift:26:48: error:\
    \ declaration is only valid at file scope\n            strongest_extension = class_name\
    \ + extension\n                                               ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw63b9oi_.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmpw63b9oi_.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    \n   \
    \ return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpzfbm71n4/tmpzfbm71n4.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f0d80fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f0d506b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f0d506988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f0d5057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfbm71n4                        0x0000555d964c24fd <unavailable> + 5373

    5    libc.so.6                          0x00002b8f0d9fb460 __libc_start_main +
    245

    6    tmpzfbm71n4                        0x0000555d964c2089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0)\
    \ { $0 + $1.countByLetter().max() }]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgp3hwkvk.swift:19:73: error: value of type 'String' has no member\
    \ 'countByLetter'\n    return class_name + \".\" + extensions[extensions.reduce(0)\
    \ { $0 + $1.countByLetter().max() }]\n                                       \
    \                              ~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var extension_strength\
    \ = extension.count\n        for c in extension {\n            if c >= 'A' &&\
    \ c <= 'Z' {\n                extension_strength -= 1 \n            }\n      \
    \      if c >= 'a' && c <= 'z' {\n                extension_strength -= 1\n  \
    \          }\n        }\n        if extension_strength > max_strength {\n    \
    \        max_strength = extension_strength\n            strongest_extension =\
    \ extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr5_fvyub.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr5_fvyub.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr5_fvyub.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr5_fvyub.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr5_fvyub.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpr5_fvyub.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpr5_fvyub.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpr5_fvyub.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr5_fvyub.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpr5_fvyub.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpr5_fvyub.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpr5_fvyub.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpr5_fvyub.swift:27:21: error: single-quoted string literal\
    \ found, use '\"'\n            if c >= 'a' && c <= 'z' {\n                   \
    \ ^~~\n                    \"a\"\n/tmp/tmpr5_fvyub.swift:27:33: error: single-quote"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    \n   \
    \ return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpzfbm71n4/tmpzfbm71n4.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f0d80fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f0d506b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f0d506988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f0d5057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfbm71n4                        0x0000555d964c24fd <unavailable> + 5373

    5    libc.so.6                          0x00002b8f0d9fb460 __libc_start_main +
    245

    6    tmpzfbm71n4                        0x0000555d964c2089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let cap = extension.count\n     \
    \   let sm = class_name.count\n        let strength = cap - sm\n        if strength\
    \ > 0 {\n            if strongest_extension == \"\" {\n                strongest_extension\
    \ = class_name + extension\n            } else {\n                if strength\
    \ < strongest_extension.count {\n                    strongest_extension = class_name\
    \ + extension\n                }\n            }\n        }\n    }\n    return\
    \ strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw3amnli4.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw3amnli4.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw3amnli4.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw3amnli4.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpw3amnli4.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpw3amnli4.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpw3amnli4.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpw3amnli4.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpw3amnli4.swift:26:52:\
    \ error: expected expression after operator\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmpw3amnli4.swift:27:13: error: expected type name in extension declaration\n\
    \            } else {\n            ^\n/tmp/tmpw3amnli4.swift:26:61: error: expected\
    \ '{' in extension\n                strongest_extension = class_name + extension\n\
    \                                                            ^\n/tmp/tmpw3amnli4.swift:26:52:\
    \ error: declaration is only valid at file scope\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmpw3amnli4.swift:29:56: error: expected expression after operator\n\
    \                    strongest_extension = class_name + extension\n          \
    \                                             ^\n/tmp/tmpw3amnli4.swift:30:17:\
    \ error: expected type name in extension declaration\n                }\n    \
    \            ^\n/tmp/tmpw3amnl"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb7sb119.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjb7sb119.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpjb7sb119.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjb7sb119.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjb7sb119.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjb7sb119.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            if strength > strongest_extension.count\
    \ {\n                strongest_extension = extension\n            }\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpfuahbqbe.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpfuahbqbe.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpfuahbqbe.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpfuahbqbe.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpfuahbqbe.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpfuahbqbe.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpfuahbqbe.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpfuahbqbe.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpfuahbqbe.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmpfuahbqbe.swift:28:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmpfuahbqbe.swift:27:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmpfuahbqbe.swift:27:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3fre75nc.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3fre75nc.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3fre75nc.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3fre75nc.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3fre75nc.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp3fre75nc.swift:23:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3fre75nc.swift:23:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3fre75nc.swift:23:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3fre75nc.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp3fre75nc.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp3fre75nc.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3fre75nc.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        var extension_strength =\
    \ extension.count\n        for character in extension {\n            if character\
    \ == character.lowercased() {\n                extension_strength -= 1\n     \
    \       }\n        }\n        if extension_strength > 0 {\n            strongest_extension\
    \ += extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp959m6a0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp959m6a0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp959m6a0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp959m6a0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp959m6a0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp959m6a0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp959m6a0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp959m6a0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp959m6a0b.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp959m6a0b.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp959m6a0b.swift:29:36: error: expected expression\
    \ after operator\n            strongest_extension += extension\n             \
    \                      ^\n/tmp/tmp959m6a0b.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp959m6a0b.swift:29:45:\
    \ error: expected '{' in extension\n            strongest_extension += extension\n\
    \                                            ^\n/tmp/tmp959m6a0b.swift:29:36:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ += extension\n            "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        var strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          strength -= 1\n            }\n        }\n        if strength > 0 {\n\
    \            strongest_extension += class_name + \".\" + extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpywciq5s8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpywciq5s8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpywciq5s8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpywciq5s8.swift:21:24:\
    \ error: expected initial value after '='\n        var strength = extension.count\n\
    \                       ^\n/tmp/tmpywciq5s8.swift:21:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = extension.count\n\
    \                      ^\n                      ;\n/tmp/tmpywciq5s8.swift:21:33:\
    \ error: expected type name in extension declaration\n        var strength = extension.count\n\
    \                                ^\n/tmp/tmpywciq5s8.swift:21:33: error: expected\
    \ '{' in extension\n        var strength = extension.count\n                 \
    \               ^\n/tmp/tmpywciq5s8.swift:21:24: error: declaration is only valid\
    \ at file scope\n        var strength = extension.count\n                    \
    \   ^\n/tmp/tmpywciq5s8.swift:22:23: error: expected Sequence expression for for-each\
    \ loop\n        for letter in extension {\n                      ^\n/tmp/tmpywciq5s8.swift:22:23:\
    \ error: expected '{' to start the body of for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpywciq5s8.swift:28:55: error: expected\
    \ expression after operator\n            strongest_extension += class_name + \"\
    .\" + extension\n                                                      ^\n/tmp/tmpywciq5s8.swift:29:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpywciq5s8.swift:28:64:\
    \ error: expected '{' in extension\n            strongest_extension += class_name\
    \ + \".\" + extension\n                                                      \
    \         ^\n/tmp/tmpywciq5s8.swift:28:55: error: declaration is only valid at\
    \ file scope\n            strongest_extension += class_name + \".\" + extension\n\
    \                                       "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_lowercase = class_name.lowercased()\n    var extension_lowercase\
    \ = extensions[0].lowercased()\n    var strength = extension_lowercase.count-class_name_lowercase.count\n\
    \    for extension in extensions {\n        var extension_lowercase = extension.lowercased()\n\
    \        var strength = extension_lowercase.count-class_name_lowercase.count\n\
    \        if strength > 0 {\n            strongest_extension = class_name + \"\
    .\" + extension\n            break\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8t36hug.swift:23:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpx8t36hug.swift:23:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpx8t36hug.swift:23:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpx8t36hug.swift:24:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpx8t36hug.swift:24:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpx8t36hug.swift:24:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpx8t36hug.swift:24:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpx8t36hug.swift:24:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpx8t36hug.swift:27:54: error: expected\
    \ expression after operator\n            strongest_extension = class_name + \"\
    .\" + extension\n                                                     ^\n/tmp/tmpx8t36hug.swift:28:13:\
    \ error: expected type name in extension declaration\n            break\n    \
    \        ^\n/tmp/tmpx8t36hug.swift:27:63: error: expected '{' in extension\n \
    \           strongest_extension = class_name + \".\" + extension\n           \
    \                                                   ^\n/tmp/tmpx8t36hug.swift:27:54:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = class_name + \".\" + extension\n                                         \
    \            ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_length = class_name.count\n    var extension_length = extensions.count\n\
    \    var strength = class_name_length - extension_length\n    if strength == 0\
    \ {\n        return class_name\n    }\n    if strength < 0 {\n        strength\
    \ *= -1\n    }\n    for extension in extensions {\n        var extension_length\
    \ = extension.count\n        var strength = class_name_length - extension_length\n\
    \        if strength == 0 {\n            continue\n        }\n        if strength\
    \ < 0 {\n            strength *= -1\n        }\n        if strength > strongest_extension.count\
    \ {\n            strongest_extension = extension\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4gfn7rtc.swift:29:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4gfn7rtc.swift:29:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4gfn7rtc.swift:29:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4gfn7rtc.swift:30:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmp4gfn7rtc.swift:30:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmp4gfn7rtc.swift:30:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmp4gfn7rtc.swift:30:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmp4gfn7rtc.swift:30:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmp4gfn7rtc.swift:39:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp4gfn7rtc.swift:40:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp4gfn7rtc.swift:39:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp4gfn7rtc.swift:39:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > 0 {\n            strongest_extension = class_name + \".\" + extension\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6itpnh62.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6itpnh62.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6itpnh62.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6itpnh62.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp6itpnh62.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp6itpnh62.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp6itpnh62.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp6itpnh62.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp6itpnh62.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmp6itpnh62.swift:27:9: error: expected type name in extension\
    \ declaration\n        }\n        ^\n/tmp/tmp6itpnh62.swift:26:63: error: expected\
    \ '{' in extension\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                              ^\n/tmp/tmp6itpnh62.swift:26:54:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = class_name + \".\" + extension\n                                         \
    \            ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    let class_name\
    \ = class_name.lowercased()\n    let extensions = extensions.sorted()\n    var\
    \ strongest_extension = \"\"\n    var strongest_extension_strength = -1\n    for\
    \ extension in extensions {\n        let extension_strength = extension.countUpToLowercase().countUpToUppercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ygo2140.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3ygo2140.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3ygo2140.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3ygo2140.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercase().countUpToUppercase()\n\
    \                                 ^\n/tmp/tmp3ygo2140.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercase().countUpToUppercase()\n                    \
    \            ^\n                                ;\n/tmp/tmp3ygo2140.swift:25:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercase().countUpToUppercase()\n                    \
    \                      ^\n/tmp/tmp3ygo2140.swift:25:43: error: expected '{' in\
    \ extension\n        let extension_strength = extension.countUpToLowercase().countUpToUppercase()\n\
    \                                          ^\n/tmp/tmp3ygo2140.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercase().countUpToUppercase()\n\
    \                                 ^\n/tmp/tmp3ygo2140.swift:28:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp3ygo2140.swift:29:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp3ygo2140.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3ygo2140.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2kqj1dp.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg2kqj1dp.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg2kqj1dp.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg2kqj1dp.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpg2kqj1dp.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpg2kqj1dp.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpg2kqj1dp.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpg2kqj1dp.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpg2kqj1dp.swift:22:83:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpg2kqj1dp.swift:22:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpg2kqj1dp.swift:"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_6d_px6i.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_6d_px6i.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_6d_px6i.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_6d_px6i.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmp_6d_px6i.swift:22:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmp_6d_px6i.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmp_6d_px6i.swift:22:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmp_6d_px6i.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmp_6d_px6i.swift:22:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmp_6d_px6i.swift:22:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmp_6d_px6i.swift:22:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components.last!\n        let extension\
    \ = extension_components.last!\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_cap = class_name_components_count - class_name_components_count.lowercased()\n\
    \        let extension_components_count_cap = extension_components_count - extension_components_count.lowercased()\n\
    \        let class_name_components_count_sm = class_name_components_count.lowercased()\n\
    \        let extension_components_count_sm = extension_components_count.lowercased()\n\
    \        let class_name_components_count_cap_extension = class_name_components_count_cap\
    \ - extension_components_count_cap\n        let extension_components_count_cap_extension\
    \ = extension_components_count_cap - class_name_components_count_cap\n       \
    \ let class_name_components_count_sm_extension = class_name_components_count_sm\
    \ - extension_components_count_sm\n        let extension_components_count_sm_extension\
    \ = extension_components_count_sm - class_name_components_count_sm\n        let\
    \ strength = class_name_components_count_cap_extension * extension_components_count_cap_extension\
    \ + class_name_components_count_sm_extension * extension_components_count_sm_extension\n\
    \        if strength > strongest_extension.characters.count {\n            strongest_extension\
    \ = class_name\n        }\n    }\n    return strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjhstlma0.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjhstlma0.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjhstlma0.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjhstlma0.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpjhstlma0.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpjhstlma0.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpjhstlma0.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpjhstlma0.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpjhstlma0.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components.last!\n\
    \            ^\n/tmp/tmpjhstlma0.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components.last!\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpjhstlma0.swift:21:48:\
    \ error: value of type 'String' has no member 'components'\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n                              \
    \      ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_uppercase = class_name.uppercased()\n    var class_name_lowercase\
    \ = class_name_uppercase.lowercased()\n    var class_name_length = class_name_uppercase.count\n\
    \    var extension_length = extensions.count\n    var extension_strength = extension_length\
    \ / class_name_length\n    var extension_strength_rounded = round(extension_strength\
    \ * 100) / 100\n    var extension_strength_rounded_rounded = round(extension_strength_rounded\
    \ * 100) / 100\n    var extension_strength_rounded_rounded_rounded = round(extension_strength_rounded_rounded\
    \ * 100) / 100\n    var extension_strength_rounded_rounded_rounded_rounded = round(extension_strength_rounded_rounded_rounded\
    \ * 100) / 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded * 100) / 100\n  \
    \  var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded = round(extension_strength_rounded_rounded_rounded_rounded_rounded\
    \ * 100) / 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded_rounded * 100) /\
    \ 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded_rounded * 100) /\
    \ 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded_rounded * 100) /\
    \ 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded_rounded * 100) /\
    \ 100\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded * 100) / 100\n  \
    \  var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded * 100) / 100\n  \
    \  var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp18e9g201.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp18e9g201.swift:37:163: note: to match this opening '('\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength\n                                               \
    \                                                                            \
    \                                       ^\n/tmp/tmp18e9g201.swift:25:38: error:\
    \ cannot find 'round' in scope\n    var extension_strength_rounded = round(extension_strength\
    \ * 100) / 100\n                                     ^~~~~\n/tmp/tmp18e9g201.swift:26:46:\
    \ error: cannot find 'round' in scope\n    var extension_strength_rounded_rounded\
    \ = round(extension_strength_rounded * 100) / 100\n                          \
    \                   ^~~~~\n/tmp/tmp18e9g201.swift:27:54: error: cannot find 'round'\
    \ in scope\n    var extension_strength_rounded_rounded_rounded = round(extension_strength_rounded_rounded\
    \ * 100) / 100\n                                                     ^~~~~\n/tmp/tmp18e9g201.swift:28:62:\
    \ error: cannot find 'round' in scope\n    var extension_strength_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded * 100) / 100\n          \
    \                                                   ^~~~~\n/tmp/tmp18e9g201.swift:29:70:\
    \ error: cannot find 'round' in scope\n    var extension_strength_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded * 100) / 100\n  \
    \                                                                   ^~~~~\n/tmp/tmp18e9g201.swift:30:78:\
    \ error: cannot find 'round' in scope\n    var extension_strength_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = round(extension_strength_rounded_rounded_rounded_rounded_rounded * 100) /\
    \ 100\n                                                                      \
    \       ^~~~~\n/tmp/tmp18e9g201.swift:31:86: error: cannot find 'round' in scope\n\
    \    var extension_strength_rounded_ro"
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4r9na3c.swift:19:47: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              ^\n\
    /tmp/tmpx4r9na3c.swift:19:47: note: found candidate with type '(Int) -> Int'\n\
    \    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              ^\n\
    /tmp/tmpx4r9na3c.swift:19:47: note: found candidate with type '(Int) -> Int'\n\
    \    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              ^\n\
    /tmp/tmpx4r9na3c.swift:19:47: note: candidate expects value of type '(String)\
    \ throws -> Bool' for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              ^\n\
    /tmp/tmpx4r9na3c.swift:19:47: note: candidate expects value of type 'String' for\
    \ parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))!]\n\
    \                                              ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        var count = 0\n        for\
    \ letter in extension {\n            if letter.isUpper() {\n                count\
    \ += 1\n            }\n        }\n        let strength = count / extension.count\n\
    \        if strength > strongest_extension.count {\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpd1v1g519.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpd1v1g519.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpd1v1g519.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpd1v1g519.swift:23:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpd1v1g519.swift:23:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmpd1v1g519.swift:28:32: error: expected expression\
    \ after operator\n        let strength = count / extension.count\n           \
    \                    ^\n/tmp/tmpd1v1g519.swift:28:31: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = count / extension.count\n\
    \                              ^\n                              ;\n/tmp/tmpd1v1g519.swift:28:41:\
    \ error: expected type name in extension declaration\n        let strength = count\
    \ / extension.count\n                                        ^\n/tmp/tmpd1v1g519.swift:28:41:\
    \ error: expected '{' in extension\n        let strength = count / extension.count\n\
    \                                        ^\n/tmp/tmpd1v1g519.swift:28:32: error:\
    \ declaration is only valid at file scope\n        let strength = count / extension.count\n\
    \                               ^\n/tmp/tmpd1v1g519.swift:30:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpd1v1g519.swift:31:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpd1v1g519.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpd1v1g519.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpd2hyv_ga.swift:19:47: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                              ^\n\
    /tmp/tmpd2hyv_ga.swift:19:47: note: candidate expects value of type 'Int' for\
    \ parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                              ^\n/tmp/tmpd2hyv_ga.swift:19:47:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                              ^\n\
    /tmp/tmpd2hyv_ga.swift:19:47: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                              ^\n\
    /tmp/tmpd2hyv_ga.swift:19:47: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                              ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_name_components.last!\n\
    \        let extension = extension_components.last!\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_upper = class_name_components_count -\
    \ class_name_components_count.map { $0.isUppercase }\n        let extension_components_count_upper\
    \ = extension_components_count - extension_components_count.map { $0.isUppercase\
    \ }\n        let class_name_components_count_lower = class_name_components_count\
    \ - class_name_components_count.map { $0.isLowercase }\n        let extension_components_count_lower\
    \ = extension_components_count - extension_components_count.map { $0.isLowercase\
    \ }\n        let class_name_components_count_cap = class_name_components_count\
    \ - class_name_components_count.map { $0.isUppercase - $0.isLowercase }\n    \
    \    let extension_components_count_cap = extension_components_count - extension_components_count.map\
    \ { $0.isUppercase - $0.isLowercase }\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components_count.map { $0.isLowercase\
    \ - $0.isUppercase }\n        let extension_components_count_sm = extension_components_count\
    \ - extension_components_count.map { $0.isLowercase - $0.isUppercase }\n     \
    \   let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ + class_name_components_count_sm) / 2\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap + extension_components_count_sm) / 2\n   \
    \     let class_name_components_count_cap_sm_lower = (class_name_components_count_cap_sm\
    \ + class_name_components_count_lower) / 2\n        let extension_components_count_cap_sm_lower\
    \ = (extension_components_count_cap_sm + extension_components_count_lower) / 2\n\
    \        let class_name_components_count_cap_sm_upper = (class_name_components_count_cap_sm\
    \ + class_name_components_count_upper) / 2\n        let extension_components_count_cap_sm_upper\
    \ = (extension_components_count_cap_sm + extension_components_count_upper) / 2\n\
    \        let class_name_components_count_cap_sm_cap = (class_name_components_count_cap_sm\
    \ + \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsou7eol7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsou7eol7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsou7eol7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsou7eol7.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpsou7eol7.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpsou7eol7.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpsou7eol7.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpsou7eol7.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpsou7eol7.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components.last!\n\
    \            ^\n/tmp/tmpsou7eol7.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components.last!\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpsou7eol7.swift:43:1:\
    \ error: expected expression after operator\n}\n^\n/tmp/tmpsou7eol7.swift:66:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpsou7eol7.swi"
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1qh6qu_p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1qh6qu_p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp1qh6qu_p.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp1qh6qu_p.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp1qh6qu_p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp1qh6qu_p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4kfef5c_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4kfef5c_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4kfef5c_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4kfef5c_.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmp4kfef5c_.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmp4kfef5c_.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmp4kfef5c_.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmp4kfef5c_.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5272c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae526fb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae526fb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae526fb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae526fb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae526db6fc3 <unavailable> + 188355

    6    tmpz6eqy7qc                        0x000056404c7d27c8 <unavailable> + 10184

    7    tmpz6eqy7qc                        0x000056404c7d15a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ae5274ac460 __libc_start_main +
    245

    9    tmpz6eqy7qc                        0x000056404c7d11f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let strength\
    \ = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n    \
    \    if strength > max_strength {\n            max_strength = strength\n     \
    \       strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm9fr1kkv.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm9fr1kkv.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm9fr1kkv.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm9fr1kkv.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                       ^\n/tmp/tmpm9fr1kkv.swift:22:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \                      ^\n                      ;\n/tmp/tmpm9fr1kkv.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                ^\n/tmp/tmpm9fr1kkv.swift:22:33:\
    \ error: expected '{' in extension\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                ^\n/tmp/tmpm9fr1kkv.swift:22:24:\
    \ error: declaration is only valid at file scope\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                       ^\n/tmp/tmpm9fr1kkv.swift:22:69:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                            ^\n/tmp/tmpm9fr1kkv.swift:22:69: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToCapitalLetters -\
    \ extension.countLowercaseLetters\n                                          \
    \                          ^\n/tmp/tmpm9fr1kkv.swift:22:60: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \               "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpepo7958p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpepo7958p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpepo7958p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpepo7958p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpepo7958p.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpepo7958p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpepo7958p.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpepo7958p.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpepo7958p.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \     if strength > max_strength {\n            max_strength = strength\n    \
    \        strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcdcqggjd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcdcqggjd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpcdcqggjd.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpcdcqggjd.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpcdcqggjd.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpcdcqggjd.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpcdcqggjd.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_length = class_name.characters.count\n    var extension_length\
    \ = extensions.count\n    var strongest_extension_length = class_name_length\n\
    \    var max_extension_strength = -1\n    for extension in extensions {\n    \
    \    var extension_strength = extension.characters.count\n        if extension_strength\
    \ > max_extension_strength {\n            max_extension_strength = extension_strength\n\
    \        }\n    }\n    for extension in extensions {\n        var extension_strength\
    \ = extension.characters.count\n        if extension_strength == max_extension_strength\
    \ {\n            strongest_extension += extension\n        }\n    }\n    if strongest_extension_length\
    \ < extension_length {\n        for _ in 0..<extension_length - strongest_extension_length\
    \ {\n            strongest_extension += \"A\"\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy83eekne.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy83eekne.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy83eekne.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy83eekne.swift:25:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpy83eekne.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpy83eekne.swift:25:43: error: expected type name\
    \ in extension declaration\n        var extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpy83eekne.swift:25:43: error:\
    \ expected '{' in extension\n        var extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpy83eekne.swift:25:34: error:\
    \ declaration is only valid at file scope\n        var extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpy83eekne.swift:30:9: error: expected\
    \ pattern\n    for extension in extensions {\n        ^\n/tmp/tmpy83eekne.swift:30:9:\
    \ error: expected Sequence expression for for-each loop\n    for extension in\
    \ extensions {\n        ^\n/tmp/tmpy83eekne.swift:30:9: error: expected '{' to\
    \ start the body of for-each loop\n    for extension in extensions {\n       \
    \ ^\n/tmp/tmpy83eekne.swift:31:34: error: expected initial value after '='\n \
    \       var extension_strength = extension.characters.count\n                \
    \                 ^\n/tmp/tmpy83eekne.swift:31:33: error: consecutive statements\
    \ on a line must be separated by ';'\n        var extension_strength = extension.characters.count\n\
    \                                ^\n                                ;\n/tmp/tmpy83eekne.swift:31:43:\
    \ error: expecte"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + extensions[extensions.reduce(0,\
    \ combine: +)].prefix(1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwlbc7sjw.swift:19:53: error: extraneous argument label 'combine:'\
    \ in call\n    return class_name + extensions[extensions.reduce(0, combine: +)].prefix(1)\n\
    \                                                    ^   ~~~~~~~~~\n         \
    \                                               \n/tmp/tmpwlbc7sjw.swift:19:66:\
    \ error: cannot convert value of type '(Int) -> Int' to expected argument type\
    \ '(Int, String) throws -> Int'\n    return class_name + extensions[extensions.reduce(0,\
    \ combine: +)].prefix(1)\n                                                   \
    \              ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1qh6qu_p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1qh6qu_p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1qh6qu_p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp1qh6qu_p.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp1qh6qu_p.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp1qh6qu_p.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp1qh6qu_p.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp1qh6qu_p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp1qh6qu_p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + Strongest_Extension_Name(extensions)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2nmz8_md.swift:19:25: error: cannot find 'Strongest_Extension_Name'\
    \ in scope\n    return class_name + Strongest_Extension_Name(extensions)\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpccvbplbw.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpccvbplbw.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpccvbplbw.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpccvbplbw.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpccvbplbw.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpccvbplbw.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpccvbplbw.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpccvbplbw.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpccvbplbw.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpccvbplbw.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpccvbplbw.swift:22:7"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb7sb119.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjb7sb119.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjb7sb119.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpjb7sb119.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpjb7sb119.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpjb7sb119.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjb7sb119.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjb7sb119.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjb7sb119.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for c in extension\
    \ {\n            if c >= 'A' && c <= 'Z' {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpykh4fele.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpykh4fele.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpykh4fele.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpykh4fele.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpykh4fele.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpykh4fele.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpykh4fele.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpykh4fele.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpykh4fele.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpykh4fele.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpykh4fele.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpykh4fele.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpykh4fele.swift:30:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpykh4fele.swift:31:9: error: expected type name in extensi"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_components = class_name.components(separatedBy: \".\")\n\
    \    var extensions_components = extensions.components(separatedBy: \".\")\n \
    \   var class_name_components_count = class_name_components.count\n    var extensions_components_count\
    \ = extensions_components.count\n    var strongest_extension_strength = -1\n \
    \   var strongest_extension_strength_components = \"\"\n    var strongest_extension_strength_components_count\
    \ = 0\n    var strongest_extension_strength_components_count_max = 0\n    var\
    \ strongest_extension_strength_components_count_min = 0\n    var strongest_extension_strength_components_count_max_index\
    \ = 0\n    var strongest_extension_strength_components_count_min_index = 0\n \
    \   var strongest_extension_strength_components_count_max_count = 0\n    var strongest_extension_strength_components_count_min_count\
    \ = 0\n    var strongest_extension_strength_components_count_max_index = 0\n \
    \   var strongest_extension_strength_components_count_min_index = 0\n    var strongest_extension_strength_components_count_max_count\
    \ = 0\n    var strongest_extension_strength_components_count_min_count = 0\n \
    \   var strongest_extension_strength_components_count_max_index = 0\n    var strongest_extension_strength_components_count_min_index\
    \ = 0\n    var strongest_extension_strength_components_count_max_count = 0\n \
    \   var strongest_extension_strength_components_count_min_count = 0\n    var strongest_extension_strength_components_count_max_index\
    \ = 0\n    var strongest_extension_strength_components_count_min_index = 0\n \
    \   var strongest_extension_strength_components_count_max_count = 0\n    var strongest_extension_strength_components_count_min_count\
    \ = 0\n    var strongest_extension_strength_components_count_max_index = 0\n \
    \   var strongest_extension_strength_components_count_min_index = 0\n    var strongest_extension_strength_components_count_max_count\
    \ = 0\n    var strongest_extension_strength_components_count_min_count = 0\n \
    \   var strongest_extension_strength_components_count_max_index = 0\n    var strongest_extension_strength_components_count_min_index\
    \ = 0\n    var strongest_extension_strength_components_count_max_count = 0\n \
    \   var strongest_extension_strength_components_count_min_count = 0\n    var strongest_extension_strength_components_count_max_index\
    \ = 0\n    var strongest_extension_strength_components_count_min_index = 0\n \
    \   var strongest_extension_strength_components_count_max_count = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpv05oqb_q.swift:56:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpv05oqb_q.swift:20:44: error: value of type 'String' has no member\
    \ 'components'\n    var class_name_components = class_name.components(separatedBy:\
    \ \".\")\n                                ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpv05oqb_q.swift:21:44:\
    \ error: value of type '[String]' has no member 'components'\n    var extensions_components\
    \ = extensions.components(separatedBy: \".\")\n                              \
    \  ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpv05oqb_q.swift:33:9: error: invalid redeclaration\
    \ of 'strongest_extension_strength_components_count_max_index'\n    var strongest_extension_strength_components_count_max_index\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:29:9: note: 'strongest_extension_strength_components_count_max_index'\
    \ previously declared here\n    var strongest_extension_strength_components_count_max_index\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:34:9: error: invalid redeclaration of\
    \ 'strongest_extension_strength_components_count_min_index'\n    var strongest_extension_strength_components_count_min_index\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:30:9: note: 'strongest_extension_strength_components_count_min_index'\
    \ previously declared here\n    var strongest_extension_strength_components_count_min_index\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:35:9: error: invalid redeclaration of\
    \ 'strongest_extension_strength_components_count_max_count'\n    var strongest_extension_strength_components_count_max_count\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:31:9: note: 'strongest_extension_strength_components_count_max_count'\
    \ previously declared here\n    var strongest_extension_strength_components_count_max_count\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:36:9: error: invalid redeclaration of\
    \ 'strongest_extension_strength_components_count_min_count'\n    var strongest_extension_strength_components_count_min_count\
    \ = 0\n        ^\n/tmp/tmpv05oqb_q.swift:32:9: note: 'strongest_extension_strength_components_count_min_count'\
    \ previously declared here\n    var strongest_extension_strength_components_count_m"
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4kfef5c_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4kfef5c_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4kfef5c_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4kfef5c_.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmp4kfef5c_.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmp4kfef5c_.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmp4kfef5c_.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmp4kfef5c_.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp4kfef5c_.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpavyk_6qx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpavyk_6qx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpavyk_6qx.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpavyk_6qx.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpavyk_6qx.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpavyk_6qx.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpavyk_6qx.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpavyk_6qx.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let strength = cap\
    \ - sm\n        if strength > 0 {\n            if strength > strength {\n    \
    \            strongest_extension = extension\n                strength = strength\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxdtmypo9.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxdtmypo9.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxdtmypo9.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxdtmypo9.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpxdtmypo9.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpxdtmypo9.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpxdtmypo9.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpxdtmypo9.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpxdtmypo9.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmpxdtmypo9.swift:28:26:\
    \ error: expected '{' in extension\n                strength = strength\n    \
    \                     ^\n/tmp/tmpxdtmypo9.swift:27:39: error: declaration is only\
    \ valid at file scope\n                strongest_extension = extension\n     \
    \                                 ^\n/tmp/tmpxdtmypo9.swift:28:17: error: cannot\
    \ find type 'strength' in scope\n                strength = strength\n       \
    \         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1w_uqx0b.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1w_uqx0b.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1w_uqx0b.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp1w_uqx0b.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp1w_uqx0b.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp1w_uqx0b.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp1w_uqx0b.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp1w_uqx0b.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp1w_uqx0b.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp1w_uqx0b.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820751
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ {$0 + $1.count})]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6ab4f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ab1e8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab6ab1e8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab6ab1e813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab6ab1e7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab6aafe7fc3 <unavailable> + 188355

    6    tmpnptkgxph                        0x0000562964c18821 <unavailable> + 10273

    7    tmpnptkgxph                        0x0000562964c175a3 <unavailable> + 5539

    8    libc.so.6                          0x00002ab6ab6dd460 __libc_start_main +
    245

    9    tmpnptkgxph                        0x0000562964c171f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fzln87.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl6fzln87.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl6fzln87.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpl6fzln87.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpl6fzln87.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpl6fzln87.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpl6fzln87.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpl6fzln87.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpl6fzln87.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpl6fzln87.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl6fzln87.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var class_name_lowercase = class_name.lowercased()\n    var class_name_uppercase\
    \ = class_name.uppercased()\n    var class_name_length = class_name.characters.count\n\
    \    var extension_length = extensions.characters.count\n    var strongest_extension_length\
    \ = class_name_length - extension_length\n    var strongest_extension_strength\
    \ = -1\n    var strongest_extension_strength_index = 0\n    for extension in extensions\
    \ {\n        var extension_lowercase = extension.lowercased()\n        var extension_uppercase\
    \ = extension.uppercased()\n        var extension_length = extension.characters.count\n\
    \        var extension_strength = extension_length - strongest_extension_length\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension_strength_index = extension_length\
    \ - strongest_extension_length\n        }\n        if extension_strength == strongest_extension_strength\
    \ {\n            if extension_lowercase == class_name_lowercase {\n          \
    \      strongest_extension = class_name + extension\n            }\n        }\n\
    \    }\n    if strongest_extension_strength == -1 {\n        return class_name\n\
    \    }\n    return class_name + extensions[strongest_extension_strength_index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnsf2g3o0.swift:27:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnsf2g3o0.swift:27:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnsf2g3o0.swift:27:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnsf2g3o0.swift:28:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpnsf2g3o0.swift:28:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpnsf2g3o0.swift:28:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpnsf2g3o0.swift:28:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpnsf2g3o0.swift:28:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpnsf2g3o0.swift:29:35: error: expected\
    \ initial value after '='\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmpnsf2g3o0.swift:29:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_uppercase\
    \ = extension.uppercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpnsf2g3o0.swift:29:44: error: expected type name\
    \ in extension declaration\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmpnsf2g3o0.swift:29:44: error:\
    \ expected '{' in extension\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmpnsf2g3o0.swift:29:35: error:\
    \ declaration is only val"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ == 0 {\n            strongest_extension = extension\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyoxng_7w.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyoxng_7w.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyoxng_7w.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyoxng_7w.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyoxng_7w.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyoxng_7w.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyoxng_7w.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyoxng_7w.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyoxng_7w.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpyoxng_7w.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpyoxng_7w.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpyoxng_7w.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpyoxng_7w.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpyoxng_7w.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var max_strength = -1\n    for extension in extensions {\n     \
    \   var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmply3ikr2q.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmply3ikr2q.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmply3ikr2q.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmply3ikr2q.swift:23:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmply3ikr2q.swift:23:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmply3ikr2q.swift:23:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmply3ikr2q.swift:23:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmply3ikr2q.swift:23:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmply3ikr2q.swift:26:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmply3ikr2q.swift:27:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmply3ikr2q.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1 // default value\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_count_cap = class_name_components_count.map { $0.capitalized\
    \ }.count\n        let extension_components_count_cap = extension_components_count.map\
    \ { $0.capitalized }.count\n        let class_name_components_count_sm = class_name_components_count.map\
    \ { $0.lowercased() }.count\n        let extension_components_count_sm = extension_components_count.map\
    \ { $0.lowercased() }.count\n        let cap_diff = class_name_components_count_cap\
    \ - extension_components_count_cap\n        let sm_diff = class_name_components_count_sm\
    \ - extension_components_count_sm\n        if cap_diff > sm_diff {\n         \
    \   strongest_extension = class_name + \".\" + extension\n            strength\
    \ = cap_diff\n        } else if sm_diff > cap_diff {\n            strongest_extension\
    \ = class_name + \".\" + extension\n            strength = sm_diff\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr6gye220.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr6gye220.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr6gye220.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr6gye220.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpr6gye220.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpr6gye220.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpr6gye220.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpr6gye220.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpr6gye220.swift:33:54: error: expected expression after operator\n\
    \            strongest_extension = class_name + \".\" + extension\n          \
    \                                           ^\n/tmp/tmpr6gye220.swift:34:22: error:\
    \ expected '{' in extension\n            strength = cap_diff\n               \
    \      ^\n/tmp/tmpr6gye220.swift:33:54: error: declaration is only valid at file\
    \ scope\n            strongest_extension = class_name + \".\" + extension\n  \
    \                                                   ^\n/tmp/tmpr6gye220.swift:36:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmpr"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpccvbplbw.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpccvbplbw.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpccvbplbw.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpccvbplbw.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpccvbplbw.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpccvbplbw.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpccvbplbw.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpccvbplbw.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpccvbplbw.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpccvbplbw.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpccvbplbw.swift:22:7"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > 0 {\n            strongest_extension += class_name + extension\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1jxlju6w.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1jxlju6w.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1jxlju6w.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1jxlju6w.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp1jxlju6w.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp1jxlju6w.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp1jxlju6w.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp1jxlju6w.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp1jxlju6w.swift:26:49:\
    \ error: expected expression after operator\n            strongest_extension +=\
    \ class_name + extension\n                                                ^\n\
    /tmp/tmp1jxlju6w.swift:27:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp1jxlju6w.swift:26:58: error: expected '{' in extension\n\
    \            strongest_extension += class_name + extension\n                 \
    \                                        ^\n/tmp/tmp1jxlju6w.swift:26:49: error:\
    \ declaration is only valid at file scope\n            strongest_extension +=\
    \ class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6nc29jeg.swift:19:53: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    return class_name + \".\" + extensions[extensions.reduce(0,\
    \ combine: max)]\n                                                    ^\n/tmp/tmp6nc29jeg.swift:19:59:\
    \ error: extraneous argument label 'combine:' in call\n    return class_name +\
    \ \".\" + extensions[extensions.reduce(0, combine: max)]\n                   \
    \                                       ^   ~~~~~~~~~\n                      \
    \                                        \n/tmp/tmp6nc29jeg.swift:19:60: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String'\n    return\
    \ class_name + \".\" + extensions[extensions.reduce(0, combine: max)]\n      \
    \                                                     ^\n"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_upper = class_name_components_count -\
    \ class_name_components.count\n        let extension_components_count_upper =\
    \ extension_components_count - extension_components.count\n        let class_name_components_count_lower\
    \ = class_name_components_count - class_name_components.count * 2\n        let\
    \ extension_components_count_lower = extension_components_count - extension_components.count\
    \ * 2\n        let class_name_components_count_cap = class_name_components_count\
    \ - class_name_components.count * 3\n        let extension_components_count_cap\
    \ = extension_components_count - extension_components.count * 3\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components.count * 4\n        let\
    \ extension_components_count_sm = extension_components_count - extension_components.count\
    \ * 4\n        let class_name_components_count_cap_small = class_name_components_count\
    \ - class_name_components.count * 5\n        let extension_components_count_cap_small\
    \ = extension_components_count - extension_components.count * 5\n        let class_name_components_count_cap_lower\
    \ = class_name_components_count - class_name_components.count * 6\n        let\
    \ extension_components_count_cap_lower = extension_components_count - extension_components.count\
    \ * 6\n        let class_name_components_count_cap_upper = class_name_components_count\
    \ - class_name_components.count * 7\n        let extension_components_count_cap_upper\
    \ = extension_components_count - extension_components.count * 7\n        let class_name_components_count_cap_small_upper\
    \ = class_name_components_count - class_name_components.count * 8\n        let\
    \ extension_components_count_cap_small_upper = extension_components_count - extension_components.count\
    \ * 8\n        let class_name_components_count_cap_small_lower = class_name_components_count\
    \ - class_name_components.count * 9\n        let extension_components_count_cap_small_lower\
    \ = extension_components_count - extension_components.count * 9\n        let class_name_components_count_cap_lower_upper\
    \ = class_name_components_count - class_name_components.count * 10\n        let\
    \ extension_components_count_cap_lower_upper = extension_components_count - extension_components.count\
    \ * 10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpf6mhqfmv.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpf6mhqfmv.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpf6mhqfmv.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpf6mhqfmv.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpf6mhqfmv.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpf6mhqfmv.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpf6mhqfmv.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpf6mhqfmv.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpf6mhqfmv.swift:69:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpf6mhqfmv.swift:18:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpf6mhqfmv.swift:49:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpf6mhqfmv.swift:22:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw63b9oi_.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmpw63b9oi_.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmpw63b9oi_.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \     if strength > max_strength {\n            max_strength = strength\n    \
    \        strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcdcqggjd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcdcqggjd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpcdcqggjd.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpcdcqggjd.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpcdcqggjd.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpcdcqggjd.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpcdcqggjd.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpcdcqggjd.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpcdcqggjd.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820752
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count - extension.lowercased().characters.count\n   \
    \     if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpc6kbp3ip.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpc6kbp3ip.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpc6kbp3ip.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpc6kbp3ip.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpc6kbp3ip.swift:22:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpc6kbp3ip.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpc6kbp3ip.swift:22:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpc6kbp3ip.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpc6kbp3ip.swift:22:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpc6kbp3ip.swift:22:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpc6kbp3ip.swift:22:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmposebzr6k.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmposebzr6k.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmposebzr6k.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmposebzr6k.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmposebzr6k.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmposebzr6k.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmposebzr6k.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmposebzr6k.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmposebzr6k.swift:22:7"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = 0\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > strongest_extension.count {\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmrwllast.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmrwllast.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmrwllast.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmrwllast.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpmrwllast.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpmrwllast.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpmrwllast.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpmrwllast.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpmrwllast.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpmrwllast.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpmrwllast.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmrwllast.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820753
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpkeq8yf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpkeq8yf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpkeq8yf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpmpkeq8yf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpmpkeq8yf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpmpkeq8yf.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpmpkeq8yf.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpmpkeq8yf.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpmpkeq8yf.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820751
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpq5uolx51.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpq5uolx51.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpq5uolx51.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpq5uolx51.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpq5uolx51.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpq5uolx51.swift:23:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpq5uolx51.swift:23:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpq5uolx51.swift:23:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpq5uolx51.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpq5uolx51.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpq5uolx51.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpq5uolx51.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820753
