language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(numbers.first!)\n    var max: Double\
    \ = Double(numbers.last!)\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_3k5f6yz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_3k5f6yz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max - min\n        scaled.append(scaledNumber)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplbffebie.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbffebie.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmplbffebie.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl500samb.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx8i6zna1.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx8i6zna1.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / max\n        rescaled.append(rescaled)\n\
    \        if min > number {\n            min = number\n        }\n        if max\
    \ < number {\n            max = number\n        }\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi70hkbgj.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpi70hkbgj.swift:12:18: error: value of type 'Double'\
    \ has no member 'append'\n        rescaled.append(rescaled)\n        ~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7dt6njtb.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dt6njtb.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp7dt6njtb.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(min(max(0.0, number), 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp1204_76v/tmp1204_76v.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66483cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66480c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66480c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66480c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1204_76v                        0x0000561fe59986f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b66485ba460 __libc_start_main +
    245

    6    tmp1204_76v                        0x0000561fe59982f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append((number - min) / (max - min))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg619fsew.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpg619fsew.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(max - number)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp6ed1ri_g/tmp6ed1ri_g.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f3f6c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f3f3b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f3f3b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f3f3b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ed1ri_g                        0x000055feb69136a3 <unavailable> + 5795

    5    libc.so.6                          0x00002b6f3f8ac460 __libc_start_main +
    245

    6    tmp6ed1ri_g                        0x000055feb69132a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpet0qeig4.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpet0qeig4.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuciv_jpx.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpehj_b8my.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                           ^\n                              \
    \             , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpehj_b8my.swift:9:60: error: missing argument for parameter\
    \ #2 in call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                                           ^\n              \
    \                                             , <#Double#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpehj_b8my.swift:9:53: error:\
    \ cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                                             ^\n/tmp/tmpehj_b8my.swift:9:37:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                             ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpukl0b3jn.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpukl0b3jn.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpukl0b3jn.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppydjd42i/tmppydjd42i.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aedc10f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aedc0dedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aedc0ded988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aedc0dec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppydjd42i                        0x00005650179716a3 <unavailable> + 5795

    5    libc.so.6                          0x00002aedc12e2460 __libc_start_main +
    245

    6    tmppydjd42i                        0x00005650179712a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm4z4yr1o.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm4z4yr1o.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpm4z4yr1o.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scale = (max - min) / (Double(numbers.count) - 1)\n    var result\
    \ = [Double](repeating: 0.0, count: numbers.count)\n    for number in numbers\
    \ {\n        result[numbers.index(of: number) - 1] = number * scale\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpaw3qxw5k.swift:20:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number) - 1] = number * scale\n\
    \                       ^\n/tmp/tmpaw3qxw5k.swift:20:24: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number) - 1] = number * scale\n                       ^\n               (  \
    \                       ?? <#default value#>)\n/tmp/tmpaw3qxw5k.swift:20:24: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        result[numbers.index(of: number) - 1] = number * scale\n            \
    \           ^\n                                        !\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        scaledNumbers.append(number / max - min)\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    return scaledNumbers\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzb9uqb9r.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzb9uqb9r.swift:12:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpzb9uqb9r.swift:13:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number /= max - min\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp55hv48hp.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp55hv48hp.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp55hv48hp.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_m21i7tz.swift:12:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_m21i7tz.swift:13:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpaoptdl6z.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpaoptdl6z.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpaoptdl6z.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(min(max(0.0, number), 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp1204_76v/tmp1204_76v.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66483cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66480c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66480c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66480c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1204_76v                        0x0000561fe59986f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b66485ba460 __libc_start_main +
    245

    6    tmp1204_76v                        0x0000561fe59982f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuciv_jpx.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpve69a1en.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpve69a1en.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpve69a1en.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double]()\n    for number in numbers {\n \
    \       result.append(number - min)\n        result.append(number - max)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpayhr41rs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpayhr41rs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd8zs5mj1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd8zs5mj1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpd8zs5mj1.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        rescaled.append(number - max)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvt38ucc5.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpvt38ucc5.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append((number - min) / (max - min))\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd02hc209.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd02hc209.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm4z4yr1o.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm4z4yr1o.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpm4z4yr1o.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqspxceqc.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpqspxceqc.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n    for number in scaled {\n        number /= max - min\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg703wezf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg703wezf.swift:22:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number /= max\
    \ - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp80bfn83w.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp80bfn83w.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ / max - min)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfv2yp4dg.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfv2yp4dg.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpfv2yp4dg.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuciv_jpx.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplqy1ymo6.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmplqy1ymo6.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmplqy1ymo6.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuciv_jpx.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaledNumber = number / largest\n        rescaled.append(rescaledNumber)\n\
    \        largest = largest * rescaledNumber\n        smallest = smallest * rescaledNumber\n\
    \    }\n    rescaled.append(1.0)\n    rescaled.append(largest)\n    rescaled.append(smallest)\n\
    \    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdbx45bkr.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyx5xfu4n.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013762
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_7iyzv_t.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_7iyzv_t.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx8i6zna1.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx8i6zna1.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplu2obdog.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplu2obdog.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = number\
    \ / max(max - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcgs5ou2a.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpcgs5ou2a.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpcgs5ou2a.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmpcgs5ou2a.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpcgs5ou2a.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmpcgs5ou2a.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvw50wxys.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpvw50wxys.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpvw50wxys.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    var smallestNumber =\
    \ Double(Int.max)\n    var largestNumber = Double(Int.min)\n    for number in\
    \ numbers {\n        let scaledNumber = number / largestNumber\n        scaledNumbers.append(scaledNumber)\n\
    \        if number < smallestNumber {\n            smallestNumber = number\n \
    \       }\n        if number > largestNumber {\n            largestNumber = number\n\
    \        }\n    }\n    for number in scaledNumbers {\n        number -= smallestNumber\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4cj8exy0.swift:21:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number -= smallestNumber\n  \
    \      ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n    for number in scaled {\n        number /= max - min\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzycpsi9h.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzycpsi9h.swift:22:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number /= max\
    \ - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = ((number\
    \ - min) / (max - min)) * Double(numbers.count)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbiubl255.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbiubl255.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpbiubl255.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * Double(numbers.count)\n        \
    \               ^\n/tmp/tmpbiubl255.swift:15:24: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * Double(numbers.count)\n        \
    \               ^\n                                         ?? <#default value#>\n\
    /tmp/tmpbiubl255.swift:15:24: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        result[numbers.index(of: number)]\
    \ = ((number - min) / (max - min)) * Double(numbers.count)\n                 \
    \      ^\n                                        !\n"
  stdout: ''
  timestamp: 1660013727
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7dt6njtb.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dt6njtb.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp7dt6njtb.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_7dchh2.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6_7dchh2.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number = number / max\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4m8qdso6.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp4m8qdso6.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp4m8qdso6.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        scaled.append(number / max - min)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzc6i0tbz.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpzc6i0tbz.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzjj5hod5.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpzjj5hod5.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaledNumber = number / max - min\n        rescaled.append(rescaledNumber)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb4gmf1l0.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4gmf1l0.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpb4gmf1l0.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = number\
    \ / max(max - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcgs5ou2a.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpcgs5ou2a.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpcgs5ou2a.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmpcgs5ou2a.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpcgs5ou2a.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmpcgs5ou2a.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd8zs5mj1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd8zs5mj1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpd8zs5mj1.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm4z4yr1o.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm4z4yr1o.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpm4z4yr1o.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgpkjyqa8.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpgpkjyqa8.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp6uj3hzwl/tmp6uj3hzwl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28cc7a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28cc49ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28cc49a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28cc4997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6uj3hzwl                        0x0000561f046cf603 <unavailable> + 5635

    5    libc.so.6                          0x00002b28cc98f460 __libc_start_main +
    245

    6    tmp6uj3hzwl                        0x0000561f046cf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        scaled.append(numbers[i] - min)\n \
    \   }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i] / (max\
    \ - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpub0tfm17.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpub0tfm17.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpub0tfm17.swift:15:31: error: binary operator '/'\
    \ cannot be applied to operands of type 'Double' and 'Duration'\n        scaled[i]\
    \ = scaled[i] / (max - min)\n                    ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmpub0tfm17.swift:15:31:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Duration)\n        scaled[i] = scaled[i] / (max\
    \ - min)\n                              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \    }\n    for number in scaled {\n        number = number / max\n    }\n   \
    \ return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgrdayb95.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgrdayb95.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpgrdayb95.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmpgrdayb95.swift:18:9:\
    \ error: cannot assign to value: 'number' is a 'let' constant\n        number\
    \ = number / max\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpukl0b3jn.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpukl0b3jn.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpukl0b3jn.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        largest = number\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / smallest)\n\
    \        smallest = number\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp819yh9a6.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number /= max - min\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp55hv48hp.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp55hv48hp.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp55hv48hp.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6ratp2h3.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6ratp2h3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6ratp2h3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgpkjyqa8.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpgpkjyqa8.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd8zs5mj1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd8zs5mj1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpd8zs5mj1.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplqy1ymo6.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmplqy1ymo6.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmplqy1ymo6.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6ratp2h3.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6ratp2h3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6ratp2h3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl500samb.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp6uj3hzwl/tmp6uj3hzwl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28cc7a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28cc49ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28cc49a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28cc4997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6uj3hzwl                        0x0000561f046cf603 <unavailable> + 5635

    5    libc.so.6                          0x00002b28cc98f460 __libc_start_main +
    245

    6    tmp6uj3hzwl                        0x0000561f046cf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppwa_aknc.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmppwa_aknc.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmppwa_aknc.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvw50wxys.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpvw50wxys.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpvw50wxys.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplu2obdog.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplu2obdog.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    let range = max - min\n\
    \    let scaled: [Double] = numbers.map { $0 - min / range }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpart6zq2o.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpart6zq2o.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpart6zq2o.swift:11:51: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n    let scaled: [Double]\
    \ = numbers.map { $0 - min / range }\n                                       \
    \           ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in scaled\
    \ {\n        number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6kp9lgb0.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6kp9lgb0.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp6kp9lgb0.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for n in numbers {\n        scaled.append(n / max\
    \ - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxhsk6tab.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpxhsk6tab.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    var range = max - min\n    var scale = 1.0 / range\n    var scaledNumbers\
    \ = [Double]()\n    for number in numbers {\n        scaledNumbers.append(number\
    \ * scale)\n    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpei9lghdx/tmpei9lghdx.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab765df7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab765aeeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab765aee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab765aed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpei9lghdx                        0x0000558bac186833 <unavailable> + 6195

    5    libc.so.6                          0x00002ab765fe3460 __libc_start_main +
    245

    6    tmpei9lghdx                        0x0000558bac186439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number /= max - min\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp55hv48hp.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp55hv48hp.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp55hv48hp.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for number in\
    \ numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number /= max - min\n   \
    \ }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphjoa1clb.swift:23:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvw50wxys.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpvw50wxys.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpvw50wxys.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpet0qeig4.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpet0qeig4.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcv1qalyu.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpcv1qalyu.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplu2obdog.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplu2obdog.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in scaled\
    \ {\n        number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6kp9lgb0.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6kp9lgb0.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp6kp9lgb0.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(min(max(0.0, number), 1.0))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp7pd9340v/tmp7pd9340v.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1ddde9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1ddae0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1ddae0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1ddadf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7pd9340v                        0x000055b23d9586f3 <unavailable> + 5875

    5    libc.so.6                          0x00002ae1ddfd5460 __libc_start_main +
    245

    6    tmp7pd9340v                        0x000055b23d9582f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number / max - min)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp6a0680q.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpp6a0680q.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpp6a0680q.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzjj5hod5.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpzjj5hod5.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzjj5hod5.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpzjj5hod5.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp6uj3hzwl/tmp6uj3hzwl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28cc7a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28cc49ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28cc49a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28cc4997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6uj3hzwl                        0x0000561f046cf603 <unavailable> + 5635

    5    libc.so.6                          0x00002b28cc98f460 __libc_start_main +
    245

    6    tmp6uj3hzwl                        0x0000561f046cf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max - min\n        scaled.append(scaledNumber)\n\
    \        min = min(number, min)\n        max = max(number, max)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyitxe9fk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyitxe9fk.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(number, min)\n            \
    \  ^\n/tmp/tmpyitxe9fk.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(number, max)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpjucefsv7/tmpjucefsv7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97d3ac2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97d37b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97d37b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97d37b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjucefsv7                        0x0000561769754703 <unavailable> + 5891

    5    libc.so.6                          0x00002b97d3cae460 __libc_start_main +
    245

    6    tmpjucefsv7                        0x0000561769754309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx8i6zna1.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx8i6zna1.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    let\
    \ range = max - min\n    let rescaled = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for i in 0..<numbers.count {\n        rescaled[i] = numbers[i] - min\n  \
    \  }\n    for i in 0..<numbers.count {\n        rescaled[i] = rescaled[i]/range\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4q3cjyj3.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp4q3cjyj3.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp4q3cjyj3.swift:12:17: error: cannot assign through\
    \ subscript: 'rescaled' is a 'let' constant\n        rescaled[i] = numbers[i]\
    \ - min\n        ~~~~~~~~^\n/tmp/tmp4q3cjyj3.swift:10:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let rescaled = [Double](repeating: 0.0, count:\
    \ numbers.count)\n    ^~~\n    var\n/tmp/tmp4q3cjyj3.swift:15:17: error: cannot\
    \ assign through subscript: 'rescaled' is a 'let' constant\n        rescaled[i]\
    \ = rescaled[i]/range\n        ~~~~~~~~^\n/tmp/tmp4q3cjyj3.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let rescaled = [Double](repeating: 0.0,\
    \ count: numbers.count)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpukl0b3jn.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpukl0b3jn.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpukl0b3jn.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_m21i7tz.swift:12:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_m21i7tz.swift:13:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7dt6njtb.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dt6njtb.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp7dt6njtb.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    var range = max - min\n    var scaled: [Double] = []\n    for number in numbers\
    \ {\n        scaled.append(number - min)\n    }\n    for number in scaled {\n\
    \        number /= range\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpv9giyiwi.swift:15:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= range\n        ~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number / max - min)\n   \
    \ }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmph5eva5vx.swift:9:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmph5eva5vx.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmph5eva5vx.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyx5xfu4n.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013762
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number = number / max\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4m8qdso6.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp4m8qdso6.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp4m8qdso6.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvw50wxys.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpvw50wxys.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpvw50wxys.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaledNumber = number / largest\n        rescaled.append(rescaledNumber)\n\
    \        smallest = min(smallest, rescaledNumber)\n        largest = max(largest,\
    \ rescaledNumber)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpirc5j_5l.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpet0qeig4.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpet0qeig4.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n    }\n  \
    \  for number in numbers {\n        rescaled.append(number / max - min)\n    }\n\
    \    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdwot632x.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdwot632x.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpdwot632x.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number / max - min)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp71xuwicb.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    let min: Double = numbers.min()\n    let max: Double = numbers.max()\n\
    \    var scaled: [Double] = []\n    for i in 0..<numbers.count {\n        scaled.append(numbers[i]\
    \ - min)\n    }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i]\
    \ / (max - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2l6gh4be.swift:10:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmp2l6gh4be.swift:10:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmp2l6gh4be.swift:10:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmp2l6gh4be.swift:11:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmp2l6gh4be.swift:11:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmp2l6gh4be.swift:11:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvw50wxys.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpvw50wxys.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpvw50wxys.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm4z4yr1o.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm4z4yr1o.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpm4z4yr1o.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmsug4imx.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpmsug4imx.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number / max(min, max))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp408lmukr.swift:9:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp408lmukr.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp408lmukr.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmp408lmukr.swift:15:34:\
    \ error: cannot call value of non-function type 'Double'\n        rescaled.append(number\
    \ / max(min, max))\n                                 ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \    }\n    for number in scaled {\n        number /= max - min\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfzg31955.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfzg31955.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpfzg31955.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmpfzg31955.swift:18:16:\
    \ error: left side of mutating operator isn't mutable: 'number' is a 'let' constant\n\
    \        number /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(min(max(number, 0.0), 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpz_ivldx1/tmpz_ivldx1.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe78a16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe7870db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe7870d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe7870c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_ivldx1                        0x00005641b2ff26f3 <unavailable> + 5875

    5    libc.so.6                          0x00002afe78c02460 __libc_start_main +
    245

    6    tmpz_ivldx1                        0x00005641b2ff22f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpve69a1en.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpve69a1en.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpve69a1en.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        guard number != 0 else {\n            fatalError(\"Cannot rescale\
    \ array of size 0 to unit interval\")\n        }\n        guard number != 1 else\
    \ {\n            fatalError(\"Cannot rescale array of size 1 to unit interval\"\
    )\n        }\n        guard number > smallest else {\n            smallest = number\n\
    \        }\n        guard number < largest else {\n            largest = number\n\
    \        }\n        scaled.append((number - smallest) / (largest - smallest))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdupccu38.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        scaled.append(numbers[i] - min)\n \
    \   }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i] / max -\
    \ min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmdworvdc.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpmdworvdc.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        scaled.append(numbers[i] / max - min)\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl4zdjs7n.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl4zdjs7n.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpve69a1en.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpve69a1en.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpve69a1en.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpehj_b8my.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                           ^\n                              \
    \             , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpehj_b8my.swift:9:60: error: missing argument for parameter\
    \ #2 in call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                                           ^\n              \
    \                                             , <#Double#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpehj_b8my.swift:9:53: error:\
    \ cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                                             ^\n/tmp/tmpehj_b8my.swift:9:37:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                             ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgxcgbocn.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgxcgbocn.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpgxcgbocn.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    for number in numbers\
    \ {\n        scaledNumbers.append(number / min(number))\n    }\n    return scaledNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9_frqlcy.swift:9:49: error: missing argument for parameter #2 in\
    \ call\n        scaledNumbers.append(number / min(number))\n                 \
    \                               ^\n                                          \
    \      , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for i in 0..<numbers.count {\n        scaled.append(numbers[i]\
    \ - min)\n    }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i]\
    \ / (max - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbxf5t9ol.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpbxf5t9ol.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpbxf5t9ol.swift:14:31: error: binary operator '/'\
    \ cannot be applied to operands of type 'Double' and 'Duration'\n        scaled[i]\
    \ = scaled[i] / (max - min)\n                    ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmpbxf5t9ol.swift:14:31:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Duration)\n        scaled[i] = scaled[i] / (max\
    \ - min)\n                              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_7iyzv_t.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_7iyzv_t.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7dt6njtb.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dt6njtb.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp7dt6njtb.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(numbers.first!)\n    var max: Double\
    \ = Double(numbers.last!)\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n    }\n   \
    \ for number in scaled {\n        number /= max - min\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpa0qykdun.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpa0qykdun.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpa0qykdun.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min: Double = numbers.min()\n    let max: Double = numbers.max()\n    let range\
    \ = max - min\n    let newMin = min - range / 2\n    let newMax = max + range\
    \ / 2\n    return numbers.map { $0 / (newMax - newMin) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3miwnb2t.swift:8:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmp3miwnb2t.swift:8:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmp3miwnb2t.swift:8:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmp3miwnb2t.swift:9:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmp3miwnb2t.swift:9:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmp3miwnb2t.swift:9:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number / max - min)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqh6fhg9v.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpqh6fhg9v.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ rescaled: [Double] = []\n    for i in 0..<numbers.count {\n        rescaled.append(numbers[i]\
    \ - min)\n    }\n    for i in 0..<numbers.count {\n        rescaled[i] = rescaled[i]\
    \ / max - min\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3rg_hsuv.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp3rg_hsuv.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpea07f6zf/tmpea07f6zf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1637576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163726db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163726d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163726c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea07f6zf                        0x0000557abb4bc693 <unavailable> + 5779

    5    libc.so.6                          0x00002b1637762460 __libc_start_main +
    245

    6    tmpea07f6zf                        0x0000557abb4bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number - min\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgxa4evx3.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = number - min\n    \
    \                   ^\n/tmp/tmpgxa4evx3.swift:19:24: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                 ?? <#default value#>\n/tmp/tmpgxa4evx3.swift:19:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                !\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp6uj3hzwl/tmp6uj3hzwl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28cc7a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28cc49ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28cc49a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28cc4997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6uj3hzwl                        0x0000561f046cf603 <unavailable> + 5635

    5    libc.so.6                          0x00002b28cc98f460 __libc_start_main +
    245

    6    tmp6uj3hzwl                        0x0000561f046cf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd8zs5mj1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd8zs5mj1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpd8zs5mj1.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7dt6njtb.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dt6njtb.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp7dt6njtb.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = number\
    \ / max(max - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcgs5ou2a.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpcgs5ou2a.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpcgs5ou2a.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmpcgs5ou2a.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpcgs5ou2a.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmpcgs5ou2a.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgxcgbocn.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgxcgbocn.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpgxcgbocn.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp80bfn83w.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp80bfn83w.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyx5xfu4n.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013762
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for n in numbers {\n        scaled.append((n - min) / (max - min))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3_bwhhwv.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp3_bwhhwv.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number / min(number, 1.0))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpeb0c_gsq/tmpeb0c_gsq.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15f82cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15f7fc5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15f7fc5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15f7fc47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeb0c_gsq                        0x0000555fbc0b0693 <unavailable> + 5779

    5    libc.so.6                          0x00002b15f84ba460 __libc_start_main +
    245

    6    tmpeb0c_gsq                        0x0000555fbc0b0299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013727
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append((number - min) / (max - min))\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd02hc209.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd02hc209.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu637ccf_.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpu637ccf_.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl500samb.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0dt2nf54.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0dt2nf54.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(numbers.min())\n    var max: Double\
    \ = Double(numbers.max())\n    var scale: Double = max - min\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number / scale)\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp22ge962t.swift:7:38: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    var min: Double = Double(numbers.min())\n\
    \                                     ^\n/tmp/tmp22ge962t.swift:7:38: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ var min: Double = Double(numbers.min())\n                                  \
    \   ^\n                                           ?? <#default value#>\n/tmp/tmp22ge962t.swift:7:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var min: Double = Double(numbers.min())\n                       \
    \              ^\n                                          !\n/tmp/tmp22ge962t.swift:8:38:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    var max: Double = Double(numbers.max())\n                    \
    \                 ^\n/tmp/tmp22ge962t.swift:8:38: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    var max: Double\
    \ = Double(numbers.max())\n                                     ^\n          \
    \                                 ?? <#default value#>\n/tmp/tmp22ge962t.swift:8:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var max: Double = Double(numbers.max())\n                       \
    \              ^\n                                          !\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1238vorf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1238vorf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp1238vorf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number))\n    }\n    return rescaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpchz6qit7.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpaoptdl6z.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpaoptdl6z.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpaoptdl6z.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013726
