language: swift
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var result = 0\n    for digit in digits {\n        switch digit {\n     \
    \   case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\"\
    :\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case\
    \ \"7\":\n        case \"8\":\n        case \"9\":\n        case \"A\":\n    \
    \    case \"B\":\n        case \"C\":\n        case \"D\":\n        case \"E\"\
    :\n        case \"F\":\n            result += 1\n        default:\n          \
    \  break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpqfx4_xap.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpqfx4_xap.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqfx4_xap.swift:40:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { $0.value }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < hexDigitPrimeCount {\n        return 0\n    }\n    return\
    \ hexDigitPrimes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpatsz7pgx.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpatsz7pgx.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpatsz7pgx.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [String]\
    \ = []\n    for char in num {\n        hexDigits.append(String(char))\n    }\n\
    \    hexDigits.sort()\n    var primeCount = 0\n    for digit in hexDigits {\n\
    \        if digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"\
    D\" || digit == \"E\" || digit == \"F\" {\n            continue\n        }\n \
    \       var prime = true\n        for index in 0..<hexDigits.count {\n       \
    \     if hexDigits[index] == digit {\n                prime = false\n        \
    \        break\n            }\n        }\n        if prime {\n            primeCount\
    \ += 1\n        }\n    }\n    return primeCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmph3yjxjjo/tmph3yjxjjo.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56bed1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56bea16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56bea16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56bea157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph3yjxjjo                        0x000055f396e929d4 <unavailable> + 6612

    5    libc.so.6                          0x00002b56bef0b460 __libc_start_main +
    245

    6    tmph3yjxjjo                        0x000055f396e92659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let len = digits.count\n    var primes = 0\n    var prime: Int = 0\n    var\
    \ prime_digit: Int = 0\n    var prime_digit_count: Int = 0\n    var prime_digit_sum:\
    \ Int = 0\n    var prime_digit_product: Int = 0\n    var prime_digit_product2:\
    \ Int = 0\n    var prime_digit_product3: Int = 0\n    var prime_digit_product4:\
    \ Int = 0\n    var prime_digit_product5: Int = 0\n    var prime_digit_product6:\
    \ Int = 0\n    var prime_digit_product7: Int = 0\n    var prime_digit_product8:\
    \ Int = 0\n    var prime_digit_product9: Int = 0\n    var prime_digit_product10:\
    \ Int = 0\n    var prime_digit_product11: Int = 0\n    var prime_digit_product12:\
    \ Int = 0\n    var prime_digit_product13: Int = 0\n    var prime_digit_product14:\
    \ Int = 0\n    var prime_digit_product15: Int = 0\n    var prime_digit_product16:\
    \ Int = 0\n    var prime_digit_product17: Int = 0\n    var prime_digit_product18:\
    \ Int = 0\n    var prime_digit_product19: Int = 0\n    var prime_digit_product20:\
    \ Int = 0\n    var prime_digit_product21: Int = 0\n    var prime_digit_product22:\
    \ Int = 0\n    var prime_digit_product23: Int = 0\n    var prime_digit_product24:\
    \ Int = 0\n    var prime_digit_product25: Int = 0\n    var prime_digit_product26:\
    \ Int = 0\n    var prime_digit_product27: Int = 0\n    var prime_digit_product28:\
    \ Int = 0\n    var prime_digit_product29: Int = 0\n    var prime_digit_product30:\
    \ Int = 0\n    var prime_digit_product31: Int = 0\n    var prime_digit_product32:\
    \ Int = 0\n    var prime_digit_product33: Int = 0\n    var prime_digit_product34:\
    \ Int = 0\n    var prime_digit_product35: Int = 0\n    var prime_digit_product36:\
    \ Int = 0\n    var prime_digit_product37: Int = 0\n    var prime_digit_product38:\
    \ Int = 0\n    var prime_digit_product39: Int = 0\n    var prime_digit_product40:\
    \ Int = 0\n    var prime_digit_product41: Int = 0\n    var prime_digit_product42:\
    \ Int = 0\n    var prime_digit_product43: Int = 0\n    var prime_digit_product44:\
    \ Int = 0\n    var prime_digit_product45: Int = 0\n    var prime_digit_product46:\
    \ Int = 0\n    var prime_digit_product47: Int = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbctmpo0p.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbctmpo0p.swift:25:9:\
    \ warning: initialization of immutable value 'len' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let len = digits.count\n    ~~~~^~~\n\
    \    _\n/tmp/tmpbctmpo0p.swift:26:9: warning: initialization of variable 'primes'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primes = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmpbctmpo0p.swift:27:9: warning:\
    \ variable 'prime' was never used; consider replacing with '_' or removing it\n\
    \    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmpbctmpo0p.swift:28:9:\
    \ warning: variable 'prime_digit' was never used; consider replacing with '_'\
    \ or removing it\n    var prime_digit: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpbctmpo0p.swift:29:9: warning: variable 'prime_digit_count' was never used;\
    \ consider replacing with '_' or removing it\n    var prime_digit_count: Int =\
    \ 0\n        ^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpbctmpo0p.swift:30:9: warning:\
    \ variable 'prime_digit_sum' was never used; consider replacing with '_' or removing\
    \ it\n    var prime_digit_sum: Int = 0\n        ^~~~~~~~~~~~~~~\n        _\n/tmp/tmpbctmpo0p.swift:31:9:\
    \ warning: variable 'prime_digit_product' was never used; consider replacing with\
    \ '_' or removing it\n    var prime_digit_product: Int = 0\n        ^~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpbctmpo0p.swift:32:9: warning: variable 'prime_digit_product2'\
    \ was never used; consider replacing with '_' or removing it\n    var prime_digit_product2:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpbctmpo0p.swift:33:9:\
    \ warning: variable 'prime_digit_product3' was never used; consider replacing\
    \ with '_' or removing it\n    var prime_digit_product3: Int = 0\n        ^~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpbctmpo0p.swift:34:9: warning:"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = [Int]()\n    var primes_count = 0\n    var primes_sum = 0\n\
    \    var primes_sum2 = 0\n    var primes_sum3 = 0\n    var primes_sum4 = 0\n \
    \   var primes_sum5 = 0\n    var primes_sum6 = 0\n    var primes_sum7 = 0\n  \
    \  var primes_sum8 = 0\n    var primes_sum9 = 0\n    var primes_sum10 = 0\n  \
    \  var primes_sum11 = 0\n    var primes_sum12 = 0\n    var primes_sum13 = 0\n\
    \    var primes_sum14 = 0\n    var primes_sum15 = 0\n    var primes_sum16 = 0\n\
    \    var primes_sum17 = 0\n    var primes_sum18 = 0\n    var primes_sum19 = 0\n\
    \    var primes_sum20 = 0\n    var primes_sum21 = 0\n    var primes_sum22 = 0\n\
    \    var primes_sum23 = 0\n    var primes_sum24 = 0\n    var primes_sum25 = 0\n\
    \    var primes_sum26 = 0\n    var primes_sum27 = 0\n    var primes_sum28 = 0\n\
    \    var primes_sum29 = 0\n    var primes_sum30 = 0\n    var primes_sum31 = 0\n\
    \    var primes_sum32 = 0\n    var primes_sum33 = 0\n    var primes_sum34 = 0\n\
    \    var primes_sum35 = 0\n    var primes_sum36 = 0\n    var primes_sum37 = 0\n\
    \    var primes_sum38 = 0\n    var primes_sum39 = 0\n    var primes_sum40 = 0\n\
    \    var primes_sum41 = 0\n    var primes_sum42 = 0\n    var primes_sum43 = 0\n\
    \    var primes_sum44 = 0\n    var primes_sum45 = 0\n    var primes_sum46 = 0\n\
    \    var primes_sum47 = 0\n    var primes_sum48 = 0\n    var primes_sum49 = 0\n\
    \    var primes_sum50 = 0\n    var primes_sum51 = 0\n    var primes_sum52 = 0\n\
    \    var primes_sum53 = 0\n    var primes_sum54 = 0\n    var primes_sum55 = 0\n\
    \    var primes_sum56 = 0\n    var primes_sum57 = 0\n    var primes_sum58 = 0\n\
    \    var primes_sum59 = 0\n    var primes_sum60 = 0\n    var primes_sum61 = 0\n\
    \    var primes_sum62 = 0\n    var primes_sum63 = 0\n    var primes_sum64 = 0\n\
    \    var primes_sum65 = 0\n    var primes_sum66 = 0\n    var primes_sum67 = 0\n\
    \    var primes_sum68 = 0\n    var primes_sum69 = 0\n    var primes_sum70 = 0\n\
    \    var primes_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpiwoa3y5f.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpiwoa3y5f.swift:97:9:\
    \ error: type annotation missing in pattern\n    var primes_sum\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        let hex = nums[_]\n\
    \        if hex >= '0' && hex <= '9' {\n            count += 1\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpociguo0e.swift:28:19: error: single-quoted string literal found,\
    \ use '\"'\n        if hex >= '0' && hex <= '9' {\n                  ^~~\n   \
    \               \"0\"\n/tmp/tmpociguo0e.swift:28:33: error: single-quoted string\
    \ literal found, use '\"'\n        if hex >= '0' && hex <= '9' {\n           \
    \                     ^~~\n                                \"9\"\n/tmp/tmpociguo0e.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpociguo0e.swift:27:24: error: '_' can only appear in\
    \ a pattern or on the left side of an assignment\n        let hex = nums[_]\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.characters\n\
    \    var hexNumLen = hexNum.count\n    var hexNumStr = \"\"\n    var hexNumStrLen\
    \ = 0\n    var hexNumStrChar = \"\"\n    var hexNumStrCharLen = 0\n    var hexNumStrCharChar\
    \ = \"\"\n    var hexNumStrCharCharLen = 0\n    var hexNumStrCharCharLen = 0\n\
    \    var hexNumStrCharCharChar = \"\"\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var hexNumStrCharCharCharLen = 0\n    var hexNumStrCharCharCharLen = 0\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfw5c14im.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpfw5c14im.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexNum = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfw5c14im.swift:32:9:\
    \ error: invalid redeclaration of 'hexNumStrCharCharLen'\n    var hexNumStrCharCharLen\
    \ = 0\n        ^\n/tmp/tmpfw5c14im.swift:31:9: note: 'hexNumStrCharCharLen' previously\
    \ declared here\n    var hexNumStrCharCharLen = 0\n        ^\n/tmp/tmpfw5c14im.swift:35:9:\
    \ error: invalid redeclaration of 'hexNumStrCharCharCharLen'\n    var hexNumStrCharCharCharLen\
    \ = 0\n        ^\n/tmp/tmpfw5c14im.swift:34:9: note: 'hexNumStrCharCharCharLen'\
    \ previously declared here\n    var hexNumStrCharCharCharLen = 0\n        ^\n\
    /tmp/tmpfw5c14im.swift:36:9: error: invalid redeclaration of 'hexNumStrCharCharCharLen'\n\
    \    var hexNumStrCharCharCharLen = 0\n        ^\n/tmp/tmpfw5c14im.swift:34:9:\
    \ note: 'hexNumStrCharCharCharLen' previously declared here\n    var hexNumStrCharCharCharLen\
    \ = 0\n        ^\n/tmp/tmpfw5c14im.swift:37:9: error: invalid redeclaration of\
    \ 'hexNumStrCharCharCharLen'\n    var hexNumStrCharCharCharLen = 0\n        ^\n\
    /tmp/tmpfw5c14im.swift:34:9: note: 'hexNumStrCharCharCharLen' previously declared\
    \ here\n    var hexNumStrCharCharCharLen = 0\n        ^\n/tmp/tmpfw5c14im.swift:38:9:\
    \ error: invalid redeclaration of 'hexNumStrCharCharCharLen'\n    var hexNumStrCharCharCharLen\
    \ = 0\n        ^\n/tmp/tmpfw5c14im.swift:34:9: note: 'hexNumStrCharCharCharLen'\
    \ previously declared here\n    var hexNumStrCharCharCharLen = 0\n        ^\n\
    /tmp/tmpfw5c14im.swift:39:9: error: invalid redeclaration of 'hexNumStrCharCharCharLen'\n\
    \    var hexNumStrCharCharCharLen = 0\n        ^\n/tmp/tmpfw5c14im.swift:34:9:\
    \ note: 'hexNumStrCharCharCharLen' previously declared here\n    var hexNumStrCharCharCharLen\
    \ = 0\n        ^\n/tmp/tmpfw5c14im.swift:40:9: error: invalid redeclaration of\
    \ 'hexNumStrCharCharCharLen'\n    va"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var prime_count = 0\n    var prime_digits = 0\n    var prime_digit = 0\n\
    \    var prime_digit_count = 0\n    var prime_digit_count_max = 0\n    var prime_digit_count_min\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\
    \ = 0\n    var prime_digit_count_min_index = 0\n    var prime_digit_count_max_index\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp80x1qet8.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp80x1qet8.swift:33:9:\
    \ error: invalid redeclaration of 'prime_digit_count_min_index'\n    var prime_digit_count_min_index\
    \ = 0\n        ^\n/tmp/tmp80x1qet8.swift:31:9: note: 'prime_digit_count_min_index'\
    \ previously declared here\n    var prime_digit_count_min_index = 0\n        ^\n\
    /tmp/tmp80x1qet8.swift:34:9: error: invalid redeclaration of 'prime_digit_count_max_index'\n\
    \    var prime_digit_count_max_index = 0\n        ^\n/tmp/tmp80x1qet8.swift:32:9:\
    \ note: 'prime_digit_count_max_index' previously declared here\n    var prime_digit_count_max_index\
    \ = 0\n        ^\n/tmp/tmp80x1qet8.swift:35:9: error: invalid redeclaration of\
    \ 'prime_digit_count_min_index'\n    var prime_digit_count_min_index = 0\n   \
    \     ^\n/tmp/tmp80x1qet8.swift:31:9: note: 'prime_digit_count_min_index' previously\
    \ declared here\n    var prime_digit_count_min_index = 0\n        ^\n/tmp/tmp80x1qet8.swift:36:9:\
    \ error: invalid redeclaration of 'prime_digit_count_max_index'\n    var prime_digit_count_max_index\
    \ = 0\n        ^\n/tmp/tmp80x1qet8.swift:32:9: note: 'prime_digit_count_max_index'\
    \ previously declared here\n    var prime_digit_count_max_index = 0\n        ^\n\
    /tmp/tmp80x1qet8.swift:37:9: error: invalid redeclaration of 'prime_digit_count_min_index'\n\
    \    var prime_digit_count_min_index = 0\n        ^\n/tmp/tmp80x1qet8.swift:31:9:\
    \ note: 'prime_digit_count_min_index' previously declared here\n    var prime_digit_count_min_index\
    \ = 0\n        ^\n/tmp/tmp80x1qet8.swift:38:9: error: invalid redeclaration of\
    \ 'prime_digit_count_max_index'\n    var prime_digit_count_max_index = 0\n   \
    \     ^\n/tmp/tmp80x1qet8.swift:32:9: note: 'prime_digit_count_max_index' previously\
    \ declared here\n    var prime_digit_count_max_index = 0\n        ^\n/tmp/tmp80x1qet8.swift:39:9:\
    \ error: invalid redeclaration of 'prime_digit_cou"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  let digits = num.characters\n    var count = 0\n    for digit in digits {\n\
    \        if digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"\
    D\" || digit == \"E\" || digit == \"F\" {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppgj28og1.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    var numsCount = 0\n    var numsCount2 = 0\n    var numsCount3 = 0\n    var\
    \ numsCount4 = 0\n    var numsCount5 = 0\n    var numsCount6 = 0\n    var numsCount7\
    \ = 0\n    var numsCount8 = 0\n    var numsCount9 = 0\n    var numsCount10 = 0\n\
    \    var numsCount11 = 0\n    var numsCount12 = 0\n    var numsCount13 = 0\n \
    \   var numsCount14 = 0\n    var numsCount15 = 0\n    var numsCount16 = 0\n  \
    \  var numsCount17 = 0\n    var numsCount18 = 0\n    var numsCount19 = 0\n   \
    \ var numsCount20 = 0\n    var numsCount21 = 0\n    var numsCount22 = 0\n    var\
    \ numsCount23 = 0\n    var numsCount24 = 0\n    var numsCount25 = 0\n    var numsCount26\
    \ = 0\n    var numsCount27 = 0\n    var numsCount28 = 0\n    var numsCount29 =\
    \ 0\n    var numsCount30 = 0\n    var numsCount31 = 0\n    var numsCount32 = 0\n\
    \    var numsCount33 = 0\n    var numsCount34 = 0\n    var numsCount35 = 0\n \
    \   var numsCount36 = 0\n    var numsCount37 = 0\n    var numsCount38 = 0\n  \
    \  var numsCount39 = 0\n    var numsCount40 = 0\n    var numsCount41 = 0\n   \
    \ var numsCount42 = 0\n    var numsCount43 = 0\n    var numsCount44 = 0\n    var\
    \ numsCount45 = 0\n    var numsCount46 = 0\n    var numsCount47 = 0\n    var numsCount48\
    \ = 0\n    var numsCount49 = 0\n    var numsCount50 = 0\n    var numsCount51 =\
    \ 0\n    var numsCount52 = 0\n    var numsCount53 = 0\n    var numsCount54 = 0\n\
    \    var numsCount55 = 0\n    var numsCount56 = 0\n    var numsCount57 = 0\n \
    \   var numsCount58 = 0\n    var numsCount59 = 0\n    var numsCount60 = 0\n  \
    \  var numsCount61 = 0\n    var numsCount62 = 0\n    var numsCount63 = 0\n   \
    \ var numsCount64 = 0\n    var numsCount65 = 0\n    var numsCount66 = 0\n    var\
    \ numsCount67 = 0\n    var numsCount68 = 0\n    var numsCount69 = 0\n    var numsCount70\
    \ = 0\n    var numsCount71 = 0\n    var numsCount72 = 0\n    var nums\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp301_o5iu.swift:97:9: error: type annotation missing in pattern\n\
    \    var nums\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = \"\"\n    for char in num {\n        if char == \"A\" || char == \"\
    B\" || char == \"C\" || char == \"D\" || char == \"E\" || char == \"F\" {\n  \
    \          digits = char\n        } else {\n            digits += char\n     \
    \   }\n    }\n    for char in digits {\n        if char == \"0\" || char == \"\
    1\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphq60992n.swift:28:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            digits = char\n                     ^~~~\n/tmp/tmphq60992n.swift:30:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            digits += char\n                      ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\
    \ // char is 'A'\n        if char.uppercased() == \"A\" {\n            count +=\
    \ 2\n        } else if char.uppercased() == \"B\" {\n            count += 3\n\
    \        } else if char.uppercased() == \"C\" {\n            count += 5\n    \
    \    } else if char.uppercased() == \"D\" {\n            count += 7\n        }\
    \ else if char.uppercased() == \"E\" {\n            count += 11\n        } else\
    \ if char.uppercased() == \"F\" {\n            count += 13\n        } else {\n\
    \            count += char.uppercased() - '0'\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5mqhixkf.swift:41:42: error: single-quoted string literal found,\
    \ use '\"'\n            count += char.uppercased() - '0'\n                   \
    \                      ^~~\n                                         \"0\"\n/tmp/tmp5mqhixkf.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5mqhixkf.swift:27:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ char = nums[index] // char is 'A'\n                   ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5mqhixkf.swift:41:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'Int' and\
    \ '_'\n            count += char.uppercased() - '0'\n            ~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num.characters {\n        switch char {\n        case \"A\":\n          \
    \  sum += 2\n        case \"B\":\n            sum += 3\n        case \"C\":\n\
    \            sum += 5\n        case \"D\":\n            sum += 7\n        case\
    \ \"E\":\n            sum += 11\n        case \"F\":\n            sum += 13\n\
    \        default:\n            sum += char.unicodeScalars.filter({$0.isPrime}).count\n\
    \        }\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppfgkiw1c.swift:25:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in num.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppfgkiw1c.swift:40:51:\
    \ error: value of type 'Unicode.Scalar' has no member 'isPrime'\n            sum\
    \ += char.unicodeScalars.filter({$0.isPrime}).count\n                        \
    \                       ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var prime = primes[0]\n\
    \    for _ in 0..<nums.count {\n        switch nums[_] {\n        case \"A\":\n\
    \            prime = primes[1]\n        case \"B\":\n            prime = primes[2]\n\
    \        case \"C\":\n            prime = primes[3]\n        case \"D\":\n   \
    \         prime = primes[4]\n        case \"E\":\n            prime = primes[5]\n\
    \        case \"F\":\n            prime = primes[6]\n        default:\n      \
    \      break\n        }\n        if prime > 1 {\n            count += 1\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpuhn_thum.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpuhn_thum.swift:29:21:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        switch nums[_] {\n                    ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    var count = 0\n    for char in hex.unicodeScalars\
    \ {\n        guard let num = Int(char.value, radix: 16) else {\n            continue\n\
    \        }\n        if num == 2 {\n            count += 1\n        } else if num\
    \ == 3 {\n            count += 1\n        } else if num == 5 {\n            count\
    \ += 1\n        } else if num == 7 {\n            count += 1\n        } else if\
    \ num == 11 {\n            count += 1\n        } else if num == 13 {\n       \
    \     count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpw9loympr.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpw9loympr.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var nums_len = num.characters.count\n    for i in 0..<nums_len {\n       \
    \ let c = num.characters[i]\n        if c >= '0' && c <= '9' {\n            nums.append(Int(c)\
    \ - 48)\n        }\n    }\n    var primes = [Int]()\n    var primes_len = nums.count\n\
    \    for i in 0..<primes_len {\n        let c = nums[i]\n        if c >= 2 &&\
    \ c <= 9 {\n            primes.append(c)\n        }\n    }\n    var result = 0\n\
    \    for i in 0..<primes_len {\n        let c = primes[i]\n        if c >= 2 &&\
    \ c <= 9 {\n            let n = nums[i]\n            if n % c == 0 {\n       \
    \         result += c\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpimtnbxsp.swift:28:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpimtnbxsp.swift:28:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpimtnbxsp.swift:25:24: error:\
    \ 'characters' is unavailable: Please use String directly\n    var nums_len =\
    \ num.characters.count\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpimtnbxsp.swift:27:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let c = num.characters[i]\n                ^~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpimtnbxsp.swift:27:21:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ c = num.characters[i]\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpimtnbxsp.swift:29:25: error: no exact matches\
    \ in call to initializer \n            nums.append(Int(c) - 48)\n            \
    \            ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'B"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var i = 0\n    for _ in 0..<nums.count {\n        let\
    \ c = nums[i]\n        switch c {\n        case \"A\":\n            result +=\
    \ 2\n        case \"B\":\n            result += 3\n        case \"C\":\n     \
    \       result += 5\n        case \"D\":\n            result += 7\n        case\
    \ \"E\":\n            result += 11\n        case \"F\":\n            result +=\
    \ 13\n        default:\n            result += Int(c)!\n        }\n        i +=\
    \ 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3l9me_dl.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3l9me_dl.swift:28:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let c = nums[i]\n                ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3l9me_dl.swift:43:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += Int(c)!\n                          ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    for c in num {\n        let digit = Int(c)\n        if digit < 48 || digit\
    \ > 57 {\n            return 0\n        }\n        nums.append(digit)\n    }\n\
    \    var result = 0\n    for digit in nums {\n        if isPrime(digit) {\n  \
    \          result += digit\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmprnodse4e.swift:26:21: error: no exact matches in call to initializer\
    \ \n        let digit = Int(c)\n                    ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\nSwift.FixedWidthInteger:3:23: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Character')\n    @inlinable public init?(_ description:\
    \ String)\n                      ^\n/tmp/tmprnodse4e.swift:34:12: error: cannot\
    \ find 'isPrime' in scope\n        if isPrime(digit) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for _ in 0..<nums.count\
    \ {\n        let digit = Int(nums[_], radix: 16)\n        if digit == 0 || digit\
    \ == 1 {\n            count += 1\n        } else {\n            for prime in primes\
    \ {\n                if digit % prime == 0 {\n                    count += 1\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpuyjrwdoi.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpuyjrwdoi.swift:28:30:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = Int(nums[_], radix: 16)\n                             ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var numAsString = \"\"\
    \n    for char in num {\n        if char >= '0' && char <= '9' {\n           \
    \ numAsString += char\n        }\n    }\n    var numAsInt = Int(numAsString)\n\
    \    var numAsInt2 = numAsInt * numAsInt\n    var numAsInt3 = numAsInt2 * numAsInt\n\
    \    var numAsInt4 = numAsInt3 * numAsInt\n    var numAsInt5 = numAsInt4 * numAsInt\n\
    \    var numAsInt6 = numAsInt5 * numAsInt\n    var numAsInt7 = numAsInt6 * numAsInt\n\
    \    var numAsInt8 = numAsInt7 * numAsInt\n    var numAsInt9 = numAsInt8 * numAsInt\n\
    \    var numAsInt10 = numAsInt9 * numAsInt\n    var numAsInt11 = numAsInt10 *\
    \ numAsInt\n    var numAsInt12 = numAsInt11 * numAsInt\n    var numAsInt13 = numAsInt12\
    \ * numAsInt\n    var numAsInt14 = numAsInt13 * numAsInt\n    var numAsInt15 =\
    \ numAsInt14 * numAsInt\n    var numAsInt16 = numAsInt15 * numAsInt\n    var numAsInt17\
    \ = numAsInt16 * numAsInt\n    var numAsInt18 = numAsInt17 * numAsInt\n    var\
    \ numAsInt19 = numAsInt18 * numAsInt\n    var numAsInt20 = numAsInt19 * numAsInt\n\
    \    var numAsInt21 = numAsInt20 * numAsInt\n    var numAsInt22 = numAsInt21 *\
    \ numAsInt\n    var numAsInt23 = numAsInt22 * numAsInt\n    var numAsInt24 = numAsInt23\
    \ * numAsInt\n    var numAsInt25 = numAsInt24 * numAsInt\n    var numAsInt26 =\
    \ numAsInt25 * numAsInt\n    var numAsInt27 = numAsInt26 * numAsInt\n    var numAsInt28\
    \ = numAsInt27 * numAsInt\n    var numAsInt29 = numAsInt28 * numAsInt\n    var\
    \ numAsInt30 = numAsInt29 * numAsInt\n    var numAsInt31 = numAsInt30 * numAsInt\n\
    \    var numAsInt32 = numAsInt31 * numAsInt\n    var numAsInt33 = numAsInt32 *\
    \ numAsInt\n    var numAsInt34 = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpumtztoiv.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpumtztoiv.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpumtztoiv.swift:63:21: error: expected initial value after '='\n    var\
    \ numAsInt34 = \n                    ^\n/tmp/tmpumtztoiv.swift:27:28: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       numAsString += char\n                           ^\n/tmp/tmpumtztoiv.swift:31:30:\
    \ error: binary operator '*' cannot be applied to two 'Int?' operands\n    var\
    \ numAsInt2 = numAsInt * numAsInt\n                    ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpumtztoiv.swift:31:30:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    var numAsInt2 = numAsInt * numAsInt\n                      \
    \       ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var primesSet =\
    \ Set(primes)\n    for char in nums {\n        if primesSet.contains(Int(char))\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2wgtv3bk.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2wgtv3bk.swift:29:31:\
    \ error: no exact matches in call to initializer \n        if primesSet.contains(Int(char))\
    \ {\n                              ^\nSwift.Int:7:12: note: candidate expects\
    \ value of type 'Float16' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value\
    \ of type 'Float' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float)\n           ^\nSwift.Int:12:12: note: candidate expects value of type\
    \ 'Double' for parameter #1 (got 'Character')\n    public init(_ source: Double)\n\
    \           ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n   \
    \        ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ count = 0\n    var prime = 0\n    var prime_found = false\n    var prime_found2\
    \ = false\n    var prime_found3 = false\n    var prime_found4 = false\n    var\
    \ prime_found5 = false\n    var prime_found6 = false\n    var prime_found7 = false\n\
    \    var prime_found8 = false\n    var prime_found9 = false\n    var prime_found10\
    \ = false\n    var prime_found11 = false\n    var prime_found12 = false\n    var\
    \ prime_found13 = false\n    var prime_found14 = false\n    var prime_found15\
    \ = false\n    var prime_found16 = false\n    var prime_found17 = false\n    var\
    \ prime_found18 = false\n    var prime_found19 = false\n    var prime_found20\
    \ = false\n    var prime_found21 = false\n    var prime_found22 = false\n    var\
    \ prime_found23 = false\n    var prime_found24 = false\n    var prime_found25\
    \ = false\n    var prime_found26 = false\n    var prime_found27 = false\n    var\
    \ prime_found28 = false\n    var prime_found29 = false\n    var prime_found30\
    \ = false\n    var prime_found31 = false\n    var prime_found32 = false\n    var\
    \ prime_found33 = false\n    var prime_found34 = false\n    var prime_found35\
    \ = false\n    var prime_found36 = false\n    var prime_found37 = false\n    var\
    \ prime_found38 = false\n    var prime_found39 = false\n    var prime_found40\
    \ = false\n    var prime_found41 = false\n    var prime_found42 = false\n    var\
    \ prime_found43 = false\n    var prime_found44 = false\n    var prime_found45\
    \ = false\n    var prime_found46 = false\n    var prime_found47 = false\n    var\
    \ prime_found48 = false\n    var prime_found49 = false\n    var prime_found50\
    \ = false\n    var prime_found51 = false\n    var prime_found52 = false\n    var\
    \ prime_found53 = false\n    var prime_found54 = false\n    var prime_found55\
    \ = false\n    var prime_found56 = false\n    var prime_found57 = false\n    var\
    \ prime_found58 = false\n    var prime_found59 = false\n    var prime_found60\
    \ = false\n    var prime_found61 = false\n    var prime_found62 = false\n    var\
    \ prime_found63 = false\n    var prime_found64 = false\n    var prime_found65\
    \ = false\n    var prime_found66 = false\n    var prime_\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpomon41yt.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmpomon41yt.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpomon41yt.swift:95:9:\
    \ error: type annotation missing in pattern\n    var prime_\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for index in 0..<digits.count {\n        let digit\
    \ = digits[index]\n        if digit == \"A\" {\n            result += 2\n    \
    \    } else if digit == \"B\" {\n            result += 3\n        } else if digit\
    \ == \"C\" {\n            result += 5\n        } else if digit == \"D\" {\n  \
    \          result += 7\n        } else if digit == \"E\" {\n            result\
    \ += 11\n        } else if digit == \"F\" {\n            result += 13\n      \
    \  } else {\n            result += digit.unicodeScalars.filter({$0.isUppercase}).count\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9a1m_0xy.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9a1m_0xy.swift:27:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[index]\n           \
    \         ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp9a1m_0xy.swift:41:55: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            result += digit.unicodeScalars.filter({$0.isUppercase}).count\n\
    \                                                   ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    \n    var count = 0\n    \n    for char\
    \ in num {\n        guard let int = Int(char) else {\n            return 0\n \
    \       }\n        \n        if int % 2 == 0 {\n            count += 1\n     \
    \   }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6902umvu.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmp6902umvu.swift:31:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        guard let int = Int(char) else {\n                            ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count = count + Int(c\
    \ - '0')\n        } else if c >= 'A' && c <= 'F' {\n            count = count\
    \ + Int(c - 'A') + 10\n        } else if c >= 'a' && c <= 'f' {\n            count\
    \ = count + Int(c - 'a') + 10\n        } else {\n            return -1\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp75zq1_ic.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmp75zq1_ic.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmp75zq1_ic.swift:27:37: error:\
    \ single-quoted string literal found, use '\"'\n            count = count + Int(c\
    \ - '0')\n                                    ^~~\n                          \
    \          \"0\"\n/tmp/tmp75zq1_ic.swift:28:24: error: single-quoted string literal\
    \ found, use '\"'\n        } else if c >= 'A' && c <= 'F' {\n                \
    \       ^~~\n                       \"A\"\n/tmp/tmp75zq1_ic.swift:28:36: error:\
    \ single-quoted string literal found, use '\"'\n        } else if c >= 'A' &&\
    \ c <= 'F' {\n                                   ^~~\n                       \
    \            \"F\"\n/tmp/tmp75zq1_ic.swift:29:37: error: single-quoted string\
    \ literal found, use '\"'\n            count = count + Int(c - 'A') + 10\n   \
    \                                 ^~~\n                                    \"\
    A\"\n/tmp/tmp75zq1_ic.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmp75zq1_ic.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmp75zq1_ic.swift:31:37: error: single-quoted string literal found,\
    \ use '\"'\n            count = count + Int(c - 'a') + 10\n                  \
    \                  ^~~\n                                    \"a\"\n/tmp/tmp75zq1_ic.swift:27:35:\
    \ error: binary operator '-' cannot be applied to two 'Character' operands\n \
    \           count = count + Int(c - '0')\n                                ~ ^\
    \ ~~~\n/tmp/tmp75zq1_ic.swift:29:35: error: binary operator '-' cannot be applied\
    \ to two 'Character' operands\n            count = count + Int(c - 'A') + 10\n\
    \             "
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num\n   \
    \ var count = 0\n    for char in hexNum {\n        switch char {\n        case\
    \ \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n    \
    \    case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\"\
    :\n        case \"8\":\n        case \"9\":\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpep_0qiph.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpep_0qiph.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpep_0qiph.swift:24:9:\
    \ warning: variable 'hexNum' was never mutated; consider changing to 'let' constant\n\
    \    var hexNum = num\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var numStr = \"\"\n    var i = 0\n    for c in num {\n        if c.isUpper()\
    \ {\n            numStr += c.lowercased()\n        } else {\n            numStr\
    \ += c\n        }\n    }\n    for c in numStr {\n        if c.isDigit() {\n  \
    \          nums.append(Int(c))\n        }\n    }\n    for num in nums {\n    \
    \    if num == 2 {\n            return num\n        }\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8gituimt.swift:28:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n/tmp/tmp8gituimt.swift:31:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            numStr += c\n                      ^\n/tmp/tmp8gituimt.swift:35:14:\
    \ error: value of type 'Character' has no member 'isDigit'\n        if c.isDigit()\
    \ {\n           ~ ^~~~~~~\n/tmp/tmp8gituimt.swift:36:25: error: no exact matches\
    \ in call to initializer \n            nums.append(Int(c))\n                 \
    \       ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float16)\n       \
    \    ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects\
    \ value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public\
    \ init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate\
    \ expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n  \
    \  public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    var hexDigits = [UInt8]()\n    for digit in digits\
    \ {\n        hexDigits.append(UInt8(digit))\n    }\n    for hexDigit in hexDigits\
    \ {\n        if hexDigit % 2 == 0 {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpgpc2q2cr.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgpc2q2cr.swift:28:26:\
    \ error: no exact matches in call to initializer \n        hexDigits.append(UInt8(digit))\n\
    \                         ^\nSwift.UInt8:7:12: note: candidate expects value of\
    \ type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.UInt8:10:12: note: candidate expects value of\
    \ type 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.UInt8:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.UInt8:14:12: note: candidate expects value of type 'Float80'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n   \
    \        ^\nSwift.UInt8:28:12: note: candidate expects value of type 'Builtin.Int8'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int8)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digit = 0\n    for char in num {\n        digit = digit*16 + Int(char) - 48\n\
    \        if digit < 2 {\n            digit += 16\n        }\n        if digit\
    \ < 16 {\n            result += digit\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp35plqkjw.swift:27:28: error: no exact matches in call to initializer\
    \ \n        digit = digit*16 + Int(char) - 48\n                           ^\n\
    Swift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hex = num.uppercased()\n    for char in hex {\n        digit\
    \ = Int(char)\n        if digit == 0 || digit == 1 {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpj1xkvbhu.swift:28:17: error: no exact matches in call to initializer\
    \ \n        digit = Int(char)\n                ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.unicodeScalars.map\
    \ { $0.value }\n    let primes = primes_digits(digits)\n    let primesCount =\
    \ primes.count\n    let primesDigits = primes.map { digits[$0] }\n    let primesDigitCount\
    \ = primesDigits.count\n    let primesDigitSum = primesDigits.reduce(0) { $0 +\
    \ $1 }\n    let primesDigitSum2 = primesDigits.reduce(0) { $0 + $1 }\n    let\
    \ primesDigitSum3 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum4\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum5 = primesDigits.reduce(0)\
    \ { $0 + $1 }\n    let primesDigitSum6 = primesDigits.reduce(0) { $0 + $1 }\n\
    \    let primesDigitSum7 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum8\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum9 = primesDigits.reduce(0)\
    \ { $0 + $1 }\n    let primesDigitSum10 = primesDigits.reduce(0) { $0 + $1 }\n\
    \    let primesDigitSum11 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum12\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum13 = primesDigits.reduce(0)\
    \ { $0 + $1 }\n    let primesDigitSum14 = primesDigits.reduce(0) { $0 + $1 }\n\
    \    let primesDigitSum15 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum16\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum17 = primesDigits.reduce(0)\
    \ { $0 + $1 }\n    let primesDigitSum18 = primesDigits.reduce(0) { $0 + $1 }\n\
    \    let primesDigitSum19 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum20\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum21 = primesDigits.reduce(0)\
    \ { $0 + $1 }\n    let primesDigitSum22 = primesDigits.reduce(0) { $0 + $1 }\n\
    \    let primesDigitSum23 = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum24\
    \ = primesDigits.reduce(0) { $0 + $1 }\n    let primesDigitSum25 = primes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbaqohk7p.swift:25:18: error: cannot find 'primes_digits' in scope\n\
    \    let primes = primes_digits(digits)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        switch char {\n        case\
    \ \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n    \
    \    case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\"\
    :\n        case \"8\":\n        case \"9\":\n        case \"A\":\n        case\
    \ \"B\":\n        case \"C\":\n        case \"D\":\n        case \"E\":\n    \
    \    case \"F\":\n            count += 1\n        default:\n            break\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6amgjfm7.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp6amgjfm7.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp6amgjfm7.swift:40:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters\n\
    \    var hexCount = 1\n    var hexDigits = [UInt8](repeating: 0, count: hex.count)\n\
    \    var hexDigitIndex = 0\n    var hexDigitCount = 0\n    var hexDigitIndex2\
    \ = 0\n    var hexDigitCount2 = 0\n    var hexDigitIndex3 = 0\n    var hexDigitCount3\
    \ = 0\n    var hexDigitIndex4 = 0\n    var hexDigitCount4 = 0\n    var hexDigitIndex5\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitIndex6 = 0\n    var hexDigitCount6\
    \ = 0\n    var hexDigitIndex7 = 0\n    var hexDigitCount7 = 0\n    var hexDigitIndex8\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitIndex9 = 0\n    var hexDigitCount9\
    \ = 0\n    var hexDigitIndex10 = 0\n    var hexDigitCount10 = 0\n    var hexDigitIndex11\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitIndex12 = 0\n    var hexDigitCount12\
    \ = 0\n    var hexDigitIndex13 = 0\n    var hexDigitCount13 = 0\n    var hexDigitIndex14\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitIndex15 = 0\n    var hexDigitCount15\
    \ = 0\n    var hexDigitIndex16 = 0\n    var hexDigitCount16 = 0\n    var hexDigitIndex17\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitIndex18 = 0\n    var hexDigitCount18\
    \ = 0\n    var hexDigitIndex19 = 0\n    var hexDigitCount19 = 0\n    var hexDigitIndex20\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitIndex21 = 0\n    var hexDigitCount21\
    \ = 0\n    var hexDigitIndex22 = 0\n    var hexDigitCount22 = 0\n    var hexDigitIndex23\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitIndex24 = 0\n    var hexDigitCount24\
    \ = 0\n    var hexDigitIndex25 = 0\n    var hexDigitCount25 = 0\n    var hexDigitIndex26\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitIndex27 = 0\n    var hexDigitCount27\
    \ = 0\n    var hexDigitIndex28 = 0\n    var hexDigitCount28 = 0\n    var hexDigitIndex29\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitIndex30 = 0\n    var hexDigitCount30\
    \ = 0\n    var hexDigitIndex31 = 0\n    var hexDigitCount31 = 0\n    var hexDigitIndex32\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitIndex33 = 0\n    var hexDigitCount33\
    \ = 0\n    var hexDigitIndex34 = 0\n    var hexDigitCount34 = 0\n    var hexDigitIndex35\
    \ = 0\n    var hexDigitCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb_7pi41z.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb_7pi41z.swift:96:9:\
    \ error: type annotation missing in pattern\n    var hexDigitCount\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters.map\
    \ { String($0) }\n    hex.forEach { hex.removeFirst() }\n    hex.removeFirst()\n\
    \    var primes = hex.filter { $0.isPrime }\n    primes.forEach { hex.removeFirst()\
    \ }\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n   \
    \ hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n    hex.removeFirst()\n\
    \    hex.removeFirst()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9vftjwph.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters.map { String($0) }\n     \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9vftjwph.swift:25:17: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n    hex.forEach\
    \ { hex.removeFirst() }\n                ^\n                  _ in\n/tmp/tmp9vftjwph.swift:27:34:\
    \ error: value of type 'String' has no member 'isPrime'\n    var primes = hex.filter\
    \ { $0.isPrime }\n                              ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexNums = \"\"\n    var hexNumsCount\
    \ = \"\"\n    var hexNumsCount2 = \"\"\n    var hexNumsCount3 = \"\"\n    var\
    \ hexNumsCount4 = \"\"\n    var hexNumsCount5 = \"\"\n    var hexNumsCount6 =\
    \ \"\"\n    var hexNumsCount7 = \"\"\n    var hexNumsCount8 = \"\"\n    var hexNumsCount9\
    \ = \"\"\n    var hexNumsCount10 = \"\"\n    var hexNumsCount11 = \"\"\n    var\
    \ hexNumsCount12 = \"\"\n    var hexNumsCount13 = \"\"\n    var hexNumsCount14\
    \ = \"\"\n    var hexNumsCount15 = \"\"\n    var hexNumsCount16 = \"\"\n    var\
    \ hexNumsCount17 = \"\"\n    var hexNumsCount18 = \"\"\n    var hexNumsCount19\
    \ = \"\"\n    var hexNumsCount20 = \"\"\n    var hexNumsCount21 = \"\"\n    var\
    \ hexNumsCount22 = \"\"\n    var hexNumsCount23 = \"\"\n    var hexNumsCount24\
    \ = \"\"\n    var hexNumsCount25 = \"\"\n    var hexNumsCount26 = \"\"\n    var\
    \ hexNumsCount27 = \"\"\n    var hexNumsCount28 = \"\"\n    var hexNumsCount29\
    \ = \"\"\n    var hexNumsCount30 = \"\"\n    var hexNumsCount31 = \"\"\n    var\
    \ hexNumsCount32 = \"\"\n    var hexNumsCount33 = \"\"\n    var hexNumsCount34\
    \ = \"\"\n    var hexNumsCount35 = \"\"\n    var hexNumsCount36 = \"\"\n    var\
    \ hexNumsCount37 = \"\"\n    var hexNumsCount38 = \"\"\n    var hexNumsCount39\
    \ = \"\"\n    var hexNumsCount40 = \"\"\n    var hexNumsCount41 = \"\"\n    var\
    \ hexNumsCount42 = \"\"\n    var hexNumsCount43 = \"\"\n    var hexNumsCount44\
    \ = \"\"\n    var hexNumsCount45 = \"\"\n    var hexNumsCount46 = \"\"\n    var\
    \ hexNumsCount47 = \"\"\n    var hexNumsCount48 = \"\"\n    var hexNumsCount49\
    \ = \"\"\n    var hexNumsCount50 = \"\"\n    var hexNumsCount51 = \"\"\n    var\
    \ hexNumsCount52 = \"\"\n    var hexNumsCount53 = \"\"\n    var hexNumsCount54\
    \ = \"\"\n    var hexNumsCount55 = \"\"\n    var hexNumsCount56 = \"\"\n    var\
    \ hexNumsCount57 = \"\"\n    var hexNumsCount58 = \"\"\n    var hexNumsCount59\
    \ = \"\"\n    var hexNumsCount60 = \"\"\n    var hex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmprith_7ad.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprith_7ad.swift:87:9:\
    \ error: type annotation missing in pattern\n    var hex\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"A\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"B\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"C\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"D\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"E\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"F\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"0\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"1\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"2\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphh_x7o1i.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmphh_x7o1i.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmphh_x7o1i.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmphh_x7o1i.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmphh_x7o1i.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphh_x7o1i.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmphh_x7o1i.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmphh_x7o1i.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = \"\"\n\
    \    var primeDigits = 0\n    var primeNumber = 0\n    var hexNumber = 0\n   \
    \ var hexDigit = \"\"\n    var hexDigits = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmps8bssxqo.swift:29:9: error: invalid redeclaration of 'hexDigits'\n\
    \    var hexDigits = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:24:9: note: 'hexDigits'\
    \ previously declared here\n    var hexDigits = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:30:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:31:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmps8bssxqo.swift:32:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit'\
    \ previously declared here\n    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:33:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:34:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmps8bssxqo.swift:35:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit'\
    \ previously declared here\n    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:36:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:37:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmps8bssxqo.swift:38:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmps8bssxqo.swift:28:9: note: 'hexDigit'\
    \ previously declared here\n    va"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var primes = Set<Int>()\n    var prime: Int?\n    for\
    \ char in nums {\n        switch char {\n        case \"A\":\n        case \"\
    B\":\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n            prime = Int(char.uppercased())\n            primes.insert(prime!)\n\
    \        default:\n            prime = nil\n        }\n    }\n    for prime in\
    \ primes {\n        if nums.contains(String(prime)) {\n            result += prime\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpygvdzzey.swift:30:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpygvdzzey.swift:31:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpygvdzzey.swift:32:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpygvdzzey.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpygvdzzey.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpygvdzzey.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpygvdzzey.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = num[0]\n    for char in num {\n        switch char {\n        case \"\
    A\":\n            digit = \"0\"\n        case \"B\":\n            digit = \"1\"\
    \n        case \"C\":\n            digit = \"2\"\n        case \"D\":\n      \
    \      digit = \"3\"\n        case \"E\":\n            digit = \"4\"\n       \
    \ case \"F\":\n            digit = \"5\"\n        default:\n            digit\
    \ = char\n        }\n        if digit == \"0\" || digit == \"1\" {\n         \
    \   count += 2\n        } else if digit == \"2\" || digit == \"3\" {\n       \
    \     count += 1\n        } else if digit == \"4\" || digit == \"5\" {\n     \
    \       count += 3\n        } else if digit == \"6\" || digit == \"7\" {\n   \
    \         count += 5\n        } else if digit == \"8\" || digit == \"9\" {\n \
    \           count += 7\n        } else if digit == \"A\" || digit == \"B\" {\n\
    \            count += 11\n        } else if digit == \"C\" || digit == \"D\" {\n\
    \            count += 13\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1v4m5un1.swift:25:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var digit = num[0]\n\
    \                ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var nums2 = [Int]()\n    var nums3 = [Int]()\n    var nums4 = [Int]()\n  \
    \  var nums5 = [Int]()\n    var nums6 = [Int]()\n    var nums7 = [Int]()\n   \
    \ var nums8 = [Int]()\n    var nums9 = [Int]()\n    var nums10 = [Int]()\n   \
    \ var nums11 = [Int]()\n    var nums12 = [Int]()\n    var nums13 = [Int]()\n \
    \   var nums14 = [Int]()\n    var nums15 = [Int]()\n    var nums16 = [Int]()\n\
    \    var nums17 = [Int]()\n    var nums18 = [Int]()\n    var nums19 = [Int]()\n\
    \    var nums20 = [Int]()\n    var nums21 = [Int]()\n    var nums22 = [Int]()\n\
    \    var nums23 = [Int]()\n    var nums24 = [Int]()\n    var nums25 = [Int]()\n\
    \    var nums26 = [Int]()\n    var nums27 = [Int]()\n    var nums28 = [Int]()\n\
    \    var nums29 = [Int]()\n    var nums30 = [Int]()\n    var nums31 = [Int]()\n\
    \    var nums32 = [Int]()\n    var nums33 = [Int]()\n    var nums34 = [Int]()\n\
    \    var nums35 = [Int]()\n    var nums36 = [Int]()\n    var nums37 = [Int]()\n\
    \    var nums38 = [Int]()\n    var nums39 = [Int]()\n    var nums40 = [Int]()\n\
    \    var nums41 = [Int]()\n    var nums42 = [Int]()\n    var nums43 = [Int]()\n\
    \    var nums44 = [Int]()\n    var nums45 = [Int]()\n    var nums46 = [Int]()\n\
    \    var nums47 = [Int]()\n    var nums48 = [Int]()\n    var nums49 = [Int]()\n\
    \    var nums50 = [Int]()\n    var nums51 = [Int]()\n    var nums52 = [Int]()\n\
    \    var nums53 = [Int]()\n    var nums54 = [Int]()\n    var nums55 = [Int]()\n\
    \    var nums56 = [Int]()\n    var nums57 = [Int]()\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk6p5s8j3.swift:81:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpk6p5s8j3.swift:24:9: warning: initialization of variable 'nums' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ nums = [Int]()\n    ~~~~^~~~\n    _\n/tmp/tmpk6p5s8j3.swift:25:9: warning: initialization\
    \ of variable 'nums2' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var nums2 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:26:9:\
    \ warning: initialization of variable 'nums3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums3 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:27:9: warning: initialization of variable 'nums4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums4 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:28:9: warning:\
    \ initialization of variable 'nums5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var nums5 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:29:9:\
    \ warning: initialization of variable 'nums6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums6 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:30:9: warning: initialization of variable 'nums7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums7 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:31:9: warning:\
    \ initialization of variable 'nums8' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var nums8 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:32:9:\
    \ warning: initialization of variable 'nums9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums9 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:33:9: warning: initialization of variable 'nums10'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums10 = [Int]()\n    ~~~~^~~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:34:9:\
    \ warning: initialization of variable 'nums11' was"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    var digits\
    \ = num.characters\n    for digit in digits {\n        sum += Int(digit)\n   \
    \ }\n    if sum%2 == 0 {\n        return 0\n    }\n    \n    var primes = Array<Int>()\n\
    \    var prime = Int(sqrt(Double(sum)))\n    for _ in 0..<prime {\n        primes.append(0)\n\
    \    }\n    primes[0] = 2\n    primes[prime] = 1\n    \n    for digit in digits\
    \ {\n        if primes[digit] == 0 {\n            primes[digit] = 1\n        }\
    \ else {\n            primes[digit] += 1\n        }\n    }\n    return primes.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb1epfdd9.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb1epfdd9.swift:27:16:\
    \ error: no exact matches in call to initializer \n        sum += Int(digit)\n\
    \               ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n/tmp/tmpb1epfdd9.swift:34:21:\
    \ error: cannot find 'sqrt' in scope\n    var prime = Int(sqrt(Double(sum)))\n\
    \                    ^~~~\n/tmp/tmpb1epfdd9.swift:42:19: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n        if primes[digit]\
    \ == 0 {\n                  ^\n/tmp/tmpb1epfdd9.swift:43:20: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes[digit]\
    \ = 1\n                   ^\n/tmp/tmpb1epfdd9.swift:45:20: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes[digit]\
    \ += 1\n                   ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexCount = hex.count\n    var hexDigits = [Int]()\n    var hexDigitCount\
    \ = 0\n    var hexDigit = 0\n    var hexDigit2 = 0\n    var hexDigit3 = 0\n  \
    \  var hexDigit4 = 0\n    var hexDigit5 = 0\n    var hexDigit6 = 0\n    var hexDigit7\
    \ = 0\n    var hexDigit8 = 0\n    var hexDigit9 = 0\n    var hexDigit10 = 0\n\
    \    var hexDigit11 = 0\n    var hexDigit12 = 0\n    var hexDigit13 = 0\n    var\
    \ hexDigit14 = 0\n    var hexDigit15 = 0\n    var hexDigit16 = 0\n    var hexDigit17\
    \ = 0\n    var hexDigit18 = 0\n    var hexDigit19 = 0\n    var hexDigit20 = 0\n\
    \    var hexDigit21 = 0\n    var hexDigit22 = 0\n    var hexDigit23 = 0\n    var\
    \ hexDigit24 = 0\n    var hexDigit25 = 0\n    var hexDigit26 = 0\n    var hexDigit27\
    \ = 0\n    var hexDigit28 = 0\n    var hexDigit29 = 0\n    var hexDigit30 = 0\n\
    \    var hexDigit31 = 0\n    var hexDigit32 = 0\n    var hexDigit33 = 0\n    var\
    \ hexDigit34 = 0\n    var hexDigit35 = 0\n    var hexDigit36 = 0\n    var hexDigit37\
    \ = 0\n    var hexDigit38 = 0\n    var hexDigit39 = 0\n    var hexDigit40 = 0\n\
    \    var hexDigit41 = 0\n    var hexDigit42 = 0\n    var hexDigit43 = 0\n    var\
    \ hexDigit44 = 0\n    var hexDigit45 = 0\n    var hexDigit46 = 0\n    var hexDigit47\
    \ = 0\n    var hexDigit48 = 0\n    var hexDigit49 = 0\n    var hexDigit50 = 0\n\
    \    var hexDigit51 = 0\n    var hexDigit52 = 0\n    var hexDigit53 = 0\n    var\
    \ hexDigit54 = 0\n    var hexDigit55 = 0\n    var hexDigit56 = 0\n    var hexDigit57\
    \ = 0\n    var hexDigit58 = 0\n    var hexDigit59 = 0\n    var hexDigit60 = 0\n\
    \    var hexDigit61 = 0\n    var hexDigit62 = 0\n    var hexDigit63 = 0\n    var\
    \ hexDigit64 = 0\n    var hexDigit65 = 0\n    var hexDigit66 = 0\n    var hexDigit67\
    \ = 0\n    var hexDigit68 = 0\n    var hexDigit69 = 0\n    var hexDigit70 = 0\n\
    \    var hexDigit71 = 0\n    var hexDigit72 = 0\n    var hexDigit73 = 0\n    var\
    \ hexDigit74 = 0\n    var hexDigit75 = 0\n    var hexDigit76 = 0\n    var hexDigit77\
    \ = 0\n    var hexDigit78 = 0\n    var hexDigit79 = 0\n    var hexDigit80 = 0\n\
    \    var hexDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvqxg9vko.swift:108:9: error: type annotation missing in pattern\n\
    \    var hexDigit\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        switch digit {\n      \
    \  case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n\
    \            count += 1\n        case \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\
    :\n            count += 1\n        default:\n            break\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmprb6d6npg.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(char) - Int(Int(char))\n    }\n    return sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6bqrubfr.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(char) - Int(Int(char))\n               ^\n/tmp/tmp6bqrubfr.swift:26:16:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \        sum += Int(char) - Int(Int(char))\n               ^\n/tmp/tmp6bqrubfr.swift:26:16:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        sum += Int(char) - Int(Int(char))\n               ^\n/tmp/tmp6bqrubfr.swift:26:16:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \        sum += Int(char) - Int(Int(char))\n               ^\n/tmp/tmp6bqrubfr.swift:26:16:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \        sum += Int(char) - Int(Int(char))\n               ^\n/tmp/tmp6bqrubfr.swift:26:16:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n        sum += Int(char) - Int(Int(char))\n               ^\n\
    /tmp/tmp6bqrubfr.swift:26:16: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n        sum += Int(char) - Int(Int(char))\n\
    \               ^\n/tmp/tmp6bqrubfr.swift:26:32: error: no exact matches in call\
    \ to initializer \n        sum += Int(char) - Int(Int(char))\n               \
    \                ^\n/tmp/tmp6bqrubfr.swift:26:32: note: candidate expects value\
    \ of type 'Float16' for parameter #1 (got 'Character')\n        sum += Int(char)\
    \ - Int(Int(char))\n                               ^\n/tmp/tmp6bqrubfr.swift:26:32:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        sum += Int(char) - Int(Int(char))\n                               ^\n\
    /tmp/tmp6bqrubfr.swift:26:32: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n        sum += Int(char) - Int(Int(char))\n\
    \                               ^\n/tmp/tmp6bqrubfr.swift:26:32: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'Character')\n       \
    \ sum += Int(char) - Int(Int(char))\n  "
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArrayLength = numAsArray.count\n\
    \    var hexKey = 0\n    for i in 0..<numAsArrayLength {\n        let hexDigit\
    \ = numAsArray[i]\n        if hexDigit == \"a\" {\n            hexKey += 10\n\
    \        } else if hexDigit == \"b\" {\n            hexKey += 11\n        } else\
    \ if hexDigit == \"c\" {\n            hexKey += 12\n        } else if hexDigit\
    \ == \"d\" {\n            hexKey += 13\n        } else if hexDigit == \"e\" {\n\
    \            hexKey += 14\n        } else if hexDigit == \"f\" {\n           \
    \ hexKey += 15\n        } else {\n            hexKey += hexDigit\n        }\n\
    \    }\n    return hexKey\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu1prctfo.swift:25:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let numAsArray = numAsString.characters\n         \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpu1prctfo.swift:29:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ hexDigit = numAsArray[i]\n                       ^~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu1prctfo.swift:43:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            hexKey += hexDigit\n                      ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var primesCount = 2\n    var primesCount2\
    \ = 2\n    var primesCount3 = 3\n    var primesCount4 = 4\n    var primesCount5\
    \ = 5\n    var primesCount6 = 6\n    var primesCount7 = 7\n    var primesCount8\
    \ = 8\n    var primesCount9 = 9\n    var primesCount10 = 10\n    var primesCount11\
    \ = 11\n    var primesCount12 = 12\n    var primesCount13 = 13\n    var primesCount14\
    \ = 14\n    var primesCount15 = 15\n    var primesCount16 = 16\n    var primesCount17\
    \ = 17\n    var primesCount18 = 18\n    var primesCount19 = 19\n    var primesCount20\
    \ = 20\n    var primesCount21 = 21\n    var primesCount22 = 22\n    var primesCount23\
    \ = 23\n    var primesCount24 = 24\n    var primesCount25 = 25\n    var primesCount26\
    \ = 26\n    var primesCount27 = 27\n    var primesCount28 = 28\n    var primesCount29\
    \ = 29\n    var primesCount30 = 30\n    var primesCount31 = 31\n    var primesCount32\
    \ = 32\n    var primesCount33 = 33\n    var primesCount34 = 34\n    var primesCount35\
    \ = 35\n    var primesCount36 = 36\n    var primesCount37 = 37\n    var primesCount38\
    \ = 38\n    var primesCount39 = 39\n    var primesCount40 = 40\n    var primesCount41\
    \ = 41\n    var primesCount42 = 42\n    var primesCount43 = 43\n    var primesCount44\
    \ = 44\n    var primesCount45 = 45\n    var primesCount46 = 46\n    var primesCount47\
    \ = 47\n    var primesCount48 = 48\n    var primesCount49 = 49\n    var primesCount50\
    \ = 50\n    var primesCount51 = 51\n    var primesCount52 = 52\n    var primesCount53\
    \ = 53\n    var primesCount54 = 54\n    var primesCount55 = 55\n    var primesCount56\
    \ = 56\n    var primesCount57 = 57\n    var primesCount58 = 58\n    var primesCount59\
    \ = 59\n    var primesCount60 = 60\n    var primesCount61 = 61\n    var primesCount62\
    \ = 62\n    var primesCount63 = 63\n    var primesCount64 = 64\n    var primesCount65\
    \ = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\n\
    assert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\n\
    assert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8fnvnzz_.swift:90:24: error: expected initial value after '='\n\
    \    var primesCount65 = \n                       ^\n/tmp/tmp8fnvnzz_.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for char in nums\
    \ {\n        if char == \"A\" || char == \"B\" || char == \"C\" || char == \"\
    D\" || char == \"E\" || char == \"F\" {\n            count += 1\n        }\n \
    \   }\n    if count > 0 {\n        return count\n    }\n    for prime in primes\
    \ {\n        if nums.contains(String(prime)) {\n            count += 1\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp0et255z8.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0et255z8.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmp0et255z8.swift:26:9:\
    \ warning: variable 'primes' was never mutated; consider changing to 'let' constant\n\
    \    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let digitCount = digits.count\n    var primeCount = 0\n    var primeDigitCount\
    \ = 0\n    var primeDigit = 0\n    var primeDigit2 = 0\n    var primeDigit3 =\
    \ 0\n    var primeDigit4 = 0\n    var primeDigit5 = 0\n    var primeDigit6 = 0\n\
    \    var primeDigit7 = 0\n    var primeDigit8 = 0\n    var primeDigit9 = 0\n \
    \   var primeDigit10 = 0\n    var primeDigit11 = 0\n    var primeDigit12 = 0\n\
    \    var primeDigit13 = 0\n    var primeDigit14 = 0\n    var primeDigit15 = 0\n\
    \    var primeDigit16 = 0\n    var primeDigit17 = 0\n    var primeDigit18 = 0\n\
    \    var primeDigit19 = 0\n    var primeDigit20 = 0\n    var primeDigit21 = 0\n\
    \    var primeDigit22 = 0\n    var primeDigit23 = 0\n    var primeDigit24 = 0\n\
    \    var primeDigit25 = 0\n    var primeDigit26 = 0\n    var primeDigit27 = 0\n\
    \    var primeDigit28 = 0\n    var primeDigit29 = 0\n    var primeDigit30 = 0\n\
    \    var primeDigit31 = 0\n    var primeDigit32 = 0\n    var primeDigit33 = 0\n\
    \    var primeDigit34 = 0\n    var primeDigit35 = 0\n    var primeDigit36 = 0\n\
    \    var primeDigit37 = 0\n    var primeDigit38 = 0\n    var primeDigit39 = 0\n\
    \    var primeDigit40 = 0\n    var primeDigit41 = 0\n    var primeDigit42 = 0\n\
    \    var primeDigit43 = 0\n    var primeDigit44 = 0\n    var primeDigit45 = 0\n\
    \    var primeDigit46 = 0\n    var primeDigit47 = 0\n    var primeDigit48 = 0\n\
    \    var primeDigit49 = 0\n    var primeDigit50 = 0\n    var primeDigit51 = 0\n\
    \    var primeDigit52 = 0\n    var primeDigit53 = 0\n    var primeDigit54 = 0\n\
    \    var primeDigit55 = 0\n    var primeDigit56 = 0\n    var primeDigit57 = 0\n\
    \    var primeDigit58 = 0\n    var primeDigit59 = 0\n    var primeDigit60 = 0\n\
    \    var primeDigit61 = 0\n    var primeDigit62 = 0\n    var primeDigit63 = 0\n\
    \    var primeDigit64 = 0\n    var primeDigit65 = 0\n    var primeDigit66 = 0\n\
    \    var primeDigit67 = 0\n    var primeDigit68 = 0\n    var primeDigit69 = 0\n\
    \    var primeDigit70 = 0\n    var primeDigit71 = 0\n    var primeDigit72 = 0\n\
    \    var primeDigit73 = 0\n    var primeDigit74 = 0\n    var primeDigit75 = 0\n\
    \    var primeDigit76 = 0\n    var primeDigit77 = 0\n    var primeDigit78 = 0\n\
    \    var primeDigit79 = 0\n    var primeDigit80 = 0\n    var primeDigit81 = 0\n\
    \    var primeDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpsc2fv9pm.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsc2fv9pm.swift:109:9:\
    \ error: type annotation missing in pattern\n    var primeDigit\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count += c - '0'\n\
    \        } else if c >= 'A' && c <= 'F' {\n            count += c - 'A' + 10\n\
    \        } else if c >= 'a' && c <= 'f' {\n            count += c - 'a' + 10\n\
    \        } else {\n            return -1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxezzpc67.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpxezzpc67.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpxezzpc67.swift:27:26: error:\
    \ single-quoted string literal found, use '\"'\n            count += c - '0'\n\
    \                         ^~~\n                         \"0\"\n/tmp/tmpxezzpc67.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmpxezzpc67.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmpxezzpc67.swift:29:26:\
    \ error: single-quoted string literal found, use '\"'\n            count += c\
    \ - 'A' + 10\n                         ^~~\n                         \"A\"\n/tmp/tmpxezzpc67.swift:30:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'a' && c <= 'f' {\n                       ^~~\n                       \"a\"\n\
    /tmp/tmpxezzpc67.swift:30:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'a' && c <= 'f' {\n                                \
    \   ^~~\n                                   \"f\"\n/tmp/tmpxezzpc67.swift:31:26:\
    \ error: single-quoted string literal found, use '\"'\n            count += c\
    \ - 'a' + 10\n                         ^~~\n                         \"a\"\n/tmp/tmpxezzpc67.swift:27:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'Int' and\
    \ '_'\n            count += c - '0'\n                  ^\nSwift.SIMD:1:11: note:\
    \ candidate requires that 'Int' conform to 'SIMD' (requirement specified as 'Self'\
    \ : 'SIMD')\nextension SIMD where Self.Scalar : FloatingPoint {\n          ^\n\
    /tmp/tmpxezzpc67.swift:29:19: error: binary operator '+=' cannot be applied to\
    \ operands of type 'Int' and '_'\n  "
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    \n    // Your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpi8og8fk8/tmpi8og8fk8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d9d564c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d9d25bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d9d25b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d9d25a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8og8fk8                        0x00005648430a2264 <unavailable> + 4708

    5    libc.so.6                          0x00002b7d9d750460 __libc_start_main +
    245

    6    tmpi8og8fk8                        0x00005648430a1ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  let numAsString = num.lowercased()\n    var numAsInt = Int(numAsString)\n \
    \   var numAsStringArray = numAsString.characters\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n    var numAsStringArrayLength\
    \ = numAsString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpioqlfi73.swift:27:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    var numAsStringArray = numAsString.characters\n   \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpioqlfi73.swift:29:9: error: invalid redeclaration of\
    \ 'numAsStringArrayLength'\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \        ^\n/tmp/tmpioqlfi73.swift:28:9: note: 'numAsStringArrayLength' previously\
    \ declared here\n    var numAsStringArrayLength = numAsStringArray.count\n   \
    \     ^\n/tmp/tmpioqlfi73.swift:30:9: error: invalid redeclaration of 'numAsStringArrayLength'\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:28:9:\
    \ note: 'numAsStringArrayLength' previously declared here\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:31:9: error: invalid\
    \ redeclaration of 'numAsStringArrayLength'\n    var numAsStringArrayLength =\
    \ numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:28:9: note: 'numAsStringArrayLength'\
    \ previously declared here\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \        ^\n/tmp/tmpioqlfi73.swift:32:9: error: invalid redeclaration of 'numAsStringArrayLength'\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:28:9:\
    \ note: 'numAsStringArrayLength' previously declared here\n    var numAsStringArrayLength\
    \ = numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:33:9: error: invalid\
    \ redeclaration of 'numAsStringArrayLength'\n    var numAsStringArrayLength =\
    \ numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:28:9: note: 'numAsStringArrayLength'\
    \ previously declared here\n    var numAsStringArrayLength = numAsStringArray.count\n\
    \        ^\n/tmp/tmpioqlfi73.swift:34:9: error: invalid redeclaration of 'numAsStringArrayLength'\n\
    \    var numAsStringArrayLength = numAsStringArray.count\n        ^\n/tmp/tmpioqlfi73.swift:28:9:\
    \ note: 'numAsStringArrayLength' "
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var nums2 = [Int]()\n    var nums3 = [Int]()\n    var nums4 = [Int]()\n  \
    \  var nums5 = [Int]()\n    var nums6 = [Int]()\n    var nums7 = [Int]()\n   \
    \ var nums8 = [Int]()\n    var nums9 = [Int]()\n    var nums10 = [Int]()\n   \
    \ var nums11 = [Int]()\n    var nums12 = [Int]()\n    var nums13 = [Int]()\n \
    \   var nums14 = [Int]()\n    var nums15 = [Int]()\n    var nums16 = [Int]()\n\
    \    var nums17 = [Int]()\n    var nums18 = [Int]()\n    var nums19 = [Int]()\n\
    \    var nums20 = [Int]()\n    var nums21 = [Int]()\n    var nums22 = [Int]()\n\
    \    var nums23 = [Int]()\n    var nums24 = [Int]()\n    var nums25 = [Int]()\n\
    \    var nums26 = [Int]()\n    var nums27 = [Int]()\n    var nums28 = [Int]()\n\
    \    var nums29 = [Int]()\n    var nums30 = [Int]()\n    var nums31 = [Int]()\n\
    \    var nums32 = [Int]()\n    var nums33 = [Int]()\n    var nums34 = [Int]()\n\
    \    var nums35 = [Int]()\n    var nums36 = [Int]()\n    var nums37 = [Int]()\n\
    \    var nums38 = [Int]()\n    var nums39 = [Int]()\n    var nums40 = [Int]()\n\
    \    var nums41 = [Int]()\n    var nums42 = [Int]()\n    var nums43 = [Int]()\n\
    \    var nums44 = [Int]()\n    var nums45 = [Int]()\n    var nums46 = [Int]()\n\
    \    var nums47 = [Int]()\n    var nums48 = [Int]()\n    var nums49 = [Int]()\n\
    \    var nums50 = [Int]()\n    var nums51 = [Int]()\n    var nums52 = [Int]()\n\
    \    var nums53 = [Int]()\n    var nums54 = [Int]()\n    var nums55 = [Int]()\n\
    \    var nums56 = [Int]()\n    var nums57 = [Int]()\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk6p5s8j3.swift:81:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpk6p5s8j3.swift:24:9: warning: initialization of variable 'nums' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ nums = [Int]()\n    ~~~~^~~~\n    _\n/tmp/tmpk6p5s8j3.swift:25:9: warning: initialization\
    \ of variable 'nums2' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var nums2 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:26:9:\
    \ warning: initialization of variable 'nums3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums3 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:27:9: warning: initialization of variable 'nums4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums4 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:28:9: warning:\
    \ initialization of variable 'nums5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var nums5 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:29:9:\
    \ warning: initialization of variable 'nums6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums6 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:30:9: warning: initialization of variable 'nums7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums7 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:31:9: warning:\
    \ initialization of variable 'nums8' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var nums8 = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:32:9:\
    \ warning: initialization of variable 'nums9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums9 = [Int]()\n    ~~~~^~~~~\n\
    \    _\n/tmp/tmpk6p5s8j3.swift:33:9: warning: initialization of variable 'nums10'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums10 = [Int]()\n    ~~~~^~~~~~\n    _\n/tmp/tmpk6p5s8j3.swift:34:9:\
    \ warning: initialization of variable 'nums11' was"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.unicodeScalars\n\
    \    var hexNumLen = hexNum.count\n    var hexNumStr = \"\"\n    for i in 0..<hexNumLen\
    \ {\n        hexNumStr += hexNum[i].value\n    }\n    var hexNumStrLen = hexNumStr.count\n\
    \    var hexNumStrArray = hexNumStr.characters\n    var hexNumStrArrayLen = hexNumStrArray.count\n\
    \    var hexNumStrArray2 = hexNumStrArray[0..<hexNumStrArrayLen-1]\n    var hexNumStrArray2Len\
    \ = hexNumStrArray2.count\n    var hexNumStrArray3 = hexNumStrArray2[0..<hexNumStrArray2Len-1]\n\
    \    var hexNumStrArray3Len = hexNumStrArray3.count\n    var hexNumStrArray4 =\
    \ hexNumStrArray3[0..<hexNumStrArray3Len-1]\n    var hexNumStrArray4Len = hexNumStrArray4.count\n\
    \    var hexNumStrArray5 = hexNumStrArray4[0..<hexNumStrArray4Len-1]\n    var\
    \ hexNumStrArray5Len = hexNumStrArray5.count\n    var hexNumStrArray6 = hexNumStrArray5[0..<hexNumStrArray5Len-1]\n\
    \    var hexNumStrArray6Len = hexNumStrArray6.count\n    var hexNumStrArray7 =\
    \ hexNumStrArray6[0..<hexNumStrArray6Len-1]\n    var hexNumStrArray7Len = hexNumStrArray7.count\n\
    \    var hexNumStrArray8 = hexNumStrArray7[0..<hexNumStrArray7Len-1]\n    var\
    \ hexNumStrArray8Len = hexNumStrArray8.count\n    var hexNumStrArray9 = hexNumStrArray8[0..<hexNumStrArray8Len-1]\n\
    \    var hexNumStrArray9Len = hexNumStrArray9.count\n    var hexNumStrArray10\
    \ = hexNumStrArray9[0..<hexNumStrArray9Len-1]\n    var hexNumStrArray10Len = hexNumStrArray10.count\n\
    \    var hexNumStrArray11 = hexNumStrArray10[0..<hexNumStrArray10Len-1]\n    var\
    \ hexNumStrArray11Len = hexNumStrArray11.count\n    var hexNumStrArray12 = hexNumStrArray11[0..<hexNumStrArray11Len-1]\n\
    \    var hexNumStrArray12Len = hexNumStrArray12.count\n    var hexNumStrArray13\
    \ = hexNumStrArray12[0..<hexNumStrArray12Len-1]\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpih0md6cx.swift:28:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n        hexNumStr += hexNum[i].value\n \
    \                              ^\n/tmp/tmpih0md6cx.swift:28:29: error: cannot\
    \ convert value of type 'Int' to expected argument type 'String.UnicodeScalarView.Index'\
    \ (aka 'String.Index')\n        hexNumStr += hexNum[i].value\n               \
    \             ^\n/tmp/tmpih0md6cx.swift:31:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var hexNumStrArray = hexNumStr.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpih0md6cx.swift:33:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    var hexNumStrArray2 = hexNumStrArray[0..<hexNumStrArrayLen-1]\n         \
    \                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpih0md6cx.swift:35:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    var hexNumStrArray3 = hexNumStrArray2[0..<hexNumStrArray2Len-1]\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpih0md6cx.swift:37:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    var hexNumStrArray4 = hexNumStrArray3[0..<hexNumStrArray3Len-1]\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public "
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"0\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"1\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"2\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"3\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"4\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"5\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"6\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"7\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"8\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpd7pwsjmd.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpd7pwsjmd.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmpd7pwsjmd.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpd7pwsjmd.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpd7pwsjmd.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd7pwsjmd.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmpd7pwsjmd.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmpd7pwsjmd.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.uppercased()\n\
    \    var count = 0\n    for char in hex {\n        if char == \"A\" {\n      \
    \      count++\n        } else if char == \"B\" {\n            count++\n     \
    \   } else if char == \"C\" {\n            count++\n        } else if char ==\
    \ \"D\" {\n            count++\n        } else if char == \"E\" {\n          \
    \  count++\n        } else if char == \"F\" {\n            count++\n        }\
    \ else {\n            count = 0\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpkzgcqodo.swift:28:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            count++\n                 ^~\n/tmp/tmpkzgcqodo.swift:30:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n/tmp/tmpkzgcqodo.swift:32:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            count++\n        \
    \         ^~\n/tmp/tmpkzgcqodo.swift:34:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            count++\n                 ^~\n/tmp/tmpkzgcqodo.swift:36:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n/tmp/tmpkzgcqodo.swift:38:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            count++\n        \
    \         ^~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = \"\"\n\
    \    var count = 0\n    for char in num {\n        hexDigits += char\n    }\n\
    \    for char in hexDigits {\n        if char == \"A\" {\n            count +=\
    \ 1\n        } else if char == \"B\" {\n            count += 1\n        } else\
    \ if char == \"C\" {\n            count += 1\n        } else if char == \"D\"\
    \ {\n            count += 1\n        } else if char == \"E\" {\n            count\
    \ += 1\n        } else if char == \"F\" {\n            count += 1\n        } else\
    \ if char == \"0\" {\n            count += 1\n        } else if char == \"1\"\
    \ {\n            count += 1\n        } else if char == \"2\" {\n            count\
    \ += 1\n        } else if char == \"3\" {\n            count += 1\n        } else\
    \ if char == \"4\" {\n            count += 1\n        } else if char == \"5\"\
    \ {\n            count += 1\n        } else if char == \"6\" {\n            count\
    \ += 1\n        } else if char == \"7\" {\n            count += 1\n        } else\
    \ if char == \"8\" {\n            count += 1\n        } else if char == \"9\"\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpuhlsi_o2.swift:27:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        hexDigits += char\n            \
    \         ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for char in nums\
    \ {\n        if char.uppercased() == \"A\" {\n            primes[0] = primes[1]\n\
    \            primes[1] = primes[2]\n            primes[2] = primes[3]\n      \
    \      primes[3] = primes[4]\n            primes[4] = primes[5]\n            primes[5]\
    \ = primes[6]\n            primes[6] = primes[7]\n            primes[7] = primes[8]\n\
    \            primes[8] = primes[9]\n            primes[9] = primes[10]\n     \
    \       primes[10] = primes[11]\n            primes[11] = primes[12]\n       \
    \     primes[12] = primes[13]\n            primes[13] = primes[14]\n         \
    \   primes[14] = primes[15]\n            primes[15] = primes[16]\n           \
    \ primes[16] = primes[17]\n            primes[17] = primes[18]\n            primes[18]\
    \ = primes[19]\n            primes[19] = primes[20]\n            primes[20] =\
    \ primes[21]\n            primes[21] = primes[22]\n            primes[22] = primes[23]\n\
    \            primes[23] = primes[24]\n            primes[24] = primes[25]\n  \
    \          primes[25] = primes[26]\n            primes[26] = primes[27]\n    \
    \        primes[27] = primes[28]\n            primes[28] = primes[29]\n      \
    \      primes[29] = primes[30]\n            primes[30] = primes[31]\n        \
    \    primes[31] = primes[32]\n            primes[32] = primes[33]\n          \
    \  primes[33] = primes[34]\n            primes[34] = primes[35]\n            primes[35]\
    \ = primes[36]\n            primes[36] = primes[37]\n            primes[37] =\
    \ primes[38]\n            primes[38] = primes[39]\n            primes[39] = primes[40]\n\
    \            primes[40] = primes[41]\n            primes[41] = primes[42]\n  \
    \          primes[42] = primes[43]\n            primes[43] = primes[44]\n    \
    \        primes[44] = primes[45]\n            primes[45] = primes[46]\n      \
    \      primes[46] = primes[47]\n            prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp4efqmjs6.swift:97:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmp4efqmjs6.swift:27:22:\
    \ note: to match this opening '{'\n    for char in nums {\n                  \
    \   ^\n/tmp/tmp4efqmjs6.swift:97:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmp4efqmjs6.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmp4efqmjs6.swift:24:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4efqmjs6.swift:76:13: error: cannot find 'prime' in scope\n     \
    \       prime\n            ^~~~~\n/tmp/tmp4efqmjs6.swift:80:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        switch digit {\n      \
    \  case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n\
    \        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"\
    7\":\n        case \"8\":\n        case \"9\":\n            count += 1\n     \
    \   case \"A\":\n        case \"B\":\n        case \"C\":\n        case \"D\"\
    :\n        case \"E\":\n        case \"F\":\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpzw6tz4ql.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzw6tz4ql.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzw6tz4ql.swift:42:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for index in 0..<nums.count {\n        let hex = nums[index]\
    \ as String\n        let digit = Int(hex, radix: 16)\n        if digit > 0 &&\
    \ digit < 10 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpgsypslc0.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgsypslc0.swift:27:31:\
    \ error: cannot convert value of type 'Character' to type 'String' in coercion\n\
    \        let hex = nums[index] as String\n                  ~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let digitCount = digits.count\n    var hexDigitCount = 0\n    var hexDigit\
    \ = 0\n    var hexDigit2 = 0\n    var hexDigit3 = 0\n    var hexDigit4 = 0\n \
    \   var hexDigit5 = 0\n    var hexDigit6 = 0\n    var hexDigit7 = 0\n    var hexDigit8\
    \ = 0\n    var hexDigit9 = 0\n    var hexDigit10 = 0\n    var hexDigit11 = 0\n\
    \    var hexDigit12 = 0\n    var hexDigit13 = 0\n    var hexDigit14 = 0\n    var\
    \ hexDigit15 = 0\n    var hexDigit16 = 0\n    var hexDigit17 = 0\n    var hexDigit18\
    \ = 0\n    var hexDigit19 = 0\n    var hexDigit20 = 0\n    var hexDigit21 = 0\n\
    \    var hexDigit22 = 0\n    var hexDigit23 = 0\n    var hexDigit24 = 0\n    var\
    \ hexDigit25 = 0\n    var hexDigit26 = 0\n    var hexDigit27 = 0\n    var hexDigit28\
    \ = 0\n    var hexDigit29 = 0\n    var hexDigit30 = 0\n    var hexDigit31 = 0\n\
    \    var hexDigit32 = 0\n    var hexDigit33 = 0\n    var hexDigit34 = 0\n    var\
    \ hexDigit35 = 0\n    var hexDigit36 = 0\n    var hexDigit37 = 0\n    var hexDigit38\
    \ = 0\n    var hexDigit39 = 0\n    var hexDigit40 = 0\n    var hexDigit41 = 0\n\
    \    var hexDigit42 = 0\n    var hexDigit43 = 0\n    var hexDigit44 = 0\n    var\
    \ hexDigit45 = 0\n    var hexDigit46 = 0\n    var hexDigit47 = 0\n    var hexDigit48\
    \ = 0\n    var hexDigit49 = 0\n    var hexDigit50 = 0\n    var hexDigit51 = 0\n\
    \    var hexDigit52 = 0\n    var hexDigit53 = 0\n    var hexDigit54 = 0\n    var\
    \ hexDigit55 = 0\n    var hexDigit56 = 0\n    var hexDigit57 = 0\n    var hexDigit58\
    \ = 0\n    var hexDigit59 = 0\n    var hexDigit60 = 0\n    var hexDigit61 = 0\n\
    \    var hexDigit62 = 0\n    var hexDigit63 = 0\n    var hexDigit64 = 0\n    var\
    \ hexDigit65 = 0\n    var hexDigit66 = 0\n    var hexDigit67 = 0\n    var hexDigit68\
    \ = 0\n    var hexDigit69 = 0\n    var hexDigit70 = 0\n    var hexDigit71 = 0\n\
    \    var hexDigit72 = 0\n    var hexDigit73 = 0\n    var hexDigit74 = 0\n    var\
    \ hexDigit75 = 0\n    var hexDigit76 = 0\n    var hexDigit77 = 0\n    var hexDigit78\
    \ = 0\n    var hexDigit79 = 0\n    var hexDigit80 = 0\n    var hexDigit81 = 0\n\
    \    var hexDigit82 = 0\n    var hex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpqb6x1zai.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqb6x1zai.swift:109:9:\
    \ error: type annotation missing in pattern\n    var hex\n        ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"0\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"1\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"2\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"3\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"4\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"5\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"6\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"7\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"8\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpd7pwsjmd.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpd7pwsjmd.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmpd7pwsjmd.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpd7pwsjmd.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpd7pwsjmd.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd7pwsjmd.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmpd7pwsjmd.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmpd7pwsjmd.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\": count++\n        case \"\
    1\": count++\n        case \"2\": count++\n        case \"3\": count++\n     \
    \   case \"4\": count++\n        case \"5\": count++\n        case \"6\": count++\n\
    \        case \"7\": count++\n        case \"8\": count++\n        case \"9\"\
    : count++\n        case \"A\": count++\n        case \"B\": count++\n        case\
    \ \"C\": count++\n        case \"D\": count++\n        case \"E\": count++\n \
    \       case \"F\": count++\n        default: break\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1wbn3zk4.swift:27:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        case \"0\": count++\n                       ^~\n\
    /tmp/tmp1wbn3zk4.swift:28:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        case \"1\": count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:29:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ \"2\": count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:30:24: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case \"3\"\
    : count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:31:24: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        case \"4\": count++\n\
    \                       ^~\n/tmp/tmp1wbn3zk4.swift:32:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"5\": count++\n         \
    \              ^~\n/tmp/tmp1wbn3zk4.swift:33:24: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        case \"6\": count++\n              \
    \         ^~\n/tmp/tmp1wbn3zk4.swift:34:24: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n        case \"7\": count++\n                 \
    \      ^~\n/tmp/tmp1wbn3zk4.swift:35:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        case \"8\": count++\n                       ^~\n\
    /tmp/tmp1wbn3zk4.swift:36:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        case \"9\": count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:37:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ \"A\": count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:38:24: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case \"B\"\
    : count++\n                       ^~\n/tmp/tmp1wbn3zk4.swift:39:24: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        case \"C\": count++\n\
    \                       ^~\n/tmp/tmp1wbn3zk4.swift:40:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"D\": count++\n         \
    \              ^~\n/tmp"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let len = digits.count\n    let primes = primes_from(digits)\n    let primesLen\
    \ = primes.count\n    let primesSum = primes.reduce(0,+)\n    let primesSumLen\
    \ = primesSum.count\n    let primesSumDiv = primesSum.map { $0 / primesLen }\n\
    \    let primesSumDivLen = primesSumDiv.count\n    let primesSumDiv2 = primesSumDiv.map\
    \ { $0 * $0 }\n    let primesSumDiv2Len = primesSumDiv2.count\n    let primesSumDiv2Sum\
    \ = primesSumDiv2.reduce(0,+)\n    let primesSumDiv2SumLen = primesSumDiv2Sum.count\n\
    \    let primesSumDiv2SumDiv = primesSumDiv2Sum.map { $0 / primesLen * $0 }\n\
    \    let primesSumDiv2SumDivLen = primesSumDiv2SumDiv.count\n    let primesSumDiv2SumDiv2\
    \ = primesSumDiv2SumDiv.map { $0 * $0 }\n    let primesSumDiv2SumDiv2Len = primesSumDiv2SumDiv2.count\n\
    \    let primesSumDiv2SumDiv2Sum = primesSumDiv2SumDiv2.reduce(0,+)\n    let primesSumDiv2SumDiv2SumLen\
    \ = primesSumDiv2SumDiv2Sum.count\n    let primesSumDiv2SumDiv2SumDiv = primesSumDiv2SumDiv2Sum.map\
    \ { $0 / primesLen * $0 }\n    let primesSumDiv2SumDiv2SumDivLen = primesSumDiv2SumDiv2SumDiv.count\n\
    \    let primesSumDiv2SumDiv2SumDiv2 = primesSumDiv2SumDiv2SumDiv.map { $0 * $0\
    \ }\n    let primesSumDiv2SumDiv2SumDiv2Len = primesSumDiv2SumDiv2SumDiv2.count\n\
    \    let primesSumDiv2SumDiv2SumDiv2Sum = primesSumDiv2SumDiv2SumDiv2Sum.map {\
    \ $0 / primesLen * $0 }\n    let primesSumDiv2SumDiv2SumDiv2SumLen = primesSumDiv2SumDiv2SumDiv2Sum.count\n\
    \    let primesSumDiv2SumDiv2SumDiv2SumDiv = primesSumDiv2SumDiv2SumDiv2\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3iz2ukpw.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3iz2ukpw.swift:26:18:\
    \ error: cannot find 'primes_from' in scope\n    let primes = primes_from(digits)\n\
    \                 ^~~~~~~~~~~\n/tmp/tmp3iz2ukpw.swift:46:42: error: use of local\
    \ variable 'primesSumDiv2SumDiv2SumDiv2Sum' before its declaration\n    let primesSumDiv2SumDiv2SumDiv2Sum\
    \ = primesSumDiv2SumDiv2SumDiv2Sum.map { $0 / primesLen * $0 }\n             \
    \                            ^\n/tmp/tmp3iz2ukpw.swift:46:9: note: 'primesSumDiv2SumDiv2SumDiv2Sum'\
    \ declared here\n    let primesSumDiv2SumDiv2SumDiv2Sum = primesSumDiv2SumDiv2SumDiv2Sum.map\
    \ { $0 / primesLen * $0 }\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            count += 1\n        case\
    \ \"A\", \"B\", \"C\", \"D\", \"E\", \"F\":\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpictyj8f6/tmpictyj8f6.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add0607cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add05d73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add05d73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add05d727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpictyj8f6                        0x000055b99dfbe414 <unavailable> + 5140

    5    libc.so.6                          0x00002add06268460 __libc_start_main +
    245

    6    tmpictyj8f6                        0x000055b99dfbe099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var numsSum = 0\n    var numsSum2 = 0\n \
    \   var numsSum3 = 0\n    var numsSum4 = 0\n    var numsSum5 = 0\n    var numsSum6\
    \ = 0\n    var numsSum7 = 0\n    var numsSum8 = 0\n    var numsSum9 = 0\n    var\
    \ numsSum10 = 0\n    var numsSum11 = 0\n    var numsSum12 = 0\n    var numsSum13\
    \ = 0\n    var numsSum14 = 0\n    var numsSum15 = 0\n    var numsSum16 = 0\n \
    \   var numsSum17 = 0\n    var numsSum18 = 0\n    var numsSum19 = 0\n    var numsSum20\
    \ = 0\n    var numsSum21 = 0\n    var numsSum22 = 0\n    var numsSum23 = 0\n \
    \   var numsSum24 = 0\n    var numsSum25 = 0\n    var numsSum26 = 0\n    var numsSum27\
    \ = 0\n    var numsSum28 = 0\n    var numsSum29 = 0\n    var numsSum30 = 0\n \
    \   var numsSum31 = 0\n    var numsSum32 = 0\n    var numsSum33 = 0\n    var numsSum34\
    \ = 0\n    var numsSum35 = 0\n    var numsSum36 = 0\n    var numsSum37 = 0\n \
    \   var numsSum38 = 0\n    var numsSum39 = 0\n    var numsSum40 = 0\n    var numsSum41\
    \ = 0\n    var numsSum42 = 0\n    var numsSum43 = 0\n    var numsSum44 = 0\n \
    \   var numsSum45 = 0\n    var numsSum46 = 0\n    var numsSum47 = 0\n    var numsSum48\
    \ = 0\n    var numsSum49 = 0\n    var numsSum50 = 0\n    var numsSum51 = 0\n \
    \   var numsSum52 = 0\n    var numsSum53 = 0\n    var numsSum54 = 0\n    var numsSum55\
    \ = 0\n    var numsSum56 = 0\n    var numsSum57 = 0\n    var numsSum58 = 0\n \
    \   var numsSum59 = 0\n    var numsSum60 = 0\n    var numsSum61 = 0\n    var numsSum62\
    \ = 0\n    var numsSum63 = 0\n    var numsSum64 = 0\n    var numsSum65 = 0\n \
    \   var numsSum66 = 0\n    var numsSum67 = 0\n    var numsSum68 = 0\n    var numsSum69\
    \ = 0\n    var numsSum70 = 0\n    var numsSum71 = 0\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpt0182lxb.swift:97:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpt0182lxb.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt0182lxb.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpt0182lxb.swift:25:9:\
    \ warning: initialization of variable 'numsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsCount = nums.count\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpt0182lxb.swift:26:9: warning: initialization of variable 'numsSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsSum = 0\n    ~~~~^~~~~~~\n    _\n/tmp/tmpt0182lxb.swift:27:9: warning:\
    \ initialization of variable 'numsSum2' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var numsSum2 = 0\n    ~~~~^~~~~~~~\n \
    \   _\n/tmp/tmpt0182lxb.swift:28:9: warning: initialization of variable 'numsSum3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsSum3 = 0\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpt0182lxb.swift:29:9: warning:\
    \ initialization of variable 'numsSum4' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var numsSum4 = 0\n    ~~~~^~~~~~~~\n \
    \   _\n/tmp/tmpt0182lxb.swift:30:9: warning: initialization of variable 'numsSum5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsSum5 = 0\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpt0182lxb.swift:31:9: warning:\
    \ initialization of variable 'numsSum6' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var numsSum6 = 0\n    ~~~~^~~~~~~~\n \
    \   _\n/tmp/tmpt0182lxb.swift:32:9: warning: initialization of variable 'numsSum7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsSum7 = 0\n    ~~~~^"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [String]()\n\
    \    var count = 0\n    for c in num {\n        hexDigits.append(String(format:\
    \ \"%c\", c))\n    }\n    for hexDigit in hexDigits {\n        if hexDigit ==\
    \ \"A\" || hexDigit == \"B\" || hexDigit == \"C\" || hexDigit == \"D\" || hexDigit\
    \ == \"E\" || hexDigit == \"F\" {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptn819ysf.swift:27:26: error: no exact matches in call to initializer\
    \ \n        hexDigits.append(String(format: \"%c\", c))\n                    \
    \     ^\nSwift.String:4:23: note: candidate '(String) -> String' requires 1 argument,\
    \ but 2 were provided\n    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\n/tmp/tmptn819ysf.swift:27:26: note: candidate has partially\
    \ matching parameter list (repeating: String, count: Int)\n        hexDigits.append(String(format:\
    \ \"%c\", c))\n                         ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = \"\"\n    for char in num {\n        switch char {\n        case \"\
    0\":\n            digits = \"0\"\n        case \"1\":\n            digits = \"\
    1\"\n        case \"2\":\n            digits = \"2\"\n        case \"3\":\n  \
    \          digits = \"3\"\n        case \"4\":\n            digits = \"4\"\n \
    \       case \"5\":\n            digits = \"5\"\n        case \"6\":\n       \
    \     digits = \"6\"\n        case \"7\":\n            digits = \"7\"\n      \
    \  case \"8\":\n            digits = \"8\"\n        case \"9\":\n            digits\
    \ = \"9\"\n        case \"A\":\n            digits = \"A\"\n        case \"B\"\
    :\n            digits = \"B\"\n        case \"C\":\n            digits = \"C\"\
    \n        case \"D\":\n            digits = \"D\"\n        case \"E\":\n     \
    \       digits = \"E\"\n        case \"F\":\n            digits = \"F\"\n    \
    \    default:\n            break\n        }\n    }\n    if digits == \"0\" ||\
    \ digits == \"1\" {\n        return Int(digits)\n    }\n    var hexDigits = \"\
    \"\n    var hexDigit = 0\n    for char in digits {\n        hexDigit = Int(String(char).unicodeScalars.first!)\n\
    \        hexDigits += String(hexDigit)\n    }\n    for char in hexDigits {\n \
    \       if Int(char) == 2 {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz31i1p3_.swift:65:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        return Int(digits)\n        \
    \       ^\n/tmp/tmpz31i1p3_.swift:65:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return Int(digits)\n\
    \               ^\n                           ?? <#default value#>\n/tmp/tmpz31i1p3_.swift:65:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Int(digits)\n               ^\n                      \
    \    !\n/tmp/tmpz31i1p3_.swift:70:20: error: no exact matches in call to initializer\
    \ \n        hexDigit = Int(String(char).unicodeScalars.first!)\n             \
    \      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that 'Unicode.Scalar'\
    \ conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n\
    \    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n  \
    \                    ^\nSwift.SignedInteger:2:23: note: candidate requires that\
    \ 'Unicode.Scalar' conform to 'BinaryInteger' (requirement specified as 'T' :\
    \ 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpz31i1p3_.swift:74:12: error: no exact matches\
    \ in call to initializer \n        if Int(char) == 2 {\n           ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Bui"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexString = \"\"\n    for hex in hex {\n        hexString += String(hex)\n\
    \    }\n    var hexStringArray = hexString.characters\n    var hexStringArrayLength\
    \ = hexStringArray.count\n    var hexStringArrayLength2 = hexStringArrayLength\
    \ / 2\n    var hexStringArrayLength3 = hexStringArrayLength / 3\n    var hexStringArrayLength4\
    \ = hexStringArrayLength / 4\n    var hexStringArrayLength5 = hexStringArrayLength\
    \ / 5\n    var hexStringArrayLength6 = hexStringArrayLength / 6\n    var hexStringArrayLength7\
    \ = hexStringArrayLength / 7\n    var hexStringArrayLength8 = hexStringArrayLength\
    \ / 8\n    var hexStringArrayLength9 = hexStringArrayLength / 9\n    var hexStringArrayLength10\
    \ = hexStringArrayLength / 10\n    var hexStringArrayLength11 = hexStringArrayLength\
    \ / 11\n    var hexStringArrayLength12 = hexStringArrayLength / 12\n    var hexStringArrayLength13\
    \ = hexStringArrayLength / 13\n    var hexStringArrayLength14 = hexStringArrayLength\
    \ / 14\n    var hexStringArrayLength15 = hexStringArrayLength / 15\n    var hexStringArrayLength16\
    \ = hexStringArrayLength / 16\n    var hexStringArrayLength17 = hexStringArrayLength\
    \ / 17\n    var hexStringArrayLength18 = hexStringArrayLength / 18\n    var hexStringArrayLength19\
    \ = hexStringArrayLength / 19\n    var hexStringArrayLength20 = hexStringArrayLength\
    \ / 20\n    var hexStringArrayLength21 = hexStringArrayLength / 21\n    var hexStringArrayLength22\
    \ = hexStringArrayLength / 22\n    var hexStringArrayLength23 = hexStringArrayLength\
    \ / 23\n    var hexStringArrayLength24 = hexStringArrayLength / 24\n    var hexStringArrayLength25\
    \ = hexStringArrayLength / 25\n    var hexStringArrayLength26 = hexStringArrayLength\
    \ / 26\n    var hexStringArrayLength27 = hexStringArrayLength / 27\n    var hexStringArrayLength28\
    \ = hexStringArrayLength / 28\n    var hexStringArrayLength29 = hexStringArrayLength\
    \ / 29\n    var hexStringArrayLength30 = hexStringArrayLength / 30\n    var hexStringArrayLength31\
    \ = hexStringArrayLength / 31\n    var hexStringArrayLength32 = hexStringArrayLength\
    \ / 32\n    var hexStringArrayLength33 = hexStringArrayLength / 33\n    var hexStringArrayLength34\
    \ = hexStringArrayLength / 34\n    var hexStringArrayLength35 = hexStringArrayLength\
    \ / \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\n\
    assert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\n\
    assert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpx5yoazj1.swift:65:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpx5yoazj1.swift:29:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexStringArray = hexString.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        let hex = nums[_]\n\
    \        if hex >= '0' && hex <= '9' {\n            count += 1\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpociguo0e.swift:28:19: error: single-quoted string literal found,\
    \ use '\"'\n        if hex >= '0' && hex <= '9' {\n                  ^~~\n   \
    \               \"0\"\n/tmp/tmpociguo0e.swift:28:33: error: single-quoted string\
    \ literal found, use '\"'\n        if hex >= '0' && hex <= '9' {\n           \
    \                     ^~~\n                                \"9\"\n/tmp/tmpociguo0e.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpociguo0e.swift:27:24: error: '_' can only appear in\
    \ a pattern or on the left side of an assignment\n        let hex = nums[_]\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.unicodeScalars\n\
    \        .filter { $0.isHexadecimal }\n        .map { $0.value }\n        .sorted()\n\
    \        .map { Int($0) }\n    return digits.count { digit in\n        let prime\
    \ = Int(pow(digit, 2))\n        return prime > 1 && prime % 2 == 0\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvy_7r30o.swift:25:22: error: value of type 'Unicode.Scalar' has\
    \ no member 'isHexadecimal'\n        .filter { $0.isHexadecimal }\n          \
    \        ~~ ^~~~~~~~~~~~~\n/tmp/tmpvy_7r30o.swift:30:25: error: cannot find 'pow'\
    \ in scope\n        let prime = Int(pow(digit, 2))\n                        ^~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < hexDigitPrimeCount {\n        return hexDigitCount\n \
    \   }\n    return hexDigitPrimeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2rri12df.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp2rri12df.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2rri12df.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = num.characters.map { Int($0) }\n    var hexNums = hexNum.map\
    \ { Int($0) }\n    var hexNumsCount = hexNums.count\n    var hexNumsSum = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum2 = hexNums.reduce(0, +)\n    var hexNumsSum3 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum4 = hexNums.reduce(0, +)\n    var hexNumsSum5 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum6 = hexNums.reduce(0, +)\n    var hexNumsSum7 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum8 = hexNums.reduce(0, +)\n    var hexNumsSum9 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum10 = hexNums.reduce(0, +)\n    var hexNumsSum11 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum12 = hexNums.reduce(0, +)\n    var hexNumsSum13 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum14 = hexNums.reduce(0, +)\n    var hexNumsSum15 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum16 = hexNums.reduce(0, +)\n    var hexNumsSum17 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum18 = hexNums.reduce(0, +)\n    var hexNumsSum19 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum20 = hexNums.reduce(0, +)\n    var hexNumsSum21 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum22 = hexNums.reduce(0, +)\n    var hexNumsSum23 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum24 = hexNums.reduce(0, +)\n    var hexNumsSum25 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum26 = hexNums.reduce(0, +)\n    var hexNumsSum27 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum28 = hexNums.reduce(0, +)\n    var hexNumsSum29 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum30 = hexNums.reduce(0, +)\n    var hexNumsSum31 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum32 = hexNums.reduce(0, +)\n    var hexNumsSum33 = hexNums.reduce(0,\
    \ +)\n    var hexNumsSum34 = hexNums.reduce(0, +)\n    var hexNum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8_whes3x.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8_whes3x.swift:25:39:\
    \ error: no exact matches in call to initializer \n    var hexNum = num.characters.map\
    \ { Int($0) }\n                                      ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'String.Element' (aka 'Character'))\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n\
    /tmp/tmp8_whes3x.swift:62:9: error: type annotation missing in pattern\n    var\
    \ hexNum\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexNum = 0\n    var hexNumCount = 0\n\
    \    var hexNumString = \"\"\n    var hexNumStringCount = 0\n    var hexNumStringArray\
    \ = [String]()\n    var hexNumStringArrayCount = 0\n    var hexNumStringArrayCount2\
    \ = 0\n    var hexNumStringArrayCount3 = 0\n    var hexNumStringArrayCount4 =\
    \ 0\n    var hexNumStringArrayCount5 = 0\n    var hexNumStringArrayCount6 = 0\n\
    \    var hexNumStringArrayCount7 = 0\n    var hexNumStringArrayCount8 = 0\n  \
    \  var hexNumStringArrayCount9 = 0\n    var hexNumStringArrayCount10 = 0\n   \
    \ var hexNumStringArrayCount11 = 0\n    var hexNumStringArrayCount12 = 0\n   \
    \ var hexNumStringArrayCount13 = 0\n    var hexNumStringArrayCount14 = 0\n   \
    \ var hexNumStringArrayCount15 = 0\n    var hexNumStringArrayCount16 = 0\n   \
    \ var hexNumStringArrayCount17 = 0\n    var hexNumStringArrayCount18 = 0\n   \
    \ var hexNumStringArrayCount19 = 0\n    var hexNumStringArrayCount20 = 0\n   \
    \ var hexNumStringArrayCount21 = 0\n    var hexNumStringArrayCount22 = 0\n   \
    \ var hexNumStringArrayCount23 = 0\n    var hexNumStringArrayCount24 = 0\n   \
    \ var hexNumStringArrayCount25 = 0\n    var hexNumStringArrayCount26 = 0\n   \
    \ var hexNumStringArrayCount27 = 0\n    var hexNumStringArrayCount28 = 0\n   \
    \ var hexNumStringArrayCount29 = 0\n    var hexNumStringArrayCount30 = 0\n   \
    \ var hexNumStringArrayCount31 = 0\n    var hexNumStringArrayCount32 = 0\n   \
    \ var hexNumStringArrayCount33 = 0\n    var hexNumStringArrayCount34 = 0\n   \
    \ var hexNumStringArrayCount35 = 0\n    var hexNumStringArrayCount36 = 0\n   \
    \ var hexNumStringArrayCount37 = 0\n    var hexNumStringArrayCount38 = 0\n   \
    \ var hexNumStringArrayCount39 = 0\n    var hexNumStringArrayCount40 = 0\n   \
    \ var hexNumStringArrayCount41 = 0\n    var hexNumStringArrayCount42 = 0\n   \
    \ var hexNumStringArrayCount43 = 0\n    var hexNumStringArrayCount44 = 0\n   \
    \ var hexNumStringArrayCount45 = 0\n    var hexNumStringArrayCount46 = 0\n   \
    \ var hexNumStringArrayCount47 = 0\n    var hexNumStringArrayCount48 = 0\n   \
    \ var hexNumStringArrayCount49 = 0\n    var hexNumStringArrayCount50 = 0\n   \
    \ var hexNumStringArrayCount51 = 0\n    var hexNumStringArray\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptbham2r3.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptbham2r3.swift:82:9:\
    \ error: type annotation missing in pattern\n    var hexNumStringArray\n     \
    \   ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for _ in 0..<nums.count {\n        let num = nums[_]\n\
    \        if num == \"A\" || num == \"B\" || num == \"C\" || num == \"D\" || num\
    \ == \"E\" || num == \"F\" {\n            continue\n        }\n        if num\
    \ == \"0\" || num == \"1\" {\n            continue\n        }\n        if num\
    \ == \"2\" {\n            result += 1\n            continue\n        }\n     \
    \   if num == \"3\" {\n            result += 2\n            continue\n       \
    \ }\n        if num == \"5\" {\n            result += 3\n            continue\n\
    \        }\n        if num == \"7\" {\n            result += 4\n            continue\n\
    \        }\n        if num == \"B\" {\n            result += 11\n            continue\n\
    \        }\n        if num == \"D\" {\n            result += 13\n            continue\n\
    \        }\n        break\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp7qezw9mr.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7qezw9mr.swift:27:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let num = nums[_]\n                       ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexDigits = hex.count\n    var hexDigit = 0\n    var hexDigitCount =\
    \ 0\n    var hexDigitCount2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitCount4\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitCount7\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitCount10\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitCount13\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitCount16\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitCount19\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitCount22\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitCount25\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitCount28\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitCount31\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitCount34\
    \ = 0\n    var hexDigitCount35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitCount37\
    \ = 0\n    var hexDigitCount38 = 0\n    var hexDigitCount39 = 0\n    var hexDigitCount40\
    \ = 0\n    var hexDigitCount41 = 0\n    var hexDigitCount42 = 0\n    var hexDigitCount43\
    \ = 0\n    var hexDigitCount44 = 0\n    var hexDigitCount45 = 0\n    var hexDigitCount46\
    \ = 0\n    var hexDigitCount47 = 0\n    var hexDigitCount48 = 0\n    var hexDigitCount49\
    \ = 0\n    var hexDigitCount50 = 0\n    var hexDigitCount51 = 0\n    var hexDigitCount52\
    \ = 0\n    var hexDigitCount53 = 0\n    var hexDigitCount54 = 0\n    var hexDigitCount55\
    \ = 0\n    var hexDigitCount56 = 0\n    var hexDigitCount57 = 0\n    var hexDigitCount58\
    \ = 0\n    var hexDigitCount59 = 0\n    var hexDigitCount60 = 0\n    var hexDigitCount61\
    \ = 0\n    var hexDigitCount62 = 0\n    var hexDigitCount63 = 0\n    var hexDigitCount64\
    \ = 0\n    var hexDigitCount65 = 0\n    var hexDigitCount66 = 0\n    var hexDigitCount67\
    \ = 0\n    var hexDigitCount68 = 0\n    var hexDigitCount69 = 0\n    var hexDigitCount70\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6c6wpln7.swift:97:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp6c6wpln7.swift:24:9: warning: variable 'hex' was never mutated; consider\
    \ changing to 'let' constant\n    var hex = num.unicodeScalars\n    ~~~ ^\n  \
    \  let\n/tmp/tmp6c6wpln7.swift:25:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = hex.count\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:26:9:\
    \ warning: initialization of variable 'hexDigit' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexDigit = 0\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:27:9: warning: initialization of variable 'hexDigitCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:28:9:\
    \ warning: initialization of variable 'hexDigitCount2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount2 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:29:9: warning: initialization\
    \ of variable 'hexDigitCount3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount3 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:30:9: warning: initialization of variable 'hexDigitCount4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount4 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:31:9:\
    \ warning: initialization of variable 'hexDigitCount5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount5 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:32:9: warning: initialization\
    \ of variable 'hexDigitCount6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount6 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:33:9: warning: initialization of variable 'hexDigitCount7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \  "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimePrimes = hexDigitPrimes.filter { $0 % 3 == 0 }\n    let\
    \ hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { $0 % 5 == 0 }\n    let hexDigitPrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { $0 % 7 == 0 }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { $0 % 11 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter\
    \ { $0 % 13 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { $0 %\
    \ 19 == 0 }\n    let hexDigitPrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp52ga59ph.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:39:56: error: use of local\
    \ variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimes' before its declaration\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n                                                       ^\n\
    /tmp/tmp52ga59ph.swift:39:9: note: 'hexDigitPrimePrimePrimePrimePrimePrimePrimes'\
    \ declared here\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n        ^\n/tmp/tmp52ga59ph.swift:40:65: error: use of local\
    \ variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes' before its\
    \ declaration\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n             \
    \                                                   ^\n/tmp/tmp52ga59ph.swift:41:9:\
    \ note: 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes' declared here\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 19 == 0 }\n        ^\n/tmp/tmp52ga59ph.swift:41:66: error: cannot find\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes' in scope\n   \
    \ let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 19 == 0 }\n                                                         \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:42:9:\
    \ error: type annotation missing in pattern\n    let hexDigitPrimePrimePrimePr"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var count = 0\n    for _ in 0..<hex.count {\n        if hex[hex.startIndex\
    \ + _].isPrime {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpzs3o_iky.swift:27:33: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        if hex[hex.startIndex + _].isPrime\
    \ {\n                                ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  let digits = num.unicodeScalars.map { $0.value }\n    var count = 0\n    for\
    \ digit in digits {\n        if digit == 0xB {\n            count += 1\n     \
    \   } else if digit == 0xD {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmphnq6ku6l/tmphnq6ku6l.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5b83b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5b80acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5b80ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5b80ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphnq6ku6l                        0x000055d7785dc674 <unavailable> + 5748

    5    libc.so.6                          0x00002ba5b85a1460 __libc_start_main +
    245

    6    tmphnq6ku6l                        0x000055d7785dc2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\":\n            count += 1\n        default:\n            break\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmphu5lm__f/tmphu5lm__f.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afee184fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afee1546b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afee1546988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afee15457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphu5lm__f                        0x0000565077d1f414 <unavailable> + 5140

    5    libc.so.6                          0x00002afee1a3b460 __libc_start_main +
    245

    6    tmphu5lm__f                        0x0000565077d1f099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    for c in num {\n        if c >= '0' && c <= '9' {\n            nums.append(c\
    \ - '0')\n        } else if c >= 'A' && c <= 'F' {\n            nums.append(c\
    \ - 'A' + 10)\n        } else if c >= 'a' && c <= 'f' {\n            nums.append(c\
    \ - 'a' + 10)\n        } else {\n            return -1\n        }\n    }\n   \
    \ return nums.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpc8rgv848.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpc8rgv848.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpc8rgv848.swift:27:29: error:\
    \ single-quoted string literal found, use '\"'\n            nums.append(c - '0')\n\
    \                            ^~~\n                            \"0\"\n/tmp/tmpc8rgv848.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmpc8rgv848.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmpc8rgv848.swift:29:29:\
    \ error: single-quoted string literal found, use '\"'\n            nums.append(c\
    \ - 'A' + 10)\n                            ^~~\n                            \"\
    A\"\n/tmp/tmpc8rgv848.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmpc8rgv848.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmpc8rgv848.swift:31:29: error: single-quoted string literal found,\
    \ use '\"'\n            nums.append(c - 'a' + 10)\n                          \
    \  ^~~\n                            \"a\"\n/tmp/tmpc8rgv848.swift:27:27: error:\
    \ binary operator '-' cannot be applied to two 'Character' operands\n        \
    \    nums.append(c - '0')\n                          ^\nSwift.Strideable:1:11:\
    \ note: candidate requires that 'Character' conform to '_Pointer' (requirement\
    \ specified as 'Self' : '_Pointer')\nextension Strideable where Self : _Pointer\
    \ {\n          ^\n/tmp/tmpc8rgv848.swift:29:33: error: binary operator '+' cannot"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimePrimes = hexDigitPrimes.filter { $0 % 3 == 0 }\n    let\
    \ hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { $0 % 5 == 0 }\n    let hexDigitPrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { $0 % 7 == 0 }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { $0 % 11 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter\
    \ { $0 % 13 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { $0 %\
    \ 19 == 0 }\n    let hexDigitPrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp52ga59ph.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:39:56: error: use of local\
    \ variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimes' before its declaration\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n                                                       ^\n\
    /tmp/tmp52ga59ph.swift:39:9: note: 'hexDigitPrimePrimePrimePrimePrimePrimePrimes'\
    \ declared here\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n        ^\n/tmp/tmp52ga59ph.swift:40:65: error: use of local\
    \ variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes' before its\
    \ declaration\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n             \
    \                                                   ^\n/tmp/tmp52ga59ph.swift:41:9:\
    \ note: 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes' declared here\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 19 == 0 }\n        ^\n/tmp/tmp52ga59ph.swift:41:66: error: cannot find\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes' in scope\n   \
    \ let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 19 == 0 }\n                                                         \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp52ga59ph.swift:42:9:\
    \ error: type annotation missing in pattern\n    let hexDigitPrimePrimePrimePr"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let c = nums[index]\n\
    \        if c >= '0' && c <= '9' {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptu9wgcph.swift:28:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmptu9wgcph.swift:28:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmptu9wgcph.swift:24:20: error:\
    \ 'characters' is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptu9wgcph.swift:27:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = nums[index]\n\
    \                ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmptu9wgcph.swift:24:9: warning: variable 'nums'\
    \ was never mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for num in nums\
    \ {\n        if nums.contains(String(num).uppercased) {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpjj2jl7dn.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjj2jl7dn.swift:28:38:\
    \ error: function produces expected type 'String'; did you mean to call it with\
    \ '()'?\n        if nums.contains(String(num).uppercased) {\n                \
    \         ~~~~~~~~~~~~^~~~~~~~~~\n                                           \
    \    ()\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\n\
    \        let digit = Int(char) ?? 0\n        switch digit {\n        case 0:\n\
    \            result += 1\n        case 1:\n            result += 1\n        case\
    \ 2:\n            result += 1\n        case 3:\n            result += 1\n    \
    \    case 4:\n            result += 1\n        case 5:\n            result +=\
    \ 1\n        case 6:\n            result += 1\n        case 7:\n            result\
    \ += 1\n        case 8:\n            result += 1\n        case 9:\n          \
    \  result += 1\n        case 10:\n            result += 1\n        case 11:\n\
    \            result += 1\n        case 12:\n            result += 1\n        case\
    \ 13:\n            result += 1\n        case 14:\n            result += 1\n  \
    \      case 15:\n            result += 1\n        case 16:\n            result\
    \ += 1\n        case 17:\n            result += 1\n        case 18:\n        \
    \    result += 1\n        case 19:\n            result += 1\n        case 20:\n\
    \            result += 1\n        case 21:\n            result += 1\n        case\
    \ 22:\n            result += 1\n        case 23:\n            result += 1\n  \
    \      case 24:\n            result += 1\n        case 25:\n            result\
    \ += 1\n        case 26:\n            result += 1\n        case 27:\n        \
    \    result += 1\n        case 28:\n            result += 1\n        case 29:\n\
    \            result += 1\n        case 30:\n            result += 1\n        case\
    \ 31:\n            result += 1\n        case 32:\n            result += 1\n  \
    \      case 33:\n            result += 1\n        case 34:\n            result\
    \ += 1\n        case 35:\n            result += 1\n        case 36:\n        \
    \    result += 1\n        case 37:\n            result += 1\n        case 38:\n\
    \            result += 1\n        case 39:\n            result += 1\n        case\
    \ 40:\n            result += 1\n        case 41:\n            result += 1\n  \
    \      case 42:\n            result += 1\n        case 43:\n            result\
    \ += 1\n        case 44:\n            result += 1\n        case 45:\n        \
    \    result += 1\n        case 46:\n            result += 1\n        case 47:\n\
    \            result += 1\n        case 48:\n            result += 1\n        case\
    \ 49:\n            result += 1\n        case 50:\n            result += 1\n  \
    \      case 51:\n            result += 1\n        case 52:\n            result\
    \ += 1\n        case 53:\n            result += 1\n        case 54:\n        \
    \    result += 1\n        case 55:\n            result += 1\n        case 56:\n\
    \            result += 1\n        case 57:\n            result += 1\n        case\
    \ 58:\n            result += 1\n        case 59:\n            result += 1\n  \
    \      case 60:\n            result += 1\n        case 61:\n            result\
    \ += 1\n        case 62\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1xi12ko_.swift:154:16: error: expected ':' after 'case'\n     \
    \   case 62\n               ^\n/tmp/tmp1xi12ko_.swift:175:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmp1xi12ko_.swift:26:33:\
    \ note: to match this opening '{'\n    for index in 0..<nums.count {\n       \
    \                         ^\n/tmp/tmp1xi12ko_.swift:175:63: error: expected '}'\
    \ at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmp1xi12ko_.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmp1xi12ko_.swift:24:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1xi12ko_.swift:27:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = nums[index]\n                   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp1xi12ko_.swift:28:25: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   let digit = Int(char) ?? 0\n                        ^\n/tmp/tmp1xi12ko_.swift:158:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexDigits = [UInt8](repeating: 0, count:\
    \ numsCount)\n    var hexDigitsCount = numsCount\n    var hexDigitsCount2 = numsCount\n\
    \    var hexDigitsCount3 = numsCount\n    var hexDigitsCount4 = numsCount\n  \
    \  var hexDigitsCount5 = numsCount\n    var hexDigitsCount6 = numsCount\n    var\
    \ hexDigitsCount7 = numsCount\n    var hexDigitsCount8 = numsCount\n    var hexDigitsCount9\
    \ = numsCount\n    var hexDigitsCount10 = numsCount\n    var hexDigitsCount11\
    \ = numsCount\n    var hexDigitsCount12 = numsCount\n    var hexDigitsCount13\
    \ = numsCount\n    var hexDigitsCount14 = numsCount\n    var hexDigitsCount15\
    \ = numsCount\n    var hexDigitsCount16 = numsCount\n    var hexDigitsCount17\
    \ = numsCount\n    var hexDigitsCount18 = numsCount\n    var hexDigitsCount19\
    \ = numsCount\n    var hexDigitsCount20 = numsCount\n    var hexDigitsCount21\
    \ = numsCount\n    var hexDigitsCount22 = numsCount\n    var hexDigitsCount23\
    \ = numsCount\n    var hexDigitsCount24 = numsCount\n    var hexDigitsCount25\
    \ = numsCount\n    var hexDigitsCount26 = numsCount\n    var hexDigitsCount27\
    \ = numsCount\n    var hexDigitsCount28 = numsCount\n    var hexDigitsCount29\
    \ = numsCount\n    var hexDigitsCount30 = numsCount\n    var hexDigitsCount31\
    \ = numsCount\n    var hexDigitsCount32 = numsCount\n    var hexDigitsCount33\
    \ = numsCount\n    var hexDigitsCount34 = numsCount\n    var hexDigitsCount35\
    \ = numsCount\n    var hexDigitsCount36 = numsCount\n    var hexDigitsCount37\
    \ = numsCount\n    var hexDigitsCount38 = numsCount\n    var hexDigitsCount39\
    \ = numsCount\n    var hexDigitsCount40 = numsCount\n    var hexDigitsCount41\
    \ = numsCount\n    var hexDigitsCount42 = numsCount\n    var hexDigitsCount43\
    \ = numsCount\n    var hexDigitsCount44 = numsCount\n    var hexDigitsCount45\
    \ = numsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmi25k_ie.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmi25k_ie.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpmi25k_ie.swift:25:9:\
    \ warning: variable 'numsCount' was never mutated; consider changing to 'let'\
    \ constant\n    var numsCount = nums.count\n    ~~~ ^\n    let\n/tmp/tmpmi25k_ie.swift:26:9:\
    \ warning: initialization of variable 'hexDigits' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexDigits = [UInt8](repeating:\
    \ 0, count: numsCount)\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpmi25k_ie.swift:27:9:\
    \ warning: initialization of variable 'hexDigitsCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitsCount = numsCount\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpmi25k_ie.swift:28:9: warning: initialization\
    \ of variable 'hexDigitsCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitsCount2 = numsCount\n    ~~~~^~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpmi25k_ie.swift:29:9: warning: initialization of variable 'hexDigitsCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitsCount3 = numsCount\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpmi25k_ie.swift:30:9:\
    \ warning: initialization of variable 'hexDigitsCount4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitsCount4 = numsCount\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpmi25k_ie.swift:31:9: warning: initialization\
    \ of variable 'hexDigitsCount5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitsCount5 = numsCount\n    ~~~~^~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpmi25k_ie.swift:32:9: warning: initialization of variable 'hexDigitsCount6'\
    \ was never used; conside"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    \n    var count = 0\n    \n    for char\
    \ in num {\n        switch char {\n        case \"0\":\n        case \"1\":\n\
    \        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"\
    5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case\
    \ \"9\":\n        case \"a\":\n        case \"b\":\n        case \"c\":\n    \
    \    case \"d\":\n        case \"e\":\n        case \"f\":\n            count\
    \ += 1\n        default:\n            break\n        }\n    }\n    \n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu3hy8jsr.swift:32:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpu3hy8jsr.swift:33:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:34:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:42:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"a\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:43:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"b\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpu3hy8jsr.swift:44:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var nums_len = nums.count\n    var nums_copy = nums\n    var nums_copy_len\
    \ = nums_copy.count\n    var nums_copy_copy = nums_copy\n    var nums_copy_copy_len\
    \ = nums_copy_copy.count\n    var nums_copy_copy_copy_len = nums_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_len = nums_copy_copy_copy_copy.count\n    var\
    \ nums_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy.count\n  \
    \  var nums_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_znfxi_0.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_znfxi_0.swift:30:35:\
    \ error: cannot find 'nums_copy_copy_copy' in scope\n    var nums_copy_copy_copy_len\
    \ = nums_copy_copy_copy.count\n                                  ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_znfxi_0.swift:31:40: error: cannot find 'nums_copy_copy_copy_copy' in\
    \ scope\n    var nums_copy_copy_copy_copy_len = nums_copy_copy_copy_copy.count\n\
    \                                       ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_znfxi_0.swift:32:45:\
    \ error: cannot find 'nums_copy_copy_copy_copy_copy' in scope\n    var nums_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy.count\n                                    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_znfxi_0.swift:33:50: error: cannot\
    \ find 'nums_copy_copy_copy_copy_copy_copy' in scope\n    var nums_copy_copy_copy_copy_copy_copy_len\
    \ = nums_copy_copy_copy_copy_copy_copy.count\n                               \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_znfxi_0.swift:34:55:\
    \ error: cannot find 'nums_copy_copy_copy_copy_copy_copy_copy' in scope\n    var\
    \ nums_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy.count\n\
    \                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_znfxi_0.swift:35:60: error: cannot find 'nums_copy_copy_copy_copy_copy_copy_copy_copy'\
    \ in scope\n    var nums_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy.count\n\
    \                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_znfxi_0.swift:36:65: error: cannot find 'nums_copy_copy_copy_copy_copy_copy_copy_copy_copy'\
    \ in scope\n    var nums_copy_copy_copy_copy_copy_copy_copy_copy_copy_len = nums_copy_copy_copy_copy_copy_copy_copy_copy_copy.coun"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = Array<Int>()\n    var prime: Int?\n    var\
    \ prime_found = false\n    var prime_found2 = false\n    var prime_found3 = false\n\
    \    var prime_found4 = false\n    var prime_found5 = false\n    var prime_found6\
    \ = false\n    var prime_found7 = false\n    var prime_found8 = false\n    var\
    \ prime_found9 = false\n    var prime_found10 = false\n    var prime_found11 =\
    \ false\n    var prime_found12 = false\n    var prime_found13 = false\n    var\
    \ prime_found14 = false\n    var prime_found15 = false\n    var prime_found16\
    \ = false\n    var prime_found17 = false\n    var prime_found18 = false\n    var\
    \ prime_found19 = false\n    var prime_found20 = false\n    var prime_found21\
    \ = false\n    var prime_found22 = false\n    var prime_found23 = false\n    var\
    \ prime_found24 = false\n    var prime_found25 = false\n    var prime_found26\
    \ = false\n    var prime_found27 = false\n    var prime_found28 = false\n    var\
    \ prime_found29 = false\n    var prime_found30 = false\n    var prime_found31\
    \ = false\n    var prime_found32 = false\n    var prime_found33 = false\n    var\
    \ prime_found34 = false\n    var prime_found35 = false\n    var prime_found36\
    \ = false\n    var prime_found37 = false\n    var prime_found38 = false\n    var\
    \ prime_found39 = false\n    var prime_found40 = false\n    var prime_found41\
    \ = false\n    var prime_found42 = false\n    var prime_found43 = false\n    var\
    \ prime_found44 = false\n    var prime_found45 = false\n    var prime_found46\
    \ = false\n    var prime_found47 = false\n    var prime_found48 = false\n    var\
    \ prime_found49 = false\n    var prime_found50 = false\n    var prime_found51\
    \ = false\n    var prime_found52 = false\n    var prime_found53 = false\n    var\
    \ prime_found54 = false\n    var prime_found55 = false\n    var prime_found56\
    \ = false\n    var prime_found57 = false\n    var prime_found58 = false\n    var\
    \ prime_found59 = false\n    var prime_found60 = false\n    var prime_found61\
    \ = false\n    var prime_found62 = false\n    var prime_found63 = false\n    var\
    \ prime_found64 = false\n    var prime_found65 = false\n    var prime_found66\
    \ = false\n    var prime_found67 = false\n    var prime_found68 = false\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp52kcrjy9.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp52kcrjy9.swift:24:9:\
    \ warning: initialization of variable 'nums' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums = num.characters\n    ~~~~^~~~\n\
    \    _\n/tmp/tmp52kcrjy9.swift:25:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmp52kcrjy9.swift:26:9: warning:\
    \ initialization of variable 'primes' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var primes = Array<Int>()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp52kcrjy9.swift:27:9: warning: variable 'prime' was never used;\
    \ consider replacing with '_' or removing it\n    var prime: Int?\n        ^~~~~\n\
    \        _\n/tmp/tmp52kcrjy9.swift:28:9: warning: initialization of variable 'prime_found'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime_found = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp52kcrjy9.swift:29:9:\
    \ warning: initialization of variable 'prime_found2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var prime_found2 = false\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp52kcrjy9.swift:30:9: warning: initialization\
    \ of variable 'prime_found3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prime_found3 = false\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp52kcrjy9.swift:31:9: warning: initialization of variable 'prime_found4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime_found4 = false\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp52kcrjy9.swift:32:9:\
    \ warning: initialization of variable 'prime_found5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var prime_found5 = false\n\
    \    ~~~~^~~~~~~~~~"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"A\":\n        case \"B\"\
    :\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n            count += 1\n        default:\n            break\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpr2w52mkw.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpr2w52mkw.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdxnnxpa1.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"0\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n    var hexDigits:\
    \ [String] = []\n    var hexDigit: Int = 0\n    for hexDigit in 0..<hex.characters.count\
    \ {\n        let hexChar = hex.substringWithRange(NSMakeRange(0, hexDigit))\n\
    \        let hexCharUpper = hexChar.uppercaseString\n        if hexCharUpper ==\
    \ \"A\" || hexCharUpper == \"B\" || hexCharUpper == \"C\" || hexCharUpper == \"\
    D\" || hexCharUpper == \"E\" || hexCharUpper == \"F\" {\n            hexDigits.append(hexCharUpper)\n\
    \        }\n    }\n    var primeDigits: [String] = []\n    var primeDigit: Int\
    \ = 0\n    for primeDigit in 0..<hexDigits.count {\n        let primeChar = hexDigits[primeDigit]\n\
    \        if primeChar == \"2\" || primeChar == \"3\" || primeChar == \"5\" ||\
    \ primeChar == \"7\" || primeChar == \"B\" || primeChar == \"D\" {\n         \
    \   primeDigits.append(primeChar)\n        }\n    }\n    return primeDigits.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpuz2vdksh.swift:24:87: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    var hex = num.stringByReplacingOccurrencesOfString(\"0x\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n         \
    \                                                                            \
    \ ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuz2vdksh.swift:24:19: error: value of type 'String'\
    \ has no member 'stringByReplacingOccurrencesOfString'\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n              ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuz2vdksh.swift:24:132:\
    \ error: 'nil' requires a contextual type\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n                                                                     \
    \                                                              ^\n/tmp/tmpuz2vdksh.swift:25:82:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuz2vdksh.swift:25:127: error: 'nil' requires\
    \ a contextual type\n    hex = hex.stringByReplacingOccurrencesOfString(\"0\"\
    , withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \                                                  ^\n/tmp/tmpuz2vdksh.swift:29:46:\
    \ error: cannot find 'NSMakeRange' in scope\n        let hexChar = hex.substringWithRange(NSMakeRange(0,\
    \ hexDigit))\n                                             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        if char == \"A\" || char ==\
    \ \"B\" || char == \"C\" || char == \"D\" || char == \"E\" || char == \"F\" {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppp40bfwj.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppp40bfwj.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [String]\
    \ = []\n    var hexDigitCount = 0\n    var hexDigitIndex = 0\n    var hexDigitCount2\
    \ = 0\n    var hexDigitIndex2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitIndex3\
    \ = 0\n    var hexDigitCount4 = 0\n    var hexDigitIndex4 = 0\n    var hexDigitCount5\
    \ = 0\n    var hexDigitIndex5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitIndex6\
    \ = 0\n    var hexDigitCount7 = 0\n    var hexDigitIndex7 = 0\n    var hexDigitCount8\
    \ = 0\n    var hexDigitIndex8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitIndex9\
    \ = 0\n    var hexDigitCount10 = 0\n    var hexDigitIndex10 = 0\n    var hexDigitCount11\
    \ = 0\n    var hexDigitIndex11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitIndex12\
    \ = 0\n    var hexDigitCount13 = 0\n    var hexDigitIndex13 = 0\n    var hexDigitCount14\
    \ = 0\n    var hexDigitIndex14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitIndex15\
    \ = 0\n    var hexDigitCount16 = 0\n    var hexDigitIndex16 = 0\n    var hexDigitCount17\
    \ = 0\n    var hexDigitIndex17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitIndex18\
    \ = 0\n    var hexDigitCount19 = 0\n    var hexDigitIndex19 = 0\n    var hexDigitCount20\
    \ = 0\n    var hexDigitIndex20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitIndex21\
    \ = 0\n    var hexDigitCount22 = 0\n    var hexDigitIndex22 = 0\n    var hexDigitCount23\
    \ = 0\n    var hexDigitIndex23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitIndex24\
    \ = 0\n    var hexDigitCount25 = 0\n    var hexDigitIndex25 = 0\n    var hexDigitCount26\
    \ = 0\n    var hexDigitIndex26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitIndex27\
    \ = 0\n    var hexDigitCount28 = 0\n    var hexDigitIndex28 = 0\n    var hexDigitCount29\
    \ = 0\n    var hexDigitIndex29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitIndex30\
    \ = 0\n    var hexDigitCount31 = 0\n    var hexDigitIndex31 = 0\n    var hexDigitCount32\
    \ = 0\n    var hexDigitIndex32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitIndex33\
    \ = 0\n    var hexDigitCount34 = 0\n    var hexDigitIndex34 = 0\n    var hexDigitCount35\
    \ = 0\n    var hexDigitIndex35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitIndex36\
    \ = 0\n    var hexDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpff6qv0mo.swift:97:9: error: type annotation missing in pattern\n\
    \    var hexDigit\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    for\
    \ char in num.characters {\n        let digit = Int(char) ?? 0\n        if digit\
    \ == 0 || digit == 1 {\n            continue\n        }\n        result += (digit\
    \ - 1) * pow(16, digit)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa_mnbh64.swift:25:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in num.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpa_mnbh64.swift:26:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        let digit = Int(char) ?? 0\n                        ^\n/tmp/tmpa_mnbh64.swift:30:33:\
    \ error: cannot find 'pow' in scope\n        result += (digit - 1) * pow(16, digit)\n\
    \                                ^~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var hexDigits = [UInt8](repeating: 0, count: digits.count)\n    for digit\
    \ in digits {\n        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n    }\n  \
    \  let hexString = String(hexDigits)\n    let hexCount = hexString.count\n   \
    \ let hexDigitCount = hexString.characters.count\n    var primeCount = 0\n   \
    \ var primeDigits = [UInt8](repeating: 0, count: hexDigitCount)\n    for digit\
    \ in hexDigits {\n        if digit == 0xB {\n            primeDigits[Int(digit)\
    \ - 0x40] = UInt8(digit)\n        }\n    }\n    for digit in primeDigits {\n \
    \       if digit == 0xB {\n            primeCount += 1\n        }\n    }\n   \
    \ return primeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp80ny5r0b.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp80ny5r0b.swift:27:19:\
    \ error: no exact matches in call to initializer \n        hexDigits[Int(digit)\
    \ - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:19: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:19:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:19:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:19:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:19:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n        \
    \          ^\n/tmp/tmp80ny5r0b.swift:27:19: note: candidate expects value of type\
    \ 'Builtin.Word' for parameter #1 (got 'Character')\n        hexDigits[Int(digit)\
    \ - 0x40] = UInt8(digit)\n                  ^\n/tmp/tmp80ny5r0b.swift:27:40: error:\
    \ no exact matches in call to initializer \n        hexDigits[Int(digit) - 0x40]\
    \ = UInt8(digit)\n                                       ^\n/tmp/tmp80ny5r0b.swift:27:40:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \        hexDigits[Int(digit) - 0x40] = UInt8(digit)\n                       \
    \                ^\n/tmp/tmp80ny5r0b.swift:27:40: note: candidate expects value\
    \ of type 'Float' for parameter #1 (got 'Character')\n       "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [String]()\n\
    \    var count = 0\n    for char in num {\n        hexDigits.append(String(char).uppercase)\n\
    \    }\n    for digit in hexDigits {\n        if digit == \"A\" {\n          \
    \  count += 1\n        } else if digit == \"B\" {\n            count += 1\n  \
    \      } else if digit == \"C\" {\n            count += 1\n        } else if digit\
    \ == \"D\" {\n            count += 1\n        } else if digit == \"E\" {\n   \
    \         count += 1\n        } else if digit == \"F\" {\n            count +=\
    \ 1\n        } else {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpssybl930.swift:27:39: error: value of type 'String' has no member\
    \ 'uppercase'\n        hexDigits.append(String(char).uppercase)\n            \
    \             ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime = 0\n    var\
    \ prime2 = 2\n    var prime3 = 3\n    var prime5 = 5\n    var prime7 = 7\n   \
    \ var prime11 = 1\n    var prime13 = 3\n    var prime17 = 7\n    var prime19 =\
    \ 7\n    var prime23 = 3\n    var prime29 = 7\n    var prime31 = 7\n    var prime37\
    \ = 7\n    var prime41 = 7\n    var prime43 = 7\n    var prime47 = 7\n    var\
    \ prime51 = 7\n    var prime59 = 7\n    var prime63 = 7\n    var prime67 = 7\n\
    \    var prime71 = 7\n    var prime73 = 7\n    var prime79 = 7\n    var prime83\
    \ = 7\n    var prime89 = 7\n    var prime93 = 7\n    var prime97 = 7\n    var\
    \ prime101 = 7\n    var prime103 = 7\n    var prime107 = 7\n    var prime109 =\
    \ 7\n    var prime113 = 7\n    var prime117 = 7\n    var prime121 = 7\n    var\
    \ prime123 = 7\n    var prime127 = 7\n    var prime129 = 7\n    var prime131 =\
    \ 7\n    var prime133 = 7\n    var prime137 = 7\n    var prime139 =  7\n    var\
    \ prime143 = 7\n    var prime147 =  7\n    var prime151 =  7\n    var prime153\
    \ =  7\n    var prime157 =  7\n    var prime159 =  7\n    var prime163 =  7\n\
    \    var prime167 =  7\n    var prime169 =  7\n    var prime173 =  7\n    var\
    \ prime177 =  7\n    var prime179 =  7\n    var prime181 =  7\n    var prime183\
    \ =  7\n    var prime187 =  7\n    var prime191 =  7\n    var prime193 =  7\n\
    \    var prime197 =  7\n    var prime199 =  7\n    var prime201 =  7\n    var\
    \ prime203 =  7\n    var prime207 =  7\n    var prime209 =  7\n    var prime211\
    \ =  7\n    var prime213 =  7\n    var prime217 =  7\n    var prime219 =  7\n\
    \    var prime221 =  7\n    var prime223 =  7\n    var prime227 =  7\n    var\
    \ prime229 =  7\n    var prime231 =  7\n    var prime233 =  7\n    var prime237\
    \ =  7\n    var prime239 =  7\n    var prime241 =  7\n    var prime243 =  7\n\
    \    var prime247 =  7\n    var prime249 =  7\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmps2cxrjqo.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmps2cxrjqo.swift:24:15:\
    \ warning: value 'num' was defined but never used; consider replacing with boolean\
    \ test\n    guard let num = num.lowercased() else {\n          ~~~~^~~~~~\n  \
    \                                   != nil\n/tmp/tmps2cxrjqo.swift:27:9: warning:\
    \ initialization of variable 'count' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmps2cxrjqo.swift:28:9:\
    \ warning: initialization of variable 'prime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmps2cxrjqo.swift:29:9: warning: initialization of variable 'prime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime2 = 2\n    ~~~~^~~~~~\n    _\n/tmp/tmps2cxrjqo.swift:30:9: warning:\
    \ initialization of variable 'prime3' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var prime3 = 3\n    ~~~~^~~~~~\n    _\n\
    /tmp/tmps2cxrjqo.swift:31:9: warning: initialization of variable 'prime5' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ prime5 = 5\n    ~~~~^~~~~~\n    _\n/tmp/tmps2cxrjqo.swift:32:9: warning: initialization\
    \ of variable 'prime7' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var prime7 = 7\n    ~~~~^~~~~~\n    _\n/tmp/tmps2cxrjqo.swift:33:9:\
    \ warning: initialization of variable 'prime11' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime11 = 1\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmps2cxrjqo.swift:34:9: warning: initialization of variable 'prime13'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime13 = 3\n    ~~~~^~~~~~~\n    _\n/tmp/tmps2cxrjqo.swift:35:9: warning:\
    \ initialization of variable 'prime17' was never used; consider replacing with\
    \ assignment to '_' or"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let len = digits.count\n    var count = 0\n    var prime: Int = 0\n    var\
    \ prime2: Int = 0\n    var prime3: Int = 0\n    var prime4: Int = 0\n    var prime5:\
    \ Int = 0\n    var prime6: Int = 0\n    var prime7: Int = 0\n    var prime8: Int\
    \ = 0\n    var prime9: Int = 0\n    var prime10: Int = 0\n    var prime11: Int\
    \ = 0\n    var prime12: Int = 0\n    var prime13: Int = 0\n    var prime14: Int\
    \ = 0\n    var prime15: Int = 0\n    var prime16: Int = 0\n    var prime17: Int\
    \ = 0\n    var prime18: Int = 0\n    var prime19: Int = 0\n    var prime20: Int\
    \ = 0\n    var prime21: Int = 0\n    var prime22: Int = 0\n    var prime23: Int\
    \ = 0\n    var prime24: Int = 0\n    var prime25: Int = 0\n    var prime26: Int\
    \ = 0\n    var prime27: Int = 0\n    var prime28: Int = 0\n    var prime29: Int\
    \ = 0\n    var prime30: Int = 0\n    var prime31: Int = 0\n    var prime32: Int\
    \ = 0\n    var prime33: Int = 0\n    var prime34: Int = 0\n    var prime35: Int\
    \ = 0\n    var prime36: Int = 0\n    var prime37: Int = 0\n    var prime38: Int\
    \ = 0\n    var prime39: Int = 0\n    var prime40: Int = 0\n    var prime41: Int\
    \ = 0\n    var prime42: Int = 0\n    var prime43: Int = 0\n    var prime44: Int\
    \ = 0\n    var prime45: Int = 0\n    var prime46: Int = 0\n    var prime47: Int\
    \ = 0\n    var prime48: Int = 0\n    var prime49: Int = 0\n    var prime50: Int\
    \ = 0\n    var prime51: Int = 0\n    var prime52: Int = 0\n    var prime53: Int\
    \ = 0\n    var prime54: Int = 0\n    var prime55: Int = 0\n    var prime56: Int\
    \ = 0\n    var prime57: Int = 0\n    var prime58: Int = 0\n    var prime59: Int\
    \ = 0\n    var prime60: Int = 0\n    var prime61: Int = 0\n    var prime62: Int\
    \ = 0\n    var prime63: Int = 0\n    var prime64: Int = 0\n    var prime65: Int\
    \ = 0\n    var prime66: Int = 0\n    var prime67: Int = 0\n    var prime68: Int\
    \ = 0\n    var prime69: Int = 0\n    var prime70: Int = 0\n    var prime71: Int\
    \ = 0\n    var prime72: Int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu0xp73pf.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu0xp73pf.swift:25:9:\
    \ warning: initialization of immutable value 'len' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let len = digits.count\n    ~~~~^~~\n\
    \    _\n/tmp/tmpu0xp73pf.swift:26:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpu0xp73pf.swift:27:9: warning:\
    \ variable 'prime' was never used; consider replacing with '_' or removing it\n\
    \    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmpu0xp73pf.swift:28:9:\
    \ warning: variable 'prime2' was never used; consider replacing with '_' or removing\
    \ it\n    var prime2: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:29:9:\
    \ warning: variable 'prime3' was never used; consider replacing with '_' or removing\
    \ it\n    var prime3: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:30:9:\
    \ warning: variable 'prime4' was never used; consider replacing with '_' or removing\
    \ it\n    var prime4: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:31:9:\
    \ warning: variable 'prime5' was never used; consider replacing with '_' or removing\
    \ it\n    var prime5: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:32:9:\
    \ warning: variable 'prime6' was never used; consider replacing with '_' or removing\
    \ it\n    var prime6: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:33:9:\
    \ warning: variable 'prime7' was never used; consider replacing with '_' or removing\
    \ it\n    var prime7: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:34:9:\
    \ warning: variable 'prime8' was never used; consider replacing with '_' or removing\
    \ it\n    var prime8: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:35:9:\
    \ warning: variable 'prime9' was never used; co"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        let hex = Int(digit, radix:\
    \ 16)\n        if hex > 9 {\n            hex -= 10\n        }\n        if hex\
    \ == 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp36z403xi.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp36z403xi.swift:27:19:\
    \ error: initializer 'init(_:radix:)' requires that 'Character' conform to 'StringProtocol'\n\
    \        let hex = Int(digit, radix: 16)\n                  ^\nSwift.FixedWidthInteger:2:23:\
    \ note: where 'S' = 'Character'\n    @inlinable public init?<S>(_ text: S, radix:\
    \ Int = 10) where S : StringProtocol\n                      ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime($0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < 2 {\n        return -1\n    }\n    if hexDigitPrimeCount\
    \ < 2 {\n        return -1\n    }\n    if hexDigitPrimeCount == hexDigitCount\
    \ {\n        return hexDigitPrimes.count\n    }\n    return -1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfk81nlub.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpfk81nlub.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfk81nlub.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime($0)\
    \ }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"0\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"1\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"2\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"3\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"4\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"5\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"6\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"7\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"8\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpd7pwsjmd.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpd7pwsjmd.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmpd7pwsjmd.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpd7pwsjmd.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpd7pwsjmd.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd7pwsjmd.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmpd7pwsjmd.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmpd7pwsjmd.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var hex_num: Int = 0\n    for char in num {\n        let hex_digit = Int(String(char).uppercased(),\
    \ radix: 16)\n        hex_num = hex_num * 16 + hex_digit\n    }\n    return hex_num\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3m02e4ko.swift:28:34: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        hex_num = hex_num * 16 + hex_digit\n\
    \                                 ^\n/tmp/tmp3m02e4ko.swift:28:34: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     hex_num = hex_num * 16 + hex_digit\n                                 ^\n\
    \                                 (         ?? <#default value#>)\n/tmp/tmp3m02e4ko.swift:28:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        hex_num = hex_num * 16 + hex_digit\n                        \
    \         ^\n                                          !\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\n\
    \        if char == \"A\" || char == \"B\" || char == \"C\" || char == \"D\" ||\
    \ char == \"E\" || char == \"F\" {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp63w5wa39.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp63w5wa39.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index]\n              \
    \     ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp63w5wa39.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var result = 0\n    var digits = num.characters\n    for digit in digits {\n\
    \        switch digit {\n        case \"A\":\n        case \"B\":\n        case\
    \ \"C\":\n        case \"D\":\n        case \"E\":\n        case \"F\":\n    \
    \        result += 1\n        default:\n            break\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpouje6xzm.swift:29:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpouje6xzm.swift:30:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpouje6xzm.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpouje6xzm.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpouje6xzm.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpouje6xzm.swift:26:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    var digits\
    \ = num.characters\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpouje6xzm.swift:26:9: warning: variable\
    \ 'digits' was never mutated; consider changing to 'let' constant\n    var digits\
    \ = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var numsIndex = 0\n    var hexDigits = [UInt8]()\n\
    \    var hexDigitCount = 0\n    var hexDigitIndex = 0\n    var hexDigitCount2\
    \ = 0\n    var hexDigitIndex2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitIndex3\
    \ = 0\n    var hexDigitCount4 = 0\n    var hexDigitIndex4 = 0\n    var hexDigitCount5\
    \ = 0\n    var hexDigitIndex5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitIndex6\
    \ = 0\n    var hexDigitCount7 = 0\n    var hexDigitIndex7 = 0\n    var hexDigitCount8\
    \ = 0\n    var hexDigitIndex8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitIndex9\
    \ = 0\n    var hexDigitCount10 = 0\n    var hexDigitIndex10 = 0\n    var hexDigitCount11\
    \ = 0\n    var hexDigitIndex11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitIndex12\
    \ = 0\n    var hexDigitCount13 = 0\n    var hexDigitIndex13 = 0\n    var hexDigitCount14\
    \ = 0\n    var hexDigitIndex14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitIndex15\
    \ = 0\n    var hexDigitCount16 = 0\n    var hexDigitIndex16 = 0\n    var hexDigitCount17\
    \ = 0\n    var hexDigitIndex17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitIndex18\
    \ = 0\n    var hexDigitCount19 = 0\n    var hexDigitIndex19 = 0\n    var hexDigitCount20\
    \ = 0\n    var hexDigitIndex20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitIndex21\
    \ = 0\n    var hexDigitCount22 = 0\n    var hexDigitIndex22 = 0\n    var hexDigitCount23\
    \ = 0\n    var hexDigitIndex23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitIndex24\
    \ = 0\n    var hexDigitCount25 = 0\n    var hexDigitIndex25 = 0\n    var hexDigitCount26\
    \ = 0\n    var hexDigitIndex26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitIndex27\
    \ = 0\n    var hexDigitCount28 = 0\n    var hexDigitIndex28 = 0\n    var hexDigitCount29\
    \ = 0\n    var hexDigitIndex29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitIndex30\
    \ = 0\n    var hexDigitCount31 = 0\n    var hexDigitIndex31 = 0\n    var hexDigitCount32\
    \ = 0\n    var hexDigitIndex32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitIndex33\
    \ = 0\n    var hexDigitCount34 = 0\n    var hexDigitIndex34 = 0\n    var hexDigitCount35\
    \ = 0\n    var hex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpi681y99z.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpi681y99z.swift:97:9:\
    \ error: type annotation missing in pattern\n    var hex\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        let digit = Int(char) - 48\n        sum += digit * digit\n\
    \    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz2nyjjfu.swift:26:21: error: no exact matches in call to initializer\
    \ \n        let digit = Int(char) - 48\n                    ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\n/tmp/tmpz2nyjjfu.swift:27:22: error: cannot\
    \ convert value of type 'Duration' to expected argument type 'Int'\n        sum\
    \ += digit * digit\n                     ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNums = \"\"\n    var primeNums = \"\"\n    var primeNumsCount = 0\n\
    \    var primeNumsCount2 = 0\n    var primeNumsCount3 = 0\n    var primeNumsCount4\
    \ = 0\n    var primeNumsCount5 = 0\n    var primeNumsCount6 = 0\n    var primeNumsCount7\
    \ = 0\n    var primeNumsCount8 = 0\n    var primeNumsCount9 = 0\n    var primeNumsCount10\
    \ = 0\n    var primeNumsCount11 = 0\n    var primeNumsCount12 = 0\n    var primeNumsCount13\
    \ = 0\n    var primeNumsCount14 = 0\n    var primeNumsCount15 = 0\n    var primeNumsCount16\
    \ = 0\n    var primeNumsCount17 = 0\n    var primeNumsCount18 = 0\n    var primeNumsCount19\
    \ = 0\n    var primeNumsCount20 = 0\n    var primeNumsCount21 = 0\n    var primeNumsCount22\
    \ = 0\n    var primeNumsCount23 = 0\n    var primeNumsCount24 = 0\n    var primeNumsCount25\
    \ = 0\n    var primeNumsCount26 = 0\n    var primeNumsCount27 = 0\n    var primeNumsCount28\
    \ = 0\n    var primeNumsCount29 = 0\n    var primeNumsCount30 = 0\n    var primeNumsCount31\
    \ = 0\n    var primeNumsCount32 = 0\n    var primeNumsCount33 = 0\n    var primeNumsCount34\
    \ = 0\n    var primeNumsCount35 = 0\n    var primeNumsCount36 = 0\n    var primeNumsCount37\
    \ = 0\n    var primeNumsCount38 = 0\n    var primeNumsCount39 = 0\n    var primeNumsCount40\
    \ = 0\n    var primeNumsCount41 = 0\n    var primeNumsCount42 = 0\n    var primeNumsCount43\
    \ = 0\n    var primeNumsCount44 = 0\n    var primeNumsCount45 = 0\n    var primeNumsCount46\
    \ = 0\n    var primeNumsCount47 = 0\n    var primeNumsCount48 = 0\n    var primeNumsCount49\
    \ = 0\n    var primeNumsCount50 = 0\n    var primeNumsCount51 = 0\n    var primeNumsCount52\
    \ = 0\n    var primeNumsCount53 = 0\n    var primeNumsCount54 = 0\n    var primeNumsCount55\
    \ = 0\n    var primeNumsCount56 = 0\n    var primeNumsCount57 = 0\n    var primeNumsCount58\
    \ = 0\n    var primeNumsCount59 = 0\n    var primeNumsCount60 = 0\n    var primeNumsCount61\
    \ = 0\n    var primeNumsCount62\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp86pdamcw.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp86pdamcw.swift:88:9:\
    \ error: type annotation missing in pattern\n    var primeNumsCount62\n      \
    \  ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    \n    // Your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpi8og8fk8/tmpi8og8fk8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d9d564c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d9d25bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d9d25b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d9d25a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8og8fk8                        0x00005648430a2264 <unavailable> + 4708

    5    libc.so.6                          0x00002b7d9d750460 __libc_start_main +
    245

    6    tmpi8og8fk8                        0x00005648430a1ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014013
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.uppercased()\n\
    \    var count = 0\n    for char in hex {\n        switch char {\n        case\
    \ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    \
    \        count += 1\n        case \"A\", \"B\", \"C\", \"D\", \"E\", \"F\":\n\
    \            count += 1\n        default:\n            break\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpokeqnvjn/tmpokeqnvjn.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92c3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92c3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92c3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92c373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokeqnvjn                        0x00005598bf830474 <unavailable> + 5236

    5    libc.so.6                          0x00002b92c3c35460 __libc_start_main +
    245

    6    tmpokeqnvjn                        0x00005598bf8300f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    var prime: Int = 0\n    var prime2: Int = 0\n    var prime3:\
    \ Int = 0\n    var prime4: Int = 0\n    var prime5: Int = 0\n    var prime6: Int\
    \ = 0\n    var prime7: Int = 0\n    var prime8: Int = 0\n    var prime9: Int =\
    \ 0\n    var prime10: Int = 0\n    var prime11: Int = 0\n    var prime12: Int\
    \ = 0\n    var prime13: Int = 0\n    var prime14: Int = 0\n    var prime15: Int\
    \ = 0\n    var prime16: Int = 0\n    var prime17: Int = 0\n    var prime18: Int\
    \ = 0\n    var prime19: Int = 0\n    var prime20: Int = 0\n    var prime21: Int\
    \ = 0\n    var prime22: Int = 0\n    var prime23: Int = 0\n    var prime24: Int\
    \ = 0\n    var prime25: Int = 0\n    var prime26: Int = 0\n    var prime27: Int\
    \ = 0\n    var prime28: Int = 0\n    var prime29: Int = 0\n    var prime30: Int\
    \ = 0\n    var prime31: Int = 0\n    var prime32: Int = 0\n    var prime33: Int\
    \ = 0\n    var prime34: Int = 0\n    var prime35: Int = 0\n    var prime36: Int\
    \ = 0\n    var prime37: Int = 0\n    var prime38: Int = 0\n    var prime39: Int\
    \ = 0\n    var prime40: Int = 0\n    var prime41: Int = 0\n    var prime42: Int\
    \ = 0\n    var prime43: Int = 0\n    var prime44: Int = 0\n    var prime45: Int\
    \ = 0\n    var prime46: Int = 0\n    var prime47: Int = 0\n    var prime48: Int\
    \ = 0\n    var prime49: Int = 0\n    var prime50: Int = 0\n    var prime51: Int\
    \ = 0\n    var prime52: Int = 0\n    var prime53: Int = 0\n    var prime54: Int\
    \ = 0\n    var prime55: Int = 0\n    var prime56: Int = 0\n    var prime57: Int\
    \ = 0\n    var prime58: Int = 0\n    var prime59: Int = 0\n    var prime60: Int\
    \ = 0\n    var prime61: Int = 0\n    var prime62: Int = 0\n    var prime63: Int\
    \ = 0\n    var prime64: Int = 0\n    var prime65: Int = 0\n    var prime66: Int\
    \ = 0\n    var prime67: Int = 0\n    var prime68: Int = 0\n    var prime69: Int\
    \ = 0\n    var prime70: Int = 0\n    var prime71: Int = 0\n    var prime72: Int\
    \ = 0\n    var prime73\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_0f67v8d.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_0f67v8d.swift:98:9:\
    \ error: type annotation missing in pattern\n    var prime73\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  let numAsString = num.lowercased()\n    var numAsInt = Int(numAsString)\n \
    \   var numAsStringArray = [String]()\n    var numAsStringArrayIndex = 0\n   \
    \ var numAsStringArrayIndex2 = 0\n    var numAsStringArrayIndex3 = 0\n    var\
    \ numAsStringArrayIndex4 = 0\n    var numAsStringArrayIndex5 = 0\n    var numAsStringArrayIndex6\
    \ = 0\n    var numAsStringArrayIndex7 = 0\n    var numAsStringArrayIndex8 = 0\n\
    \    var numAsStringArrayIndex9 = 0\n    var numAsStringArrayIndex10 = 0\n   \
    \ var numAsStringArrayIndex11 = 0\n    var numAsStringArrayIndex12 = 0\n    var\
    \ numAsStringArrayIndex13 = 0\n    var numAsStringArrayIndex14 = 0\n    var numAsStringArrayIndex15\
    \ = 0\n    var numAsStringArrayIndex16 = 0\n    var numAsStringArrayIndex17 =\
    \ 0\n    var numAsStringArrayIndex18 = 0\n    var numAsStringArrayIndex19 = 0\n\
    \    var numAsStringArrayIndex20 = 0\n    var numAsStringArrayIndex21 = 0\n  \
    \  var numAsStringArrayIndex22 = 0\n    var numAsStringArrayIndex23 = 0\n    var\
    \ numAsStringArrayIndex24 = 0\n    var numAsStringArrayIndex25 = 0\n    var numAsStringArrayIndex26\
    \ = 0\n    var numAsStringArrayIndex27 = 0\n    var numAsStringArrayIndex28 =\
    \ 0\n    var numAsStringArrayIndex29 = 0\n    var numAsStringArrayIndex30 = 0\n\
    \    var numAsStringArrayIndex31 = 0\n    var numAsStringArrayIndex32 = 0\n  \
    \  var numAsStringArrayIndex33 = 0\n    var numAsStringArrayIndex34 = 0\n    var\
    \ numAsStringArrayIndex35 = 0\n    var numAsStringArrayIndex36 = 0\n    var numAsStringArrayIndex37\
    \ = 0\n    var numAsStringArrayIndex38 = 0\n    var numAsStringArrayIndex39 =\
    \ 0\n    var numAsStringArrayIndex40 = 0\n    var numAsStringArrayIndex41 = 0\n\
    \    var numAsStringArrayIndex42 = 0\n    var numAsStringArrayIndex43 = 0\n  \
    \  var numAsStringArrayIndex44 = 0\n    var numAsStringArrayIndex45 = 0\n    var\
    \ numAsStringArrayIndex46 = 0\n    var numAsStringArrayIndex47 = 0\n    var numAsStringArrayIndex48\
    \ = 0\n    var numAsStringArrayIndex49 = 0\n    var numAsStringArrayIndex50 =\
    \ 0\n    var numAsStringArrayIndex51 = 0\n    var numAsStringArrayIndex52 = 0\n\
    \    var numAsStringArrayIndex53 = 0\n    var num\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1wkjbdzj.swift:81:9: error: type annotation missing in pattern\n\
    \    var num\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var i = 0\n    for char in nums {\n        switch char\
    \ {\n        case \"A\":\n        case \"B\":\n        case \"C\":\n        case\
    \ \"D\":\n        case \"E\":\n        case \"F\":\n            result += 2\n\
    \        default:\n            result += 3\n        }\n        i += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1oww8czr.swift:29:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp1oww8czr.swift:30:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp1oww8czr.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1oww8czr.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1oww8czr.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp1oww8czr.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1oww8czr.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"A\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"B\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"C\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"D\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"E\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"F\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"0\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"1\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"2\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphh_x7o1i.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmphh_x7o1i.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmphh_x7o1i.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmphh_x7o1i.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmphh_x7o1i.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphh_x7o1i.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmphh_x7o1i.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmphh_x7o1i.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            count += 2\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 3\n        }\
    \ else if digit == \"D\" {\n            count += 5\n        } else if digit ==\
    \ \"E\" {\n            count += 7\n        } else if digit == \"F\" {\n      \
    \      count += 11\n        } else {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk8iwou48.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk8iwou48.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    for\
    \ char in num {\n        switch char {\n        case \"A\": result += 1\n    \
    \    case \"B\": result += 1\n        case \"C\": result += 1\n        case \"\
    D\": result += 1\n        case \"E\": result += 1\n        case \"F\": result\
    \ += 1\n        default:\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpice7d6yv/tmpice7d6yv.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b223d7cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b223d4c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b223d4c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b223d4c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpice7d6yv                        0x000056060e3ab414 <unavailable> + 5140

    5    libc.so.6                          0x00002b223d9bb460 __libc_start_main +
    245

    6    tmpice7d6yv                        0x000056060e3ab099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    var digits\
    \ = num.characters\n    for digit in digits {\n        sum += Int(digit)\n   \
    \ }\n    if sum % 2 == 0 {\n        return sum / 2\n    }\n    return sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcj0yi6ki.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcj0yi6ki.swift:27:16:\
    \ error: no exact matches in call to initializer \n        sum += Int(digit)\n\
    \               ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        switch digit {\n\
    \        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\":\n            result += 1\n        case \"A\", \"B\", \"C\", \"D\", \"E\"\
    , \"F\":\n            result += 1\n        default:\n            break\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpsoj6ireu.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsoj6ireu.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var primes = Set<Int>()\n    var primesCount = 2\n  \
    \  var primesCountMax = primes.count\n    for _ in 0..<primesCountMax {\n    \
    \    primes.insert(0)\n    }\n    for numIndex in 0..<nums.count {\n        let\
    \ num = nums[numIndex]\n        if num == hexDigits.first {\n            primes[hexDigits.count]\
    \ = hexDigits.count\n            primesCount += 1\n        }\n        else {\n\
    \            let prime = primes[hexDigits.count]\n            if num == hexDigits.last!\
    \ {\n                primes[prime] = hexDigits.count\n                primesCount\
    \ += 1\n            }\n            else {\n                let prime2 = primes[prime]\n\
    \                if num == hexDigits.last! {\n                    primes[prime2]\
    \ = hexDigits.count\n                    primesCount += 1\n                }\n\
    \                else {\n                    let prime3 = primes[prime2]\n   \
    \                 if num == hexDigits.last! {\n                        primes[prime3]\
    \ = hexDigits.count\n                        primesCount += 1\n              \
    \      }\n                    else {\n                        let prime4 = primes[prime3]\n\
    \                        if num == hexDigits.last! {\n                       \
    \     primes[prime4] = hexDigits.count\n                            primesCount\
    \ += 1\n                        }\n                        else {\n          \
    \                  let prime5 = primes[prime4]\n                            if\
    \ num == hexDigits.last! {\n                                primes[prime5] = hexDigits.count\n\
    \                                primesCount += 1\n                          \
    \  }\n                            else {\n                                let\
    \ prime6 = primes[prime5]\n                                if num == hexDigits.last!\
    \ {\n                                    primes[prime6] = hexDigits.count\n  \
    \                                  primesCount += 1\n                        \
    \        }\n                                else {\n                         \
    \           let prime7 = primes[prime6]\n                                    if\
    \ num == hexDigits.last! {\n                                        primes[prime7]\
    \ = hexDigits.count\n                                        primesCount += 1\n\
    \                                    }\n                                    else\
    \ {\n                                        let prime8 = primes[prime7]\n   \
    \                                     if num == hexDigits.last! {\n          \
    \                                  primes[prime8] = hexDigits.count\n        \
    \                                    primesCount += 1\n                      \
    \                  }\n                                        else {\n       \
    \                                     let prime9 = primes[prime8]\n          \
    \                                  if num == hexDigits.last! {\n             \
    \                                   primes[prime9] = hexDigits.count\n       \
    \                                         primesCount += 1\n                 \
    \                           }\n                                            else\
    \ {\n                                                let prime10 = primes[prime9]\n\
    \                                                if num == hexDigits.last! {\n\
    \                                                    primes[prime10] = hexDigits.count\n\
    \                                                    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpiwt5luhl.swift:117:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpiwt5luhl.swift:92:50:\
    \ note: to match this opening '{'\n                                          \
    \  else {\n                                                 ^\n/tmp/tmpiwt5luhl.swift:117:63:\
    \ error: expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpiwt5luhl.swift:86:46:\
    \ note: to match this opening '{'\n                                        else\
    \ {\n                                             ^\n/tmp/tmpiwt5luhl.swift:117:63:\
    \ error: expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpiwt5luhl.swift:80:42:\
    \ note: to match this opening '{'\n                                    else {\n\
    \                                         ^\n/tmp/tmpiwt5luhl.swift:117:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpiwt5luhl.swift:74:38:\
    \ note: to match this opening '{'\n                                else {\n  \
    \                                   ^\n/tmp/tmpiwt5luhl.swift:117:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpiwt5luhl.swift:68:34:\
    \ note: to match this opening '{'\n                            else {\n      \
    \                           ^\n/tmp/tmpiwt5luhl.swift:117:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpiwt5luhl.swift:62:30:\
    \ note: to match this opening '{'\n                      "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(char) - 48\n    }\n    if sum % 2 == 0 {\n    \
    \    return sum\n    }\n    return sum + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmnlqwcx2.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(char) - 48\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \    var hexDigits = [UInt8]()\n    var hexDigit = UInt8(0)\n    var hexDigitString\
    \ = String()\n    var hexDigitStringLength = hexDigitString.length\n    var hexDigitStringArray\
    \ = [String]()\n    var hexDigitStringArrayLength = hexDigitStringArray.length\n\
    \    var hexDigitStringArrayIndex = 0\n    var hexDigitStringArrayIndexLength\
    \ = 0\n    var hexDigitStringArrayIndexValue = 0\n    var hexDigitStringArrayIndexValueLength\
    \ = 0\n    var hexDigitStringArrayIndexValueLength2 = 0\n    var hexDigitStringArrayIndexValueLength3\
    \ = 0\n    var hexDigitStringArrayIndexValueLength4 = 0\n    var hexDigitStringArrayIndexValueLength5\
    \ = 0\n    var hexDigitStringArrayIndexValueLength6 = 0\n    var hexDigitStringArrayIndexValueLength7\
    \ = 0\n    var hexDigitStringArrayIndexValueLength8 = 0\n    var hexDigitStringArrayIndexValueLength9\
    \ = 0\n    var hexDigitStringArrayIndexValueLength10 = 0\n    var hexDigitStringArrayIndexValueLength11\
    \ = 0\n    var hexDigitStringArrayIndexValueLength12 = 0\n    var hexDigitStringArrayIndexValueLength13\
    \ = 0\n    var hexDigitStringArrayIndexValueLength14 = 0\n    var hexDigitStringArrayIndexValueLength15\
    \ = 0\n    var hexDigitStringArrayIndexValueLength16 = 0\n    var hexDigitStringArrayIndexValueLength17\
    \ = 0\n    var hexDigitStringArrayIndexValueLength18 = 0\n    var hexDigitStringArrayIndexValueLength19\
    \ = 0\n    var hexDigitStringArrayIndexValueLength20 = 0\n    var hexDigitStringArrayIndexValueLength21\
    \ = 0\n    var hexDigitStringArrayIndexValueLength22 = 0\n    var hexDigitStringArrayIndexValueLength23\
    \ = 0\n    var hexDigitStringArrayIndexValueLength24 = 0\n    var hexDigitStringArrayIndexValueLength25\
    \ = 0\n    var hexDigitStringArrayIndexValueLength26 = 0\n    var hexDigitStringArrayIndexValueLength27\
    \ = 0\n    var hexDigitStringArrayIndexValueLength28 = 0\n    var hexDigitStringArrayIndexValueLength29\
    \ = 0\n    var hexDigitStringArrayIndexValueLength30 = 0\n    var hexDigitStringArrayIndexValueLength31\
    \ = 0\n    var hexDigitStringArrayIndexValueLength32 = 0\n    var hexDigitStringArrayIndexValueLength33\
    \ = 0\n    var hexDigitStringArrayIndexValueLength34 = 0\n    var hexDigitStringArrayIndexValueLength35\
    \ = 0\n    var hexDigitStringArrayIndexValueLength36 = 0\n    var hexDigitString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpt7jf6xdb.swift:26:51: error: cannot find 'NSCharacterSet' in scope\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \                                                  ^~~~~~~~~~~~~~\n/tmp/tmpt7jf6xdb.swift:26:19:\
    \ error: value of type 'String' has no member 'stringByTrimmingCharactersInSet'\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7jf6xdb.swift:30:47:\
    \ error: value of type 'String' has no member 'length'\n    var hexDigitStringLength\
    \ = hexDigitString.length\n                               ~~~~~~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpt7jf6xdb.swift:32:57: error: value of type '[String]' has no member 'length'\n\
    \    var hexDigitStringArrayLength = hexDigitStringArray.length\n            \
    \                        ~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpt7jf6xdb.swift:72:9:\
    \ error: type annotation missing in pattern\n    var hexDigitString\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        switch digit {\n\
    \        case \"0\": result += 1\n        case \"1\": result += 1\n        case\
    \ \"2\": result += 1\n        case \"3\": result += 1\n        case \"4\": result\
    \ += 1\n        case \"5\": result += 1\n        case \"6\": result += 1\n   \
    \     case \"7\": result += 1\n        case \"8\": result += 1\n        case \"\
    9\": result += 1\n        case \"A\": result += 1\n        case \"B\": result\
    \ += 1\n        case \"C\": result += 1\n        case \"D\": result += 1\n   \
    \     case \"E\": result += 1\n        case \"F\": result += 1\n        default:\
    \ break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5zf3ve23.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5zf3ve23.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"#\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n    var hexDigits:\
    \ [String] = []\n    for char in hex {\n        hexDigits.append(String(char))\n\
    \    }\n    var hexDigitCount = hexDigits.count\n    var hexDigitPrimes: [String]\
    \ = []\n    for index in 0..<hexDigitCount {\n        var hexDigit = hexDigits[index]\n\
    \        var hexDigitPrime = true\n        for index2 in 0..<hexDigitCount {\n\
    \            if index2 != index {\n                var hexDigit2 = hexDigits[index2]\n\
    \                if hexDigit == hexDigit2 {\n                    hexDigitPrime\
    \ = false\n                    break\n                }\n            }\n     \
    \   }\n        if hexDigitPrime {\n            hexDigitPrimes.append(hexDigit)\n\
    \        }\n    }\n    var hexDigitPrimeCount = hexDigitPrimes.count\n    if hexDigitPrimeCount\
    \ == hexDigitCount {\n        return hexDigitPrimeCount\n    }\n    return 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpyf37ohqu.swift:24:86: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    var hex = num.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n         \
    \                                                                            ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyf37ohqu.swift:24:19: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    var hex = num.stringByReplacingOccurrencesOfString(\" \", withString: \"\"\
    , options: NSStringCompareOptions.LiteralSearch, range: nil)\n              ~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyf37ohqu.swift:24:131: error:\
    \ 'nil' requires a contextual type\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n                                                                     \
    \                                                             ^\n/tmp/tmpyf37ohqu.swift:25:82:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    #\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyf37ohqu.swift:25:127: error: 'nil' requires\
    \ a contextual type\n    hex = hex.stringByReplacingOccurrencesOfString(\"#\"\
    , withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \                                                  ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    var digit: Int = 0\n    var isPrime: Bool = false\n    var isHexDigit:\
    \ Bool = false\n    var isHexDigitUppercase: Bool = false\n    var isHexDigitLowercase:\
    \ Bool = false\n    var isHexDigitDigit: Bool = false\n    var isHexDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitLowercase: Bool = false\n    var isHexDigitDigitDigit:\
    \ Bool = false\n    var isHexDigitDigitDigitUppercase: Bool = false\n    var isHexDigitDigitDigitLowercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigitUppercase:\
    \ Bool = false\n    var isHexDigitDigitDigitDigitLowercase: Bool = false\n   \
    \ var isHexDigitDigitDigitDigitDigit: Bool = false\n    var isHexDigitDigitDigitDigit\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdav0iilo.swift:40:9: error: invalid redeclaration of 'isHexDigitDigitDigitDigitUppercase'\n\
    \    var isHexDigitDigitDigitDigitUppercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:37:9:\
    \ note: 'isHexDigitDigitDigitDigitUppercase' previously declared here\n    var\
    \ isHexDigitDigitDigitDigitUppercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:41:9:\
    \ error: invalid redeclaration of 'isHexDigitDigitDigitDigitLowercase'\n    var\
    \ isHexDigitDigitDigitDigitLowercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:38:9:\
    \ note: 'isHexDigitDigitDigitDigitLowercase' previously declared here\n    var\
    \ isHexDigitDigitDigitDigitLowercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:42:9:\
    \ error: invalid redeclaration of 'isHexDigitDigitDigitDigitDigit'\n    var isHexDigitDigitDigitDigitDigit:\
    \ Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:39:9: note: 'isHexDigitDigitDigitDigitDigit'\
    \ previously declared here\n    var isHexDigitDigitDigitDigitDigit: Bool = false\n\
    \        ^\n/tmp/tmpdav0iilo.swift:43:9: error: invalid redeclaration of 'isHexDigitDigitDigitDigitUppercase'\n\
    \    var isHexDigitDigitDigitDigitUppercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:37:9:\
    \ note: 'isHexDigitDigitDigitDigitUppercase' previously declared here\n    var\
    \ isHexDigitDigitDigitDigitUppercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:44:9:\
    \ error: invalid redeclaration of 'isHexDigitDigitDigitDigitLowercase'\n    var\
    \ isHexDigitDigitDigitDigitLowercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:38:9:\
    \ note: 'isHexDigitDigitDigitDigitLowercase' previously declared here\n    var\
    \ isHexDigitDigitDigitDigitLowercase: Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:45:9:\
    \ error: invalid redeclaration of 'isHexDigitDigitDigitDigitDigit'\n    var isHexDigitDigitDigitDigitDigit:\
    \ Bool = false\n        ^\n/tmp/tmpdav0iilo.swift:39:9: note: 'isHexDigitDigitDigitDigitDigit'\
    \ previously declared here\n    var isHexDigitDigitDigitDigitDigit: Bool = false\n\
    \        ^\n/tmp/tmpdav0iilo.swift:46:9: error: invalid redeclaration of 'isHexDigitDigitDigitDigitUppercase'\n\
    \    var "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        let hex = nums[_]\n\
    \        switch hex {\n        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\",\
    \ \"6\", \"7\", \"8\", \"9\":\n            count += 1\n        case \"A\", \"\
    B\", \"C\", \"D\", \"E\", \"F\":\n            count += 1\n        default:\n \
    \           break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpopgitsn3.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpopgitsn3.swift:27:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let hex = nums[_]\n                       ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit\
    \ == \"F\" {\n            result += 2\n        }\n        result += Int(digit)\
    \ - 48\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_yghrhww.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_yghrhww.swift:30:19:\
    \ error: no exact matches in call to initializer \n        result += Int(digit)\
    \ - 48\n                  ^\nSwift.Int:7:12: note: candidate expects value of\
    \ type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value of type\
    \ 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float80)\n       \
    \    ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\n\
    \        switch char {\n        case \"0\":\n        case \"1\":\n        case\
    \ \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n    \
    \    case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\"\
    :\n        case \"A\":\n        case \"B\":\n        case \"C\":\n        case\
    \ \"D\":\n        case \"E\":\n        case \"F\":\n            result += 1\n\
    \        default:\n            break\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpsnvjhw7u.swift:29:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpsnvjhw7u.swift:30:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpsnvjhw7u.swift:41:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsStr = num.lowercased()\n\
    \    let numAsInt = Int(numAsStr)\n    let numAsHex = numAsInt.hexDigit\n    let\
    \ numAsHexAsInt = Int(numAsHex)\n    let numAsHexAsString = String(numAsHexAsInt)\n\
    \    let numAsHexAsStringAsInt = Int(numAsHexAsString)\n    let numAsHexAsStringAsString\
    \ = String(numAsHexAsStringAsInt)\n    let numAsHexAsStringAsStringAsInt = Int(numAsHexAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsString = String(numAsHexAsStringAsStringAsInt)\n\
    \    let numAsHexAsStringAsStringAsStringAsInt = Int(numAsHexAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsString = String(numAsHexAsStringAsStringAsStringAsInt)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsInt = Int(numAsHexAsStringAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsString = String(numAsHexAsStringAsStringAsStringAsStringAsInt)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsInt = Int(numAsHexAsStringAsStringAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsString = String(numAsHexAsStringAsStringAsStringAsStringAsStringAsInt)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsInt = Int(numAsHexAsStringAsStringAsStringAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsString = String(numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsInt)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString)\n\
    \    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpd1jij01q.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpd1jij01q.swift:43:100: note: to match this opening '('\n    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsString\n                   \
    \                                                                            \
    \    ^\n/tmp/tmpd1jij01q.swift:26:29: error: value of type 'Int?' has no member\
    \ 'hexDigit'\n    let numAsHex = numAsInt.hexDigit\n                   ~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpd1jij01q.swift:41:85: error: cannot find 'numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString'\
    \ in scope\n    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString)\n\
    \                                                                            \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd1jij01q.swift:42:93: error: cannot find 'numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString'\
    \ in scope\n    let numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsInt\
    \ = Int(numAsHexAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsStringAsString)\n\
    \                                                                            \
    \                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        let hex = Int(digit, radix:\
    \ 16)\n        if hex == 0 || hex == 1 {\n            continue\n        }\n  \
    \      let prime = hex_key(hex)\n        if prime > 1 {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8nv0pewu.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8nv0pewu.swift:27:19:\
    \ error: initializer 'init(_:radix:)' requires that 'Character' conform to 'StringProtocol'\n\
    \        let hex = Int(digit, radix: 16)\n                  ^\nSwift.FixedWidthInteger:2:23:\
    \ note: where 'S' = 'Character'\n    @inlinable public init?<S>(_ text: S, radix:\
    \ Int = 10) where S : StringProtocol\n                      ^\n/tmp/tmp8nv0pewu.swift:31:29:\
    \ error: missing argument label 'num:' in call\n        let prime = hex_key(hex)\n\
    \                            ^\n                            num: \n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    var digits\
    \ = num.characters\n    for digit in digits {\n        sum += Int(digit)\n   \
    \ }\n    if sum % 2 == 0 {\n        return sum / 2\n    }\n    return sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcj0yi6ki.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcj0yi6ki.swift:27:16:\
    \ error: no exact matches in call to initializer \n        sum += Int(digit)\n\
    \               ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count += c - '0'\n\
    \        } else if c >= 'A' && c <= 'F' {\n            count += 10 + c - 'A'\n\
    \        } else if c >= 'a' && c <= 'f' {\n            count += 10 + c - 'a'\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpj4k9pdsb.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpj4k9pdsb.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpj4k9pdsb.swift:27:26: error:\
    \ single-quoted string literal found, use '\"'\n            count += c - '0'\n\
    \                         ^~~\n                         \"0\"\n/tmp/tmpj4k9pdsb.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmpj4k9pdsb.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmpj4k9pdsb.swift:29:31:\
    \ error: single-quoted string literal found, use '\"'\n            count += 10\
    \ + c - 'A'\n                              ^~~\n                             \
    \ \"A\"\n/tmp/tmpj4k9pdsb.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmpj4k9pdsb.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmpj4k9pdsb.swift:31:31: error: single-quoted string literal found,\
    \ use '\"'\n            count += 10 + c - 'a'\n                              ^~~\n\
    \                              \"a\"\n/tmp/tmpj4k9pdsb.swift:27:19: error: binary\
    \ operator '+=' cannot be applied to operands of type 'Int' and '_'\n        \
    \    count += c - '0'\n                  ^\nSwift.SIMD:1:11: note: candidate requires\
    \ that 'Int' conform to 'SIMD' (requirement specified as 'Self' : 'SIMD')\nextension\
    \ SIMD where Self.Scalar : FloatingPoint {\n          ^\n/tmp/tmpj4k9pdsb.swift:29:19:\
    \ error: binary operator '+=' cannot be applied to operands of t"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var primesSet =\
    \ Set(primes)\n    var primesSetCount = primesSet.count\n    var primesSetSum\
    \ = primesSet.sum\n    var primesSetSumCount = primesSetSum.count\n    var primesSetSumSum\
    \ = primesSetSum.sum\n    var primesSetSumSumCount = primesSetSumSum.count\n \
    \   var primesSetSumSumSum = primesSetSumSum.sum\n    var primesSetSumSumSumCount\
    \ = primesSetSumSumSum.count\n    var primesSetSumSumSumSum = primesSetSumSumSum.sum\n\
    \    var primesSetSumSumSumSumCount = primesSetSumSumSumSum.count\n    var primesSetSumSumSumSumSum\
    \ = primesSetSumSumSumSum.sum\n    var primesSetSumSumSumSumSumCount = primesSetSumSumSumSumSum.count\n\
    \    var primesSetSumSumSumSumSum = primesSetSumSumSumSumSum.sum\n    var primesSetSumSumSumSumSumCount\
    \ = primesSetSumSumSumSumSum.count\n    var primesSetSumSumSumSumSumSum = primesSetSumSumSumSumSumSum.sum\n\
    \    var primesSetSumSumSumSumSumCount = primesSetSumSumSumSumSumSum.count\n \
    \   var primesSetSumSumSumSumSumSumSum = primesSetSumSumSumSumSumSum.sum\n   \
    \ var primesSetSumSumSumSumSumSumCount = primesSetSumSumSumSumSumSum.count\n \
    \   var primesSetSumSumSumSumSumSumSum = primesSetSumSumSumSumSumSumSum.sum\n\
    \    var primesSetSumSumSumSumSumSumSumCount = primesSetSumSumSumSumSumSumSum.count\n\
    \    var primesSetSumSumSumSumSumSumSum = primesSetSumSumSumSumSumSumSum.sum\n\
    \    var primesSetSumSumSumSumSumSumSumCount = primesSetSumSumSumSumSumSumSum.count\n\
    \    var primesSetSumSumSumSumSumSumSumSum = primesSetSumSumSumSumSumSumSumSum.sum\n\
    \    var primesSetSumSumSumSumSumSumSumCount = primesSetSumSumSumSumSumSum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvxndzow8.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvxndzow8.swift:29:34:\
    \ error: value of type 'Set<Int>' has no member 'sum'\n    var primesSetSum =\
    \ primesSet.sum\n                       ~~~~~~~~~ ^~~\n/tmp/tmpvxndzow8.swift:41:39:\
    \ error: use of local variable 'primesSetSumSumSumSumSumSum' before its declaration\n\
    \    var primesSetSumSumSumSumSumSum = primesSetSumSumSumSumSumSum.sum\n     \
    \                                 ^\n/tmp/tmpvxndzow8.swift:41:9: note: 'primesSetSumSumSumSumSumSum'\
    \ declared here\n    var primesSetSumSumSumSumSumSum = primesSetSumSumSumSumSumSum.sum\n\
    \        ^\n/tmp/tmpvxndzow8.swift:49:45: error: use of local variable 'primesSetSumSumSumSumSumSumSumSum'\
    \ before its declaration\n    var primesSetSumSumSumSumSumSumSumSum = primesSetSumSumSumSumSumSumSumSum.sum\n\
    \                                            ^\n/tmp/tmpvxndzow8.swift:49:9: note:\
    \ 'primesSetSumSumSumSumSumSumSumSum' declared here\n    var primesSetSumSumSumSumSumSumSumSum\
    \ = primesSetSumSumSumSumSumSumSumSum.sum\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexString = \"\"\n    for _ in 0..<hex.count {\n        hexString +=\
    \ String(hex[hex.startIndex])\n    }\n    \n    var primes = Set<Int>()\n    var\
    \ primesCount = 0\n    \n    for _ in 0..<hexString.count {\n        let hexDigit\
    \ = hexString[hexString.startIndex]\n        \n        if hexDigit == \"A\" {\n\
    \            primes.insert(2)\n            primesCount += 1\n        } else if\
    \ hexDigit == \"B\" {\n            primes.insert(3)\n            primesCount +=\
    \ 1\n        } else if hexDigit == \"C\" {\n            primes.insert(5)\n   \
    \         primesCount += 1\n        } else if hexDigit == \"D\" {\n          \
    \  primes.insert(7)\n            primesCount += 1\n        } else if hexDigit\
    \ == \"E\" {\n            primes.insert(11)\n            primesCount += 1\n  \
    \      } else if hexDigit == \"F\" {\n            primes.insert(13)\n        \
    \    primesCount += 1\n        } else {\n            primes.insert(Int(hexDigit)!)\n\
    \            primesCount += 1\n        }\n    }\n    \n    return primesCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpx0l__u6n.swift:55:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            primes.insert(Int(hexDigit)!)\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var numAsInt: Int = 0\n    for i in 0..<numAsString.characters.count {\n\
    \        let c = numAsString.character(at: i)\n        if c >= '0' && c <= '9'\
    \ {\n            numAsInt = numAsInt * 16 + Int(c - UInt('0'))\n        } else\
    \ if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n\
    \            numAsInt = numAsInt * 16 + Int(c - UInt('A') + 10)\n        }\n \
    \   }\n    return numAsInt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpl9ww0kdn.swift:28:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpl9ww0kdn.swift:28:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpl9ww0kdn.swift:29:53: error:\
    \ single-quoted string literal found, use '\"'\n            numAsInt = numAsInt\
    \ * 16 + Int(c - UInt('0'))\n                                                \
    \    ^~~\n                                                    \"0\"\n/tmp/tmpl9ww0kdn.swift:30:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n        \
    \               ^~~\n                       \"A\"\n/tmp/tmpl9ww0kdn.swift:30:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n        \
    \                           ^~~\n                                   \"B\"\n/tmp/tmpl9ww0kdn.swift:30:48:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n        \
    \                                       ^~~\n                                \
    \               \"C\"\n/tmp/tmpl9ww0kdn.swift:30:60: error: single-quoted string\
    \ literal found, use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C'\
    \ || c == 'D' || c == 'E' || c == 'F' {\n                                    \
    \                       ^~~\n                                                \
    \           \"D\"\n/tmp/tmpl9ww0kdn.swift:30:72: error: single-quoted string literal\
    \ found, use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C' || c ==\
    \ 'D' || c == 'E' || c == 'F' {\n                                            \
    \                           ^~~\n                                            \
    \                           \"E\"\n/tmp/tmpl9ww0kdn.swift:30:84: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c =="
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [String]()\n\
    \    var count = 0\n    for c in num {\n        hexDigits.append(String(format:\
    \ \"%c\", c))\n    }\n    for h in hexDigits {\n        if h == \"A\" {\n    \
    \        count += 1\n        } else if h == \"B\" {\n            count += 1\n\
    \        } else if h == \"C\" {\n            count += 1\n        } else if h ==\
    \ \"D\" {\n            count += 1\n        } else if h == \"E\" {\n          \
    \  count += 1\n        } else if h == \"F\" {\n            count += 1\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpo_51lnhm.swift:27:26: error: no exact matches in call to initializer\
    \ \n        hexDigits.append(String(format: \"%c\", c))\n                    \
    \     ^\nSwift.String:4:23: note: candidate '(String) -> String' requires 1 argument,\
    \ but 2 were provided\n    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\n/tmp/tmpo_51lnhm.swift:27:26: note: candidate has partially\
    \ matching parameter list (repeating: String, count: Int)\n        hexDigits.append(String(format:\
    \ \"%c\", c))\n                         ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexString = \"\"\n    for char in hex {\n        hexString += String(char)\n\
    \    }\n    var hexStringArray = hexString.characters\n    var hexStringArrayCount\
    \ = hexStringArray.count\n    var hexStringArrayCount2 = hexStringArrayCount /\
    \ 2\n    var hexStringArrayCount3 = hexStringArrayCount2 / 2\n    var hexStringArrayCount4\
    \ = hexStringArrayCount3 / 2\n    var hexStringArrayCount5 = hexStringArrayCount4\
    \ / 2\n    var hexStringArrayCount6 = hexStringArrayCount5 / 2\n    var hexStringArrayCount7\
    \ = hexStringArrayCount6 / 2\n    var hexStringArrayCount8 = hexStringArrayCount7\
    \ / 2\n    var hexStringArrayCount9 = hexStringArrayCount8 / 2\n    var hexStringArrayCount10\
    \ = hexStringArrayCount9 / 2\n    var hexStringArrayCount11 = hexStringArrayCount10\
    \ / 2\n    var hexStringArrayCount12 = hexStringArrayCount11 / 2\n    var hexStringArrayCount13\
    \ = hexStringArrayCount12 / 2\n    var hexStringArrayCount14 = hexStringArrayCount13\
    \ / 2\n    var hexStringArrayCount15 = hexStringArrayCount14 / 2\n    var hexStringArrayCount16\
    \ = hexStringArrayCount15 / 2\n    var hexStringArrayCount17 = hexStringArrayCount16\
    \ / 2\n    var hexStringArrayCount18 = hexStringArrayCount17 / 2\n    var hexStringArrayCount19\
    \ = hexStringArrayCount18 / 2\n    var hexStringArrayCount20 = hexStringArrayCount19\
    \ / 2\n    var hexStringArrayCount21 = hexStringArrayCount20 / 2\n    var hexStringArrayCount22\
    \ = hexStringArrayCount21 / 2\n    var hexStringArrayCount23 = hexStringArrayCount22\
    \ / 2\n    var hexStringArrayCount24 = hexStringArrayCount23 / 2\n    var hexStringArrayCount25\
    \ = hexStringArrayCount24 / 2\n    var hexStringArrayCount26 = hexStringArrayCount25\
    \ / 2\n    var hexStringArrayCount27 = hexStringArrayCount26 / 2\n    var hexStringArrayCount28\
    \ = hexStringArrayCount27 / 2\n    var hexStringArrayCount29 = hexStringArrayCount28\
    \ / 2\n    var hexStringArrayCount30 = hexStringArrayCount29 / 2\n    var hexStringArrayCount31\
    \ = hexStringArrayCount30 / 2\n    var hexStringArrayCount32 = hexStringArrayCount31\
    \ / 2\n    var hexStringArrayCount33 = hexStringArrayCount32 / \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpjg1s4gqx.swift:63:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpjg1s4gqx.swift:29:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexStringArray = hexString.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        let hex = nums[_]\n\
    \        switch hex {\n        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\",\
    \ \"6\", \"7\", \"8\", \"9\":\n            count += 1\n        case \"A\", \"\
    B\", \"C\", \"D\", \"E\", \"F\":\n            count += 1\n        default:\n \
    \           break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpopgitsn3.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpopgitsn3.swift:27:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let hex = nums[_]\n                       ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\":\n        case \"1\":\n \
    \       case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"\
    5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case\
    \ \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n            count\
    \ += 1\n        default:\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_l2vf8_4.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_l2vf8_4.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime($0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimePrimes = hexDigitPrimes.filter { isPrime($0) }\n    let\
    \ hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { isPrime($0) }\n    let hexDigitPrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { isPrime($0) }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n    let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount =\
    \ hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { isPrime($0)\
    \ }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6pnv3did.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp6pnv3did.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp6pnv3did.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime($0)\
    \ }\n                                            ^~~~~~~\n/tmp/tmp6pnv3did.swift:29:55:\
    \ error: cannot find 'isPrime' in scope\n    let hexDigitPrimePrimes = hexDigitPrimes.filter\
    \ { isPrime($0) }\n                                                      ^~~~~~~\n\
    /tmp/tmp6pnv3did.swift:31:65: error: cannot find 'isPrime' in scope\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { isPrime($0) }\n                             \
    \                                   ^~~~~~~\n/tmp/tmp6pnv3did.swift:33:75: error:\
    \ cannot find 'isPrime' in scope\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { isPrime($0) }\n                                                          \
    \                ^~~~~~~\n/tmp/tmp6pnv3did.swift:35:85: error: cannot find 'isPrime'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n                                                          \
    \                          ^~~~~~~\n/tmp/tmp6pnv3did.swift:37:95: error: cannot\
    \ find 'isPrime' in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n                                                          \
    \                                    ^~~~~~~\n/tmp/tmp6pnv3did.swift:39:51: error:\
    \ cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimes' in scope\n    let\
    \ hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { isPrime($0) }\n                                          "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for i in 0..<digits.count {\n        let digit\
    \ = digits[i]\n        if digit == \"A\" || digit == \"B\" || digit == \"C\" ||\
    \ digit == \"D\" || digit == \"E\" || digit == \"F\" {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptc18sy0g.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptc18sy0g.swift:27:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[i]\n               \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmptc18sy0g.swift:25:9: warning: variable 'digits' was never\
    \ mutated; consider changing to 'let' constant\n    var digits = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let hexDigits = digits.map { String($0) }\n    let hexDigitCount = hexDigits.count\n\
    \    let hexDigitPrimes = hexDigits.filter { $0.isPrime }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimePrimes = hexDigitPrimes.filter\
    \ { $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimes.filter { $0.isPrime\
    \ && $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter { $0.isPrime && $0.isPrime\
    \ && $0.isPrime && $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter {\
    \ $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime\
    \ }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpqrvlok1e.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqrvlok1e.swift:27:48:\
    \ error: value of type 'String' has no member 'isPrime'\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0.isPrime }\n                                        \
    \    ~~ ^~~~~~~\n/tmp/tmpqrvlok1e.swift:35:61: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime }\n   \
    \                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvlok1e.swift:37:71: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter {\
    \ $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime && $0.isPrime\
    \ }\n                                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvlok1e.swift:38:80: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \                                                                            \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for num in nums {\n        if nums.contains(where: { $0\
    \ == num }) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvyaxqewq.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvyaxqewq.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        switch digit {\n\
    \        case \"0\": result = result + 0\n        case \"1\": result = result\
    \ + 1\n        case \"2\": result = result + 2\n        case \"3\": result = result\
    \ + 3\n        case \"4\": result = result + 4\n        case \"5\": result = result\
    \ + 5\n        case \"6\": result = result + 6\n        case \"7\": result = result\
    \ + 7\n        case \"8\": result = result + 8\n        case \"9\": result = result\
    \ + 9\n        case \"A\": result = result + 10\n        case \"B\": result =\
    \ result + 11\n        case \"C\": result = result + 12\n        case \"D\": result\
    \ = result + 13\n        case \"E\": result = result + 14\n        case \"F\"\
    : result = result + 15\n        default: break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpv_rf5sha.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpv_rf5sha.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var i = 0\n    for c in num {\n        switch c {\n        case \"A\": nums.append(0)\n\
    \        case \"B\": nums.append(1)\n        case \"C\": nums.append(2)\n    \
    \    case \"D\": nums.append(3)\n        case \"E\": nums.append(4)\n        case\
    \ \"F\": nums.append(5)\n        default:\n            if c >= \"0\" && c <= \"\
    9\" {\n                nums.append(c - \"0\")\n            } else {\n        \
    \        nums.append(0)\n            }\n        }\n        i += 1\n    }\n   \
    \ return nums.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9hettnj6.swift:36:31: error: binary operator '-' cannot be applied\
    \ to two 'Character' operands\n                nums.append(c - \"0\")\n      \
    \                        ^\nSwift.Strideable:1:11: note: candidate requires that\
    \ 'Character' conform to '_Pointer' (requirement specified as 'Self' : '_Pointer')\n\
    extension Strideable where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hex = hex.lowercased()\n    let\
    \ hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map { String($0)\
    \ }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter { $0.value\
    \ > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n  \
    \  let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter\
    \ { $0.value > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n\
    \    let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter\
    \ { $0.value > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n\
    \    let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter\
    \ { $0.value > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n\
    \    let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter\
    \ { $0.value > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n\
    \    let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex = hex.unicodeScalars.filter\
    \ { $0.value > 0 }\n    let hex = hex.map { String($0) }\n    let hex = hex.joined()\n\
    \    let hex = hex.unicodeScalars.filter { $0.value > 0 }\n    let hex = hex.map\
    \ { String($0) }\n    let hex = hex.joined()\n    let hex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp7zgrkwou.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp7zgrkwou.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7zgrkwou.swift:65:9: error: type annotation\
    \ missing in pattern\n    let hex\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var prime = 0\n    var prime_digit = 0\n    var prime_digit_count\
    \ = 0\n    var prime_digit_sum = 0\n    var prime_digit_sum2 = 0\n    var prime_digit_sum3\
    \ = 0\n    var prime_digit_sum4 = 0\n    var prime_digit_sum5 = 0\n    var prime_digit_sum6\
    \ = 0\n    var prime_digit_sum7 = 0\n    var prime_digit_sum8 = 0\n    var prime_digit_sum9\
    \ = 0\n    var prime_digit_sum10 = 0\n    var prime_digit_sum11 = 0\n    var prime_digit_sum12\
    \ = 0\n    var prime_digit_sum13 = 0\n    var prime_digit_sum14 = 0\n    var prime_digit_sum15\
    \ = 0\n    var prime_digit_sum16 = 0\n    var prime_digit_sum17 = 0\n    var prime_digit_sum18\
    \ = 0\n    var prime_digit_sum19 = 0\n    var prime_digit_sum20 = 0\n    var prime_digit_sum21\
    \ = 0\n    var prime_digit_sum22 = 0\n    var prime_digit_sum23 = 0\n    var prime_digit_sum24\
    \ = 0\n    var prime_digit_sum25 = 0\n    var prime_digit_sum26 = 0\n    var prime_digit_sum27\
    \ = 0\n    var prime_digit_sum28 = 0\n    var prime_digit_sum29 = 0\n    var prime_digit_sum30\
    \ = 0\n    var prime_digit_sum31 = 0\n    var prime_digit_sum32 = 0\n    var prime_digit_sum33\
    \ = 0\n    var prime_digit_sum34 = 0\n    var prime_digit_sum35 = 0\n    var prime_digit_sum36\
    \ = 0\n    var prime_digit_sum37 = 0\n    var prime_digit_sum38 = 0\n    var prime_digit_sum39\
    \ = 0\n    var prime_digit_sum40 = 0\n    var prime_digit_sum41 = 0\n    var prime_digit_sum42\
    \ = 0\n    var prime_digit_sum43 = 0\n    var prime_digit_sum44 = 0\n    var prime_digit_sum45\
    \ = 0\n    var prime_digit_sum46 = 0\n    var prime_digit_sum47 = 0\n    var prime_digit_sum48\
    \ = 0\n    var prime_digit_sum49 = 0\n    var prime_digit_sum50 = 0\n    var prime_digit_sum51\
    \ = 0\n    var prime_digit_sum52 = 0\n    var prime_digit_sum53 = 0\n    var prime_digit_sum54\
    \ = 0\n    var prime_digit_sum55 = 0\n    var prime_digit_sum56 = 0\n    var prime_digit_sum57\
    \ = 0\n    var prime_digit_sum58 = 0\n    var prime_digit_sum59 = 0\n    var prime_digit_sum60\
    \ = 0\n    var prime_digit_sum61 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfajepnzi.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfajepnzi.swift:24:9:\
    \ warning: initialization of variable 'nums' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums = num.characters\n    ~~~~^~~~\n\
    \    _\n/tmp/tmpfajepnzi.swift:25:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpfajepnzi.swift:26:9: warning:\
    \ initialization of variable 'prime' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prime = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpfajepnzi.swift:27:9:\
    \ warning: initialization of variable 'prime_digit' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime_digit = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpfajepnzi.swift:28:9: warning: initialization of variable 'prime_digit_count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime_digit_count = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpfajepnzi.swift:29:9:\
    \ warning: initialization of variable 'prime_digit_sum' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var prime_digit_sum = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpfajepnzi.swift:30:9: warning: initialization\
    \ of variable 'prime_digit_sum2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prime_digit_sum2 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpfajepnzi.swift:31:9: warning: initialization of variable 'prime_digit_sum3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime_digit_sum3 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpfajepnzi.swift:32:9:\
    \ warning: initialization of variable 'prime_digit_sum4' was never used; consider\
    \ replacing with assignment "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    var digits\
    \ = num.characters\n    for digit in digits {\n        sum += Int(digit) - 48\n\
    \    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2ava8e5o.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2ava8e5o.swift:27:16:\
    \ error: no exact matches in call to initializer \n        sum += Int(digit) -\
    \ 48\n               ^\nSwift.Int:7:12: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n\
    \           ^\nSwift.Int:10:12: note: candidate expects value of type 'Float'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float)\n     \
    \      ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Double)\n        \
    \   ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n    public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12:\
    \ note: candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        switch digit {\n      \
    \  case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n\
    \        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"\
    7\":\n        case \"8\":\n        case \"9\":\n        case \"A\":\n        case\
    \ \"B\":\n        case \"C\":\n        case \"D\":\n        case \"E\":\n    \
    \    case \"F\":\n            count += 1\n        default:\n            break\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbxf_a20u.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpbxf_a20u.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:40:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ count = 0\n    var prime = 0\n    var prime2 = 0\n    var prime3 = 0\n    var\
    \ prime4 = 0\n    var prime5 = 0\n    var prime6 = 0\n    var prime7 = 0\n   \
    \ var prime8 = 0\n    var prime9 = 0\n    var prime10 = 0\n    var prime11 = 0\n\
    \    var prime12 = 0\n    var prime13 = 0\n    var prime14 = 0\n    var prime15\
    \ = 0\n    var prime16 = 0\n    var prime17 = 0\n    var prime18 = 0\n    var\
    \ prime19 = 0\n    var prime20 = 0\n    var prime21 = 0\n    var prime22 = 0\n\
    \    var prime23 = 0\n    var prime24 = 0\n    var prime25 = 0\n    var prime26\
    \ = 0\n    var prime27 = 0\n    var prime28 = 0\n    var prime29 = 0\n    var\
    \ prime30 = 0\n    var prime31 = 0\n    var prime32 = 0\n    var prime33 = 0\n\
    \    var prime34 = 0\n    var prime35 = 0\n    var prime36 = 0\n    var prime37\
    \ = 0\n    var prime38 = 0\n    var prime39 = 0\n    var prime40 = 0\n    var\
    \ prime41 = 0\n    var prime42 = 0\n    var prime43 = 0\n    var prime44 = 0\n\
    \    var prime45 = 0\n    var prime46 = 0\n    var prime47 = 0\n    var prime48\
    \ = 0\n    var prime49 = 0\n    var prime50 = 0\n    var prime51 = 0\n    var\
    \ prime52 = 0\n    var prime53 = 0\n    var prime54 = 0\n    var prime55 = 0\n\
    \    var prime56 = 0\n    var prime57 = 0\n    var prime58 = 0\n    var prime59\
    \ = 0\n    var prime60 = 0\n    var prime61 = 0\n    var prime62 = 0\n    var\
    \ prime63 = 0\n    var prime64 = 0\n    var prime65 = 0\n    var prime66 = 0\n\
    \    var prime67 = 0\n    var prime68 = 0\n    var prime69 = 0\n    var prime70\
    \ = 0\n    var prime71 = 0\n    var prime72 = 0\n    var prime73 = 0\n    var\
    \ prime74 = 0\n    var prime75 = 0\n    var prime76 = 0\n    var prime77 = 0\n\
    \    var prime78 = 0\n    var prime79 = 0\n    var prime80 = 0\n    var prime81\
    \ = 0\n    var prime82 = 0\n    var prime83 = 0\n    var prime84 = 0\n    var\
    \ prime85 = 0\n    var prime86 = 0\n    var prime87 = 0\n    var prime88 = 0\n\
    \    var prime89 = 0\n    var prime90 = 0\n    var prime91 = 0\n    var prime92\
    \ = 0\n    var prime93 = 0\n    var prime94 = 0\n    var prime95 = 0\n    var\
    \ prime96 = 0\n    var prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp39p0ilmf.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmp39p0ilmf.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp39p0ilmf.swift:124:9:\
    \ error: type annotation missing in pattern\n    var prime\n        ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var i = 0\n    for c in num {\n        if c >= '0' && c <= '9' {\n       \
    \     nums.append(c - '0')\n        }\n    }\n    for num in nums {\n        if\
    \ num % 2 == 0 {\n            return num\n        }\n    }\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpckozqwnm.swift:27:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpckozqwnm.swift:27:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpckozqwnm.swift:28:29: error:\
    \ single-quoted string literal found, use '\"'\n            nums.append(c - '0')\n\
    \                            ^~~\n                            \"0\"\n/tmp/tmpckozqwnm.swift:28:27:\
    \ error: binary operator '-' cannot be applied to two 'Character' operands\n \
    \           nums.append(c - '0')\n                          ^\nSwift.Strideable:1:11:\
    \ note: candidate requires that 'Character' conform to '_Pointer' (requirement\
    \ specified as 'Self' : '_Pointer')\nextension Strideable where Self : _Pointer\
    \ {\n          ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = \"\"\n    for char in num {\n        switch char {\n        case \"\
    A\":\n            digits = \"ABCDEF\"\n        case \"B\":\n            digits\
    \ = \"ABCDEF\"\n        case \"C\":\n            digits = \"ABCDEF\"\n       \
    \ case \"D\":\n            digits = \"ABCDEF\"\n        case \"E\":\n        \
    \    digits = \"ABCDEF\"\n        case \"F\":\n            digits = \"ABCDEF\"\
    \n        default:\n            digits = \"\"\n        }\n        if digits.contains(char)\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp8h5_e3nb/tmp8h5_e3nb.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adee37ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adee34d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adee34d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adee34d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8h5_e3nb                        0x000055e384c27524 <unavailable> + 5412

    5    libc.so.6                          0x00002adee39c9460 __libc_start_main +
    245

    6    tmp8h5_e3nb                        0x000055e384c271a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            result += 1\n        } else if digit == \"B\" {\n           \
    \ result += 2\n        } else if digit == \"C\" {\n            result += 3\n \
    \       } else if digit == \"D\" {\n            result += 5\n        } else if\
    \ digit == \"E\" {\n            result += 7\n        } else if digit == \"F\"\
    \ {\n            result += 11\n        } else {\n            result += digit.unicodeScalars.count\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9hufhynb.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9hufhynb.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters\n\
    \    var hexDigits = [Int]()\n    var count = 0\n    for char in hex {\n     \
    \   hexDigits.append(Int(char))\n    }\n    for digit in hexDigits {\n       \
    \ if digit % 2 == 0 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp7ob1rr9w.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7ob1rr9w.swift:28:26:\
    \ error: no exact matches in call to initializer \n        hexDigits.append(Int(char))\n\
    \                         ^\nSwift.Int:7:12: note: candidate expects value of\
    \ type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value of type\
    \ 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float80)\n       \
    \    ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        if char >= '0' && char <= '9' {\n            count +=\
    \ Int(char) - Int(Int(char)) * Int(Int(char)) - Int(Int(char)) * Int(Int(char))\
    \ * Int(Int(char)) * Int(Int(char))\n        } else {\n            count += Int(char)\
    \ - Int(Int(char)) * Int(Int(char)) * Int(Int(char)) * Int(Int(char)) * Int(Int(char))\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb37hy8p1.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpb37hy8p1.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpb37hy8p1.swift:27:13: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n            count += Int(char) - Int(Int(char)) * Int(Int(char))\
    \ - Int(Int(char)) * Int(Int(char)) * Int(Int(char)) * Int(Int(char))\n      \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb37hy8p1.swift:29:13: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n            count += Int(char) - Int(Int(char)) * Int(Int(char))\
    \ * Int(Int(char)) * Int(Int(char)) * Int(Int(char))\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014071
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for index in 0..<digits.count {\n        let digit\
    \ = digits[index]\n        switch digit {\n        case \"0\":\n        case \"\
    1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case\
    \ \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n    \
    \    case \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\"\
    :\n        case \"D\":\n        case \"E\":\n        case \"F\":\n        default:\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpylc60cwo.swift:29:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpylc60cwo.swift:30:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpylc60cwo.swift:41:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArrayLength = numAsArray.count\n\
    \    let numAsArray2 = numAsArray.filter({$0 != \"A\" && $0 != \"B\" && $0 !=\
    \ \"C\" && $0 != \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray3 =\
    \ numAsArray2.filter({$0 != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\"\
    \ && $0 != \"B\" && $0 != \"D\" && $0 != \"E\"})\n    let numAsArray4 = numAsArray3.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray6 = numAsArray5.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray7 = numAsArray6.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray9 = numAsArray8.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray10 = numAsArray9.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && $0 != \"B\" && $0 !=\
    \ \"D\" && $0 != \"E\" && $0 != \"F\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpensop1qu.swift:37:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpensop1qu.swift:40:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpensop1qu.swift:36:43:\
    \ note: to match this opening '('\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"2\" && $0 != \"3\" && $0 != \"5\" && $0 != \"7\" && \n                \
    \                          ^\n/tmp/tmpensop1qu.swift:57:63: error: expected '}'\
    \ at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpensop1qu.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpensop1qu.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpensop1qu.swift:40:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var hexDigits: [Int] = []\n    var hexDigitCount = 0\n    var hexDigitIndex\
    \ = 0\n    var hexDigit = Int(0)\n    var hexDigitString = \"\"\n    var hexDigitStringIndex\
    \ = 0\n    var hexDigitStringIndex2 = 0\n    var hexDigitStringIndex3 = 0\n  \
    \  var hexDigitStringIndex4 = 0\n    var hexDigitStringIndex5 = 0\n    var hexDigitStringIndex6\
    \ = 0\n    var hexDigitStringIndex7 = 0\n    var hexDigitStringIndex8 = 0\n  \
    \  var hexDigitStringIndex9 = 0\n    var hexDigitStringIndex10 = 0\n    var hexDigitStringIndex11\
    \ = 0\n    var hexDigitStringIndex12 = 0\n    var hexDigitStringIndex13 = 0\n\
    \    var hexDigitStringIndex14 = 0\n    var hexDigitStringIndex15 = 0\n    var\
    \ hexDigitStringIndex16 = 0\n    var hexDigitStringIndex17 = 0\n    var hexDigitStringIndex18\
    \ = 0\n    var hexDigitStringIndex19 = 0\n    var hexDigitStringIndex20 = 0\n\
    \    var hexDigitStringIndex21 = 0\n    var hexDigitStringIndex22 = 0\n    var\
    \ hexDigitStringIndex23 = 0\n    var hexDigitStringIndex24 = 0\n    var hexDigitStringIndex25\
    \ = 0\n    var hexDigitStringIndex26 = 0\n    var hexDigitStringIndex27 = 0\n\
    \    var hexDigitStringIndex28 = 0\n    var hexDigitStringIndex29 = 0\n    var\
    \ hexDigitStringIndex30 = 0\n    var hexDigitStringIndex31 = 0\n    var hexDigitStringIndex32\
    \ = 0\n    var hexDigitStringIndex33 = 0\n    var hexDigitStringIndex34 = 0\n\
    \    var hexDigitStringIndex35 = 0\n    var hexDigitStringIndex36 = 0\n    var\
    \ hexDigitStringIndex37 = 0\n    var hexDigitStringIndex38 = 0\n    var hexDigitStringIndex39\
    \ = 0\n    var hexDigitStringIndex40 = 0\n    var hexDigitStringIndex41 = 0\n\
    \    var hexDigitStringIndex42 = 0\n    var hexDigitStringIndex43 = 0\n    var\
    \ hexDigitStringIndex44 = 0\n    var hexDigitStringIndex45 = 0\n    var hexDigitStringIndex46\
    \ = 0\n    var hexDigitStringIndex47 = 0\n    var hexDigitStringIndex48 = 0\n\
    \    var hexDigitStringIndex49 = 0\n    var hexDigitStringIndex50 = 0\n    var\
    \ hexDigitStringIndex51 = 0\n    var hexDigitStringIndex52 = 0\n    var hexDigitStringIndex53\
    \ = 0\n    var hexDigitStringIndex54 = 0\n    var hexDigitStringIndex55 = 0\n\
    \    var hexDigitStringIndex56 = 0\n    var hexDigitStringIndex57 = 0\n    var\
    \ hexDigitStringIndex58 = 0\n    var hexDigitStringIndex59 = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp66jouqj6.swift:24:9: warning: initialization of immutable value\
    \ 'numAsString' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let numAsString = num.lowercased()\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:25:9:\
    \ warning: variable 'hexDigits' was never used; consider replacing with '_' or\
    \ removing it\n    var hexDigits: [Int] = []\n        ^~~~~~~~~\n        _\n/tmp/tmp66jouqj6.swift:26:9:\
    \ warning: initialization of variable 'hexDigitCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:27:9: warning: initialization\
    \ of variable 'hexDigitIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitIndex = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmp66jouqj6.swift:28:9: warning: initialization of variable 'hexDigit'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigit = Int(0)\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:29:9:\
    \ warning: initialization of variable 'hexDigitString' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitString = \"\
    \"\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:30:9: warning: initialization\
    \ of variable 'hexDigitStringIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitStringIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp66jouqj6.swift:31:9: warning: initialization of variable 'hexDigitStringIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitStringIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:32:9:\
    \ warning: initialization of variable 'hexDigitStringIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitStringIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp66jouqj6.swift:33:9: warning:\
    \ initialization of variable 'hexDigitStringIndex4' was never used; consider replacing\
    \ with assignment"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\
    \ as Character\n        if char.uppercased() == \"A\" {\n            count +=\
    \ 1\n        } else if char.uppercased() == \"B\" {\n            count += 1\n\
    \        } else if char.uppercased() == \"C\" {\n            count += 1\n    \
    \    } else if char.uppercased() == \"D\" {\n            count += 1\n        }\
    \ else if char.uppercased() == \"E\" {\n            count += 1\n        } else\
    \ if char.uppercased() == \"F\" {\n            count += 1\n        } else {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpkv9krali.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkv9krali.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index] as Character\n \
    \                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpkv9krali.swift:24:9: warning: variable 'nums'\
    \ was never mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(String(char).unicodeScalars.first!.value) * 16\n\
    \    }\n    return sum % 10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmp910490ly/tmp910490ly.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba13d89ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba13d595b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba13d595988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba13d5947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp910490ly                        0x000055deeb65c754 <unavailable> + 5972

    5    libc.so.6                          0x00002ba13da8a460 __libc_start_main +
    245

    6    tmp910490ly                        0x000055deeb65c3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  let digits = num.characters\n    let digitCount = digits.count\n    var hexDigitCount\
    \ = 0\n    var hexDigits = \"\"\n    for i in 0..<digitCount {\n        let digit\
    \ = digits[i]\n        if digit == \"A\" {\n            hexDigitCount++\n    \
    \    }\n        else if digit == \"B\" {\n            hexDigitCount++\n      \
    \  }\n        else if digit == \"C\" {\n            hexDigitCount++\n        }\n\
    \        else if digit == \"D\" {\n            hexDigitCount++\n        }\n  \
    \      else if digit == \"E\" {\n            hexDigitCount++\n        }\n    \
    \    else if digit == \"F\" {\n            hexDigitCount++\n        }\n      \
    \  else if digit == \"0\" {\n            hexDigitCount++\n        }\n        else\
    \ if digit == \"1\" {\n            hexDigitCount++\n        }\n        else if\
    \ digit == \"2\" {\n            hexDigitCount++\n        }\n        else if digit\
    \ == \"3\" {\n            hexDigitCount++\n        }\n        else if digit ==\
    \ \"4\" {\n            hexDigitCount++\n        }\n        else if digit == \"\
    5\" {\n            hexDigitCount++\n        }\n        else if digit == \"6\"\
    \ {\n            hexDigitCount++\n        }\n        else if digit == \"7\" {\n\
    \            hexDigitCount++\n        }\n        else if digit == \"8\" {\n  \
    \          hexDigitCount++\n        }\n        else if digit == \"9\" {\n    \
    \        hexDigitCount++\n        }\n    }\n    if hexDigitCount % 2 == 0 {\n\
    \        return hexDigitCount\n    }\n    else {\n        return hexDigitCount\
    \ - 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppdirtvuw.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppdirtvuw.swift:30:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[i]\n               \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppdirtvuw.swift:32:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:35:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:38:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:41:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:44:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:47:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:50:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:53:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:56:26: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            hexDigitCount++\n              \
    \           ^~\n/tmp/tmppdirtvuw.swift:59:26: error: cannot find operator '++'\
    \ in scope"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < 2 || hexDigitPrimeCount < 2 {\n        return 0\n    }\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { $0 / 2 }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    if hexDigitPrimeCount > hexDigitCount {\n      \
    \  return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map { $0 % hexDigitCount\
    \ }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    if hexDigitPrimeCount\
    \ != hexDigitCount {\n        return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map\
    \ { $0 % hexDigitCount }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitPrimeCount != hexDigitCount {\n        return 0\n    }\n    let\
    \ hexDigitPrimes = hexDigitPrimes.map { $0 % hexDigitCount }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    if hexDigitPrimeCount != hexDigitCount {\n     \
    \   return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map { $0 % hexDigitCount\
    \ }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    if hexDigitPrimeCount\
    \ != hexDigitCount {\n        return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map\
    \ { $0 % hexDigitCount }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitPrimeCount != hexDigitCount {\n        return 0\n    }\n    let\
    \ hexDigitPrimes = hexDigitPrimes.map { $0 % hexDigitCount }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    if hexDigitPrimeCount != hexDigitCount {\n     \
    \   return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map { $0 % hexDigitCount\
    \ }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    if hexDigitPrimeCount\
    \ != hexDigitCount {\n        return 0\n    }\n    let hexDigitPrimes = hexDigitPrimes.map\
    \ { $0 % hexDigitCount \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpoy5803ax.swift:93:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpoy5803ax.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpoy5803ax.swift:24:42: error: cannot find\
    \ 'CharacterSet' in scope\n    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpoy5803ax.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpoy5803ax.swift:76:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let nums = num.characters\n\
    \    var count = 0\n    for n in nums {\n        if n % 16 == 0 {\n          \
    \  count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpaa91fahi.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpaa91fahi.swift:27:12:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        if n % 16 == 0 {\n           ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(char) - 48\n    }\n    return sum % 10\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxv9qqoyd.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(char) - 48\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        if digit == \"A\" {\n \
    \           count += 2\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 3\n        }\
    \ else if digit == \"D\" {\n            count += 5\n        } else if digit ==\
    \ \"E\" {\n            count += 7\n        } else if digit == \"F\" {\n      \
    \      count += 11\n        } else {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp06jvs1wa.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNums = [Int]()\n    var primes = [Int]()\n    var primeCount = 0\n\
    \    var primeCount2 = 0\n    var primeCount3 = 0\n    var primeCount4 = 0\n \
    \   var primeCount5 = 0\n    var primeCount6 = 0\n    var primeCount7 = 0\n  \
    \  var primeCount8 = 0\n    var primeCount9 = 0\n    var primeCount10 = 0\n  \
    \  var primeCount11 = 0\n    var primeCount12 = 0\n    var primeCount13 = 0\n\
    \    var primeCount14 = 0\n    var primeCount15 = 0\n    var primeCount16 = 0\n\
    \    var primeCount17 = 0\n    var primeCount18 = 0\n    var primeCount19 = 0\n\
    \    var primeCount20 = 0\n    var primeCount21 = 0\n    var primeCount22 = 0\n\
    \    var primeCount23 = 0\n    var primeCount24 = 0\n    var primeCount25 = 0\n\
    \    var primeCount26 = 0\n    var primeCount27 = 0\n    var primeCount28 = 0\n\
    \    var primeCount29 = 0\n    var primeCount30 = 0\n    var primeCount31 = 0\n\
    \    var primeCount32 = 0\n    var primeCount33 = 0\n    var primeCount34 = 0\n\
    \    var primeCount35 = 0\n    var primeCount36 = 0\n    var primeCount37 = 0\n\
    \    var primeCount38 = 0\n    var primeCount39 = 0\n    var primeCount40 = 0\n\
    \    var primeCount41 = 0\n    var primeCount42 = 0\n    var primeCount43 = 0\n\
    \    var primeCount44 = 0\n    var primeCount45 = 0\n    var primeCount46 = 0\n\
    \    var primeCount47 = 0\n    var primeCount48 = 0\n    var primeCount49 = 0\n\
    \    var primeCount50 = 0\n    var primeCount51 = 0\n    var primeCount52 = 0\n\
    \    var primeCount53 = 0\n    var primeCount54 = 0\n    var primeCount55 = 0\n\
    \    var primeCount56 = 0\n    var primeCount57 = 0\n    var primeCount58 = 0\n\
    \    var primeCount59 = 0\n    var primeCount60 = 0\n    var primeCount61 = 0\n\
    \    var primeCount62 = 0\n    var primeCount63 = 0\n    var primeCount64 = 0\n\
    \    var primeCount65 = 0\n    var primeCount66 = 0\n    var primeCount67 = 0\n\
    \    var primeCount68 = 0\n    var primeCount69 = 0\n    var primeCount70 = 0\n\
    \    var primeCount71 = 0\n    var primeCount72 = 0\n    var primeCount73 = 0\n\
    \    var primeCount74 = 0\n    var primeCount75 = 0\n    var primeCount76 = 0\n\
    \    var primeCount77 = 0\n    var primeCount78 = 0\n    var primeCount79 = 0\n\
    \    var primeCount80 = 0\n    var primeCount81 = 0\n    var primeCount82 = 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5lvzpp_c.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5lvzpp_c.swift:24:9:\
    \ warning: initialization of variable 'nums' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums = num.characters\n    ~~~~^~~~\n\
    \    _\n/tmp/tmp5lvzpp_c.swift:25:9: warning: initialization of variable 'hexNums'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexNums = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmp5lvzpp_c.swift:26:9:\
    \ warning: initialization of variable 'primes' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primes = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp5lvzpp_c.swift:27:9: warning: initialization of variable 'primeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeCount = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp5lvzpp_c.swift:28:9:\
    \ warning: initialization of variable 'primeCount2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primeCount2 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp5lvzpp_c.swift:29:9: warning: initialization of variable 'primeCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeCount3 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp5lvzpp_c.swift:30:9:\
    \ warning: initialization of variable 'primeCount4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primeCount4 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp5lvzpp_c.swift:31:9: warning: initialization of variable 'primeCount5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeCount5 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp5lvzpp_c.swift:32:9:\
    \ warning: initialization of variable 'primeCount6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primeCount6 = 0\n "
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var count = 0\n    for hex in hex {\n        if hex.value > 0xFF {\n    \
    \        hex.value -= 0x100\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpp6kygsrc.swift:28:23: error: left side of mutating operator isn't\
    \ mutable: 'value' is a get-only property\n            hex.value -= 0x100\n  \
    \          ~~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    guard\
    \ let hex = num.unicodeScalars.filter { $0.isHexadecimal }.first else {\n    \
    \    return 0\n    }\n    let hex = hex.value as Int\n    let hexDigits = hex.count\n\
    \    let hexDigitPrimes = hexDigits - hex.filter{ $0 % 2 == 0 }.count\n    let\
    \ hexDigitPrimes = hexDigitPrimes % hexDigits\n    return hexDigitPrimes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpydik5fy2.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmpydik5fy2.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014016
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            count += 1\n        case\
    \ \"A\", \"B\", \"C\", \"D\", \"E\", \"F\":\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpictyj8f6/tmpictyj8f6.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add0607cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add05d73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add05d73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add05d727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpictyj8f6                        0x000055b99dfbe414 <unavailable> + 5140

    5    libc.so.6                          0x00002add06268460 __libc_start_main +
    245

    6    tmpictyj8f6                        0x000055b99dfbe099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.unicodeScalars\n\
    \    var hexNumLen = hexNum.count\n    var hexNumChars = hexNum.characters\n \
    \   var hexNumCharsLen = hexNumChars.count\n    var hexNumCharsChars = hexNumChars.characters\n\
    \    var hexNumCharsCharsLen = hexNumCharsChars.count\n    var hexNumCharsCharsChars\
    \ = hexNumCharsChars.characters\n    var hexNumCharsCharsCharsLen = hexNumCharsCharsChars.count\n\
    \    var hexNumCharsCharsCharsChars = hexNumCharsCharsChars.characters\n    var\
    \ hexNumCharsCharsCharsCharsLen = hexNumCharsCharsCharsChars.count\n    var hexNumCharsCharsCharsCharsChars\
    \ = hexNumCharsCharsCharsChars.characters\n    var hexNumCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsChars.count\n    var hexNumCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsChars.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n    var hexNumCharsCharsCharsCharsChars\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpezqsg6_a.swift:26:30: error: value of type 'String.UnicodeScalarView'\
    \ has no member 'characters'\n    var hexNumChars = hexNum.characters\n      \
    \                ~~~~~~ ^~~~~~~~~~\n/tmp/tmpezqsg6_a.swift:36:46: error: cannot\
    \ find 'hexNumCharsCharsCharsCharsCharsChars' in scope\n    var hexNumCharsCharsCharsCharsCharsLen\
    \ = hexNumCharsCharsCharsCharsCharsChars.count\n                             \
    \                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpezqsg6_a.swift:37:51:\
    \ error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsCharsLen' in scope\n\
    \    var hexNumCharsCharsCharsCharsCharsCharsLen = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpezqsg6_a.swift:38:51: error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsCharsLen'\
    \ in scope\n    var hexNumCharsCharsCharsCharsCharsCharsLen = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpezqsg6_a.swift:39:51: error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsCharsLen'\
    \ in scope\n    var hexNumCharsCharsCharsCharsCharsCharsLen = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpezqsg6_a.swift:40:51: error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsCharsLen'\
    \ in scope\n    var hexNumCharsCharsCharsCharsCharsCharsLen = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpezqsg6_a.swift:41:51: error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsCharsLen'\
    \ in scope\n    var hexNumCharsCharsCharsCharsCharsCharsLen = hexNumCharsCharsCharsCharsCharsCharsCharsLen.count\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpezqsg6_a.swift:42:51: error: cannot find 'hexNumCharsCharsCharsCharsCharsCharsChars"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters\n\
    \    var hexString = \"\"\n    for char in hex {\n        hexString += String(char)\n\
    \    }\n    var hexStringArray = hexString.characters\n    var hexStringArrayCount\
    \ = hexStringArray.count\n    var hexStringArrayCount2 = hexStringArrayCount /\
    \ 2\n    var hexStringArrayCount3 = hexStringArrayCount2 / 2\n    var hexStringArrayCount4\
    \ = hexStringArrayCount3 / 2\n    var hexStringArrayCount5 = hexStringArrayCount4\
    \ / 2\n    var hexStringArrayCount6 = hexStringArrayCount5 / 2\n    var hexStringArrayCount7\
    \ = hexStringArrayCount6 / 2\n    var hexStringArrayCount8 = hexStringArrayCount7\
    \ / 2\n    var hexStringArrayCount9 = hexStringArrayCount8 / 2\n    var hexStringArrayCount10\
    \ = hexStringArrayCount9 / 2\n    var hexStringArrayCount11 = hexStringArrayCount10\
    \ / 2\n    var hexStringArrayCount12 = hexStringArrayCount11 / 2\n    var hexStringArrayCount13\
    \ = hexStringArrayCount12 / 2\n    var hexStringArrayCount14 = hexStringArrayCount13\
    \ / 2\n    var hexStringArrayCount15 = hexStringArrayCount14 / 2\n    var hexStringArrayCount16\
    \ = hexStringArrayCount15 / 2\n    var hexStringArrayCount17 = hexStringArrayCount16\
    \ / 2\n    var hexStringArrayCount18 = hexStringArrayCount17 / 2\n    var hexStringArrayCount19\
    \ = hexStringArrayCount18 / 2\n    var hexStringArrayCount20 = hexStringArrayCount19\
    \ / 2\n    var hexStringArrayCount21 = hexStringArrayCount20 / 2\n    var hexStringArrayCount22\
    \ = hexStringArrayCount21 / 2\n    var hexStringArrayCount23 = hexStringArrayCount22\
    \ / 2\n    var hexStringArrayCount24 = hexStringArrayCount23 / 2\n    var hexStringArrayCount25\
    \ = hexStringArrayCount24 / 2\n    var hexStringArrayCount26 = hexStringArrayCount25\
    \ / 2\n    var hexStringArrayCount27 = hexStringArrayCount26 / 2\n    var hexStringArrayCount28\
    \ = hexStringArrayCount27 / 2\n    var hexStringArrayCount29 = hexStringArrayCount28\
    \ / 2\n    var hexStringArrayCount30 = hexStringArrayCount29 / 2\n    var hexStringArrayCount31\
    \ = hexStringArrayCount30 / 2\n    var hexStringArrayCount32 = hexStringArrayCount31\
    \ / 2\n    var hexStringArrayCount33 = hexStringArrayCount32 / 2\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptgvy_ln_.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptgvy_ln_.swift:29:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    var hexStringArray\
    \ = hexString.characters\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptgvy_ln_.swift:24:9: warning: variable\
    \ 'hex' was never mutated; consider changing to 'let' constant\n    var hex =\
    \ num.characters\n    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:29:9: warning: variable\
    \ 'hexStringArray' was never mutated; consider changing to 'let' constant\n  \
    \  var hexStringArray = hexString.characters\n    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:30:9:\
    \ warning: variable 'hexStringArrayCount' was never mutated; consider changing\
    \ to 'let' constant\n    var hexStringArrayCount = hexStringArray.count\n    ~~~\
    \ ^\n    let\n/tmp/tmptgvy_ln_.swift:31:9: warning: variable 'hexStringArrayCount2'\
    \ was never mutated; consider changing to 'let' constant\n    var hexStringArrayCount2\
    \ = hexStringArrayCount / 2\n    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:32:9:\
    \ warning: variable 'hexStringArrayCount3' was never mutated; consider changing\
    \ to 'let' constant\n    var hexStringArrayCount3 = hexStringArrayCount2 / 2\n\
    \    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:33:9: warning: variable 'hexStringArrayCount4'\
    \ was never mutated; consider changing to 'let' constant\n    var hexStringArrayCount4\
    \ = hexStringArrayCount3 / 2\n    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:34:9:\
    \ warning: variable 'hexStringArrayCount5' was never mutated; consider changing\
    \ to 'let' constant\n    var hexStringArrayCount5 = hexStringArrayCount4 / 2\n\
    \    ~~~ ^\n    let\n/tmp/tmptgvy_ln_.swift:35:9: warning: variable 'hexStringArrayCount6'\
    \ was never mutated; consider changing to 'let' constant\n    v"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = \"\"\n\
    \    var primeDigits = \"\"\n    var primeCount = 0\n    var primeDigitCount =\
    \ 0\n    var hexDigitCount = 0\n    var hexDigit = \"\"\n    var hexDigits = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit =\
    \ \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\
    \"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n\
    \    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n \
    \   var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n  \
    \  var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n   \
    \ var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var\
    \ hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit = \"\"\n    var hexDigit\
    \ = \"\"\n    var hex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb8frakv5.swift:30:9: error: invalid redeclaration of 'hexDigits'\n\
    \    var hexDigits = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:24:9: note: 'hexDigits'\
    \ previously declared here\n    var hexDigits = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:31:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:32:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmpb8frakv5.swift:33:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit'\
    \ previously declared here\n    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:34:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:35:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmpb8frakv5.swift:36:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit'\
    \ previously declared here\n    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:37:9:\
    \ error: invalid redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n      \
    \  ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit' previously declared here\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:38:9: error: invalid\
    \ redeclaration of 'hexDigit'\n    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9:\
    \ note: 'hexDigit' previously declared here\n    var hexDigit = \"\"\n       \
    \ ^\n/tmp/tmpb8frakv5.swift:39:9: error: invalid redeclaration of 'hexDigit'\n\
    \    var hexDigit = \"\"\n        ^\n/tmp/tmpb8frakv5.swift:29:9: note: 'hexDigit'\
    \ previously declared here\n    va"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.unicodeScalars.map\
    \ { $0.value }\n    let primes = prime_digits(digits)\n    return primes.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpuvlf01fw.swift:25:18: error: cannot find 'prime_digits' in scope\n\
    \    let primes = prime_digits(digits)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   for c in num {\n        switch c {\n        case \"0\":\n            nums.append(0)\n\
    \        case \"1\":\n            nums.append(1)\n        case \"2\":\n      \
    \      nums.append(2)\n        case \"3\":\n            nums.append(3)\n     \
    \   case \"4\":\n            nums.append(4)\n        case \"5\":\n           \
    \ nums.append(5)\n        case \"6\":\n            nums.append(6)\n        case\
    \ \"7\":\n            nums.append(7)\n        case \"8\":\n            nums.append(8)\n\
    \        case \"9\":\n            nums.append(9)\n        case \"A\":\n      \
    \      nums.append(10)\n        case \"B\":\n            nums.append(11)\n   \
    \     case \"C\":\n            nums.append(12)\n        case \"D\":\n        \
    \    nums.append(13)\n        case \"E\":\n            nums.append(14)\n     \
    \   case \"F\":\n            nums.append(15)\n        default:\n            return\
    \ -1\n        }\n    }\n    return nums.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmp70wy3uvb/tmp70wy3uvb.swift:79: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ea0d13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ea0a0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ea0a0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ea0a097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70wy3uvb                        0x00005616c845e564 <unavailable> + 5476

    5    libc.so.6                          0x00002b5ea0eff460 __libc_start_main +
    245

    6    tmp70wy3uvb                        0x00005616c845e1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = [Int]()\n    var count = 0\n    var prime: Int = 0\n    var\
    \ digit: Int = 0\n    var prime_found = false\n    var digit_found = false\n \
    \   var digit_found2 = false\n    var digit_found3 = false\n    var digit_found4\
    \ = false\n    var digit_found5 = false\n    var digit_found6 = false\n    var\
    \ digit_found7 = false\n    var digit_found8 = false\n    var digit_found9 = false\n\
    \    var digit_foundA = false\n    var digit_foundB = false\n    var digit_foundC\
    \ = false\n    var digit_foundD = false\n    var digit_foundE = false\n    var\
    \ digit_foundF = false\n    var digit_found0 = false\n    var digit_found1 = false\n\
    \    var digit_found2 = false\n    var digit_found3 = false\n    var digit_found4\
    \ = false\n    var digit_found5 = false\n    var digit_found6 = false\n    var\
    \ digit_found7 = false\n    var digit_found8 = false\n    var digit_found9 = false\n\
    \    var digit_foundA = false\n    var digit_foundB = false\n    var digit_foundC\
    \ = false\n    var digit_foundD = false\n    var digit_foundE = false\n    var\
    \ digit_foundF = false\n    var digit_found0 = false\n    var digit_found1 = false\n\
    \    var digit_found2 = false\n    var digit_found3 = false\n    var digit_found4\
    \ = false\n    var digit_found5 = false\n    var digit_found6 = false\n    var\
    \ digit_found7 = false\n    var digit_found8 = false\n    var digit_found9 = false\n\
    \    var digit_foundA = false\n    var digit_foundB = false\n    var digit_foundC\
    \ = false\n    var digit_foundD = false\n    var digit_foundE = false\n    var\
    \ digit_foundF = false\n    var digit_found0 = false\n    var digit_found1 = false\n\
    \    var digit_found2 = false\n    var digit_found3 = false\n    var digit_found4\
    \ = false\n    var digit_found5 = false\n    var digit_found6 = false\n    var\
    \ digit_found7 = false\n    var digit_found8 = false\n    var digit_found9 = false\n\
    \    var digit_foundA = false\n    var digit_foundB = false\n    var digit_foundC\
    \ = false\n    var digit_foundD = false\n    var digit_foundE = false\n    var\
    \ digit_foundF = false\n    var digit_found0 = false\n    var digit_found1 = false\n\
    \    var digit_found2 = false\n    var digit_found3 = false\n    var digit_found4\
    \ = false\n    var digit_found5 = false\n    var digit_found6 = false\n    var\
    \ digit_found7 = false\n    var digit_found8 = false\n    var digit_found9 = false\n\
    \    var digit_foundA = false\n    var digit_foundB = false\n    var digit_foundC\
    \ = false\n    var digit_foundD = false\n    var digit_foundE = false\n    var\
    \ digit_foundF = false\n    var digit_found0 = \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp0ibvk021.swift:109:23: error: expected initial value after '='\n\
    \    var digit_found0 = \n                      ^\n/tmp/tmp0ibvk021.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0ibvk021.swift:47:9: error: invalid redeclaration of\
    \ 'digit_found2'\n    var digit_found2 = false\n        ^\n/tmp/tmp0ibvk021.swift:31:9:\
    \ note: 'digit_found2' previously declared here\n    var digit_found2 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:48:9: error: invalid redeclaration of 'digit_found3'\n\
    \    var digit_found3 = false\n        ^\n/tmp/tmp0ibvk021.swift:32:9: note: 'digit_found3'\
    \ previously declared here\n    var digit_found3 = false\n        ^\n/tmp/tmp0ibvk021.swift:49:9:\
    \ error: invalid redeclaration of 'digit_found4'\n    var digit_found4 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:33:9: note: 'digit_found4' previously declared\
    \ here\n    var digit_found4 = false\n        ^\n/tmp/tmp0ibvk021.swift:50:9:\
    \ error: invalid redeclaration of 'digit_found5'\n    var digit_found5 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:34:9: note: 'digit_found5' previously declared\
    \ here\n    var digit_found5 = false\n        ^\n/tmp/tmp0ibvk021.swift:51:9:\
    \ error: invalid redeclaration of 'digit_found6'\n    var digit_found6 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:35:9: note: 'digit_found6' previously declared\
    \ here\n    var digit_found6 = false\n        ^\n/tmp/tmp0ibvk021.swift:52:9:\
    \ error: invalid redeclaration of 'digit_found7'\n    var digit_found7 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:36:9: note: 'digit_found7' previously declared\
    \ here\n    var digit_found7 = false\n        ^\n/tmp/tmp0ibvk021.swift:53:9:\
    \ error: invalid redeclaration of 'digit_found8'\n    var digit_found8 = false\n\
    \        ^\n/tmp/tmp0ibvk021.swift:37:9: note: 'digit_found8' previously declared\
    \ here\n    var digit_found8 = false\n        ^\n/tmp/tmp0ibvk021.swift:54:9:\
    \ error: invalid r"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count = count * 16\
    \ + c - '0'\n        }\n    }\n    if count % 2 == 0 {\n        return count\n\
    \    }\n    return count + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpy5ziufbe.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpy5ziufbe.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpy5ziufbe.swift:27:38: error:\
    \ single-quoted string literal found, use '\"'\n            count = count * 16\
    \ + c - '0'\n                                     ^~~\n                      \
    \               \"0\"\n/tmp/tmpy5ziufbe.swift:27:34: error: cannot convert value\
    \ of type 'Character' to expected argument type 'Int'\n            count = count\
    \ * 16 + c - '0'\n                                 ^\n/tmp/tmpy5ziufbe.swift:27:38:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \            count = count * 16 + c - '0'\n                                  \
    \   ^\n"
  stdout: ''
  timestamp: 1660014016
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        switch digit {\n\
    \        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\":\n        case \"A\", \"B\", \"C\", \"D\", \"E\", \"F\":\n            count\
    \ += 1\n        default:\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptm_ztu7f.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\", \"1\", \"2\", \"3\",\
    \ \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                               break\n/tmp/tmptm_ztu7f.swift:25:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    var digits\
    \ = num.characters\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmptm_ztu7f.swift:25:9: warning: variable\
    \ 'digits' was never mutated; consider changing to 'let' constant\n    var digits\
    \ = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    var count = 0\n    for char\
    \ in numAsArray {\n        let hex = Int(char, radix: 16)\n        if hex > 9\
    \ {\n            hex -= 10\n        }\n        if hex == 2 {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpg4_1cq6a.swift:25:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let numAsArray = numAsString.characters\n         \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpg4_1cq6a.swift:28:19: error: initializer 'init(_:radix:)'\
    \ requires that 'Character' conform to 'StringProtocol'\n        let hex = Int(char,\
    \ radix: 16)\n                  ^\nSwift.FixedWidthInteger:2:23: note: where 'S'\
    \ = 'Character'\n    @inlinable public init?<S>(_ text: S, radix: Int = 10) where\
    \ S : StringProtocol\n                      ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let digit = Int(nums[index],\
    \ radix: 16)\n        if digit == 11 || digit == 13 {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvhtb95ta.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhtb95ta.swift:27:30:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n\
    \        let digit = Int(nums[index], radix: 16)\n                           \
    \  ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hex = num.uppercased()\n    for char in hex {\n        digit\
    \ = Int(char) - 48\n        if digit == 0 {\n            digit = Int(char) - 55\n\
    \        }\n        if digit % 2 == 0 {\n            count += digit / 2\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmph667odp4.swift:28:17: error: no exact matches in call to initializer\
    \ \n        digit = Int(char) - 48\n                ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n/tmp/tmph667odp4.swift:30:21: error: no exact matches in call to\
    \ initializer \n            digit = Int(char) - 55\n                    ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n "
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for index in 0..<nums.count\
    \ {\n        let char = nums[index].uppercased()\n        if char == \"A\" ||\
    \ char == \"B\" || char == \"C\" || char == \"D\" || char == \"E\" || char ==\
    \ \"F\" {\n            continue\n        }\n        if primes.contains(char) {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1w9ilygw.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1w9ilygw.swift:28:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index].uppercased()\n \
    \                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp1w9ilygw.swift:32:12: error: instance method\
    \ 'contains' requires the types 'Int' and 'String.Element' (aka 'Character') be\
    \ equivalent\n        if primes.contains(char) {\n           ^\n_StringProcessing.Collection:3:17:\
    \ note: where 'Self.Element' = 'Int', 'C.Element' = 'String.Element' (aka 'Character')\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime = 0\n    var\
    \ prime_digit = 0\n    var prime_digit_count = 0\n    var prime_digit_count_max\
    \ = 0\n    var prime_digit_count_min = 0\n    var prime_digit_count_max_min =\
    \ 0\n    var prime_digit_count_max_min_index = 0\n    var prime_digit_count_max_min_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var prime_digit_count_max_min_index_index_index = 0\n    var prime_digit_count_max_min_index_index_index\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcjepev8b.swift:72:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpcjepev8b.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmpcjepev8b.swift:36:9: error:\
    \ invalid redeclaration of 'prime_digit_count_max_min_index_index'\n    var prime_digit_count_max_min_index_index\
    \ = 0\n        ^\n/tmp/tmpcjepev8b.swift:35:9: note: 'prime_digit_count_max_min_index_index'\
    \ previously declared here\n    var prime_digit_count_max_min_index_index = 0\n\
    \        ^\n/tmp/tmpcjepev8b.swift:38:9: error: invalid redeclaration of 'prime_digit_count_max_min_index_index_index'\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:37:9:\
    \ note: 'prime_digit_count_max_min_index_index_index' previously declared here\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:39:9:\
    \ error: invalid redeclaration of 'prime_digit_count_max_min_index_index_index'\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:37:9:\
    \ note: 'prime_digit_count_max_min_index_index_index' previously declared here\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:40:9:\
    \ error: invalid redeclaration of 'prime_digit_count_max_min_index_index_index'\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:37:9:\
    \ note: 'prime_digit_count_max_min_index_index_index' previously declared here\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:41:9:\
    \ error: invalid redeclaration of 'prime_digit_count_max_min_index_index_index'\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:37:9:\
    \ note: 'prime_digit_count_max_min_index_index_index' previously declared here\n\
    \    var prime_digit_count_max_min_index_index_index = 0\n        ^\n/tmp/tmpcjepev8b.swift:42:9:\
    \ error: invalid redeclaration of 'prime_digit_count_max_"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            count += 2\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 3\n        }\
    \ else if digit == \"D\" {\n            count += 5\n        } else if digit ==\
    \ \"E\" {\n            count += 7\n        } else if digit == \"F\" {\n      \
    \      count += 11\n        } else {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk8iwou48.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk8iwou48.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n    for i in 0..<nums.count\
    \ {\n        let digit = Int(nums[i])\n        if digit == 0 || digit == 1 {\n\
    \            count += 1\n        } else {\n            for j in 0..<primes.count\
    \ {\n                if digit % primes[j] == 0 {\n                    count +=\
    \ 1\n                    break\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu59lowee.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu59lowee.swift:28:29:\
    \ error: no exact matches in call to subscript \n        let digit = Int(nums[i])\n\
    \                            ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        let digit = Int(digit)\n\
    \        switch digit {\n        case 0: break\n        case 1: result += 2\n\
    \        case 2: result += 3\n        case 3: result += 5\n        case 4: result\
    \ += 7\n        case 5: result += 11\n        case 6: result += 13\n        case\
    \ 7: result += 17\n        case 8: result += 19\n        case 9: result += 23\n\
    \        case 10: result += 29\n        case 11: result += 31\n        case 12:\
    \ result += 37\n        case 13: result += 41\n        case 14: result += 43\n\
    \        case 15: result += 47\n        case 16: result += 53\n        case 17:\
    \ result += 59\n        case 18: result += 61\n        case 19: result += 67\n\
    \        case 20: result += 71\n        case 21: result += 73\n        case 22:\
    \ result += 79\n        case 23: result += 83\n        case 24: result += 89\n\
    \        case 25: result += 97\n        case 26: result += 101\n        case 27:\
    \ result += 103\n        case 28: result += 107\n        case 29: result += 109\n\
    \        case 30: result += 113\n        case 31: result += 127\n        case\
    \ 32: result += 131\n        case 33: result += 139\n        case 34: result +=\
    \ 147\n        case 35: result += 151\n        case 36: result += 157\n      \
    \  case 37: result += 163\n        case 38: result += 169\n        case 39: result\
    \ += 175\n        case 40: result += 181\n        case 41: result += 187\n   \
    \     case 42: result += 193\n        case 43: result += 199\n        case 44:\
    \ result += 207\n        case 45: result += 211\n        case 46: result += 217\n\
    \        case 47: result += 223\n        case 48: result += 229\n        case\
    \ 49: result += 237\n        case 50: result += 241\n        case 51: result +=\
    \ 247\n        case 52: result += 253\n        case 53: result += 259\n      \
    \  case 54: result += 265\n        case 55: result += 271\n        case 56: result\
    \ += 277\n        case 57: result += 283\n        case 58: result += 289\n   \
    \     case 59: result += 297\n        case 60: result += 303\n        case 61:\
    \ result += 309\n        case 62: result += 317\n        case 63: result += 323\n\
    \        case 64: result += 329\n        case 65: result += 337\n        case\
    \ 66: result += 343\n        case 67: result += 349\n        case 68: result +=\
    \ 357\n        case 69: result += 363\n        case 70: result += 369\n      \
    \  case 71: result += 375\n        case 72: result += 381\n        case 73: result\
    \ += 387\n        case 74: result += 393\n        case 75: result += 399\n   \
    \     case 76: result += 405\n        case 77: result += 411\n        case 78:\
    \ result += 417\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpiaxmq1vx.swift:128:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpiaxmq1vx.swift:26:25:\
    \ note: to match this opening '{'\n    for digit in digits {\n               \
    \         ^\n/tmp/tmpiaxmq1vx.swift:128:63: error: expected '}' at end of brace\
    \ statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n\
    \                                                              ^\n/tmp/tmpiaxmq1vx.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpiaxmq1vx.swift:25:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    var digits = num.characters\n\
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpiaxmq1vx.swift:27:21: error: no exact matches in call to initializer\
    \ \n        let digit = Int(digit)\n                    ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' fo"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // TODO: write your code\
    \ in Swift 5.1\n    guard let num = num.lowercased() else {\n        return 0\n\
    \    }\n    var count = 0\n    var prime = 0\n    var prime2 = 2\n    var prime3\
    \ = 3\n    var prime5 = 5\n    var prime7 = 7\n    var prime11 = 1\n    var prime13\
    \ = 3\n    var prime17 = 7\n    var prime19 = 7\n    var prime23 = 3\n    var\
    \ prime29 = 7\n    var prime31 = 7\n    var prime37 = 7\n    var prime41 = 7\n\
    \    var prime43 = 7\n    var prime47 = 7\n    var prime51 = 7\n    var prime53\
    \ = 7\n    var prime59 = 7\n    var prime61 = 7\n    var prime67 = 7\n    var\
    \ prime71 = 7\n    var prime73 = 7\n    var prime79 = 7\n    var prime83 = 7\n\
    \    var prime89 = 7\n    var prime91 = 7\n    var prime93 = 7\n    var prime97\
    \ = 7\n    var prime101 = 7\n    var prime103 = 7\n    var prime107 = 7\n    var\
    \ prime109 = 7\n    var prime113 = 7\n    var prime117 = 7\n    var prime121 =\
    \ 7\n    var prime123 = 7\n    var prime127 = 7\n    var prime131 = 7\n    var\
    \ prime133 = 7\n    var prime137 = 7\n    var prime139 =  7\n    var prime143\
    \ = 7\n    var prime147 =  7\n    var prime151 =  7\n    var prime153 =  7\n \
    \   var prime157 =  7\n    var prime159 =  7\n    var prime163 =  7\n    var prime167\
    \ =  7\n    var prime171 =  7\n    var prime173 =  7\n    var prime177 =  7\n\
    \    var prime179 =  7\n    var prime181 =  7\n    var prime183 =  7\n    var\
    \ prime187 =  7\n    var prime191 =  7\n    var prime193 =  7\n    var prime197\
    \ =  7\n    var prime199 =  7\n    var prime203 =  7\n    var prime207 =  7\n\
    \    var prime209 =  7\n    var prime211 =  7\n    var prime213 =  7\n    var\
    \ prime217 =  7\n    var prime219 =  7\n    var prime223 =  7\n    var prime227\
    \ =  7\n    var prime229 =  7\n    var prime231 =  7\n    var prime233 =  7\n\
    \    var prime237 =  7\n    var prime239 =  7\n    var prime241 =  7\n    var\
    \ prime243 =  7\n    var prime247 =  7\n    var prime249\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpehraj2rs.swift:25:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmpehraj2rs.swift:107:9:\
    \ error: type annotation missing in pattern\n    var prime249\n        ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime($0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < 2 {\n        return 0\n    }\n    if hexDigitPrimeCount\
    \ < 2 {\n        return 1\n    }\n    return hexDigitPrimeCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcf7a29n7.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpcf7a29n7.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpcf7a29n7.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime($0)\
    \ }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let len = digits.count\n    let hexDigits = Array(digits)\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigits = Array(hexDigits)\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpymbevuck.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpymbevuck.swift:28:9:\
    \ error: invalid redeclaration of 'hexDigits'\n    let hexDigits = Array(hexDigits)\n\
    \        ^\n/tmp/tmpymbevuck.swift:26:9: note: 'hexDigits' previously declared\
    \ here\n    let hexDigits = Array(digits)\n        ^\n/tmp/tmpymbevuck.swift:81:25:\
    \ error: cannot find 'hexDigit' in scope\n    let hexDigitCount = hexDigit\n \
    \                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ count = 0\n    for char in num.unicodeScalars {\n        guard let value = Int(char.value,\
    \ radix: 16) else {\n            return 0\n        }\n        if value == 2 {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpzvbyx74n.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmpzvbyx74n.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = 0\n    var digits = 0\n    var prime: Int = 0\n    var prime_found\
    \ = false\n    var prime_found2 = false\n    var prime_found3 = false\n    var\
    \ prime_found4 = false\n    var prime_found5 = false\n    var prime_found6 = false\n\
    \    var prime_found7 = false\n    var prime_found8 = false\n    var prime_found9\
    \ = false\n    var prime_found10 = false\n    var prime_found11 = false\n    var\
    \ prime_found12 = false\n    var prime_found13 = false\n    var prime_found14\
    \ = false\n    var prime_found15 = false\n    var prime_found16 = false\n    var\
    \ prime_found17 = false\n    var prime_found18 = false\n    var prime_found19\
    \ = false\n    var prime_found20 = false\n    var prime_found21 = false\n    var\
    \ prime_found22 = false\n    var prime_found23 = false\n    var prime_found24\
    \ = false\n    var prime_found25 = false\n    var prime_found26 = false\n    var\
    \ prime_found27 = false\n    var prime_found28 = false\n    var prime_found29\
    \ = false\n    var prime_found30 = false\n    var prime_found31 = false\n    var\
    \ prime_found32 = false\n    var prime_found33 = false\n    var prime_found34\
    \ = false\n    var prime_found35 = false\n    var prime_found36 = false\n    var\
    \ prime_found37 = false\n    var prime_found38 = false\n    var prime_found39\
    \ = false\n    var prime_found40 = false\n    var prime_found41 = false\n    var\
    \ prime_found42 = false\n    var prime_found43 = false\n    var prime_found44\
    \ = false\n    var prime_found45 = false\n    var prime_found46 = false\n    var\
    \ prime_found47 = false\n    var prime_found48 = false\n    var prime_found49\
    \ = false\n    var prime_found50 = false\n    var prime_found51 = false\n    var\
    \ prime_found52 = false\n    var prime_found53 = false\n    var prime_found54\
    \ = false\n    var prime_found55 = false\n    var prime_found56 = false\n    var\
    \ prime_found57 = false\n    var prime_found58 = false\n    var prime_found59\
    \ = false\n    var prime_found60 = false\n    var prime_found61 = false\n    var\
    \ prime_found62 = false\n    var prime_found63 = false\n    var prime_found64\
    \ = false\n    var prime_found65 = false\n    var prime_found66 = false\n    var\
    \ prime_found67 = false\n    var prime_found68 = false\n    var prime_\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_wpabe9r.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_wpabe9r.swift:96:9:\
    \ error: type annotation missing in pattern\n    var prime_\n        ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var nums = num.characters\n    var hexNum = 0\n    for char in nums {\n   \
    \     switch char {\n        case \"A\":\n            hexNum += 10\n        case\
    \ \"B\":\n            hexNum += 11\n        case \"C\":\n            hexNum +=\
    \ 12\n        case \"D\":\n            hexNum += 13\n        case \"E\":\n   \
    \         hexNum += 14\n        case \"F\":\n            hexNum += 15\n      \
    \  default:\n            hexNum += char.unicodeScalars.first!.value\n        }\n\
    \    }\n    return hexNum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphnjl311v.swift:25:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphnjl311v.swift:42:50:\
    \ error: cannot convert value of type 'UInt32' to expected argument type 'Int'\n\
    \            hexNum += char.unicodeScalars.first!.value\n                    \
    \                             ^\n                      Int(                  \
    \          )\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsLen = nums.count\n    var result = 0\n    var primesLen = primes.count\n\
    \    var primesLen2 = primesLen * primesLen\n    var primesLen3 = primesLen2 *\
    \ primesLen\n    var primesLen4 = primesLen3 * primesLen\n    var primesLen5 =\
    \ primesLen4 * primesLen\n    var primesLen6 = primesLen5 * primesLen\n    var\
    \ primesLen7 = primesLen6 * primesLen\n    var primesLen8 = primesLen7 * primesLen\n\
    \    var primesLen9 = primesLen8 * primesLen\n    var primesLen10 = primesLen9\
    \ * primesLen\n    var primesLen11 = primesLen10 * primesLen\n    var primesLen12\
    \ = primesLen11 * primesLen\n    var primesLen13 = primesLen12 * primesLen\n \
    \   var primesLen14 = primesLen13 * primesLen\n    var primesLen15 = primesLen14\
    \ * primesLen\n    var primesLen16 = primesLen15 * primesLen\n    var primesLen17\
    \ = primesLen16 * primesLen\n    var primesLen18 = primesLen17 * primesLen\n \
    \   var primesLen19 = primesLen18 * primesLen\n    var primesLen20 = primesLen19\
    \ * primesLen\n    var primesLen21 = primesLen20 * primesLen\n    var primesLen22\
    \ = primesLen21 * primesLen\n    var primesLen23 = primesLen22 * primesLen\n \
    \   var primesLen24 = primesLen23 * primesLen\n    var primesLen25 = primesLen24\
    \ * primesLen\n    var primesLen26 = primesLen25 * primesLen\n    var primesLen27\
    \ = primesLen26 * primesLen\n    var primesLen28 = primesLen27 * primesLen\n \
    \   var primesLen29 = primesLen28 * primesLen\n    var primesLen30 = primesLen29\
    \ * primesLen\n    var primesLen31 = primesLen30 * primesLen\n    var primesLen32\
    \ = primesLen31 * primesLen\n    var primesLen33 = primesLen32 * primesLen\n \
    \   var primesLen34 = primesLen33 * primesLen\n    var primesLen35 = \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpj2m3_0xc.swift:61:22: error: expected initial value after '='\n\
    \    var primesLen35 = \n                     ^\n/tmp/tmpj2m3_0xc.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpj2m3_0xc.swift:27:21: error: cannot find 'primes' in\
    \ scope\n    var primesLen = primes.count\n                    ^~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = nums.map { Int($0, radix: 16) }\n    var primes = hexNum.filter{\
    \ $0 % 2 == 0 }\n    var primesCount = primes.count\n    var hexNumCount = hexNum.count\n\
    \    var hexNumPrimes = hexNum.filter{ $0 % 2 == 0 }\n    var hexNumPrimesCount\
    \ = hexNumPrimes.count\n    var hexNumPrimesSum = hexNumPrimes.reduce(0, +)\n\
    \    var hexNumPrimesSumCount = hexNumPrimesSum.count\n    var hexNumPrimesSumPrimes\
    \ = hexNumPrimesSum.filter{ $0 % 2 == 0 }\n    var hexNumPrimesSumPrimesCount\
    \ = hexNumPrimesSumPrimes.count\n    var hexNumPrimesSumPrimesSum = hexNumPrimesSumPrimes.reduce(0,\
    \ +)\n    var hexNumPrimesSumPrimesSumCount = hexNumPrimesSumPrimesSum.count\n\
    \    var hexNumPrimesSumPrimesSumPrimes = hexNumPrimesSumPrimesSum.filter{ $0\
    \ % 2 == 0 }\n    var hexNumPrimesSumPrimesSumPrimesCount = hexNumPrimesSumPrimesSumPrimes.count\n\
    \    var hexNumPrimesSumPrimesSumPrimesSum = hexNumPrimesSumPrimesSumPrimes.reduce(0,\
    \ +)\n    var hexNumPrimesSumPrimesSumPrimesSumCount = hexNumPrimesSumPrimesSumPrimesSum.count\n\
    \    var hexNumPrimesSumPrimesSumPrimesSumPrimes = hexNumPrimesSumPrimesSumPrimesSum.filter{\
    \ $0 % 2 == 0 }\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesCount = hexNumPrimesSumPrimesSumPrimesSumPrimes.count\n\
    \    var hexNumPrimesSumPrimesSumPrimesSumPrimesSum = hexNumPrimesSumPrimesSumPrimesSumPrimes.reduce(0,\
    \ +)\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumCount = hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes.count\n\
    \    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes = hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesCount.reduce(0,\
    \ +)\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesSum = hexNumPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpj3msdqqe.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpj3msdqqe.swift:25:29:\
    \ error: initializer 'init(_:radix:)' requires that 'String.Element' (aka 'Character')\
    \ conform to 'StringProtocol'\n    var hexNum = nums.map { Int($0, radix: 16)\
    \ }\n                            ^\nSwift.FixedWidthInteger:2:23: note: where\
    \ 'S' = 'String.Element' (aka 'Character')\n    @inlinable public init?<S>(_ text:\
    \ S, radix: Int = 10) where S : StringProtocol\n                      ^\n/tmp/tmpj3msdqqe.swift:44:59:\
    \ error: use of local variable 'hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes'\
    \ before its declaration\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumCount\
    \ = hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes.count\n                 \
    \                                         ^\n/tmp/tmpj3msdqqe.swift:45:9: note:\
    \ 'hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes' declared here\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes\
    \ = hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesCount.reduce(0, +)\n     \
    \   ^\n/tmp/tmpj3msdqqe.swift:45:60: error: cannot find 'hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesCount'\
    \ in scope\n    var hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimes = hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesCount.reduce(0,\
    \ +)\n                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpj3msdqqe.swift:46:63: error: cannot find 'hexNumPri' in scope\n    var\
    \ hexNumPrimesSumPrimesSumPrimesSumPrimesSumPrimesSum = hexNumPri\n          \
    \                                                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = 0\n    for _ in 0..<nums.count {\n        let hex = nums[_]\
    \ as UInt\n        hexNum += hex * 16\n    }\n    return hexNum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp22zgjrlq.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp22zgjrlq.swift:27:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let hex = nums[_] as UInt\n                       ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { $0.value }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    return hexDigitPrimeCount + hexDigitCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxymibzwt.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpxymibzwt.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpxymibzwt.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n/tmp/tmpxymibzwt.swift:29:31:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \    return hexDigitPrimeCount + hexDigitCount\n           ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"0\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"1\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"2\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"3\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"4\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"5\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"6\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"7\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"8\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpd7pwsjmd.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpd7pwsjmd.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmpd7pwsjmd.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpd7pwsjmd.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpd7pwsjmd.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd7pwsjmd.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmpd7pwsjmd.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmpd7pwsjmd.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var primes = 0\n    var prime_digits = 0\n    var prime_digit_count = 0\n\
    \    var prime_digit_sum = 0\n    var prime_digit_sum2 = 0\n    var prime_digit_sum3\
    \ = 0\n    var prime_digit_sum4 = 0\n    var prime_digit_sum5 = 0\n    var prime_digit_sum6\
    \ = 0\n    var prime_digit_sum7 = 0\n    var prime_digit_sum8 = 0\n    var prime_digit_sum9\
    \ = 0\n    var prime_digit_sum10 = 0\n    var prime_digit_sum11 = 0\n    var prime_digit_sum12\
    \ = 0\n    var prime_digit_sum13 = 0\n    var prime_digit_sum14 = 0\n    var prime_digit_sum15\
    \ = 0\n    var prime_digit_sum16 = 0\n    var prime_digit_sum17 = 0\n    var prime_digit_sum18\
    \ = 0\n    var prime_digit_sum19 = 0\n    var prime_digit_sum20 = 0\n    var prime_digit_sum21\
    \ = 0\n    var prime_digit_sum22 = 0\n    var prime_digit_sum23 = 0\n    var prime_digit_sum24\
    \ = 0\n    var prime_digit_sum25 = 0\n    var prime_digit_sum26 = 0\n    var prime_digit_sum27\
    \ = 0\n    var prime_digit_sum28 = 0\n    var prime_digit_sum29 = 0\n    var prime_digit_sum30\
    \ = 0\n    var prime_digit_sum31 = 0\n    var prime_digit_sum32 = 0\n    var prime_digit_sum33\
    \ = 0\n    var prime_digit_sum34 = 0\n    var prime_digit_sum35 = 0\n    var prime_digit_sum36\
    \ = 0\n    var prime_digit_sum37 = 0\n    var prime_digit_sum38 = 0\n    var prime_digit_sum39\
    \ = 0\n    var prime_digit_sum40 = 0\n    var prime_digit_sum41 = 0\n    var prime_digit_sum42\
    \ = 0\n    var prime_digit_sum43 = 0\n    var prime_digit_sum44 = 0\n    var prime_digit_sum45\
    \ = 0\n    var prime_digit_sum46 = 0\n    var prime_digit_sum47 = 0\n    var prime_digit_sum48\
    \ = 0\n    var prime_digit_sum49 = 0\n    var prime_digit_sum50 = 0\n    var prime_digit_sum51\
    \ = 0\n    var prime_digit_sum52 = 0\n    var prime_digit_sum53 = 0\n    var prime_digit_sum54\
    \ = 0\n    var prime_digit_sum55 = 0\n    var prime_digit_sum56 = 0\n    var prime_digit_sum57\
    \ = 0\n    var prime_digit_sum58 = 0\n    var prime_digit_sum59 = 0\n    var prime_digit_sum60\
    \ = 0\n    var prime_digit_sum61 = 0\n    var prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpytp6dx29.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpytp6dx29.swift:89:9:\
    \ error: type annotation missing in pattern\n    var prime\n        ^\n"
  stdout: ''
  timestamp: 1660014015
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdxnnxpa1.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014014
