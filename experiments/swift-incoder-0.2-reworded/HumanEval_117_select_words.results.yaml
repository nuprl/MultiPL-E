language: swift
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n        }\n        \n        if j == n {\n            result.append(String(s[i..<s.endIndex]))\n\
    \            i = s.endIndex\n            j = n\n        }\n        \n        if\
    \ s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i] ==\
    \ \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n        }\n        \n        if s[i] == \" \" {\n       \
    \     i += 1\n        }\n        \n        if s[i] == \" \" {\n            i +=\
    \ 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n   \
    \     }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n        }\n       \
    \ \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n    \
    \    if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpakuxxkrg.swift:184:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpakuxxkrg.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpakuxxkrg.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpakuxxkrg.swift:34:36:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            result.append(String(s[i..<s.endIndex]))\n                      \
    \             ^\n/tmp/tmpakuxxkrg.swift:35:19: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n            i = s.endIndex\n                ~~^~~~~~~~\n\
    /tmp/tmpakuxxkrg.swift:39:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s[i] == \" \" {\n\
    \           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpakuxxkrg.swift:43:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpakuxxkrg.swift:47:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpakuxxkrg.swift:51"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            words.append(String(char))\n        }\n    }\n\
    \    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm926_yso.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm926_yso.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let chars =\
    \ s.characters\n    \n    for char in chars {\n        if char.unicodeScalars.filter({\
    \ $0.isConsonant() }).count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvx_efe0k.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvx_efe0k.swift:28:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    while i < s.characters.count {\n        if s.characters.count\
    \ > i {\n            if s.characters.characters[i] != \" \" {\n              \
    \  if s.characters.characters[i] == \"a\" || s.characters.characters[i] == \"\
    e\" || s.characters.characters[i] == \"i\" || s.characters.characters[i] == \"\
    o\" || s.characters.characters[i] == \"u\" {\n                    if s.characters.count\
    \ - i > n {\n                        result.append(String(s.characters.characters.subarray(i\
    \ + 1, i + n)))\n                        i += n\n                    } else {\n\
    \                        result.append(String(s.characters.characters.subarray(i\
    \ + 1, s.characters.count)))\n                        i = s.characters.count\n\
    \                    }\n                } else {\n                    if s.characters.count\
    \ - i > n {\n                        result.append(String(s.characters.characters.subarray(i\
    \ + 1, i + n)))\n                        i += n\n                    } else {\n\
    \                        result.append(String(s.characters.characters.subarray(i\
    \ + 1, s.characters.count)))\n                        i = s.characters.count\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpse0oeb6d.swift:21:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    while i < s.characters.count {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpse0oeb6d.swift:22:14:\
    \ error: 'characters' is unavailable: Please use String directly\n        if s.characters.count\
    \ > i {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpse0oeb6d.swift:23:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if s.characters.characters[i]\
    \ != \" \" {\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpse0oeb6d.swift:23:18: error:\
    \ 'characters' is unavailable: Please use String directly\n            if s.characters.characters[i]\
    \ != \" \" {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpse0oeb6d.swift:23:29: error: 'characters' is unavailable:\
    \ Please use String directly\n            if s.characters.characters[i] != \"\
    \ \" {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpse0oeb6d.swift:24:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if s.characters.characters[i] == \"a\" || s.characters.characters[i] ==\
    \ \"e\" || s.characters.characters[i] == \"i\" || s.characters.characters[i] ==\
    \ \"o\" || s.characters.characters[i] == \"u\" {\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let words = s.components(separatedBy:\
    \ \" \")\n    \n    var result = [String]()\n    \n    for word in words {\n \
    \       \n        let letters = word.components(separatedBy: \" \")\n        \n\
    \        for letter in letters {\n            \n            let count = letters.filter({\
    \ $0 == letter }).count\n            \n            if count == n {\n         \
    \       \n                result.append(word)\n                \n            }\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplt3uwdp1.swift:20:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n\
    \ {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9r7bo5r9.swift:26:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isConsonant'\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n                                        ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s.characters {\n        if let index = s.firstIndex(of: letter)\
    \ {\n            if index == s.startIndex {\n                result.append(String(letter))\n\
    \            } else if index == s.endIndex {\n                result.append(String(letter))\n\
    \            } else {\n                let subString = String(s[..<index])\n \
    \               if subString.hasPrefix(String(letter)) {\n                   \
    \ result.append(String(letter))\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaj9_tfin.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j - i > n {\n                result.appendContentsOf(s[i : j])\n       \
    \         i = j\n            }\n        }\n        \n        if s[i] == \"a\"\
    \ {\n            k = i\n            \n            while k < s.count && s[k] ==\
    \ \"a\" {\n                k += 1\n            }\n            \n            if\
    \ k - i > n {\n                result.appendContentsOf(s[i : k])\n           \
    \     i = k\n            }\n        }\n        \n        if s[i] == \"e\" {\n\
    \            k = i\n            \n            while k < s.count && s[k] == \"\
    e\" {\n                k += 1\n            }\n            \n            if k -\
    \ i > n {\n                result.appendContentsOf(s[i : k])\n               \
    \ i = k\n            }\n        }\n        \n        if s[i] == \"i\" {\n    \
    \        k = i\n            \n            while k < s.count && s[k] == \"i\" {\n\
    \                k += 1\n            }\n            \n            if k - i > n\
    \ {\n                result.appendContentsOf(s[i : k])\n                i = k\n\
    \            }\n        }\n        \n        if s[i] == \"o\" {\n            k\
    \ = i\n            \n            while k < s.count && s[k] == \"o\" {\n      \
    \          k += 1\n            }\n            \n            if k - i > n {\n \
    \               result.appendContentsOf(s[i : k])\n                i = k\n   \
    \         }\n        }\n        \n        if s[i] == \"u\" {\n            k =\
    \ i\n            \n            while k < s.count && s[k] == \"u\" {\n        \
    \        k += 1\n            }\n            \n            if k - i > n {\n   \
    \             result.appendContentsOf(s[i : k])\n                i = k\n     \
    \       }\n        }\n        \n        if s[i] == \"y\" {\n            k = i\n\
    \            \n            while k < s.count && s[k] == \"y\" {\n            \
    \    k += 1\n            }\n            \n            if k - i > n {\n       \
    \         result.appendContentsOf(s[i : k])\n                i = k\n         \
    \   }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuev48ql9.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpuev48ql9.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpuev48ql9.swift:29:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \" \" {\n            j = i\n        }\n  \
    \      \n        if char == \"n\" {\n            i = j\n        }\n        \n\
    \        if char == \"c\" || char == \"d\" || char == \"m\" || char == \"p\" ||\
    \ char == \"t\" || char == \"v\" {\n            i = j\n        }\n        \n \
    \       if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"n\" {\n            i = j\n        }\n        \n        if char == \"c\" ||\
    \ char == \"d\" || char == \"m\" || char == \"p\" || char == \"t\" || char ==\
    \ \"v\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"f\" || char == \"k\" || char == \"p\" || char == \"s\" || char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"b\" ||\
    \ char == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkp3qs0_o.swift:93:35: error: unterminated string literal\n    \
    \    if char == \"b\" || char == \"\n                                  ^\n/tmp/tmpkp3qs0_o.swift:115:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpkp3qs0_o.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpkp3qs0_o.swift:97:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s.characters {\n        if let index = s.firstIndex(of: letter)\
    \ {\n            if index == s.startIndex {\n                result.append(String(letter))\n\
    \            } else {\n                let sub = s[index...index]\n          \
    \      if sub.characters.count >= n {\n                    result.append(String(letter))\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe_v2ux9x.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe_v2ux9x.swift:26:24:\
    \ error: 'characters' is unavailable: Please use Substring directly\n        \
    \        if sub.characters.count >= n {\n                       ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var index = 0\n    var count = 0\n    var last = 0\n    for c in s.characters\
    \ {\n        if c == \" \" {\n            words.append(String(s[last:index]))\n\
    \            last = index\n            count = 0\n        }\n        if c == \"\
    \ \" || c == \"\\n\" {\n            count += 1\n        }\n        if count ==\
    \ n {\n            words.append(String(s[last:index]))\n            last = index\n\
    \            count = 0\n        }\n        index += 1\n    }\n    words.append(String(s[last:index]))\n\
    \    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7csgf5da.swift:23:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7csgf5da.swift:25:34:\
    \ error: extraneous argument label 'last:' in subscript\n            words.append(String(s[last:index]))\n\
    \                                 ^~~~~~\n                                  \n\
    /tmp/tmp7csgf5da.swift:33:34: error: extraneous argument label 'last:' in subscript\n\
    \            words.append(String(s[last:index]))\n                           \
    \      ^~~~~~\n                                  \n/tmp/tmp7csgf5da.swift:39:26:\
    \ error: extraneous argument label 'last:' in subscript\n    words.append(String(s[last:index]))\n\
    \                         ^~~~~~\n                          \n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.count == n {\n\
    \            result.append(String(char))\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9a54s4v1.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxa2nj7od.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpxa2nj7od.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpxa2nj7od.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpxa2nj7od.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpxa2nj7od.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxa2nj7od.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxa2nj7od.swift:40:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxa2nj7od.swift:45:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxa2nj7od.swift:50:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    \n    while i < s.count {\n \
    \       if s[i] == \" \" {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi9fk_nrp.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpi9fk_nrp.swift:30:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpi9fk_nrp.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpi9fk_nrp.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpi9fk_nrp.swift:31:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi9fk_nrp.swift:36:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi9fk_nrp.swift:41:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi9fk_nrp.swift:46:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi9fk_nrp.swift:51:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.count >= n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0jn7jr8w.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Your code here\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpnv_34gjh.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            result.append(String(char))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2zrisx06.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2zrisx06.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var temp\
    \ = \"\"\n    var temp2 = \"\"\n    var temp3 = \"\"\n    var temp4 = \"\"\n \
    \   var temp5 = \"\"\n    var temp6 = \"\"\n    var temp7 = \"\"\n    var temp8\
    \ = \"\"\n    var temp9 = \"\"\n    var temp10 = \"\"\n    var temp11 = \"\"\n\
    \    var temp12 = \"\"\n    var temp13 = \"\"\n    var temp14 = \"\"\n    var\
    \ temp15 = \"\"\n    var temp16 = \"\"\n    var temp17 = \"\"\n    var temp18\
    \ = \"\"\n    var temp19 = \"\"\n    var temp20 = \"\"\n    var temp21 = \"\"\n\
    \    var temp22 = \"\"\n    var temp23 = \"\"\n    var temp24 = \"\"\n    var\
    \ temp25 = \"\"\n    var temp26 = \"\"\n    var temp27 = \"\"\n    var temp28\
    \ = \"\"\n    var temp29 = \"\"\n    var temp30 = \"\"\n    var temp31 = \"\"\n\
    \    var temp32 = \"\"\n    var temp33 = \"\"\n    var temp34 = \"\"\n    var\
    \ temp35 = \"\"\n    var temp36 = \"\"\n    var temp37 = \"\"\n    var temp38\
    \ = \"\"\n    var temp39 = \"\"\n    var temp40 = \"\"\n    var temp41 = \"\"\n\
    \    var temp42 = \"\"\n    var temp43 = \"\"\n    var temp44 = \"\"\n    var\
    \ temp45 = \"\"\n    var temp46 = \"\"\n    var temp47 = \"\"\n    var temp48\
    \ = \"\"\n    var temp49 = \"\"\n    var temp50 = \"\"\n    var temp51 = \"\"\n\
    \    var temp52 = \"\"\n    var temp53 = \"\"\n    var temp54 = \"\"\n    var\
    \ temp55 = \"\"\n    var temp56 = \"\"\n    var temp57 = \"\"\n    var temp58\
    \ = \"\"\n    var temp59 = \"\"\n    var temp60 = \"\"\n    var temp61 = \"\"\n\
    \    var temp62 = \"\"\n    var temp63 = \"\"\n    var temp64 = \"\"\n    var\
    \ temp65 = \"\"\n    var temp66 = \"\"\n    var temp67 = \"\"\n    var temp68\
    \ = \"\"\n    var temp69 = \"\"\n    var temp70 = \"\"\n    var temp71 = \"\"\n\
    \    var temp72 = \"\"\n    var temp73 = \"\"\n    var temp74 = \"\"\n    var\
    \ temp75 = \"\"\n    var temp76 = \"\"\n    var temp77 = \"\"\n    var temp78\
    \ = \"\"\n    var temp79 = \"\"\n    var temp80 = \"\"\n    var temp81 = \"\"\n\
    \    var temp82 = \"\"\n    var temp83 = \"\"\n    var temp84 = \"\"\n    var\
    \ temp85 = \"\"\n    var temp86 = \"\"\n    var temp87 = \"\"\n    var temp88\
    \ = \"\"\n    var temp89 = \"\"\n    var temp90 = \"\"\n    var temp91 = \"\"\n\
    \    var temp92 = \"\"\n    var temp93 = \"\"\n    var temp94\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp243fiv15.swift:117:9: error: type annotation missing in pattern\n\
    \    var temp94\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    for i < s.count {\n        if s[i] == \" \" {\n      \
    \      j = i\n            for k < s.count {\n                if s[k] == \" \"\
    \ {\n                    k = k + 1\n                } else {\n               \
    \     break\n                }\n            }\n            if k == s.count {\n\
    \                result.append(String(s[i..j]))\n            }\n        }\n  \
    \      i = i + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8a84411v.swift:26:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp8a84411v.swift:26:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp8a84411v.swift:29:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmp8a84411v.swift:29:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmp8a84411v.swift:26:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmp8a84411v.swift:29:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"i\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"o\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"h\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"l\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"l\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"a\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"e\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"i\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"o\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"h\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"l\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"l\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"i\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"o\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"h\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"l\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"l\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"a\" {\n            i\
    \ += 1\n            continue\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpluyay12y.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpluyay12y.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpluyay12y.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpluyay12y.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpluyay12y.swift:39:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpluyay12y.swift:44:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpluyay12y.swift:49:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpluyay12y.swift:54:12:\
    \ error: 'subscript(_:)' "
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb0nxozo2.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpb0nx"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.consonants.count == n {\n   \
    \         result.append(String(char))\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp55pd9_wu.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp55pd9_wu.swift:21:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants.count\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var last\
    \ = 0\n    var lastCount = 0\n    var lastLast = 0\n    var lastLastCount = 0\n\
    \    var lastLastLast = 0\n    var lastLastLastCount = 0\n    var lastLastLastLast\
    \ = 0\n    var lastLastLastLastCount = 0\n    var lastLastLastLastLast = 0\n \
    \   var lastLastLastLastLastCount = 0\n    var lastLastLastLastLastLast = 0\n\
    \    var lastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLast\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd4ib266.swift:38:9: error: invalid redeclaration of 'lastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:36:9:\
    \ note: 'lastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:39:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:37:9: note: 'lastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastCount = 0\n  \
    \      ^\n/tmp/tmprd4ib266.swift:42:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:43:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:41:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmprd4ib266.swift:46:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:44:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:47:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:45:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:49:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb0nxozo2.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpb0nx"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            j = i\n            j = 0\n            i = 0\n        }\n    }\n \
    \   \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7ndhf7v5.swift:38:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.count >= n {\n\
    \            result.append(String(char))\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_baiv4ct.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in 0..<s.characters.count {\n \
    \       if s.characters[k] == \" \" {\n            i += 1\n        }\n       \
    \ \n        if s.characters[k] == \" \" {\n            j += 1\n        }\n   \
    \     \n        if s.characters[k] == s.characters[k+1] {\n            k += 1\n\
    \        }\n        \n        if s.characters[k] == s.characters[k+1] {\n    \
    \        k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n        \n        if s.characters[k] == s.characters[k+1]\
    \ {\n            k += 1\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9q7rd192.swift:151:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9q7rd192.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp9q7rd192.swift:29:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ 0..<s.characters.count {\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9q7rd192.swift:30:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s.characters[k] == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9q7rd192.swift:30:14:\
    \ error: 'characters' is unavailable: Please use String directly\n        if s.characters[k]\
    \ == \" \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9q7rd192.swift:34:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s.characters[k] == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp9q7rd192.swift:34:14: error:\
    \ 'characters' is unavailable: Please use String directly\n        if s.characters[k]\
    \ == \" \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9q7rd192.swift:38:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index in"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    var lastChar = \"\"\n    \n    for char in s {\n        if char == lastChar\
    \ {\n            count += 1\n        } else {\n            if count == n {\n \
    \               result.append(String(lastChar))\n                count = 0\n \
    \           }\n            lastChar = char\n            count = 1\n        }\n\
    \    }\n    \n    if count > n {\n        result.append(String(lastChar))\n  \
    \  }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpno9s9tbt.swift:29:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == lastChar {\n\
    \           ~~~~ ^  ~~~~~~~~\n/tmp/tmpno9s9tbt.swift:29:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == lastChar {\n                ^\n/tmp/tmpno9s9tbt.swift:36:24:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  lastChar = char\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for char in s {\n        if char == \"\
    \ \" {\n            j = i\n            i = k\n            k += 1\n           \
    \ continue\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = k\n     \
    \       k += 1\n            continue\n        }\n        \n        if char ==\
    \ \"n\" {\n            i = k\n            k += 1\n            continue\n     \
    \   }\n        \n        if char == \"t\" || char == \"s\" || char == \"h\" ||\
    \ char == \"r\" || char == \"d\" {\n            i = k\n            k += 1\n  \
    \          continue\n        }\n        \n        if char == \"b\" || char ==\
    \ \"c\" || char == \"m\" || char == \"p\" || char == \"f\" || char == \"v\" ||\
    \ char == \"x\" {\n            i = k\n            k += 1\n            continue\n\
    \        }\n        \n        if char == \"k\" || char == \"l\" || char == \"\
    q\" || char == \"z\" || char == \"x\" {\n            i = k\n            k += 1\n\
    \            continue\n        }\n        \n        if char == \"j\" || char ==\
    \ \"q\" || char == \"z\" || char == \"x\" {\n            i = k\n            k\
    \ += 1\n            continue\n        }\n        \n        if char == \"m\" ||\
    \ char == \"a\" || char == \"p\" || char == \"s\" || char == \"d\" || char ==\
    \ \"f\" || char == \"v\" || char == \"x\" {\n            i = k\n            k\
    \ += 1\n            continue\n        }\n        \n        if char == \"n\" ||\
    \ char == \"t\" || char == \"s\" || char == \"h\" || char == \"r\" || char ==\
    \ \"d\" || char == \"b\" || char == \"c\" || char == \"m\" || char == \"p\" ||\
    \ char == \"f\" || char == \"v\" || char == \"x\" {\n            i = k\n     \
    \       k += 1\n            continue\n        }\n        \n        if char ==\
    \ \"k\" || char == \"l\" || char == \"q\" || char == \"z\" || char == \"x\" ||\
    \ char == \"j\" || char == \"q\" || char == \"z\" || char == \"x\" {\n       \
    \     i = k\n            k += 1\n            continue\n        }\n        \n \
    \       if char == \"m\" || char == \"a\" || char == \"p\" || char == \"s\" ||\
    \ char == \"d\" || char == \"f\" || char == \"v\" || char == \"x\" || char ==\
    \ \"j\" || char == \"q\" || char == \"z\" || char == \"x\" {\n            i =\
    \ k\n            k += 1\n            continue\n        }\n        \n        if\
    \ char == \"n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppi89h_rb.swift:97:20: error: unterminated string literal\n    \
    \    if char == \"n\n                   ^\n/tmp/tmppi89h_rb.swift:119:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmppi89h_rb.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmppi89h_rb.swift:101:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var last\
    \ = 0\n    var lastCount = 0\n    var lastLast = 0\n    var lastLastCount = 0\n\
    \    var lastLastLast = 0\n    var lastLastLastCount = 0\n    var lastLastLastLast\
    \ = 0\n    var lastLastLastLastCount = 0\n    var lastLastLastLastLast = 0\n \
    \   var lastLastLastLastLastCount = 0\n    var lastLastLastLastLastLast = 0\n\
    \    var lastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLast\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd4ib266.swift:38:9: error: invalid redeclaration of 'lastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:36:9:\
    \ note: 'lastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:39:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:37:9: note: 'lastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastCount = 0\n  \
    \      ^\n/tmp/tmprd4ib266.swift:42:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:43:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:41:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmprd4ib266.swift:46:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:44:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:47:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:45:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:49:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            continue\n        }\n        \n    \
    \    if count_consonants(c) == n {\n            result.append(String(s.characters.prefix(s.startIndex.advancedBy(c))))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpeup0h3ck.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpeup0h3ck.swift:30:12:\
    \ error: cannot find 'count_consonants' in scope\n        if count_consonants(c)\
    \ == n {\n           ^~~~~~~~~~~~~~~~\n/tmp/tmpeup0h3ck.swift:31:67: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n            result.append(String(s.characters.prefix(s.startIndex.advancedBy(c))))\n\
    \                                                     ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.characters.count >= n {\n \
    \           result.append(word)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq21wwwex.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j - i > n {\n                for k = i; k < j; k++ {\n                 \
    \   result.append(String(s[k]))\n                }\n            }\n          \
    \  \n            i = j\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0e6rez0t.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp0e6rez0t.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp0e6rez0t.swift:38:17: error: C-style for statement\
    \ has been removed in Swift 3\n                for k = i; k < j; k++ {\n     \
    \           ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp0e6rez0t.swift:29:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    \n    while i < s.count {\n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"a\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"e\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"i\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"o\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"y\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"A\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"E\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"I\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"O\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"U\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"Y\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"b\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"c\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"d\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"f\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"g\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"h\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"j\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"k\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"l\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"m\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"n\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"p\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"q\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"r\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"s\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"t\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"v\" {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptmwmggkm.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmptmwmggkm.swift:30:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmptmwmggkm.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmptmwmggkm.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmptmwmggkm.swift:31:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptmwmggkm.swift:36:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptmwmggkm.swift:41:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptmwmggkm.swift:46:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptmwmggkm.swift:51:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = s.count\n    for i < m {\n    \
    \    if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \"\
    a\" {\n            i += 1\n        }\n        if s[i] == \"e\" {\n           \
    \ i += 1\n        }\n        if s[i] == \"i\" {\n            i += 1\n        }\n\
    \        if s[i] == \"o\" {\n            i += 1\n        }\n        if s[i] ==\
    \ \"u\" {\n            i += 1\n        }\n        if s[i] == \"y\" {\n       \
    \     i += 1\n        }\n        if s[i] == \"A\" {\n            i += 1\n    \
    \    }\n        if s[i] == \"E\" {\n            i += 1\n        }\n        if\
    \ s[i] == \"I\" {\n            i += 1\n        }\n        if s[i] == \"O\" {\n\
    \            i += 1\n        }\n        if s[i] == \"U\" {\n            i += 1\n\
    \        }\n        if s[i] == \"Y\" {\n            i += 1\n        }\n      \
    \  if s[i] == \"n\" {\n            i += 1\n        }\n        if s[i] == \"d\"\
    \ {\n            i += 1\n        }\n        if s[i] == \"h\" {\n            i\
    \ += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n        }\n\
    \        if s[i] == \"l\" {\n            i += 1\n        }\n        if s[i] ==\
    \ \"l\" {\n            i += 1\n        }\n        if s[i] == \"l\" {\n       \
    \     i += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n    \
    \    }\n        if s[i] == \"l\" {\n            i += 1\n        }\n        if\
    \ s[i] == \"l\" {\n            i += 1\n        }\n        if s[i] == \"l\" {\n\
    \            i += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n\
    \        }\n        if s[i] == \"l\" {\n            i += 1\n        }\n      \
    \  if s[i] == \"l\" {\n            i += 1\n        }\n        if s[i] == \"l\"\
    \ {\n            i += 1\n        }\n        if s[i] == \"l\" {\n            i\
    \ += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n        }\n\
    \        if s[i] == \"l\" {\n            i += 1\n        }\n        if s[i] ==\
    \ \"l\" {\n            i += 1\n        }\n        if s[i] == \"l\" {\n       \
    \     i += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n    \
    \    }\n        if s[i] == \"l\" {\n            i += 1\n        }\n        if\
    \ s[i] == \"l\" {\n            i += 1\n        }\n        if s[i] == \"l\" {\n\
    \            i += 1\n        }\n        if s[i] == \"l\" {\n            i += 1\n\
    \        }\n        if s[i] == \"l\" {\n            i += 1\n        }\n      \
    \  if s[i] == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6bm3666y.swift:28:11: error: expected 'in' after for-each pattern\n\
    \    for i < m {\n          ^\n/tmp/tmp6bm3666y.swift:28:11: error: unary operator\
    \ cannot be separated from its operand\n    for i < m {\n          ^~\n      \
    \     \n/tmp/tmp6bm3666y.swift:146:20: error: unterminated string literal\n  \
    \      if s[i] == \"\n                   ^\n/tmp/tmp6bm3666y.swift:168:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp6bm3666y.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp6bm3666y.swift:28:11:\
    \ error: '<' is not a prefix unary operator\n    for i < m {\n          ^\n/tmp/tmp6bm3666y.swift:150:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            i += 1\n            if j == n {\n   \
    \             result.append(\"a\")\n                j += 1\n                k\
    \ = 0\n                continue\n            }\n        }\n        \n        if\
    \ s[i] == \"e\" {\n            i += 1\n            if j == n {\n             \
    \   result.append(\"e\")\n                j += 1\n                k = 0\n    \
    \            continue\n            }\n        }\n        \n        if s[i] ==\
    \ \"i\" {\n            i += 1\n            if j == n {\n                result.append(\"\
    i\")\n                j += 1\n                k = 0\n                continue\n\
    \            }\n        }\n        \n        if s[i] == \"o\" {\n            i\
    \ += 1\n            if j == n {\n                result.append(\"o\")\n      \
    \          j += 1\n                k = 0\n                continue\n         \
    \   }\n        }\n        \n        if s[i] == \"u\" {\n            i += 1\n \
    \           if j == n {\n                result.append(\"u\")\n              \
    \  j += 1\n                k = 0\n                continue\n            }\n  \
    \      }\n        \n        if s[i] == \"y\" {\n            i += 1\n         \
    \   if j == n {\n                result.append(\"y\")\n                j += 1\n\
    \                k = 0\n                continue\n            }\n        }\n \
    \       \n        if s[i] == \"A\" {\n            i += 1\n            if j ==\
    \ n {\n                result.append(\"A\")\n                j += 1\n        \
    \        k = 0\n                continue\n            }\n        }\n        \n\
    \        if s[i] == \"E\" {\n            i += 1\n            if j == n {\n   \
    \             result.append(\"E\")\n                j += 1\n                k\
    \ = 0\n                continue\n            }\n        }\n        \n        if\
    \ s[i] == \"I\" {\n            i += 1\n            if j == n {\n             \
    \   result.append(\"I\")\n                j += 1\n                k = 0\n    \
    \            continue\n            }\n        }\n        \n        if s[i] ==\
    \ \"O\" {\n            i += 1\n            if j == n {\n                result.append(\"\
    O\")\n                j += 1\n                k = 0\n                continue\n\
    \            }\n        }\n        \n        if s[i] == \"U\" {\n            i\
    \ += 1\n            if j == n {\n                result.append(\"U\")\n      \
    \          j += 1\n                k = 0\n                continue\n         \
    \   }\n        }\n        \n        if s[i] == \"Y\" {\n            i += 1\n \
    \           if j == n {\n                result.append(\"Y\")\n              \
    \  j += 1\n                k = 0\n                continue\n            }\n  \
    \      }\n        \n        if s[i] == \"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5jit8h52.swift:155:20: error: unterminated string literal\n   \
    \     if s[i] == \"\n                   ^\n/tmp/tmp5jit8h52.swift:177:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp5jit8h52.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp5jit8h52.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5jit8h52.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5jit8h52.swift:45:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5jit8h52.swift:55:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5jit8h52.swift:65:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"o\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    publ"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    \n    for letter in s.characters {\n        if letter == \" \" {\n  \
    \          continue\n        }\n        \n        if count == n {\n          \
    \  result.append(String(letter))\n            count = 0\n        }\n        \n\
    \        count += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphttxaha3.swift:27:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    var index = 0\n    \n    for char in s {\n        if char == \" \" {\n\
    \            count += 1\n        }\n        \n        if count == n {\n      \
    \      result.append(String(s[index...]))\n            count = 0\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            count += 1\n        }\n        \n \
    \       if char == \"y\" {\n            count += 1\n        }\n        \n    \
    \    if char == \"s\" {\n            count += 1\n        }\n        \n       \
    \ if char == \"d\" {\n            count += 1\n        }\n        \n        if\
    \ char == \"h\" {\n            count += 1\n        }\n        \n        if char\
    \ == \"l\" {\n            count += 1\n        }\n        \n        if char ==\
    \ \"m\" {\n            count += 1\n        }\n        \n        if char == \"\
    n\" {\n            count += 1\n        }\n        \n        if char == \"t\" {\n\
    \            count += 1\n        }\n        \n        if char == \"k\" {\n   \
    \         count += 1\n        }\n        \n        if char == \"p\" {\n      \
    \      count += 1\n        }\n        \n        if char == \"r\" {\n         \
    \   count += 1\n        }\n        \n        if char == \"f\" {\n            count\
    \ += 1\n        }\n        \n        if char == \"v\" {\n            count +=\
    \ 1\n        }\n        \n        if char == \"b\" {\n            count += 1\n\
    \        }\n        \n        if char == \"j\" {\n            count += 1\n   \
    \     }\n        \n        if char == \"q\" {\n            count += 1\n      \
    \  }\n        \n        if char == \"z\" {\n            count += 1\n        }\n\
    \        \n        if char == \"x\" {\n            count += 1\n        }\n   \
    \     \n        if char == \"q\" {\n            count += 1\n        }\n      \
    \  \n        if char == \"z\" {\n            count += 1\n        }\n        \n\
    \        if char == \"x\" {\n            count += 1\n        }\n        \n   \
    \     if char == \"q\" {\n            count += 1\n        }\n        \n      \
    \  if char == \"z\" {\n            count += 1\n        }\n        \n        if\
    \ char == \"x\" {\n            count += 1\n        }\n        \n        if char\
    \ == \"q\" {\n            count += 1\n        }\n        \n        if char ==\
    \ \"z\" {\n            count += 1\n        }\n        \n        if char == \"\
    x\" {\n            count += 1\n        }\n        \n        if char == \"q\" {\n\
    \            count += 1\n        }\n        \n        if char == \"z\" {\n   \
    \         count += 1\n        }\n        \n        if char == \"x\" {\n      \
    \      count += 1\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwxjhnsc9.swift:182:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpwxjhnsc9.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpwxjhnsc9.swift:34:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            result.append(String(s[index...]))\n\
    \                                 ^~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpwxjhnsc9.swift:164:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n/tmp/tmpwxjhnsc9.swift:26:9: warning: variable 'index' was never\
    \ mutated; consider changing to 'let' constant\n    var index = 0\n    ~~~ ^\n\
    \    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j - i > n {\n                for k = i; k < j; k++ {\n                 \
    \   result.append(String(s[k]))\n                }\n            }\n          \
    \  \n            i = j\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0e6rez0t.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp0e6rez0t.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp0e6rez0t.swift:38:17: error: C-style for statement\
    \ has been removed in Swift 3\n                for k = i; k < j; k++ {\n     \
    \           ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp0e6rez0t.swift:29:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            words.append(\"\")\n        } else {\n\
    \            if c.isConsonant() {\n                words.append(c.string)\n  \
    \          }\n        }\n    }\n    \n    return words.filter {\n        $0.characters.count\
    \ == n\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsiwkb0mf.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsiwkb0mf.swift:29:18:\
    \ error: value of type 'Character' has no member 'isConsonant'\n            if\
    \ c.isConsonant() {\n               ~ ^~~~~~~~~~~\n/tmp/tmpsiwkb0mf.swift:30:32:\
    \ error: value of type 'Character' has no member 'string'\n                words.append(c.string)\n\
    \                             ~ ^~~~~~\n/tmp/tmpsiwkb0mf.swift:36:12: error: 'characters'\
    \ is unavailable: Please use String directly\n        $0.characters.count == n\n\
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpy2j4mtyo/tmpy2j4mtyo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c0964c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c065bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c065b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c065a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2j4mtyo                        0x000055d0ec3894c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab1c0b50460 __libc_start_main +
    245

    6    tmpy2j4mtyo                        0x000055d0ec3890c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   var i = 0\n    var j = 0\n    \n    for char in s {\n        if char == \"\
    \ \" {\n            i = j\n        }\n        \n        if char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i\
    \ = j\n        }\n        \n        if char == \"y\" {\n            i = j\n  \
    \      }\n        \n        if char == \"s\" {\n            i = j\n        }\n\
    \        \n        if char == \"d\" || char == \"h\" || char == \"l\" || char\
    \ == \"m\" || char == \"n\" || char == \"t\" || char == \"p\" || char == \"v\"\
    \ || char == \"z\" {\n            i = j\n        }\n        \n        if char\
    \ == \"b\" || char == \"c\" || char == \"f\" || char == \"g\" || char == \"j\"\
    \ || char == \"k\" || char == \"q\" || char == \"r\" || char == \"x\" || char\
    \ == \"z\" {\n            i = j\n        }\n        \n        if char == \"k\"\
    \ || char == \"q\" || char == \"r\" || char == \"x\" || char == \"z\" {\n    \
    \        i = j\n        }\n        \n        if char == \"m\" || char == \"n\"\
    \ || char == \"t\" || char == \"p\" || char == \"v\" || char == \"z\" {\n    \
    \        i = j\n        }\n        \n        if char == \"b\" || char == \"c\"\
    \ || char == \"f\" || char == \"g\" || char == \"j\" || char == \"k\" || char\
    \ == \"q\" || char == \"r\" || char == \"x\" || char == \"z\" {\n            i\
    \ = j\n        }\n        \n        if char == \"k\" || char == \"q\" || char\
    \ == \"r\" || char == \"x\" || char == \"z\" {\n            i = j\n        }\n\
    \        \n        if char == \"m\" || char == \"n\" || char == \"t\" || char\
    \ == \"p\" || char == \"v\" || char == \"z\" {\n            i = j\n        }\n\
    \        \n        if char == \"b\" || char == \"c\" || char == \"f\" || char\
    \ == \"g\" || char == \"j\" || char == \"k\" || char == \"q\" || char == \"r\"\
    \ || char == \"x\" || char == \"z\" {\n            i = j\n        }\n        \n\
    \        if char == \"k\" || char == \"q\" || char == \"r\" || char == \"x\" ||\
    \ char == \"z\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"m\" || char == \"n\" || char == \"t\" || char == \"p\" || char == \"v\" ||\
    \ char == \"z\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_72vw8b3.swift:86:20: error: unterminated string literal\n    \
    \    if char == \"b\n                   ^\n/tmp/tmp_72vw8b3.swift:108:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp_72vw8b3.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp_72vw8b3.swift:90:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb0nxozo2.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpb0nx"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if i == 0 {\n                j = 0\n            }\n            \n     \
    \       if j == n {\n                result.append(\"\\(strings[i - 1])\")\n \
    \               \n                i = i + 1\n                j = 0\n         \
    \   }\n            \n            if j == 0 {\n                result.append(\"\
    \\(strings[i])\")\n                \n                i = i + 1\n             \
    \   j = 0\n            }\n            \n            if i == 0 {\n            \
    \    result.append(\"\\(strings[j])\")\n                \n                j =\
    \ j + 1\n                i = 0\n            }\n        }\n        \n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            if i == 0 {\n                j = 0\n            }\n   \
    \         \n            if j == n {\n                result.append(\"\\(strings[i\
    \ - 1])\")\n                \n                i = i + 1\n                j = 0\n\
    \            }\n            \n            if j == 0 {\n                result.append(\"\
    \\(strings[i])\")\n                \n                i = i + 1\n             \
    \   j = 0\n            }\n            \n            if i == 0 {\n            \
    \    result.append(\"\\(strings[j])\")\n                \n                j =\
    \ j + 1\n                i = 0\n            }\n        }\n        \n        if\
    \ char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" || char ==\
    \ \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char == \"l\" ||\
    \ char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" || char ==\
    \ \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char == \"w\" ||\
    \ char == \"x\" || char == \"y\" || char == \"z\" {\n            if i == 0 {\n\
    \                j = 0\n            }\n            \n            if j == n {\n\
    \                result.append(\"\\(strings[i - 1])\")\n                \n   \
    \             i = i + 1\n                j = 0\n            }\n            \n\
    \            if j == 0 {\n                result.append(\"\\(strings[i])\")\n\
    \                \n                i = i + 1\n                j = 0\n        \
    \    }\n            \n            if i == 0 {\n                result.append(\"\
    \\(strings[j])\")\n                \n                j = j + 1\n             \
    \   i = 0\n            }\n        }\n        \n        if char == \"c\" || char\
    \ == \"d\" || char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\"\
    \ || char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char\
    \ == \"p\" || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\"\
    \ || char == \"v\" || char == \"w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqr85wma1.swift:110:260: error: unterminated string literal\n  \
    \      if char == \"c\" || char == \"d\" || char == \"f\" || char == \"g\" ||\
    \ char == \"h\" || char == \"j\" || char == \"k\" || char == \"l\" || char ==\
    \ \"m\" || char == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" ||\
    \ char == \"s\" || char == \"t\" || char == \"v\" || char == \"w\n           \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                    ^\n/tmp/tmpqr85wma1.swift:132:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpqr85wma1.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpqr85wma1.swift:35:34: error: cannot\
    \ find 'strings' in scope\n                result.append(\"\\(strings[i - 1])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:42:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[i])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:49:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[j])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:62:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[i\
    \ - 1])\")\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:69:34:\
    \ error: cannot find 'strings' in scope\n                result.append(\"\\(strings[i])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:76:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[j])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpqr85wma1.swift:89:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[i\
    \ - 1])\")\n               "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() ==\
    \ true }).count == n {\n            result.append(String(char))\n        }\n \
    \   }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0sc15jj0.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0sc15jj0.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() == true }).count == n {\n    \
    \                                    ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n            j = 0\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb_mnwk22.swift:38:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe3r__5ox.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe3r__5ox.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe3r__5ox.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe3r__5ox.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8w845vtg.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8w845vtg.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qw_0wx.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp69qw_0wx.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in s.characters {\n        if s.characters[k]\
    \ == \" \" {\n            j = k\n        }\n    }\n    \n    for k in s.characters\
    \ {\n        if s.characters[k] == \" \" {\n            j = k\n        }\n   \
    \     if s.characters[k] == \" \" {\n            i = k\n        }\n        if\
    \ s.characters[k] == \" \" {\n            i = k\n        }\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n        if s.characters[k] == \" \"\
    \ {\n            i = k\n        }\n        if s.characters[k] == \" \" {\n   \
    \         i = k\n        }\n        if s.characters[k] == \" \" {\n          \
    \  i = k\n        }\n        if s.characters[k] == \" \" {\n            i = k\n\
    \        }\n        if s.characters[k] == \" \" {\n            i = k\n       \
    \ }\n        if s.characters[k] == \" \" {\n            i = k\n        }\n   \
    \     if s.characters[k] == \" \" {\n            i = k\n        }\n        if\
    \ s.characters[k] == \" \" {\n            i = k\n        }\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n        if s.characters[k] == \" \"\
    \ {\n            i = k\n        }\n        if s.characters[k] == \" \" {\n   \
    \         i = k\n        }\n        if s.characters[k] == \" \" {\n          \
    \  i = k\n        }\n        if s.characters[k] == \" \" {\n            i = k\n\
    \        }\n        if s.characters[k] == \" \" {\n            i = k\n       \
    \ }\n        if s.characters[k] == \" \" {\n            i = k\n        }\n   \
    \     if s.characters[k] == \" \" {\n            i = k\n        }\n        if\
    \ s.characters[k] == \" \" {\n            i = k\n        }\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n        if s.characters[k] == \" \"\
    \ {\n            i = k\n        }\n        if s.characters[k] == \" \" {\n   \
    \         i = k\n        }\n        if s.characters[k] == \" \" {\n          \
    \  i = k\n        }\n        if s.characters[k] == \" \" {\n            i = k\n\
    \        }\n        if s.characters[k] == \" \" {\n            i = k\n       \
    \ }\n        if s.characters[k] == \" \" {\n            i = k\n        }\n   \
    \     if s.characters[k] == \" \" {\n            i = k\n        }\n        if\
    \ s.characters[k] == \" \" {\n            i = k\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp82aveu8j.swift:147:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp82aveu8j.swift:35:27:\
    \ note: to match this opening '{'\n    for k in s.characters {\n             \
    \             ^\n/tmp/tmp82aveu8j.swift:147:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmp82aveu8j.swift:18:50: note: to match this opening '{'\n\
    func select_words(s: String, n: Int) -> [String] {\n                         \
    \                        ^\n/tmp/tmp82aveu8j.swift:29:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for k in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp82aveu8j.swift:30:24: error: no exact matches in call to subscript\
    \ \n        if s.characters[k] == \" \" {\n                       ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Character')\n    public subscript(r: Range<String.Index>) -> Substring\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp82aveu8j.swift:31:17: error: cannot assign value\
    \ of type 'Character' to type 'Int'\n            j = k\n                ^\n/tmp/tmp82aveu8j.swift:35:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp82aveu8j.swift:36:24: error: no exact matches in call\
    \ to subscript \n        if s.char"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = s.characters.count\n    var n =\
    \ m\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = s.characters.count\n\
    \    var s = String()\n    var t = String()\n    var u = String()\n    var v =\
    \ String()\n    var w = String()\n    var x = String()\n    var y = String()\n\
    \    var z = String()\n    var A = String()\n    var B = String()\n    var C =\
    \ String()\n    var D = String()\n    var E = String()\n    var F = String()\n\
    \    var G = String()\n    var H = String()\n    var I = String()\n    var J =\
    \ String()\n    var K = String()\n    var L = String()\n    var M = String()\n\
    \    var N = String()\n    var O = String()\n    var P = String()\n    var Q =\
    \ String()\n    var R = String()\n    var S = String()\n    var T = String()\n\
    \    var U = String()\n    var V = String()\n    var W = String()\n    var X =\
    \ String()\n    var Y = String()\n    var Z = String()\n    var a = String()\n\
    \    var b = String()\n    var c = String()\n    var d = String()\n    var e =\
    \ String()\n    var f = String()\n    var g = String()\n    var h = String()\n\
    \    var i = String()\n    var j = String()\n    var k = String()\n    var l =\
    \ String()\n    var m = String()\n    var n = String()\n    var o = String()\n\
    \    var p = String()\n    var q = String()\n    var r = String()\n    var s =\
    \ String()\n    var t = String()\n    var u = String()\n    var v = String()\n\
    \    var w = String()\n    var x = String()\n    var y = String()\n    var z =\
    \ String()\n    var A = String()\n    var B = String()\n    var C = String()\n\
    \    var D = String()\n    var E = String()\n    var F = String()\n    var G =\
    \ String()\n    var H = String()\n    var I = String()\n    var J = String()\n\
    \    var K = String()\n    var L = String()\n    var M = String()\n    var N =\
    \ String()\n    var O = String()\n    var P = String()\n    var Q = String()\n\
    \    var R = String()\n    var S = String()\n    var T = String()\n    var U =\
    \ String()\n    var V = String()\n    var W = String()\n    var X = String()\n\
    \    var Y = String()\n    var Z = String()\n    var a = String\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppbjjv4vq.swift:27:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var m = s.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppbjjv4vq.swift:32:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    var r =\
    \ s.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmppbjjv4vq.swift:75:9: error: invalid redeclaration of\
    \ 'i'\n    var i = String()\n        ^\n/tmp/tmppbjjv4vq.swift:23:9: note: 'i'\
    \ previously declared here\n    var i = 0\n        ^\n/tmp/tmppbjjv4vq.swift:76:9:\
    \ error: invalid redeclaration of 'j'\n    var j = String()\n        ^\n/tmp/tmppbjjv4vq.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmppbjjv4vq.swift:77:9:\
    \ error: invalid redeclaration of 'k'\n    var k = String()\n        ^\n/tmp/tmppbjjv4vq.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmppbjjv4vq.swift:78:9:\
    \ error: invalid redeclaration of 'l'\n    var l = String()\n        ^\n/tmp/tmppbjjv4vq.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmppbjjv4vq.swift:79:9:\
    \ error: invalid redeclaration of 'm'\n    var m = String()\n        ^\n/tmp/tmppbjjv4vq.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = s.characters.count\n       \
    \ ^\n/tmp/tmppbjjv4vq.swift:80:9: error: invalid redeclaration of 'n'\n    var\
    \ n = String()\n        ^\n/tmp/tmppbjjv4vq.swift:28:9: note: 'n' previously declared\
    \ here\n    var n = m\n        ^\n/tmp/tmppbjjv4vq.swift:81:9: error: invalid\
    \ redeclaration of 'o'\n    var o = String()\n        ^\n/tmp/tmppbjjv4vq.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmppbjjv4vq.swift:82:9:\
    \ error: invalid redeclaration of 'p'\n    var p = String()\n        ^\n/tmp/tmppbjjv4vq.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qw_0wx.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp69qw_0wx.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for c in s.characters {\n        if c.isConsonant() {\n            if n ==\
    \ 1 {\n                words.append(String(c.unicodeScalars))\n            } else\
    \ {\n                words.append(String(c.unicodeScalars))\n                n\
    \ -= 1\n            }\n        }\n    }\n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk6sxalan.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk6sxalan.swift:21:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmpk6sxalan.swift:26:19: error: left side\
    \ of mutating operator isn't mutable: 'n' is a 'let' constant\n              \
    \  n -= 1\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n        }\n        \n        if j == n {\n            result.append(String(s[i..<s.endIndex]))\n\
    \            i = s.endIndex\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n        }\n        \n        if s[i] == \" \" {\n       \
    \     i += 1\n        }\n        \n        if s[i] == \" \" {\n            i +=\
    \ 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n   \
    \     }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n        }\n       \
    \ \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n    \
    \    if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplxse4gzr.swift:162:16: error: expected '{' after 'if' condition\n\
    \        if s[i]\n               ^\n/tmp/tmplxse4gzr.swift:184:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmplxse4gzr.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmplxse4gzr.swift:29:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmplxse4gzr.swift:34:36: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            result.append(String(s[i..<s.endIndex]))\n                      \
    \             ^\n/tmp/tmplxse4gzr.swift:35:19: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n            i = s.endIndex\n                ~~^~~~~~~~\n\
    /tmp/tmplxse4gzr.swift:38:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s[i] == \" \" {\n\
    \           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmplxse4gzr.swift:42:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplxse4gzr.swift:46:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.count >= n {\n            words.append(String(char))\n\
    \        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6m3klelc.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonants {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1ejnhhsy.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1ejnhhsy.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ != \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                result.append(\"\\n\")\n            }\n\
    \            \n            k = i\n            \n            while k < s.count\
    \ && s[k] != \" \" {\n                k += 1\n            }\n            \n  \
    \          if k == s.count {\n                result.append(\"\\n\")\n       \
    \     }\n            \n            i += j - k\n        }\n        \n        if\
    \ s[i] == \"\\n\" {\n            i += 2\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n    }\n    \n    if n <= result.count\
    \ {\n        return result[n]\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwkdj88f6.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpwkdj88f6.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpwkdj88f6.swift:29:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n/tmp/tmpwkdj88f6.swift:64:22:\
    \ error: cannot convert return expression of type 'String' to return type '[String]'\n\
    \        return result[n]\n               ~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.unicodeScalars.filter({ $0.isConsonant() }).count ==\
    \ n {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqp6qxx2r.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqp6qxx2r.swift:30:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s {\n        if char.unicodeScalars.count == n {\n          \
    \  result.append(String(char.unicodeScalars))\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpqa6qtgle/tmpqa6qtgle.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8b4973c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8b466ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8b466a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8b46697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqa6qtgle                        0x00005602c74cd7f4 <unavailable> + 6132

    5    libc.so.6                          0x00002ab8b4b5f460 __libc_start_main +
    245

    6    tmpqa6qtgle                        0x00005602c74cd3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if k == s.count {\n                result.append(s[i\
    \ : j])\n                i = j + 1\n            }\n        }\n    }\n    \n  \
    \  for k < s.count {\n        if s[k] == \" \" {\n            k = k + 1\n    \
    \    } else {\n            break\n        }\n    }\n    \n    for i < s.count\
    \ {\n        if s[i] == \" \" {\n            j = i\n            \n           \
    \ for k < s.count {\n                if s[k] == \" \" {\n                    k\
    \ = k + 1\n                } else {\n                    break\n             \
    \   }\n            }\n            \n            if k == s.count {\n          \
    \      result.append(s[i : j])\n                i = j + 1\n            }\n   \
    \     }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpstlacu18.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpstlacu18.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpstlacu18.swift:33:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpstlacu18.swift:33:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpstlacu18.swift:48:11:\
    \ error: expected 'in' after for-each pattern\n    for k < s.count {\n       \
    \   ^\n/tmp/tmpstlacu18.swift:48:11: error: unary operator cannot be separated\
    \ from its operand\n    for k < s.count {\n          ^~\n           \n/tmp/tmpstlacu18.swift:56:11:\
    \ error: expected 'in' after for-each pattern\n    for i < s.count {\n       \
    \   ^\n/tmp/tmpstlacu18.swift:56:11: error: unary operator cannot be separated\
    \ from its operand\n    for i < s.count {\n          ^~\n           \n/tmp/tmpstlacu18.swift:60:19:\
    \ error: expected 'in' after for-each pattern\n            for k < s.count {\n\
    \                  ^\n/tmp/tmpstlacu18.swift:60:19: error: unary operator cannot\
    \ be separated from its operand\n            for k < s.count {\n             \
    \     ^~\n                   \n/tmp/tmpstlacu18.swift:29:11: error: '<' is not\
    \ a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpstlacu18.swift:48:11:\
    \ error: '<' is not a prefix unary operator\n    for k < s.count {\n         \
    \ ^\n/tmp/tmpstlacu18.swift:56:11: error: '<' is not a prefix unary operator\n\
    \    for i < s.count {\n          ^\n/tmp/tmpstlacu18.swift:33:19: error: '<'\
    \ is not a prefix unary operator\n            for k < s.count {\n            \
    \      ^\n/tmp/tmpstlacu18.swift:60:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.characters.count {\n    \
    \    if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i] !=\
    \ 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n            result.append(s.substringWithRange(NSMakeRange(i,\
    \ 1)))\n            i += 1\n            continue\n        }\n        \n      \
    \  if i == s.characters.count {\n            break\n        }\n        \n    \
    \    if s.characters[i] == 'a' || s.characters[i] == 'e' || s.characters[i] ==\
    \ 'i' || s.characters[i] == 'o' || s.characters[i] == 'u' {\n            if j\
    \ == n {\n                result.append(s.substringWithRange(NSMakeRange(i, 1)))\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 0 {\n\
    \                result.append(s.substringWithRange(NSMakeRange(i, 1)))\n    \
    \            i += 1\n                j += 1\n                k += 1\n        \
    \        continue\n            }\n            \n            if k == n {\n    \
    \            result.append(s.substringWithRange(NSMakeRange(i, 1)))\n        \
    \        i += 1\n                j += 1\n                k += 1\n            \
    \    continue\n            }\n            \n            if k == 0 {\n        \
    \        result.append(s.substringWithRange(NSMakeRange(i, 1)))\n            \
    \    i += 1\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if j == 0 {\n                result.append(s.substringWithRange(NSMakeRange(i,\
    \ 1)))\n                i += 1\n                j += 1\n                k += 1\n\
    \                continue\n            }\n            \n            if k == 0\
    \ {\n                result.append(s.substringWithRange(NSMakeRange(i, 1)))\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == n {\n\
    \                result.append(s.substringWithRange(NSMakeRange(i, 1)))\n    \
    \            i += 1\n                j += 1\n                k += 1\n        \
    \        continue\n            }\n            \n            if k == n {\n    \
    \            result.append(s.substringWithRange(NSMakeRange(i, 1)))\n        \
    \        i += 1\n                j += 1\n                k += 1\n            \
    \    continue\n            }\n            \n            if j == n {\n        \
    \        result.append(s.substringWithRange(NSMakeRange(i, 1)))\n            \
    \    i += 1\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                result.append(s.substringWithRange(NSMakeRange(i,\
    \ 1)))\n                i += 1\n                j += 1\n                k += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                result.append(s.substringWithRange(NSMakeRange(i, 1)))\n\
    \                i += 1\n                j += 1\n                \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz6sr4jro.swift:30:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                 ^~~\n                              \"a\"\n/tmp/tmpz6sr4jro.swift:30:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ != 'a' && s.characters[i] != 'e' && s.characters[i] != 'i' && s.characters[i]\
    \ != 'o' && s.characters[i] != 'u' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"e\"\n/tmp/tmpz6sr4jro.swift:30:83: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                                                                     ^~~\n  \
    \                                                                            \
    \    \"i\"\n/tmp/tmpz6sr4jro.swift:30:109: error: single-quoted string literal\
    \ found, use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e'\
    \ && s.characters[i] != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u'\
    \ {\n                                                                        \
    \                                    ^~~\n                                   \
    \                                                                         \"o\"\
    \n/tmp/tmpz6sr4jro.swift:30:135: error: single-quoted string literal found, use\
    \ '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                                                                            \
    \                                             ^~~\n                          \
    \                                                                            \
    \                                \"u\"\n/tmp/tmpz6sr4jro.swift:40:31: error: single-quoted\
    \ string literal found, use '\"'\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnxafrprs.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpnxafrprs.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpnxafrprs.swift:198:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpnxafrprs.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpnxafrprs.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnxafrprs.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnxafrprs.swift:40:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnxafrprs.swift:45:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnxafrprs.swift:50:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ != \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                break\n            }\n            \n   \
    \         for k < j {\n                if s[k] != \" \" {\n                  \
    \  break\n                }\n                \n                k += 1\n      \
    \      }\n            \n            if k == j {\n                result.append(String(s[i:k]))\n\
    \                i = k + 1\n            }\n        }\n        \n        i += 1\n\
    \    }\n    \n    if i < s.count {\n        result.append(String(s[i:s.count]))\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppdbk7j25.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmppdbk7j25.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmppdbk7j25.swift:41:19: error: expected 'in' after\
    \ for-each pattern\n            for k < j {\n                  ^\n/tmp/tmppdbk7j25.swift:41:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < j {\n                  ^~\n                   \n/tmp/tmppdbk7j25.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmppdbk7j25.swift:59:31: error: extraneous argument label 'i:' in subscript\n\
    \        result.append(String(s[i:s.count]))\n                              ^~~\n\
    \                               \n/tmp/tmppdbk7j25.swift:41:19: error: '<' is\
    \ not a prefix unary operator\n            for k < j {\n                  ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let letters\
    \ = Array(s.characters)\n    \n    for letter in letters {\n        if letter\
    \ == \" \" {\n            continue\n        }\n        \n        if letter ==\
    \ \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter ==\
    \ \"u\" {\n            continue\n        }\n        \n        if letter == \"\
    y\" {\n            if letters.count > 1 {\n                continue\n        \
    \    }\n        }\n        \n        if letter == \"h\" || letter == \"n\" ||\
    \ letter == \"r\" || letter == \"t\" {\n            if letters.count > 1 {\n \
    \               continue\n            }\n        }\n        \n        if letter\
    \ == \"d\" || letter == \"l\" || letter == \"m\" || letter == \"s\" || letter\
    \ == \"w\" {\n            if letters.count > 1 {\n                continue\n \
    \           }\n        }\n        \n        if letter == \"p\" || letter == \"\
    b\" || letter == \"v\" || letter == \"j\" {\n            if letters.count > 1\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ letter == \"f\" || letter == \"g\" || letter == \"q\" || letter == \"x\" {\n\
    \            if letters.count > 1 {\n                continue\n            }\n\
    \        }\n        \n        if letter == \"k\" || letter == \"j\" || letter\
    \ == \"z\" {\n            if letters.count > 1 {\n                continue\n \
    \           }\n        }\n        \n        if letter == \"m\" || letter == \"\
    n\" || letter == \"l\" || letter == \"r\" {\n            if letters.count > 1\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ letter == \"c\" || letter == \"v\" || letter == \"b\" || letter == \"m\" {\n\
    \            if letters.count > 1 {\n                continue\n            }\n\
    \        }\n        \n        if letter == \"e\" || letter == \"g\" || letter\
    \ == \"q\" || letter == \"x\" {\n            if letters.count > 1 {\n        \
    \        continue\n            }\n        }\n        \n        if letter == \"\
    s\" || letter == \"w\" || letter == \"d\" || letter == \"h\" || letter == \"n\"\
    \ || letter == \"r\" || letter == \"t\" || letter == \"v\" || letter == \"b\"\
    \ || letter == \"m\" {\n            if letters.count > 1 {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"a\" || letter == \"\
    e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n            if\
    \ letters.count > 1 {\n                continue\n            }\n        }\n  \
    \      \n        if letter == \"y\" {\n            if letters.count > 1 {\n  \
    \              continue\n            }\n        }\n        \n        if letter\
    \ == \"h\" || letter == \"n\" || letter == \"r\" || letter == \"t\" {\n      \
    \      if letters.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0mp9o7wo.swift:109:23: error: expected member name following '.'\n\
    \            if letters.\n                      ^\n/tmp/tmp0mp9o7wo.swift:109:24:\
    \ error: expected '{' after 'if' condition\n            if letters.\n        \
    \               ^\n/tmp/tmp0mp9o7wo.swift:131:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmp0mp9o7wo.swift:27:27: note: to match this opening '{'\n\
    \    for letter in letters {\n                          ^\n/tmp/tmp0mp9o7wo.swift:131:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp0mp9o7wo.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp0mp9o7wo.swift:25:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let letters\
    \ = Array(s.characters)\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp0mp9o7wo.swift:113:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.characters.count >= n {\n \
    \           result.append(word)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq21wwwex.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            if j == 0 {\n                i += 1\n\
    \                continue\n            }\n            \n            if s[j-1]\
    \ == \"a\" {\n                j += 1\n                continue\n            }\n\
    \            \n            if k == 0 {\n                i += 1\n             \
    \   continue\n            }\n            \n            if s[k-1] == \"a\" {\n\
    \                k += 1\n                continue\n            }\n           \
    \ \n            if j == n {\n                i += 1\n                j += 1\n\
    \                k += 1\n                continue\n            }\n           \
    \ \n            if k == n {\n                i += 1\n                j += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                i += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                i += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                i += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                i += 1\n\
    \                j += 1\n                continue\n            }\n           \
    \ \n            if j == n {\n                i += 1\n                k += 1\n\
    \                continue\n            }\n            \n            if k == n\
    \ {\n                i += 1\n                j += 1\n                k += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                i += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                i += 1\n\
    \                j += 1\n                continue\n            }\n           \
    \ \n            if j == n {\n                i += 1\n                k += 1\n\
    \                continue\n            }\n            \n            if k == n\
    \ {\n                i += 1\n                j += 1\n                continue\n\
    \            }\n            \n            if j == n {\n                i += 1\n\
    \                k += 1\n                continue\n            }\n           \
    \ \n            if k == n {\n                i += 1\n                j += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                i += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                i += 1\n\
    \                j += 1\n                k += 1\n                continue\n  \
    \          }\n            \n            if j == n {\n                i += 1\n\
    \                k += 1\n                continue\n            }\n           \
    \ \n            if k == n {\n                i += 1\n                j += 1\n\
    \                continue\n            }\n            \n            if j == n\
    \ {\n                i += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if k == n {\n                i += 1\n\
    \                j += 1\n                continue\n            }\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpikdq2k7k.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpikdq2k7k.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpikdq2k7k.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpikdq2k7k.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpikdq2k7k.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpikdq2k7k.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpikdq2k7k.swift:41:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[j-1] == \"a\" {\n            \
    \   ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpikdq2k7k.swift:51:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if s[k-1] == \"a\" {\n               ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpikdq2k7k.swift:181"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            continue\n        }\n        \n    \
    \    if c.isConsonant() {\n            if n == 0 {\n                break\n  \
    \          }\n            n--\n        }\n        \n        if n == 0 {\n    \
    \        result.append(String(c.unicodeScalars))\n        }\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcnli0l7q.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcnli0l7q.swift:30:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmpcnli0l7q.swift:34:14: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            n--\n            \
    \ ^~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for char in s {\n        if char == \"\
    \ \" {\n            if i == 0 {\n                i = j\n                j = k\n\
    \            }\n            \n            if j == n {\n                result.insert(i,\
    \ s[k:s.endIndex])\n                i = j\n                j = k\n           \
    \     k = s.endIndex\n            }\n            \n            i = j\n       \
    \     j = k\n            k = s.endIndex\n        }\n        \n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            if i == 0 {\n                i = j\n                j = k\n \
    \           }\n            \n            if j == n {\n                result.insert(i,\
    \ s[k:s.endIndex])\n                i = j\n                j = k\n           \
    \     k = s.endIndex\n            }\n            \n            i = j\n       \
    \     j = k\n            k = s.endIndex\n        }\n        \n        if char\
    \ == \"y\" || char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\"\
    \ || char == \"u\" {\n            if i == 0 {\n                i = j\n       \
    \         j = k\n            }\n            \n            if j == n {\n      \
    \          result.insert(i, s[k:s.endIndex])\n                i = j\n        \
    \        j = k\n                k = s.endIndex\n            }\n            \n\
    \            i = j\n            j = k\n            k = s.endIndex\n        }\n\
    \        \n        if char == \"o\" || char == \"u\" || char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"y\" {\n            if i == 0 {\n    \
    \            i = j\n                j = k\n            }\n            \n     \
    \       if j == n {\n                result.insert(i, s[k:s.endIndex])\n     \
    \           i = j\n                j = k\n                k = s.endIndex\n   \
    \         }\n            \n            i = j\n            j = k\n            k\
    \ = s.endIndex\n        }\n        \n        if char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" || char == \"a\" || char == \"y\" {\n    \
    \        if i == 0 {\n                i = j\n                j = k\n         \
    \   }\n            \n            if j == n {\n                result.insert(i,\
    \ s[k:s.endIndex])\n                i = j\n                j = k\n           \
    \     k = s.endIndex\n            }\n            \n            i = j\n       \
    \     j = k\n            k = s.endIndex\n        }\n        \n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp36hkrd0p.swift:120:80: error: unterminated string literal\n   \
    \     if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"\n                                                                    \
    \           ^\n/tmp/tmp36hkrd0p.swift:142:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmp36hkrd0p.swift:18:50: note: to match this opening '{'\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n                                            \
    \     ^\n/tmp/tmp36hkrd0p.swift:37:30: error: missing argument labels 'contentsOf:at:'\
    \ in call\n                result.insert(i, s[k:s.endIndex])\n               \
    \              ^\n                              contentsOf:  at: \n/tmp/tmp36hkrd0p.swift:37:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Array<String>.Index'\
    \ (aka 'Int')\n                result.insert(i, s[k:s.endIndex])\n           \
    \                       ^\n/tmp/tmp36hkrd0p.swift:37:17: error: instance method\
    \ 'insert(contentsOf:at:)' requires that 'Int' conform to 'Collection'\n     \
    \           result.insert(i, s[k:s.endIndex])\n                ^\nSwift.RangeReplaceableCollection:7:37:\
    \ note: where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n/tmp/tmp36hkrd0p.swift:37:35:\
    \ error: extraneous argument label 'k:' in subscript\n                result.insert(i,\
    \ s[k:s.endIndex])\n                                  ^~~\n                  \
    \                 \n/tmp/tmp36hkrd0p.swift:40:23: error: cannot assign value of\
    \ type 'String.Index' to type 'Int'\n                k = s.endIndex\n        \
    \            ~~^~~~~~~~\n/tmp/tmp36hkrd0p.swift:45:19: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            k = s.endIndex\n         \
    \       ~~^~~~~~~~\n/tmp/tmp36hkrd0p.swift:55:30: error: missing argument "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for letter\
    \ in s.characters {\n        if letter.isConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(letter))\n            }\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa5nawv80.swift:25:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpa5nawv80.swift:26:19:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if letter.isConsonant()\
    \ {\n           ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qx0tjr_.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp3qx0"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qx0tjr_.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp3qx0"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j + 1\n        }\n        \n \
    \       if s[i] == \"a\" && s[i+1] == \"p\" {\n            i = i + 2\n       \
    \ }\n        \n        if s[i] == \"e\" && s[i+1] == \"a\" && s[i+2] == \"d\"\
    \ {\n            i = i + 3\n        }\n        \n        if s[i] == \"i\" && s[i+1]\
    \ == \"s\" {\n            i = i + 2\n        }\n        \n        if s[i] == \"\
    o\" && s[i+1] == \"u\" && s[i+2] == \"n\" {\n            i = i + 3\n        }\n\
    \        \n        if s[i] == \"u\" && s[i+1] == \"c\" && s[i+2] == \"l\" {\n\
    \            i = i + 3\n        }\n        \n        if s[i] == \"y\" && s[i+1]\
    \ == \"e\" && s[i+2] == \"l\" {\n            i = i + 3\n        }\n        \n\
    \        if s[i] == \"a\" && s[i+1] == \"p\" && s[i+2] == \"h\" {\n          \
    \  i = i + 3\n        }\n        \n        if s[i] == \"e\" && s[i+1] == \"a\"\
    \ && s[i+2] == \"d\" && s[i+3] == \"h\" {\n            i = i + 4\n        }\n\
    \        \n        if s[i] == \"i\" && s[i+1] == \"s\" && s[i+2] == \"h\" {\n\
    \            i = i + 3\n        }\n        \n        if s[i] == \"o\" && s[i+1]\
    \ == \"u\" && s[i+2] == \"n\" && s[i+3] == \"h\" {\n            i = i + 4\n  \
    \      }\n        \n        if s[i] == \"u\" && s[i+1] == \"c\" && s[i+2] == \"\
    l\" && s[i+3] == \"h\" {\n            i = i + 4\n        }\n        \n       \
    \ if s[i] == \"y\" && s[i+1] == \"e\" && s[i+2] == \"l\" && s[i+3] == \"h\" {\n\
    \            i = i + 4\n        }\n        \n        if s[i] == \"a\" && s[i+1]\
    \ == \"p\" && s[i+2] == \"h\" && s[i+3] == \"e\" {\n            i = i + 4\n  \
    \      }\n        \n        if s[i] == \"e\" && s[i+1] == \"a\" && s[i+2] == \"\
    d\" && s[i+3] == \"h\" && s[i+4] == \"e\" {\n            i = i + 5\n        }\n\
    \        \n        if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5htdgvpo.swift:28:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp5htdgvpo.swift:28:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp5htdgvpo.swift:99:11: error: expected expression,\
    \ var, or let in 'if' condition\n        if \n          ^\n/tmp/tmp5htdgvpo.swift:121:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp5htdgvpo.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp5htdgvpo.swift:28:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmp5htdgvpo.swift:103:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i = j\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"n\" {\n            i = j\n        }\n  \
    \      \n        if char == \"t\" || char == \"s\" || char == \"h\" || char ==\
    \ \"r\" || char == \"d\" {\n            i = j\n        }\n        \n        if\
    \ char == \"l\" || char == \"m\" || char == \"a\" || char == \"p\" || char ==\
    \ \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char == \"c\" ||\
    \ char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" || char ==\
    \ \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char == \"l\" ||\
    \ char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" || char ==\
    \ \"h\" || char == \"r\" || char == \"d\" || char == \"m\" || char == \"a\" ||\
    \ char == \"p\" || char == \"e\" || char == \"l\" || char == \"b\" || char ==\
    \ \"s\" || char == \"c\" || char == \"k\" || char == \"h\" || char == \"r\" ||\
    \ char == \"d\" || char == \"m\" || char == \"a\" || char == \"p\" || char ==\
    \ \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char == \"c\" ||\
    \ char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" || char ==\
    \ \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char == \"l\" ||\
    \ char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" || char ==\
    \ \"h\" || char == \"r\" || char == \"d\" || char == \"m\" || char == \"a\" ||\
    \ char == \"p\" || char == \"e\" || char == \"l\" || char == \"b\" || char ==\
    \ \"s\" || char == \"c\" || char == \"k\" || char == \"h\" || char == \"r\" ||\
    \ char == \"d\" || char == \"m\" || char == \"a\" || char == \"p\" || char ==\
    \ \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char == \"c\" ||\
    \ char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" || char ==\
    \ \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char == \"l\" ||\
    \ char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" || char ==\
    \ \"h\" || char == \"r\" || char == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpegexwknr.swift:45:1460: error: unterminated string literal\n  \
    \      if char == \"l\" || char == \"m\" || char == \"a\" || char == \"p\" ||\
    \ char == \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char ==\
    \ \"c\" || char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" ||\
    \ char == \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char ==\
    \ \"l\" || char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" ||\
    \ char == \"h\" || char == \"r\" || char == \"d\" || char == \"m\" || char ==\
    \ \"a\" || char == \"p\" || char == \"e\" || char == \"l\" || char == \"b\" ||\
    \ char == \"s\" || char == \"c\" || char == \"k\" || char == \"h\" || char ==\
    \ \"r\" || char == \"d\" || char == \"m\" || char == \"a\" || char == \"p\" ||\
    \ char == \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char ==\
    \ \"c\" || char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" ||\
    \ char == \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char ==\
    \ \"l\" || char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" ||\
    \ char == \"h\" || char == \"r\" || char == \"d\" || char == \"m\" || char ==\
    \ \"a\" || char == \"p\" || char == \"e\" || char == \"l\" || char == \"b\" ||\
    \ char == \"s\" || char == \"c\" || char == \"k\" || char == \"h\" || char ==\
    \ \"r\" || char == \"d\" || char == \"m\" || char == \"a\" || char == \"p\" ||\
    \ char == \"e\" || char == \"l\" || char == \"b\" || char == \"s\" || char ==\
    \ \"c\" || char == \"k\" || char == \"h\" || char == \"r\" || char == \"d\" ||\
    \ char == \"m\" || char == \"a\" || char == \"p\" || char == \"e\" || char ==\
    \ \"l\" || char == \"b\" || char == \"s\" || char == \"c\" || char == \"k\" ||\
    \ char == \"h\" || char == \"r\" || char == \"\n                             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                   "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonants.count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpax7kw5fh.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpax7kw5fh.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants.count\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s.characters\
    \ {\n        if c.isConsonant() {\n            if n == 1 {\n                result.append(s)\n\
    \            } else {\n                result.appendContentsOf(select_words(s.substringToIndex(s.startIndex.advancedBy(c.unicodeScalars.count)),\
    \ n - 1))\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppg7kad7f.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppg7kad7f.swift:26:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmppg7kad7f.swift:30:24: error: value of type\
    \ '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(select_words(s.substringToIndex(s.startIndex.advancedBy(c.unicodeScalars.count)),\
    \ n - 1))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmppg7kad7f.swift:30:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(s.substringToIndex(s.startIndex.advancedBy(c.unicodeScalars.count)),\
    \ n - 1))\n                                                    ^\n           \
    \                                          s:                                \
    \                                   n: \n/tmp/tmppg7kad7f.swift:30:56: error:\
    \ value of type 'String' has no member 'substringToIndex'\n                result.appendContentsOf(select_words(s.substringToIndex(s.startIndex.advancedBy(c.unicodeScalars.count)),\
    \ n - 1))\n                                                     ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmppg7kad7f.swift:30:86: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n                result.appendContentsOf(select_words(s.substringToIndex(s.startIndex.advancedBy(c.unicodeScalars.count)),\
    \ n - 1))\n                                                                  \
    \      ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for c in s {\n        if c.isConsonant() {\n            if n == 1 {\n   \
    \             words.append(c)\n            } else {\n                words.append(c)\n\
    \                n -= 1\n            }\n        }\n    }\n    return words\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp61y0iam3.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmp61y0iam3.swift:23:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmp61y0iam3.swift:25:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmp61y0iam3.swift:26:19:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= 1\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   for char in s.characters {\n        if char.hasConsonants {\n            if\
    \ result.count < n {\n                result.append(String(char))\n          \
    \  }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8ml2k_0r.swift:26:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8ml2k_0r.swift:27:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    let vowelsCount = vowels.characters.count\n    \n\
    \    if vowelsCount > n {\n        return result\n    }\n    \n    let vowelsArray\
    \ = vowels.characters\n    \n    let vowelsArrayCount = vowelsArray.count\n  \
    \  \n    if vowelsArrayCount > n {\n        return result\n    }\n    \n    let\
    \ vowelsArrayIndex = vowelsArray.indices\n    \n    let vowelsArrayIndexCount\
    \ = vowelsArrayIndex.count\n    \n    if vowelsArrayIndexCount > n {\n       \
    \ return result\n    }\n    \n    let vowelsArrayIndexLast = vowelsArrayIndex.last!\n\
    \    \n    let vowelsArrayIndexLastCount = vowelsArrayIndexLast.count\n    \n\
    \    if vowelsArrayIndexLastCount > n {\n        return result\n    }\n    \n\
    \    let vowelsArrayIndexLastLast = vowelsArrayIndexLast.last!\n    \n    let\
    \ vowelsArrayIndexLastLastCount = vowelsArrayIndexLastLast.count\n    \n    if\
    \ vowelsArrayIndexLastLastCount > n {\n        return result\n    }\n    \n  \
    \  let vowelsArrayIndexLastLastLast = vowelsArrayIndexLastLast.last!\n    \n \
    \   let vowelsArrayIndexLastLastLastCount = vowelsArrayIndexLastLastLast.count\n\
    \    \n    if vowelsArrayIndexLastLastLastCount > n {\n        return result\n\
    \    }\n    \n    let vowelsArrayIndexLastLastLastLast = vowelsArrayIndexLastLastLast.last!\n\
    \    \n    let vowelsArrayIndexLastLastLastLastCount = vowelsArrayIndexLastLastLastLast.count\n\
    \    \n    if vowelsArrayIndexLastLastLastLastCount > n {\n        return result\n\
    \    }\n    \n    let vowelsArrayIndexLastLastLastLastLast = vowelsArrayIndexLastLastLastLast.last!\n\
    \    \n    let vowelsArrayIndexLastLastLastLastLastCount = vowelsArrayIndexLastLastLastLastLast.count\n\
    \    \n    if vowelsArrayIndexLastLastLastLastLastCount > n {\n        return\
    \ result\n    }\n    \n    let vowelsArrayIndexLastLastLastLastLastLast = vowelsArrayIndexLastLastLastLastLast.last!\n\
    \    \n    let vowelsArrayIndexLastLastLastLastLastLastCount = vowelsArrayIndexLastLastLastLastLastLast.count\n\
    \    \n    if vowelsArrayIndexLastLastLastLastLastLastCount > n {\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyr4fmoib.swift:115:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpyr4fmoib.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpyr4fmoib.swift:27:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelsCount\
    \ = vowels.characters.count\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpyr4fmoib.swift:33:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    let vowelsArray = vowels.characters\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyr4fmoib.swift:51:58: error: value of type 'DefaultIndices<String>.Element'\
    \ (aka 'String.Index') has no member 'count'\n    let vowelsArrayIndexLastCount\
    \ = vowelsArrayIndexLast.count\n                                    ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmpyr4fmoib.swift:57:57: error: value of type 'DefaultIndices<String>.Element'\
    \ (aka 'String.Index') has no member 'last'\n    let vowelsArrayIndexLastLast\
    \ = vowelsArrayIndexLast.last!\n                                   ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~\n/tmp/tmpyr4fmoib.swift:97:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxu45066g.swift:197:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpxu45066g.swift:25:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpxu45066g.swift:197:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpxu45066g.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpxu45066g.swift:179:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpxu45066g.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if k == s.count {\n                result.append(s[i\
    \ : j])\n                i = j + 1\n            }\n        } else {\n        \
    \    k = k + 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaqxl2zga.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpaqxl2zga.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpaqxl2zga.swift:33:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpaqxl2zga.swift:33:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpaqxl2zga.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpaqxl2zga.swift:33:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.hasConsonants() {\n         \
    \   if result.count < n {\n                result.append(String(char))\n     \
    \       }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvdkr1l8b.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvdkr1l8b.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants()\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s.substring(i, i+n).contains(\"\
    a\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"e\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n        if s.substring(i, i+n).contains(\"i\") {\n            result.append(s.substring(i,\
    \ j))\n            i = j + 1\n        }\n        \n        if s.substring(i, i+n).contains(\"\
    o\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"u\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n        if s.substring(i, i+n).contains(\"y\") {\n            result.append(s.substring(i,\
    \ j))\n            i = j + 1\n        }\n        \n        if s.substring(i, i+n).contains(\"\
    s\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"h\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n        if s.substring(i, i+n).contains(\"l\") {\n            result.append(s.substring(i,\
    \ j))\n            i = j + 1\n        }\n        \n        if s.substring(i, i+n).contains(\"\
    d\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"p\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n        if s.substring(i, i+n).contains(\"f\") {\n            result.append(s.substring(i,\
    \ j))\n            i = j + 1\n        }\n        \n        if s.substring(i, i+n).contains(\"\
    v\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"m\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n        if s.substring(i, i+n).contains(\"t\") {\n            result.append(s.substring(i,\
    \ j))\n            i = j + 1\n        }\n        \n        if s.substring(i, i+n).contains(\"\
    k\") {\n            result.append(s.substring(i, j))\n            i = j + 1\n\
    \        }\n        \n        if s.substring(i, i+n).contains(\"g\") {\n     \
    \       result.append(s.substring(i, j))\n            i = j + 1\n        }\n \
    \       \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzuexjaq8.swift:136:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpzuexjaq8.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpzuexjaq8.swift:29:14:\
    \ error: value of type 'String' has no member 'substring'\n        if s.substring(i,\
    \ i+n).contains(\"a\") {\n           ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:30:29:\
    \ error: value of type 'String' has no member 'substring'\n            result.append(s.substring(i,\
    \ j))\n                          ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:34:14: error:\
    \ value of type 'String' has no member 'substring'\n        if s.substring(i,\
    \ i+n).contains(\"e\") {\n           ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:35:29:\
    \ error: value of type 'String' has no member 'substring'\n            result.append(s.substring(i,\
    \ j))\n                          ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:39:14: error:\
    \ value of type 'String' has no member 'substring'\n        if s.substring(i,\
    \ i+n).contains(\"i\") {\n           ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:40:29:\
    \ error: value of type 'String' has no member 'substring'\n            result.append(s.substring(i,\
    \ j))\n                          ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:44:14: error:\
    \ value of type 'String' has no member 'substring'\n        if s.substring(i,\
    \ i+n).contains(\"o\") {\n           ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:45:29:\
    \ error: value of type 'String' has no member 'substring'\n            result.append(s.substring(i,\
    \ j))\n                          ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:49:14: error:\
    \ value of type 'String' has no member 'substring'\n        if s.substring(i,\
    \ i+n).contains(\"u\") {\n           ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:50:29:\
    \ error: value of type 'String' has no member 'substring'\n            result.append(s.substring(i,\
    \ j))\n                          ~ ^~~~~~~~~\n/tmp/tmpzuexjaq8.swift:54:14: error:\
    \ value "
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt7x112v3.swift:174:23: error: expected '{' after 'if' condition\n\
    \        if char == \" \" \n                      ^\n/tmp/tmpt7x112v3.swift:196:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpt7x112v3.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpt7x112v3.swift:25:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt7x112v3.swift:178:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpt7x112v3.swift:19:9: warning: variable\
    \ 'result' was never mutated; consider changing to 'let' constant\n    var result\
    \ = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var lastChar\
    \ = \" \"\n    var lastCharCount = 0\n    var lastWord = \"\"\n    var lastWordCount\
    \ = 0\n    var lastWordIndex = 0\n    var lastWordChar = \"\"\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharIndex = 0\n    var lastWordCharCountIndex = 0\n   \
    \ var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n\
    \    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var\
    \ lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex = 0\n    var lastWordCharIndexIndex\
    \ = 0\n    var last\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7scwc14x.swift:34:9: error: invalid redeclaration of 'lastWordCharIndexIndex'\n\
    \    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9: note:\
    \ 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:35:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:36:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:37:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:38:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:39:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:40:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    var lastWordCharIndexIndex\
    \ = 0\n        ^\n/tmp/tmp7scwc14x.swift:41:9: error: invalid redeclaration of\
    \ 'lastWordCharIndexIndex'\n    var lastWordCharIndexIndex = 0\n        ^\n/tmp/tmp7scwc14x.swift:33:9:\
    \ note: 'lastWordCharIndexIndex' previously declared here\n    v"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    \n    for i < s.count {\n  \
    \      if s[i] == \" \" {\n            j = i\n            \n            for k\
    \ < j {\n                if s[k] == \" \" {\n                    l = k\n     \
    \               break\n                }\n                \n                k\
    \ += 1\n            }\n            \n            if l == j {\n               \
    \ result.append(\"\\n\")\n            }\n            \n            for k < j {\n\
    \                if s[k] == \" \" {\n                    l = k\n             \
    \       break\n                }\n                \n                k += 1\n \
    \           }\n            \n            if l == j {\n                result.append(\"\
    \\n\")\n            }\n            \n            for k < j {\n               \
    \ if s[k] == \" \" {\n                    l = k\n                    break\n \
    \               }\n                \n                k += 1\n            }\n \
    \           \n            if l == j {\n                result.append(\"\\n\")\n\
    \            }\n            \n            for k < j {\n                if s[k]\
    \ == \" \" {\n                    l = k\n                    break\n         \
    \       }\n                \n                k += 1\n            }\n         \
    \   \n            if l == j {\n                result.append(\"\\n\")\n      \
    \      }\n            \n            for k < j {\n                if s[k] == \"\
    \ \" {\n                    l = k\n                    break\n               \
    \ }\n                \n                k += 1\n            }\n            \n \
    \           if l == j {\n                result.append(\"\\n\")\n            }\n\
    \            \n            for k < j {\n                if s[k] == \" \" {\n \
    \                   l = k\n                    break\n                }\n    \
    \            \n                k += 1\n            }\n            \n         \
    \   if l == j {\n                result.append(\"\\n\")\n            }\n     \
    \       \n            for k < j {\n                if s[k] == \" \" {\n      \
    \              l = k\n                    break\n                }\n         \
    \       \n                k += 1\n            }\n            \n            if\
    \ l == j {\n                result.append(\"\\n\")\n            }\n          \
    \  \n            for k < j {\n                if s[k] == \" \" {\n           \
    \         l = k\n                    break\n                }\n              \
    \  \n                k += 1\n            }\n            \n            if l ==\
    \ j {\n                result.append(\"\\n\")\n            }\n            \n \
    \           for k < j {\n                if s[k] == \" \" {\n                \
    \    l = k\n                    break\n                }\n                \n \
    \               k += 1\n            }\n            \n            if l == j {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     for k < j {\n                if s[k] == \" \" {\n                    l =\
    \ k\n                    break\n                }\n                \n        \
    \        k += 1\n            }\n            \n            if l == j {\n      \
    \          result.append(\"\\n\")\n            }\n            \n            for\
    \ k < j {\n                if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp22lnejn4.swift:30:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp22lnejn4.swift:30:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp22lnejn4.swift:34:19: error: expected 'in' after\
    \ for-each pattern\n            for k < j {\n                  ^\n/tmp/tmp22lnejn4.swift:34:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < j {\n                  ^~\n                   \n/tmp/tmp22lnejn4.swift:47:19:\
    \ error: expected 'in' after for-each pattern\n            for k < j {\n     \
    \             ^\n/tmp/tmp22lnejn4.swift:47:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < j {\n                  ^~\n\
    \                   \n/tmp/tmp22lnejn4.swift:60:19: error: expected 'in' after\
    \ for-each pattern\n            for k < j {\n                  ^\n/tmp/tmp22lnejn4.swift:60:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < j {\n                  ^~\n                   \n/tmp/tmp22lnejn4.swift:73:19:\
    \ error: expected 'in' after for-each pattern\n            for k < j {\n     \
    \             ^\n/tmp/tmp22lnejn4.swift:73:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < j {\n                  ^~\n\
    \                   \n/tmp/tmp22lnejn4.swift:86:19: error: expected 'in' after\
    \ for-each pattern\n            for k < j {\n                  ^\n/tmp/tmp22lnejn4.swift:86:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < j {\n                  ^~\n                   \n/tmp/tmp22lnejn4.swift:99:19:\
    \ error: expected 'in' after for-each pattern\n            for k < j {\n     \
    \             ^\n/tmp/tmp22lnejn4.swift:99:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < j {\n                  ^~\n\
    \                   \n/tmp/tmp22lnejn4.swift:112:19: error: expected 'in' after\
    \ for-each pattern\n            for k < j {\n                  ^\n/tmp/tmp22lnejn4.swift:112:19:\
    \ error: unary operator "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"d\" || s[i] == \"\
    f\" || s[i] == \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i]\
    \ == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\"\
    \ || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i]\
    \ == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"A\" ||\
    \ s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s[i] == \"\
    B\" || s[i] == \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i]\
    \ == \"H\" || s[i] == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\"\
    \ || s[i] == \"N\" || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i]\
    \ == \"S\" || s[i] == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\"\
    \ || s[i] == \"Y\" || s[i] == \"Z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"0\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"1\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"2\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"3\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"4\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"5\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"6\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"7\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"8\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"9\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \".\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \",\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"!\" {\n            i += 1\n       \
    \     continue\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp467hhffn.swift:140:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp467hhffn.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmp467hhffn.swift:140:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp467hhffn.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp467hhffn.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp467hhffn.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp467hhffn.swift:35:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp467hhffn.swift:35:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                   "
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        if char == \"a\" || char == \"e\" || char ==\
    \ \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n \
    \       if j == n {\n            result.append(String(s[i:j]))\n            i\
    \ = j\n            j = 0\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj2ktta9y.swift:36:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s.characters {\n        if char == \" \"\
    \ {\n            i = j\n        }\n        \n        if char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i\
    \ = j\n        }\n        \n        if char == \"y\" {\n            i = j\n  \
    \      }\n        \n        if char == \"n\" {\n            i = j\n        }\n\
    \        \n        if char == \"d\" || char == \"h\" || char == \"r\" || char\
    \ == \"l\" || char == \"m\" || char == \"s\" || char == \"t\" || char == \"w\"\
    \ || char == \"v\" || char == \"z\" {\n            i = j\n        }\n        \n\
    \        if char == \"b\" || char == \"c\" || char == \"f\" || char == \"k\" ||\
    \ char == \"p\" || char == \"v\" || char == \"x\" {\n            i = j\n     \
    \   }\n        \n        if char == \"j\" || char == \"q\" || char == \"x\" {\n\
    \            i = j\n        }\n        \n        if char == \"k\" || char == \"\
    p\" || char == \"v\" || char == \"x\" {\n            i = j\n        }\n      \
    \  \n        if char == \"q\" || char == \"j\" || char == \"x\" {\n          \
    \  i = j\n        }\n        \n        if char == \"p\" || char == \"k\" || char\
    \ == \"v\" || char == \"x\" {\n            i = j\n        }\n        \n      \
    \  if char == \"v\" || char == \"p\" || char == \"k\" || char == \"x\" {\n   \
    \         i = j\n        }\n        \n        if char == \"v\" || char == \"p\"\
    \ || char == \"k\" || char == \"x\" {\n            i = j\n        }\n        \n\
    \        if char == \"k\" || char == \"p\" || char == \"v\" || char == \"x\" {\n\
    \            i = j\n        }\n        \n        if char == \"p\" || char == \"\
    k\" || char == \"v\" || char == \"x\" {\n            i = j\n        }\n      \
    \  \n        if char == \"v\" || char == \"p\" || char == \"k\" || char == \"\
    x\" {\n            i = j\n        }\n        \n        if char == \"v\" || char\
    \ == \"p\" || char == \"k\" || char == \"x\" {\n            i = j\n        }\n\
    \        \n        if char == \"k\" || char == \"p\" || char == \"v\" || char\
    \ == \"x\" {\n            i = j\n        }\n        \n        if char == \"p\"\
    \ || char == \"k\" || char == \"v\" || char == \"x\" {\n            i = j\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjtmbfy4f.swift:120:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjtmbfy4f.swift:28:30:\
    \ note: to match this opening '{'\n    for char in s.characters {\n          \
    \                   ^\n/tmp/tmpjtmbfy4f.swift:120:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpjtmbfy4f.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpjtmbfy4f.swift:28:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtmbfy4f.swift:102:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmpjtmbfy4f.swift:19:9: warning: variable 'result' was\
    \ never mutated; consider changing to 'let' constant\n    var result = [String]()\n\
    \    ~~~ ^\n    let\n/tmp/tmpjtmbfy4f.swift:25:9: warning: variable 'i' was written\
    \ to, but never read\n    var i = 0\n        ^\n/tmp/tmpjtmbfy4f.swift:26:9: warning:\
    \ variable 'j' was never mutated; consider changing to 'let' constant\n    var\
    \ j = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            if j > i {\n                result.append(\"\\n\")\n       \
    \     }\n            \n            i += j - i\n        } else {\n            k\
    \ += 1\n            \n            if k == n {\n                result.append(\"\
    \\n\")\n                k = 0\n            }\n            \n            if k >\
    \ i {\n                result.append(\"\\n\")\n            }\n            \n \
    \           i += 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqyx_f_rs.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqyx_f_rs.swift:32:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8w845vtg.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8w845vtg.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var index = 0\n    var count = 0\n    var last = 0\n    var lastCount = 0\n\
    \    var lastLast = 0\n    var lastLastCount = 0\n    var lastLastLast = 0\n \
    \   var lastLastLastCount = 0\n    var lastLastLastLast = 0\n    var lastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLast = 0\n    var lastLastLastLastLastCount = 0\n\
    \    var lastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastCount =\
    \ 0\n    var lastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var\
    \ lastLastLast\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr46yiltl.swift:37:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:35:9:\
    \ note: 'lastLastLastLastLastLastLastCount' previously declared here\n    var\
    \ lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:38:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n    var\
    \ lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpr46yiltl.swift:36:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmpr46yiltl.swift:40:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLast'\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmpr46yiltl.swift:36:9: note: 'lastLastLastLastLastLastLastLast'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLast = 0\n   \
    \     ^\n/tmp/tmpr46yiltl.swift:41:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:39:9:\
    \ note: 'lastLastLastLastLastLastLastLastCount' previously declared here\n   \
    \ var lastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:44:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n   \
    \ var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpr46yiltl.swift:42:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpr46yiltl.swift:45:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:43:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpr46yiltl.swift:47:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n       "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                result.append(\"\\n\")\n            }\n\
    \            else {\n                result.append(String(s[i:j]))\n         \
    \   }\n            \n            i = j + 1\n        }\n        \n        if s[i]\
    \ == \"a\" && s[i+1] == \"p\" && s[i+2] == \"p\" && s[i+3] == \"s\" {\n      \
    \      k = i\n            \n            while k < s.count && s[k] == \"a\" &&\
    \ s[k+1] == \"p\" && s[k+2] == \"p\" && s[k+3] == \"s\" {\n                k +=\
    \ 4\n            }\n            \n            if k == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            else {\n             \
    \   result.append(String(s[i:k]))\n            }\n            \n            i\
    \ += 4\n        }\n        \n        if s[i] == \"a\" && s[i+1] == \"p\" && s[i+2]\
    \ == \"p\" && s[i+3] == \"s\" && s[i+4] == \" \" {\n            k = i\n      \
    \      \n            while k < s.count && s[k] == \"a\" && s[k+1] == \"p\" &&\
    \ s[k+2] == \"p\" && s[k+3] == \"s\" && s[k+4] == \" \" {\n                k +=\
    \ 5\n            }\n            \n            if k == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            else {\n             \
    \   result.append(String(s[i:k]))\n            }\n            \n            i\
    \ += 5\n        }\n        \n        if s[i] == \"a\" && s[i+1] == \"p\" && s[i+2]\
    \ == \"p\" && s[i+3] == \"s\" && s[i+4] == \"s\" {\n            k = i\n      \
    \      \n            while k < s.count && s[k] == \"a\" && s[k+1] == \"p\" &&\
    \ s[k+2] == \"p\" && s[k+3] == \"s\" && s[k+4] == \"s\" {\n                k +=\
    \ 6\n            }\n            \n            if k == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            else {\n             \
    \   result.append(String(s[i:k]))\n            }\n            \n            i\
    \ += 6\n        }\n        \n        if s[i] == \"a\" && s[i+1] == \"p\" && s[i+2]\
    \ == \"p\" && s[i+3] == \"s\" && s[i+4] == \"s\" && s[i+5] == \" \" {\n      \
    \      k = i\n            \n            while k < s.count && s[k] == \"a\" &&\
    \ s[k+1] == \"p\" && s[k+2] == \"p\" && s[k+3] == \"s\" && s[k+4]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnnsxmza3.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpnnsxmza3.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpnnsxmza3.swift:101:106: error: expected '{' after\
    \ 'while' condition\n            while k < s.count && s[k] == \"a\" && s[k+1]\
    \ == \"p\" && s[k+2] == \"p\" && s[k+3] == \"s\" && s[k+4]\n                 \
    \                                                                            \
    \            ^\n/tmp/tmpnnsxmza3.swift:123:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpnnsxmza3.swift:29:21: note: to match this opening '{'\n    for\
    \ i < s.count {\n                    ^\n/tmp/tmpnnsxmza3.swift:123:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpnnsxmza3.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpnnsxmza3.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.count >= n {\n\
    \            result.append(String(char))\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_baiv4ct.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var last\
    \ = 0\n    var lastCount = 0\n    var lastLast = 0\n    var lastLastCount = 0\n\
    \    var lastLastLast = 0\n    var lastLastLastCount = 0\n    var lastLastLastLast\
    \ = 0\n    var lastLastLastLastCount = 0\n    var lastLastLastLastLast = 0\n \
    \   var lastLastLastLastLastCount = 0\n    var lastLastLastLastLastLast = 0\n\
    \    var lastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLast\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd4ib266.swift:38:9: error: invalid redeclaration of 'lastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:36:9:\
    \ note: 'lastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:39:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:37:9: note: 'lastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastCount = 0\n  \
    \      ^\n/tmp/tmprd4ib266.swift:42:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:43:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmprd4ib266.swift:41:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmprd4ib266.swift:46:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:44:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmprd4ib266.swift:47:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:45:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib266.swift:49:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmprd4ib"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if j == n {\n                result.append(\"\\n\")\n                j\
    \ = 0\n            } else {\n                j += 1\n            }\n        }\
    \ else {\n            if j == n {\n                result.append(\"\\n\")\n  \
    \              j = 0\n            }\n            \n            if char == \"a\"\
    \ || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n    \
    \            result.append(\"a\")\n            } else if char == \"b\" || char\
    \ == \"c\" || char == \"d\" || char == \"f\" || char == \"g\" || char == \"h\"\
    \ || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char\
    \ == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char == \"s\"\
    \ || char == \"t\" || char == \"v\" || char == \"w\" || char == \"x\" || char\
    \ == \"y\" || char == \"z\" {\n                result.append(\"b\")\n        \
    \    } else if char == \"A\" || char == \"E\" || char == \"I\" || char == \"O\"\
    \ || char == \"U\" {\n                result.append(\"A\")\n            } else\
    \ if char == \"B\" || char == \"C\" || char == \"D\" || char == \"F\" || char\
    \ == \"G\" || char == \"H\" || char == \"J\" || char == \"K\" || char == \"L\"\
    \ || char == \"M\" || char == \"N\" || char == \"P\" || char == \"Q\" || char\
    \ == \"R\" || char == \"S\" || char == \"T\" || char == \"V\" || char == \"W\"\
    \ || char == \"X\" || char == \"Y\" || char == \"Z\" {\n                result.append(\"\
    B\")\n            } else if char == \"0\" {\n                result.append(\"\
    0\")\n            } else if char == \"1\" {\n                result.append(\"\
    1\")\n            } else if char == \"2\" {\n                result.append(\"\
    2\")\n            } else if char == \"3\" {\n                result.append(\"\
    3\")\n            } else if char == \"4\" {\n                result.append(\"\
    4\")\n            } else if char == \"5\" {\n                result.append(\"\
    5\")\n            } else if char == \"6\" {\n                result.append(\"\
    6\")\n            } else if char == \"7\" {\n                result.append(\"\
    7\")\n            } else if char == \"8\" {\n                result.append(\"\
    8\")\n            } else if char == \"9\" {\n                result.append(\"\
    9\")\n            } else {\n                result.append(String(char))\n    \
    \        }\n            \n            j += 1\n        }\n        \n        i +=\
    \ 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpqgu735dj/tmpqgu735dj.swift:96: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b701aedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b701abd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b701abd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b701abd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqgu735dj                        0x00005587f82d07c4 <unavailable> + 6084

    5    libc.so.6                          0x00002b701b0cb460 __libc_start_main +
    245

    6    tmpqgu735dj                        0x00005587f82d03c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qw_0wx.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp69qw_0wx.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8w845vtg.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8w845vtg.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if j == n {\n                result.append(\"\\n\")\n                j\
    \ = 0\n            }\n        } else {\n            if char == \"a\" || char ==\
    \ \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n               \
    \ result.append(\"a\")\n                j++\n            } else if char == \"\
    b\" || char == \"c\" || char == \"d\" || char == \"f\" || char == \"g\" || char\
    \ == \"h\" || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\"\
    \ || char == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char\
    \ == \"s\" || char == \"t\" || char == \"v\" || char == \"w\" || char == \"x\"\
    \ || char == \"y\" || char == \"z\" {\n                result.append(\"b\")\n\
    \                j++\n            } else if char == \"0\" {\n                result.append(\"\
    0\")\n                j++\n            } else if char == \"1\" {\n           \
    \     result.append(\"1\")\n                j++\n            } else if char ==\
    \ \"2\" {\n                result.append(\"2\")\n                j++\n       \
    \     } else if char == \"3\" {\n                result.append(\"3\")\n      \
    \          j++\n            } else if char == \"4\" {\n                result.append(\"\
    4\")\n                j++\n            } else if char == \"5\" {\n           \
    \     result.append(\"5\")\n                j++\n            } else if char ==\
    \ \"6\" {\n                result.append(\"6\")\n                j++\n       \
    \     } else if char == \"7\" {\n                result.append(\"7\")\n      \
    \          j++\n            } else if char == \"8\" {\n                result.append(\"\
    8\")\n                j++\n            } else if char == \"9\" {\n           \
    \     result.append(\"9\")\n                j++\n            } else {\n      \
    \          result.append(String(char))\n                j++\n            }\n \
    \       }\n        i++\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnwetz1yu.swift:37:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:40:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:43:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                j++\n        \
    \         ^~\n/tmp/tmpnwetz1yu.swift:46:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:49:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:52:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                j++\n        \
    \         ^~\n/tmp/tmpnwetz1yu.swift:55:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:58:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:61:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                j++\n        \
    \         ^~\n/tmp/tmpnwetz1yu.swift:64:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:67:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:70:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                j++\n        \
    \         ^~\n/tmp/tmpnwetz1yu.swift:73:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpnwetz1yu.swift:76:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        i++\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            \n            if i == s.count {\n             \
    \   i += 1\n                \n                if i == s.count {\n            \
    \        i += 1\n                }\n            }\n        } else {\n        \
    \    if j == n {\n                result.append(String(s[i..<s.count]))\n    \
    \            \n                i += 1\n                \n                if i\
    \ == s.count {\n                    i += 1\n                }\n              \
    \  \n                j += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsys47y34.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpsys47y34.swift:41:38: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n                result.append(String(s[i..<s.count]))\n    \
    \                                 ^~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.hasPrefix(\"a\") {\n      \
    \      if word.hasPrefix(\"b\") {\n                if word.hasPrefix(\"c\") {\n\
    \                    if word.hasPrefix(\"d\") {\n                        if word.hasPrefix(\"\
    e\") {\n                            if word.hasPrefix(\"f\") {\n             \
    \                   if word.hasPrefix(\"g\") {\n                             \
    \       if word.hasPrefix(\"h\") {\n                                        if\
    \ word.hasPrefix(\"i\") {\n                                            if word.hasPrefix(\"\
    j\") {\n                                                if word.hasPrefix(\"k\"\
    ) {\n                                                    if word.hasPrefix(\"\
    l\") {\n                                                        if word.hasPrefix(\"\
    m\") {\n                                                            if word.hasPrefix(\"\
    n\") {\n                                                                if word.hasPrefix(\"\
    o\") {\n                                                                    if\
    \ word.hasPrefix(\"p\") {\n                                                  \
    \                      if word.hasPrefix(\"q\") {\n                          \
    \                                                  if word.hasPrefix(\"r\") {\n\
    \                                                                            \
    \    if word.hasPrefix(\"s\") {\n                                            \
    \                                        if word.hasPrefix(\"t\") {\n        \
    \                                                                            \
    \    if word.hasPrefix(\"u\") {\n                                            \
    \                                                if word.hasPrefix(\"v\") {\n\
    \                                                                            \
    \                    if word.hasPrefix(\"w\") {\n                            \
    \                                                                        if word.hasPrefix(\"\
    x\") {\n                                                                     \
    \                                   if word.hasPrefix(\"y\") {\n             \
    \                                                                            \
    \                   if word.hasPrefix(\"z\") {\n                             \
    \                                                                            \
    \       if word.hasPrefix(\"A\") {\n                                         \
    \                                                                           if\
    \ word.hasPrefix(\"B\") {\n                                                  \
    \                                                                      if word.hasPrefix(\"\
    C\") {\n                                                                     \
    \                                                       if word.hasPrefix(\"D\"\
    ) {\n                                                                        \
    \                                                                        if word.hasPrefix(\"\
    E\") {\n                                                                     \
    \                                                               if word.hasPrefix(\"\
    F\") {\n                                                                     \
    \                                                                   if word.hasPrefix(\"\
    G\") {\n                                                                     \
    \                                                                            \
    \                           if word.hasPrefix(\"H\") {\n                     \
    \                                                                            \
    \                                                                            \
    \   if word.hasPrefix(\"I\") {\n                                             \
    \                                                                            \
    \                                                           if word.hasPrefix(\"\
    J\") {\n                                                                     \
    \                                                                            \
    \                                       if word.hasPrefix(\"K\") {\n         \
    \                                                                            \
    \                                                                            \
    \                           if word.hasPrefix(\"L\") {\n                     \
    \                                                                            \
    \                                                                            \
    \                                   if word.hasPrefix(\"M\") {\n             \
    \                                                                            \
    \                                                                            \
    \                               if word.hasPrefix(\"N\") {\n                 \
    \                                                                            \
    \                                                                            \
    \                               if word.hasPrefix(\"O\") {\n                 \
    \                                                                            \
    \                                                                            \
    \                                                                   if word.hasPrefix(\"\
    P\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                   if word.hasPrefix(\"Q\") {\n                             \
    \                                                                            \
    \                                                                            \
    \                                                               if word.hasPrefix(\"\
    R\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                           if word.hasPrefix(\"S\") {\n                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   if word.hasPrefix(\"T\") {\n                                             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \               if word.hasPrefix(\"U\") {\n                                 \
    \                                                                            \
    \                                                                            \
    \                                                                           if\
    \ word.hasPrefix(\"V\") {\n                                                  \
    \                                                                            \
    \                                                                            \
    \                                                              if word.hasPrefix(\"\
    W\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_hg52hbh.swift:70:303: error: expected expression, var, or let\
    \ in 'if' condition\n                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                if \n                                                       \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                   ^\n/tmp/tmp_hg52hbh.swift:92:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp_hg52hbh.swift:68:284: note: to match this opening\
    \ '{'\n                                                                      \
    \                                                                            \
    \                                                                            \
    \                                      if word.hasPrefix(\"V\") {\n          \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                             ^\n/tmp/tmp_hg52hbh.swift:92:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp_hg52hbh.swift:67:312:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                                                            \
    \                               "
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i = j\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"b\" || char == \"c\" || char == \"d\" ||\
    \ char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\" || char ==\
    \ \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char == \"p\" ||\
    \ char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\" || char ==\
    \ \"v\" || char == \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n\
    \            i = j\n        }\n        \n        if char == \"A\" || char == \"\
    E\" || char == \"I\" || char == \"O\" || char == \"U\" {\n            i = j\n\
    \        }\n        \n        if char == \"B\" || char == \"C\" || char == \"\
    D\" || char == \"F\" || char == \"G\" || char == \"H\" || char == \"J\" || char\
    \ == \"K\" || char == \"L\" || char == \"M\" || char == \"N\" || char == \"P\"\
    \ || char == \"Q\" || char == \"R\" || char == \"S\" || char == \"T\" || char\
    \ == \"V\" || char == \"W\" || char == \"X\" || char == \"Y\" || char == \"Z\"\
    \ {\n            i = j\n        }\n        \n        if char == \"0\" {\n    \
    \        i = j\n        }\n        \n        if char == \"1\" {\n            i\
    \ = j\n        }\n        \n        if char == \"2\" {\n            i = j\n  \
    \      }\n        \n        if char == \"3\" {\n            i = j\n        }\n\
    \        \n        if char == \"4\" {\n            i = j\n        }\n        \n\
    \        if char == \"5\" {\n            i = j\n        }\n        \n        if\
    \ char == \"6\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"7\" {\n            i = j\n        }\n        \n        if char == \"8\" {\n\
    \            i = j\n        }\n        \n        if char == \"9\" {\n        \
    \    i = j\n        }\n        \n        if char == \"-\" {\n            i = j\n\
    \        }\n        \n        if char == \"_\" {\n            i = j\n        }\n\
    \        \n        if char == \"+\" {\n            i = j\n        }\n        \n\
    \        if char == \"*\" {\n            i = j\n        }\n        \n        if\
    \ char == \"/\" {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsdslygov.swift:127:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpsdslygov.swift:28:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpsdslygov.swift:127:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpsdslygov.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpsdslygov.swift:109:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpsdslygov.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n/tmp/tmpsdslygov.swift:25:9:\
    \ warning: variable 'i' was written to, but never read\n    var i = 0\n      \
    \  ^\n/tmp/tmpsdslygov.swift:26:9: warning: variable 'j' was never mutated; consider\
    \ changing to 'let' constant\n    var j = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.characters.count {\n    \
    \    if s.characters[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"a\" || s.characters[i] ==\
    \ \"e\" || s.characters[i] == \"i\" || s.characters[i] == \"o\" || s.characters[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s.characters[i] == \"n\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"t\" || s.characters[i] ==\
    \ \"s\" || s.characters[i] == \"h\" || s.characters[i] == \"r\" || s.characters[i]\
    \ == \"d\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s.characters[i] == \"b\" || s.characters[i] == \"c\" || s.characters[i]\
    \ == \"m\" || s.characters[i] == \"p\" || s.characters[i] == \"f\" || s.characters[i]\
    \ == \"v\" || s.characters[i] == \"x\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"j\" || s.characters[i] ==\
    \ \"k\" || s.characters[i] == \"l\" || s.characters[i] == \"z\" {\n          \
    \  i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == \"y\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s.characters[i] == \"k\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"p\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"q\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"l\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"m\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"n\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"a\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"e\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"i\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"o\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"u\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"l\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"s\" {\n            i +=\
    \ 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp586ktc9i.swift:153:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp586ktc9i.swift:29:34:\
    \ note: to match this opening '{'\n    while i < s.characters.count {\n      \
    \                           ^\n/tmp/tmp586ktc9i.swift:153:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp586ktc9i.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp586ktc9i.swift:29:17: error:\
    \ 'characters' is unavailable: Please use String directly\n    while i < s.characters.count\
    \ {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp586ktc9i.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s.characters[i]\
    \ == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp586ktc9i.swift:30:14: error: 'characters'\
    \ is unavailable: Please use String directly\n        if s.characters[i] == \"\
    \ \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp586ktc9i.swift:35:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s.characters[i]\
    \ == \"a\" || s.characters[i] == \"e\" || s.characters[i] == \"i\" || s.characters[i]\
    \ == \"o\" || s.characters[i] == \"u\" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: I"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in s.characters {\n        if k\
    \ == \" \" {\n            i = j\n            j = 0\n        }\n        \n    \
    \    if j == n {\n            result.append(String(s.characters[i:k]))\n     \
    \       i = k\n            j = 0\n        }\n        \n        if k == \" \" {\n\
    \            j = k\n        }\n    }\n    \n    if j != 0 {\n        result.append(String(s.characters[i:j]))\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmps0ow3izi.swift:29:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for k in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmps0ow3izi.swift:36:46:\
    \ error: no exact matches in call to subscript \n            result.append(String(s.characters[i:k]))\n\
    \                                             ^\n/tmp/tmps0ow3izi.swift:36:46:\
    \ note: candidate expects value of type 'String.Index' for parameter #1 (got 'Character')\n\
    \            result.append(String(s.characters[i:k]))\n                      \
    \                       ^\n/tmp/tmps0ow3izi.swift:36:46: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Character')\n   \
    \         result.append(String(s.characters[i:k]))\n                         \
    \                    ^\n/tmp/tmps0ow3izi.swift:36:46: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \            result.append(String(s.characters[i:k]))\n                      \
    \                       ^\n/tmp/tmps0ow3izi.swift:37:17: error: cannot assign\
    \ value of type 'Character' to type 'Int'\n            i = k\n               \
    \ ^\n/tmp/tmps0ow3izi.swift:42:17: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n            j = k\n                ^\n/tmp/tmps0ow3izi.swift:47:42:\
    \ error: extraneous argument label 'i:' in subscript\n        result.append(String(s.characters[i:j]))\n\
    \                                         ^~~\n                              \
    \            \n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n\
    \ {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9r7bo5r9.swift:26:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isConsonant'\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n                                        ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        \n        if char\
    \ == \"n\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        } else {\n                result.append(\"n\")\n            }\n     \
    \       continue\n        }\n        \n        if char == \"c\" || char == \"\
    d\" || char == \"h\" || char == \"l\" || char == \"r\" || char == \"v\" {\n  \
    \          if n == 1 {\n                result.append(s)\n            } else {\n\
    \                result.append(\"c\")\n            }\n            continue\n \
    \       }\n        \n        if char == \"b\" || char == \"f\" || char == \"k\"\
    \ || char == \"p\" || char == \"s\" {\n            if n == 1 {\n             \
    \   result.append(s)\n            } else {\n                result.append(\"b\"\
    )\n            }\n            continue\n        }\n        \n        if char ==\
    \ \"m\" || char == \"n\" || char == \"t\" || char == \"v\" {\n            if n\
    \ == 1 {\n                result.append(s)\n            } else {\n           \
    \     result.append(\"m\")\n            }\n            continue\n        }\n \
    \       \n        if char == \"x\" || char == \"z\" {\n            if n == 1 {\n\
    \                result.append(s)\n            } else {\n                result.append(\"\
    x\")\n            }\n            continue\n        }\n        \n        if char\
    \ == \"j\" || char == \"q\" || char == \"z\" {\n            if n == 1 {\n    \
    \            result.append(s)\n            } else {\n                result.append(\"\
    j\")\n            }\n            continue\n        }\n        \n        if char\
    \ == \"q\" || char == \"z\" {\n            if n == 1 {\n                result.append(s)\n\
    \            } else {\n                result.append(\"q\")\n            }\n \
    \           continue\n        }\n        \n        if char == \"z\" {\n      \
    \      if n == 1 {\n                result.append(s)\n            } else {\n \
    \               result.append(\"z\")\n            }\n            continue\n  \
    \      }\n        \n        if char == \"p\" || char == \"s\" {\n            if\
    \ n == 1 {\n                result.append(s)\n            } else {\n         \
    \       result.append(\"p\")\n            }\n            continue\n        }\n\
    \        \n        if char == \"h\" || char == \"v\" || char == \"w\" || char\
    \ == \"x\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        } else {\n                result.append(\"h\")\n            }\n     \
    \       continue\n        }\n        \n        if char == \"v\" || char == \"\
    w\" || char == \"x\" {\n            if n == 1 {\n                result.append(s)\n\
    \            } else {\n                result.append(\"v\")\n            }\n \
    \           continue\n        }\n        \n        if char == \"w\" || char ==\
    \ \"x\" {\n            if n == 1 {\n                result.append(s)\n       \
    \     } else {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvq6man11.swift:159:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpvq6man11.swift:133:39:\
    \ note: to match this opening '{'\n        if char == \"w\" || char == \"x\" {\n\
    \                                      ^\n/tmp/tmpvq6man11.swift:159:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpvq6man11.swift:25:19: note: to match\
    \ this opening '{'\n    for char in s {\n                  ^\n/tmp/tmpvq6man11.swift:159:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpvq6man11.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpvq6man11.swift:141:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            if j-i == n {\n\
    \                result.append(String(s[i:j]))\n            }\n            \n\
    \            i = j + 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp26t5mz0p.swift:35:39: error: extraneous argument label 'i:' in\
    \ subscript\n                result.append(String(s[i:j]))\n                 \
    \                     ^~~\n                                       \n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.characters.count {\n    \
    \    if s.characters[i] >= 'a' && s.characters[i] <= 'z' {\n            i += 1\n\
    \            continue\n        }\n        \n        if s.characters[i] >= 'A'\
    \ && s.characters[i] <= 'Z' {\n            i += 1\n            continue\n    \
    \    }\n        \n        if s.characters[i] >= '0' && s.characters[i] <= '9'\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s.characters[i] == ' ' {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s.characters[i] == '.' {\n            i += 1\n     \
    \       continue\n        }\n        \n        if s.characters[i] == '-' {\n \
    \           i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == '_' {\n            i += 1\n            continue\n        }\n        \n  \
    \      if s.characters[i] == '!' {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == '?' {\n            i += 1\n\
    \            continue\n        }\n        \n        if s.characters[i] == ';'\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s.characters[i] == '\\'' {\n            i += 1\n            continue\n     \
    \   }\n        \n        if s.characters[i] == '\"' {\n            i += 1\n  \
    \          continue\n        }\n        \n        if s.characters[i] == '(' {\n\
    \            i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == ')' {\n            i += 1\n            continue\n        }\n        \n  \
    \      if s.characters[i] == ',' {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == ':' {\n            i += 1\n\
    \            continue\n        }\n        \n        if s.characters[i] == '-'\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s.characters[i] == '.' {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s.characters[i] == '_' {\n            i += 1\n     \
    \       continue\n        }\n        \n        if s.characters[i] == '!' {\n \
    \           i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == '?' {\n            i += 1\n            continue\n        }\n        \n  \
    \      if s.characters[i] == ';' {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == '\\'' {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ '\"' {\n            i += 1\n            continue\n        }\n        \n    \
    \    if s.characters[i] == '(' {\n            i += 1\n            continue\n \
    \       }\n        \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp663052g0.swift:30:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] >= 'a' && s.characters[i] <= 'z' {\n  \
    \                            ^~~\n                              \"a\"\n/tmp/tmp663052g0.swift:30:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ >= 'a' && s.characters[i] <= 'z' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"z\"\n/tmp/tmp663052g0.swift:35:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] >= 'A' && s.characters[i] <= 'Z' {\n  \
    \                            ^~~\n                              \"A\"\n/tmp/tmp663052g0.swift:35:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ >= 'A' && s.characters[i] <= 'Z' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"Z\"\n/tmp/tmp663052g0.swift:40:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] >= '0' && s.characters[i] <= '9' {\n  \
    \                            ^~~\n                              \"0\"\n/tmp/tmp663052g0.swift:40:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ >= '0' && s.characters[i] <= '9' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"9\"\n/tmp/tmp663052g0.swift:45:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] == ' ' {\n                            \
    \  ^~~\n                              \" \"\n/tmp/tmp663052g0.swift:50:31: error:\
    \ single-quoted string literal found, use '\"'\n        if s.characters[i] ==\
    \ '.' {\n                              ^~~\n                              \".\"\
    \n/tmp/tmp663052g0.swift:55:31: error: single-quoted string literal found, use\
    \ '\"'\n        if s.characters[i] == '-' {\n                              ^~~\n\
    \                              \"-\"\n/tmp/tmp663052g0.swift:60:31: error: single-quoted\
    \ string literal found"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    while i < s.count {\n        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n            result.append(s.substringWithRange(i))\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdc5fdwto.swift:24:10: error: expected ',' separator\n        }\n\
    \         ^\n         ,\n/tmp/tmpdc5fdwto.swift:22:14: error: value of type 'String'\
    \ has no member 'substringWithRange'\n        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n           ~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdc5fdwto.swift:22:97: error: value of type 'String' has no member 'substringWithRange'\n\
    \        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n                            \
    \                                                                  ~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdc5fdwto.swift:22:127: error: cannot call value of non-function type 'Int'\n\
    \        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n                            \
    \                                                                            \
    \                      ^\n/tmp/tmpdc5fdwto.swift:22:68: error: value of optional\
    \ type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped to\
    \ a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n                            \
    \                                       ^\n/tmp/tmpdc5fdwto.swift:22:68: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) && s.substringWithRange(i).count > n {\n                            \
    \                                       ^\n                                  \
    \                                                       ?? <#default value#>\n\
    /tmp/tmpdc5fdwto.swift:22:68: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if s.substringWithRange(i).containsString(String(Character(UnicodeScalar(97\
    \ + n))) &&"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"y\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"s\" {\n            i += 1\n            continue\n \
    \       }\n        \n        if s[i] == \"h\" || s[i] == \"d\" || s[i] == \"l\"\
    \ || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"r\" || s[i] == \"t\" || s[i]\
    \ == \"w\" || s[i] == \"v\" || s[i] == \"z\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \" \" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"b\" || s[i]\
    \ == \"c\" || s[i] == \"d\" || s[i] == \"f\" || s[i] == \"g\" || s[i] == \"h\"\
    \ || s[i] == \"j\" || s[i] == \"k\" || s[i] == \"l\" || s[i] == \"m\" || s[i]\
    \ == \"p\" || s[i] == \"q\" || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\"\
    \ || s[i] == \"v\" || s[i] == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i]\
    \ == \"z\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"A\" || s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" ||\
    \ s[i] == \"U\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"Y\" {\n            i += 1\n            continue\n \
    \       }\n        \n        if s[i] == \"S\" {\n            i += 1\n        \
    \    continue\n        }\n        \n        if s[i] == \"H\" || s[i] == \"D\"\
    \ || s[i] == \"L\" || s[i] == \"M\" || s[i] == \"N\" || s[i] == \"R\" || s[i]\
    \ == \"T\" || s[i] == \"W\" || s[i] == \"V\" || s[i] == \"Z\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"B\" || s[i] == \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\"\
    \ || s[i] == \"H\" || s[i] == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i]\
    \ == \"M\" || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i] == \"S\"\
    \ || s[i] == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\" || s[i]\
    \ == \"Y\" || s[i] == \"Z\" {\n            i += 1\n            continue\n    \
    \    }\n        \n        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" ||\
    \ s[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpibotddj3.swift:94:61: error: expected '{' after 'if' condition\n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i]\n        \
    \                                                    ^\n/tmp/tmpibotddj3.swift:116:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpibotddj3.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpibotddj3.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpibotddj3.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpibotddj3.swift:34:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpibotddj3.swift:34:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qw_0wx.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp69qw_0wx.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = s.count\n    for (i; i < m && j\
    \ < n; i++ {\n        if s[i] == \" \" {\n            j = j + 1\n        }\n \
    \       if j == n {\n            result.append(String(s[i:k]))\n            i\
    \ = k\n            j = j + 1\n            k = 0\n        }\n        if s[i] ==\
    \ \" \" {\n            j = j + 1\n        }\n        if j == n {\n           \
    \ result.append(String(s[i:l]))\n            i = l\n            j = j + 1\n  \
    \          l = 0\n        }\n        if s[i] == \" \" {\n            j = j + 1\n\
    \        }\n        if j == n {\n            result.append(String(s[i:m]))\n \
    \           i = m\n            j = j + 1\n            m = 0\n        }\n     \
    \   if s[i] == \" \" {\n            j = j + 1\n        }\n        if j == n {\n\
    \            result.append(String(s[i:k]))\n            i = k\n            j =\
    \ j + 1\n            k = 0\n        }\n        if s[i] == \" \" {\n          \
    \  j = j + 1\n        }\n        if j == n {\n            result.append(String(s[i:l]))\n\
    \            i = l\n            j = j + 1\n            l = 0\n        }\n    \
    \    if s[i] == \" \" {\n            j = j + 1\n        }\n        if j == n {\n\
    \            result.append(String(s[i:m]))\n            i = m\n            j =\
    \ j + 1\n            m = 0\n        }\n        if s[i] == \" \" {\n          \
    \  j = j + 1\n        }\n        if j == n {\n            result.append(String(s[i:k]))\n\
    \            i = k\n            j = j + 1\n            k = 0\n        }\n    \
    \    if s[i] == \" \" {\n            j = j + 1\n        }\n        if j == n {\n\
    \            result.append(String(s[i:l]))\n            i = l\n            j =\
    \ j + 1\n            l = 0\n        }\n        if s[i] == \" \" {\n          \
    \  j = j + 1\n        }\n        if j == n {\n            result.append(String(s[i:m]))\n\
    \            i = m\n            j = j + 1\n            m = 0\n        }\n    \
    \    if s[i] == \" \" {\n            j = j + 1\n        }\n        if j == n {\n\
    \            result.append(String(s[i:k]))\n            i = k\n            j =\
    \ j + 1\n            k = 0\n        }\n        if s[i] == \" \" {\n          \
    \  j = j + 1\n        }\n        if j == n {\n            result.append(String(s[i:l]))\n\
    \            i = l\n            j = j + 1\n            l = 0\n        }\n    \
    \    if s[i] == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp46m00fhe.swift:28:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i; i < m && j < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp46m00fhe.swift:150:69: error: expected '{' to start the body of for-each\
    \ loop\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\"\
    , \"f\"])\n                                                                  \
    \  ^\n/tmp/tmp46m00fhe.swift:150:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp46m00fhe.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if i == 0 {\n                i = j\n            }\n            \n     \
    \       if i == j {\n                j = j + 1\n            }\n            \n\
    \            if j == n {\n                result.appendContentsOf(s[i ..< s.endIndex])\n\
    \                j = 0\n                i = i + 1\n            }\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            if i == 0 {\n                i = j\n\
    \            }\n            \n            if i == j {\n                j = j +\
    \ 1\n            }\n            \n            if j == n {\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                j = 0\n                i = i + 1\n       \
    \     }\n        }\n        \n        if char == \"b\" || char == \"c\" || char\
    \ == \"d\" || char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\"\
    \ || char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char\
    \ == \"p\" || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\"\
    \ || char == \"v\" || char == \"w\" || char == \"x\" || char == \"y\" || char\
    \ == \"z\" {\n            if i == 0 {\n                i = j\n            }\n\
    \            \n            if i == j {\n                j = j + 1\n          \
    \  }\n            \n            if j == n {\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                j = 0\n                i = i + 1\n       \
    \     }\n        }\n        \n        if char == \"q\" || char == \"w\" || char\
    \ == \"e\" || char == \"r\" || char == \"t\" || char == \"y\" || char == \"u\"\
    \ || char == \"i\" || char == \"o\" || char == \"p\" || char == \"a\" || char\
    \ == \"s\" || char == \"d\" || char == \"f\" || char == \"g\" || char == \"h\"\
    \ || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char\
    \ == \"n\" || char == \"z\" {\n            if i == 0 {\n                i = j\n\
    \            }\n            \n            if i == j {\n                j = j +\
    \ 1\n            }\n            \n            if j == n {\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                j = 0\n                i = i + 1\n       \
    \     }\n        }\n        \n        if char == \"z\" || char == \"x\" || char\
    \ == \"c\" || char == \"v\" || char == \"b\" || char == \"n\" || char == \"m\"\
    \ || char == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp387252_n.swift:93:125: error: unterminated string literal\n   \
    \     if char == \"z\" || char == \"x\" || char == \"c\" || char == \"v\" || char\
    \ == \"b\" || char == \"n\" || char == \"m\" || char == \"\n                 \
    \                                                                            \
    \                               ^\n/tmp/tmp387252_n.swift:115:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp387252_n.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp387252_n.swift:39:24: error:\
    \ value of type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp387252_n.swift:39:43:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                result.appendContentsOf(s[i ..< s.endIndex])\n              \
    \                            ^\n/tmp/tmp387252_n.swift:55:24: error: value of\
    \ type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp387252_n.swift:55:43:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                result.appendContentsOf(s[i ..< s.endIndex])\n              \
    \                            ^\n/tmp/tmp387252_n.swift:71:24: error: value of\
    \ type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(s[i\
    \ ..< s.endIndex])\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp387252_n.swift:71:43:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                result.appendContentsOf(s[i ..< s.endIndex])\n              \
    \                            ^\n/tmp/tmp387252_n.swift:87:24: error: value of\
    \ type '[String]' has no member 'appendContentsOf'\n             "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = s.count\n    var m = 1\n    var n = n\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 1\n    var s = \"\"\n    var\
    \ t = \"\"\n    var u = \"\"\n    var v = \"\"\n    var w = 0\n    var x = \"\"\
    \n    var y = \"\"\n    var z = \"\"\n    var aa = \"\"\n    var ab = \"\"\n \
    \   var ac = \"\"\n    var ad = \"\"\n    var ae = \"\"\n    var af = \"\"\n \
    \   var ag = \"\"\n    var ah = \"\"\n    var ai = \"\"\n    var aj = \"\"\n \
    \   var ak = \"\"\n    var al = \"\"\n    var am = \"\"\n    var an = \"\"\n \
    \   var ao = \"\"\n    var ap = \"\"\n    var aq = \"\"\n    var ar = \"\"\n \
    \   var as = \"\"\n    var at = \"\"\n    var au = \"\"\n    var av = \"\"\n \
    \   var aw = \"\"\n    var ax = \"\"\n    var ay = \"\"\n    var az = \"\"\n \
    \   var aA = \"\"\n    var aB = \"\"\n    var aC = \"\"\n    var aD = \"\"\n \
    \   var aE = \"\"\n    var aF = \"\"\n    var aG = \"\"\n    var aH = \"\"\n \
    \   var aI = \"\"\n    var aJ = \"\"\n    var aK = \"\"\n    var aL = \"\"\n \
    \   var aM = \"\"\n    var aN = \"\"\n    var aO = \"\"\n    var aP = \"\"\n \
    \   var aQ = \"\"\n    var aR = \"\"\n    var aS = \"\"\n    var aT = \"\"\n \
    \   var aU = \"\"\n    var aV = \"\"\n    var aW = \"\"\n    var aX = \"\"\n \
    \   var aY = \"\"\n    var aZ = \"\"\n    var aAA = \"\"\n    var aAB = \"\"\n\
    \    var aAC = \"\"\n    var aAD = \"\"\n    var aAE = \"\"\n    var aAF = \"\"\
    \n    var aAG = \"\"\n    var aAH = \"\"\n    var aAI = \"\"\n    var aAJ = \"\
    \"\n    var aAK = \"\"\n    var aAL = \"\"\n    var aAM = \"\"\n    var aAN =\
    \ \"\"\n    var aAO = \"\"\n    var aAP = \"\"\n    var aAQ = \"\"\n    var aAR\
    \ = \"\"\n    var aAS = \"\"\n    var aAT = \"\"\n    var aAU = \"\"\n    var\
    \ aAV = \"\"\n    var aAW = \"\"\n    var aAX = \"\"\n    var aAY = \"\"\n   \
    \ var aAZ = \"\"\n    var aAaA = \"\"\n    var aAaB = \"\"\n    var aAaC = \"\"\
    \n    var aAaD = \"\"\n    var aAaE = \"\"\n    var aAaF = \"\"\n    var aAaG\
    \ = \"\"\n    var aAaH = \"\"\n    var a\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9660abd2.swift:59:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = \"\"\n        ^\n/tmp/tmp9660abd2.swift:59:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = \"\"\n       \
    \ ^~\n        `as`\n/tmp/tmp9660abd2.swift:127:9: error: type annotation missing\
    \ in pattern\n    var a\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var index = 0\n    var\
    \ count = 0\n    for char in s.characters {\n        if char == \" \" {\n    \
    \        if count == n {\n                result.insert(index, String(char))\n\
    \                index++\n                count = 0\n            } else {\n  \
    \              count++\n            }\n        } else {\n            if count\
    \ == n {\n                result.insert(index, String(char))\n               \
    \ index++\n                count = 0\n            } else {\n                count++\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjqtzxlt3.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjqtzxlt3.swift:28:30:\
    \ error: missing argument labels 'contentsOf:at:' in call\n                result.insert(index,\
    \ String(char))\n                             ^\n                            \
    \  contentsOf:  at: \n/tmp/tmpjqtzxlt3.swift:28:38: error: cannot convert value\
    \ of type 'String' to expected argument type 'Array<String>.Index' (aka 'Int')\n\
    \                result.insert(index, String(char))\n                        \
    \             ^\n/tmp/tmpjqtzxlt3.swift:28:17: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Int' conform to 'Collection'\n                result.insert(index,\
    \ String(char))\n                ^\nSwift.RangeReplaceableCollection:7:37: note:\
    \ where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n/tmp/tmpjqtzxlt3.swift:29:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      index++\n                     ^~\n/tmp/tmpjqtzxlt3.swift:32:22: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n                count++\n\
    \                     ^~\n/tmp/tmpjqtzxlt3.swift:36:30: error: missing argument\
    \ labels 'contentsOf:at:' in call\n                result.insert(index, String(char))\n\
    \                             ^\n                              contentsOf:  at:\
    \ \n/tmp/tmpjqtzxlt3.swift:36:38: error: cannot convert value of type 'String'\
    \ to expected argument type 'Array<String>.Index' (aka 'Int')\n              \
    \  result.insert(index, String(char))\n                                     ^\n\
    /tmp/tmpjqtzxlt3.swift:36:17: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Int' conform to 'Collection'\n                result.insert(index,\
    \ Str"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.characters.count {\n        if s.characters[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s.characters[i] == \"a\" || s.characters[i] == \"e\" || s.characters[i]\
    \ == \"i\" || s.characters[i] == \"o\" || s.characters[i] == \"u\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == \"b\" || s.characters[i] == \"c\" || s.characters[i] == \"d\" || s.characters[i]\
    \ == \"f\" || s.characters[i] == \"g\" || s.characters[i] == \"h\" || s.characters[i]\
    \ == \"j\" || s.characters[i] == \"k\" || s.characters[i] == \"l\" || s.characters[i]\
    \ == \"m\" || s.characters[i] == \"n\" || s.characters[i] == \"p\" || s.characters[i]\
    \ == \"q\" || s.characters[i] == \"r\" || s.characters[i] == \"s\" || s.characters[i]\
    \ == \"t\" || s.characters[i] == \"v\" || s.characters[i] == \"w\" || s.characters[i]\
    \ == \"x\" || s.characters[i] == \"y\" || s.characters[i] == \"z\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s.characters[i]\
    \ == \"A\" || s.characters[i] == \"E\" || s.characters[i] == \"I\" || s.characters[i]\
    \ == \"O\" || s.characters[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"B\" || s.characters[i] ==\
    \ \"C\" || s.characters[i] == \"D\" || s.characters[i] == \"F\" || s.characters[i]\
    \ == \"G\" || s.characters[i] == \"H\" || s.characters[i] == \"J\" || s.characters[i]\
    \ == \"K\" || s.characters[i] == \"L\" || s.characters[i] == \"M\" || s.characters[i]\
    \ == \"N\" || s.characters[i] == \"P\" || s.characters[i] == \"Q\" || s.characters[i]\
    \ == \"R\" || s.characters[i] == \"S\" || s.characters[i] == \"T\" || s.characters[i]\
    \ == \"V\" || s.characters[i] == \"W\" || s.characters[i] == \"X\" || s.characters[i]\
    \ == \"Y\" || s.characters[i] == \"Z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"0\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"1\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"2\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s.characters[i] == \"3\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s.characters[i] ==\
    \ \"4\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s.characters[i] == \"5\" {\n            i += 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7zjml732.swift:102:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp7zjml732.swift:28:34:\
    \ note: to match this opening '{'\n    while i < s.characters.count {\n      \
    \                           ^\n/tmp/tmp7zjml732.swift:102:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp7zjml732.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp7zjml732.swift:28:17: error:\
    \ 'characters' is unavailable: Please use String directly\n    while i < s.characters.count\
    \ {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7zjml732.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s.characters[i]\
    \ == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7zjml732.swift:29:14: error: 'characters'\
    \ is unavailable: Please use String directly\n        if s.characters[i] == \"\
    \ \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7zjml732.swift:34:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s.characters[i]\
    \ == \"a\" || s.characters[i] == \"e\" || s.characters[i] == \"i\" || s.characters[i]\
    \ == \"o\" || s.characters[i] == \"u\" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: I"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            i += 1\n            if j == n {\n   \
    \             result.append(\"a\")\n                j += 1\n            }\n  \
    \          continue\n        }\n        \n        if s[i] == \"e\" {\n       \
    \     i += 1\n            if j == n {\n                result.append(\"e\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"i\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"i\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"o\" {\n     \
    \       i += 1\n            if j == n {\n                result.append(\"o\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"u\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"u\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"y\" {\n     \
    \       i += 1\n            if j == n {\n                result.append(\"y\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"A\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"A\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"E\" {\n     \
    \       i += 1\n            if j == n {\n                result.append(\"E\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"I\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"I\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"O\" {\n     \
    \       i += 1\n            if j == n {\n                result.append(\"O\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"U\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"U\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"Y\" {\n     \
    \       i += 1\n            if j == n {\n                result.append(\"Y\")\n\
    \                j += 1\n            }\n            continue\n        }\n    \
    \    \n        if s[i] == \"b\" {\n            i += 1\n            if j == n {\n\
    \                result.append(\"b\")\n                j += 1\n            }\n\
    \            continue\n        }\n        \n        if s[i] == \"c\" {\n     \
    \       i += 1\n            if j == n {\n                result.\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb41i1yf7.swift:155:23: error: expected member name following '.'\n\
    \                result.\n                      ^\n/tmp/tmpb41i1yf7.swift:177:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpb41i1yf7.swift:152:24:\
    \ note: to match this opening '{'\n        if s[i] == \"c\" {\n              \
    \         ^\n/tmp/tmpb41i1yf7.swift:177:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpb41i1yf7.swift:29:23: note: to match this opening '{'\n    while\
    \ i < s.count {\n                      ^\n/tmp/tmpb41i1yf7.swift:177:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpb41i1yf7.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpb41i1yf7.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb41i1yf7.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb41i1yf7.swift:44:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked una"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j - i > n {\n                result.appendContentsOf(s.substringWithRange(NSMakeRange(i,\
    \ j)))\n                i = j\n            }\n        }\n        \n        i +=\
    \ 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5colspbg.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp5colspbg.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp5colspbg.swift:29:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.characters.count {\n        if s.characters[i]\
    \ != 'a' && s.characters[i] != 'e' && s.characters[i] != 'i' && s.characters[i]\
    \ != 'o' && s.characters[i] != 'u' {\n            if s.characters[i] == ' ' {\n\
    \                result.insert(j, s.substring(i, j))\n                i = j +\
    \ 1\n                j = 0\n            } else {\n                j = j + 1\n\
    \            }\n        } else {\n            i = i + 1\n        }\n    }\n  \
    \  \n    if j > 0 {\n        result.insert(j, s.substring(i, j))\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptfqwp39o.swift:29:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                 ^~~\n                              \"a\"\n/tmp/tmptfqwp39o.swift:29:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ != 'a' && s.characters[i] != 'e' && s.characters[i] != 'i' && s.characters[i]\
    \ != 'o' && s.characters[i] != 'u' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"e\"\n/tmp/tmptfqwp39o.swift:29:83: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                                                                     ^~~\n  \
    \                                                                            \
    \    \"i\"\n/tmp/tmptfqwp39o.swift:29:109: error: single-quoted string literal\
    \ found, use '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e'\
    \ && s.characters[i] != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u'\
    \ {\n                                                                        \
    \                                    ^~~\n                                   \
    \                                                                         \"o\"\
    \n/tmp/tmptfqwp39o.swift:29:135: error: single-quoted string literal found, use\
    \ '\"'\n        if s.characters[i] != 'a' && s.characters[i] != 'e' && s.characters[i]\
    \ != 'i' && s.characters[i] != 'o' && s.characters[i] != 'u' {\n             \
    \                                                                            \
    \                                             ^~~\n                          \
    \                                                                            \
    \                                \"u\"\n/tmp/tmptfqwp39o.swift:30:35: error: single-quoted\
    \ string literal found, use '\"'\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe3r__5ox.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe3r__5ox.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    for i < s.count {\n        if s[i] == \" \" {\n      \
    \      i += 1\n            j += 1\n            if j == n {\n                j\
    \ += 1\n                k += 1\n                if k == n {\n                \
    \    result.append(String(s[i:]))\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoght12qd.swift:26:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpoght12qd.swift:26:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpoght12qd.swift:34:46: error: expected expression\
    \ in list of expressions\n                    result.append(String(s[i:]))\n \
    \                                            ^\n/tmp/tmpoght12qd.swift:26:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            \n            if j == n {\n                result.appendContentsOf(select_words(s.substringFromIndex(advance(s.startIndex,\
    \ i)), n))\n                \n                i += 1\n                j = 0\n\
    \            } else {\n                j += 1\n            }\n        } else {\n\
    \            i += 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbb0v8blx.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbb0v8blx.swift:33:75: error: cannot find 'advance'\
    \ in scope\n                result.appendContentsOf(select_words(s.substringFromIndex(advance(s.startIndex,\
    \ i)), n))\n                                                                 \
    \         ^~~~~~~\n/tmp/tmpbb0v8blx.swift:33:24: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n                result.appendContentsOf(select_words(s.substringFromIndex(advance(s.startIndex,\
    \ i)), n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpbb0v8blx.swift:33:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(s.substringFromIndex(advance(s.startIndex,\
    \ i)), n))\n                                                    ^\n          \
    \                                           s:                               \
    \               n: \n/tmp/tmpbb0v8blx.swift:33:56: error: value of type 'String'\
    \ has no member 'substringFromIndex'\n                result.appendContentsOf(select_words(s.substringFromIndex(advance(s.startIndex,\
    \ i)), n))\n                                                     ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    for letter in s.characters {\n        if letter == \" \" {\n\
    \            continue\n        }\n        if letter == \"a\" || letter == \"e\"\
    \ || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n            continue\n\
    \        }\n        if letter == \"n\" {\n            if i == n {\n          \
    \      result.append(String(s[i:]))\n            }\n            i = i + 1\n  \
    \          continue\n        }\n        if letter == \"c\" || letter == \"d\"\
    \ || letter == \"h\" || letter == \"l\" || letter == \"r\" || letter == \"v\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"b\" || letter == \"f\" || letter == \"p\" || letter == \"s\"\
    \ || letter == \"t\" {\n            if i == n {\n                result.append(String(s[i:]))\n\
    \            }\n            i = i + 1\n            continue\n        }\n     \
    \   if letter == \"m\" || letter == \"n\" || letter == \"p\" || letter == \"t\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"k\" || letter == \"q\" || letter == \"s\" || letter == \"v\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"j\" || letter == \"z\" {\n            if i == n {\n        \
    \        result.append(String(s[i:]))\n            }\n            i = i + 1\n\
    \            continue\n        }\n        if letter == \"x\" || letter == \"z\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"m\" || letter == \"n\" {\n            if i == n {\n        \
    \        result.append(String(s[i:]))\n            }\n            i = i + 1\n\
    \            continue\n        }\n        if letter == \"p\" || letter == \"t\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"f\" || letter == \"v\" {\n            if i == n {\n        \
    \        result.append(String(s[i:]))\n            }\n            i = i + 1\n\
    \            continue\n        }\n        if letter == \"b\" || letter == \"s\"\
    \ {\n            if i == n {\n                result.append(String(s[i:]))\n \
    \           }\n            i = i + 1\n            continue\n        }\n      \
    \  if letter == \"c\" || letter == \"d\" || letter == \"h\" || letter == \"l\"\
    \ || letter == \"r\" || letter == \"v\" {\n            if i == n {\n         \
    \       result.append(String(s[i:]))\n            }\n            i = i + 1\n \
    \           continue\n        }\n        if letter == \"a\" || letter\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvwshf7ja.swift:30:42: error: expected expression in list of expressions\n\
    \                result.append(String(s[i:]))\n                              \
    \           ^\n/tmp/tmpvwshf7ja.swift:37:42: error: expected expression in list\
    \ of expressions\n                result.append(String(s[i:]))\n             \
    \                            ^\n/tmp/tmpvwshf7ja.swift:44:42: error: expected\
    \ expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:51:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:58:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:65:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:72:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:79:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:86:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:93:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:100:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:107:42: error:\
    \ expected expression in list of expressions\n                result.append(String(s[i:]))\n\
    \                                         ^\n/tmp/tmpvwshf7ja.swift:112:35:"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            result.append(String(char))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2zrisx06.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2zrisx06.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qx0tjr_.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp3qx0"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words: [String]\
    \ = []\n    \n    if s == \"\" {\n        return words\n    }\n    \n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    \n    while i < s.count\
    \ {\n        if s[i] == \" \" {\n            i += 1\n            continue\n  \
    \      }\n        \n        if s[i] == \"a\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"e\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"i\" {\n \
    \           i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"o\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"u\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"y\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"A\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"E\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"I\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"O\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"U\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"Y\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"a\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"e\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"i\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"o\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"A\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"E\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"I\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"O\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"Y\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"a\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"e\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"i\" \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp97xw7y6u.swift:176:23: error: expected '{' after 'if' condition\n\
    \        if s[i] == \"i\" \n                      ^\n/tmp/tmp97xw7y6u.swift:198:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp97xw7y6u.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp97xw7y6u.swift:31:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp97xw7y6u.swift:36:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp97xw7y6u.swift:41:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp97xw7y6u.swift:46:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp97xw7y6u.swift:51:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"o\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable h"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.consonant() == false {\n            if n ==\
    \ 1 {\n                result.append(String(char))\n            } else {\n   \
    \             result.append(String(char))\n                n -= 1\n          \
    \  }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt4rkg46l.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt4rkg46l.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonant'\n        if char.consonant()\
    \ == false {\n           ~~~~ ^~~~~~~~~\n/tmp/tmpt4rkg46l.swift:31:19: error:\
    \ left side of mutating operator isn't mutable: 'n' is a 'let' constant\n    \
    \            n -= 1\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.hasConsonants {\n            if result.count < n {\n\
    \                result.append(String(char))\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptj6q6ld9.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptj6q6ld9.swift:30:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in 0..<s.characters.count {\n \
    \       if s.characters[k] == \" \" {\n            i = k\n            break\n\
    \        }\n    }\n    \n    for j in i..<s.characters.count {\n        if s.characters[j]\
    \ == \" \" {\n            i = j\n            break\n        }\n    }\n    \n \
    \   for k in i..<s.characters.count {\n        if s.characters[k] == \" \" {\n\
    \            i = k\n            break\n        }\n    }\n    \n    for j in i..<s.characters.count\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n            break\n\
    \        }\n    }\n    \n    for k in i..<s.characters.count {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n            break\n        }\n    }\n    \n \
    \   for j in i..<s.characters.count {\n        if s.characters[j] == \" \" {\n\
    \            i = j\n            break\n        }\n    }\n    \n    for k in i..<s.characters.count\
    \ {\n        if s.characters[k] == \" \" {\n            i = k\n            break\n\
    \        }\n    }\n    \n    for j in i..<s.characters.count {\n        if s.characters[j]\
    \ == \" \" {\n            i = j\n            break\n        }\n    }\n    \n \
    \   for k in i..<s.characters.count {\n        if s.characters[k] == \" \" {\n\
    \            i = k\n            break\n        }\n    }\n    \n    for j in i..<s.characters.count\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n            break\n\
    \        }\n    }\n    \n    for k in i..<s.characters.count {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n            break\n        }\n    }\n    \n \
    \   for j in i..<s.characters.count {\n        if s.characters[j] == \" \" {\n\
    \            i = j\n            break\n        }\n    }\n    \n    for k in i..<s.characters.count\
    \ {\n        if s.characters[k] == \" \" {\n            i = k\n            break\n\
    \        }\n    }\n    \n    for j in i..<s.characters.count {\n        if s.characters[j]\
    \ == \" \" {\n            i = j\n            break\n        }\n    }\n    \n \
    \   for k in i..<s.characters.count {\n        if s.characters[k] == \" \" {\n\
    \            i = k\n            break\n        }\n    }\n    \n    for j in i..<s.characters.count\
    \ {\n        if s.characters[j\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvps63e0c.swift:136:1: error: expected ']' in expression list\n\
    }\n^\n/tmp/tmpvps63e0c.swift:135:24: note: to match this opening '['\n       \
    \ if s.characters[j\n                       ^\n/tmp/tmpvps63e0c.swift:157:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpvps63e0c.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpvps63e0c.swift:29:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ 0..<s.characters.count {\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvps63e0c.swift:30:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s.characters[k] == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvps63e0c.swift:30:14:\
    \ error: 'characters' is unavailable: Please use String directly\n        if s.characters[k]\
    \ == \" \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvps63e0c.swift:36:20: error: 'characters' is unavailable:\
    \ Please use String directly\n    for j in i..<s.characters.count {\n        \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvps63e0c.swift:37:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s.characters[j]\
    \ == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    \n    var result = [String]()\n    \n    for word in words {\n    \
    \    let letters = word.componentsSeparatedByString(\"\")\n        \n        if\
    \ letters.count == n {\n            result.append(word)\n        }\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxl2k004v.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s {\n        if letter == \" \" {\n            continue\n \
    \       }\n        if letter == \"a\" || letter == \"e\" || letter == \"i\" ||\
    \ letter == \"o\" || letter == \"u\" {\n            continue\n        }\n    \
    \    if letter == \"n\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"c\" || letter == \"h\" || letter\
    \ == \"l\" || letter == \"o\" || letter == \"r\" {\n            if s.count > n\
    \ {\n                continue\n            }\n        }\n        if letter ==\
    \ \"d\" || letter == \"s\" || letter == \"t\" || letter == \"u\" {\n         \
    \   if s.count > n {\n                continue\n            }\n        }\n   \
    \     if letter == \"m\" || letter == \"a\" || letter == \"r\" || letter == \"\
    y\" {\n            if s.count > n {\n                continue\n            }\n\
    \        }\n        if letter == \"p\" || letter == \"e\" || letter == \"l\" ||\
    \ letter == \"s\" || letter == \"t\" {\n            if s.count > n {\n       \
    \         continue\n            }\n        }\n        if letter == \"f\" || letter\
    \ == \"r\" || letter == \"v\" || letter == \"a\" || letter == \"l\" {\n      \
    \      if s.count > n {\n                continue\n            }\n        }\n\
    \        if letter == \"g\" || letter == \"u\" || letter == \"n\" || letter ==\
    \ \"e\" || letter == \"s\" || letter == \"t\" {\n            if s.count > n {\n\
    \                continue\n            }\n        }\n        if letter == \"b\"\
    \ || letter == \"l\" || letter == \"o\" || letter == \"r\" || letter == \"u\"\
    \ || letter == \"d\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"k\" || letter == \"e\" || letter\
    \ == \"m\" || letter == \"o\" || letter == \"r\" || letter == \"t\" {\n      \
    \      if s.count > n {\n                continue\n            }\n        }\n\
    \        if letter == \"j\" || letter == \"u\" || letter == \"n\" || letter ==\
    \ \"e\" || letter == \"s\" || letter == \"t\" {\n            if s.count > n {\n\
    \                continue\n            }\n        }\n        if letter == \"m\"\
    \ || letter == \"a\" || letter == \"r\" || letter == \"y\" {\n            if s.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"p\" || letter == \"e\" || letter == \"l\" || letter == \"s\" || letter\
    \ == \"t\" {\n            if s.count > n {\n                continue\n       \
    \     }\n        }\n        if letter == \"f\" || letter == \"r\" || letter ==\
    \ \"v\" || letter == \"a\" || letter == \"l\" {\n            if s.count > n {\n\
    \                continue\n            }\n        }\n        if letter == \"g\"\
    \ || letter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmu3matw7.swift:92:35: error: expected '{' after 'if' condition\n\
    \        if letter == \"g\" || letter\n                                  ^\n/tmp/tmpmu3matw7.swift:114:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpmu3matw7.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpmu3matw7.swift:92:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Bool'\n\
    \        if letter == \"g\" || letter\n                            ^\n/tmp/tmpmu3matw7.swift:96:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var count = 0\n    for letter in s.characters {\n        if letter == \"\
    \ \" {\n            count += 1\n            if count == n {\n                result.append(\"\
    \\n\")\n                count = 0\n            }\n        } else {\n         \
    \   if count == n {\n                result.append(\"\\n\")\n                count\
    \ = 0\n            }\n            result.append(String(letter))\n            count\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppkf4kdfm.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp57oi5rzr.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp57oi5rzr.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp57oi5rzr.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp57oi5rzr.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp57oi5rzr.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp57oi5rzr.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp57oi5rzr.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp57oi5rzr.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp57oi5rzr.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp57oi5rzr.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp57oi5rzr.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp57oi5rzr.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp57oi5rzr.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp57oi5rzr.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp57oi5rzr.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp57oi5rzr.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp57oi5rzr.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp57oi5rzr.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp57oi5rzr.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp57oi5rzr.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp57oi5rzr.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp57oi5rzr.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp57oi5rzr.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp57oi"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw4rhtm_1.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    var last = 0\n    var index = 0\n    \n    for char in s {\n        if\
    \ char == \" \" {\n            count += 1\n        }\n        \n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            count += 1\n        }\n        \n        if char == \"y\" {\n\
    \            count += 1\n        }\n        \n        if char == \"s\" {\n   \
    \         count += 1\n        }\n        \n        if char == \"d\" || char ==\
    \ \"h\" || char == \"l\" || char == \"m\" || char == \"n\" || char == \"t\" {\n\
    \            count += 1\n        }\n        \n        if char == \"k\" || char\
    \ == \"b\" || char == \"p\" || char == \"v\" || char == \"z\" {\n            count\
    \ += 1\n        }\n        \n        if char == \"n\" {\n            count +=\
    \ 1\n        }\n        \n        if char == \"f\" || char == \"r\" || char ==\
    \ \"q\" || char == \"s\" || char == \"x\" {\n            count += 1\n        }\n\
    \        \n        if char == \"c\" || char == \"v\" || char == \"b\" || char\
    \ == \"d\" || char == \"m\" || char == \"l\" || char == \"s\" {\n            count\
    \ += 1\n        }\n        \n        if char == \"k\" || char == \"b\" || char\
    \ == \"p\" || char == \"v\" || char == \"z\" {\n            count += 1\n     \
    \   }\n        \n        if char == \"n\" {\n            count += 1\n        }\n\
    \        \n        if char == \"f\" || char == \"r\" || char == \"q\" || char\
    \ == \"s\" || char == \"x\" {\n            count += 1\n        }\n        \n \
    \       if char == \"c\" || char == \"v\" || char == \"b\" || char == \"d\" ||\
    \ char == \"m\" || char == \"l\" || char == \"s\" {\n            count += 1\n\
    \        }\n        \n        if char == \"k\" || char == \"b\" || char == \"\
    p\" || char == \"v\" || char == \"z\" {\n            count += 1\n        }\n \
    \       \n        if char == \"n\" {\n            count += 1\n        }\n    \
    \    \n        if char == \"f\" || char == \"r\" || char == \"q\" || char == \"\
    s\" || char == \"x\" {\n            count += 1\n        }\n        \n        if\
    \ char == \"c\" || char == \"v\" || char == \"b\" || char == \"d\" || char ==\
    \ \"m\" || char == \"l\" || char == \"s\" {\n            count += 1\n        }\n\
    \        \n        if char == \"k\" || char == \"b\" || char == \"p\" || char\
    \ == \"v\" || char == \"z\" {\n            count += 1\n        }\n        \n \
    \       if char == \"n\" {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt3yr8sng.swift:125:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpt3yr8sng.swift:29:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpt3yr8sng.swift:125:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpt3yr8sng.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpt3yr8sng.swift:107:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpt3yr8sng.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n/tmp/tmpt3yr8sng.swift:26:9:\
    \ warning: initialization of variable 'last' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var last = 0\n    ~~~~^~~~\n    _\n\
    /tmp/tmpt3yr8sng.swift:27:9: warning: initialization of variable 'index' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var index\
    \ = 0\n    ~~~~^~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        \n     \
    \   if s[i] == \" \" {\n            \n            j = i\n            \n      \
    \      while j < s.count && s[j] != \" \" {\n                j += 1\n        \
    \    }\n            \n            if j == s.count {\n                \n      \
    \          words.append(s[i : j])\n                \n                i = j + 1\n\
    \                \n            } else {\n                \n                words.append(s[i\
    \ : j])\n                \n                i = j + 1\n                \n     \
    \           k = j\n                \n                while k < s.count && s[k]\
    \ == \" \" {\n                    k += 1\n                }\n                \n\
    \                if k == s.count {\n                    \n                   \
    \ words.append(s[i : k])\n                    \n                    i = k + 1\n\
    \                    \n                } else {\n                    \n      \
    \              words.append(s[i : k])\n                    \n                \
    \    i = k + 1\n                    \n                    k = k + 1\n        \
    \            \n                    while k < s.count && s[k] == \" \" {\n    \
    \                    k += 1\n                    }\n                    \n   \
    \                 if k == s.count {\n                        \n              \
    \          words.append(s[i : k])\n                        \n                \
    \        i = k + 1\n                        \n                    } else {\n \
    \                       \n                        words.append(s[i : k])\n   \
    \                     \n                        i = k + 1\n                  \
    \      \n                        k = k + 1\n                        \n       \
    \                 while k < s.count && s[k] == \" \" {\n                     \
    \       k += 1\n                        }\n                        \n        \
    \                if k == s.count {\n                            \n           \
    \                 words.append(s[i : k])\n                            \n     \
    \                       i = k + 1\n                            \n            \
    \            } else {\n                            \n                        \
    \    words.append(s[i : k])\n                            \n                  \
    \          i = k + 1\n                            \n                         \
    \   k = k + 1\n                            \n                            while\
    \ k < s.count && s[k] == \" \" {\n                                k += 1\n   \
    \                         }\n                            \n                  \
    \          if k == s.count {\n                                \n             \
    \                   words.append(s[i : k])\n                                \n\
    \                                i = k + 1\n                                \n\
    \                            } else {\n                                \n    \
    \                            words.append(s[i : k])\n                        \
    \        \n                                i = k + 1\n                       \
    \         \n                                k = k + 1\n                      \
    \          \n                                while k < s.count && s[k] == \" \"\
    \ {\n                                    k += 1\n                            \
    \    }\n                                \n                                if k\
    \ == s.count {\n                                    \n                       \
    \             words.append(s[i : k])\n                                    \n \
    \                                   i = k + 1\n                              \
    \      \n                                } else {\n                          \
    \          \n                                    words.append(s[i : k])\n    \
    \                                \n                                    i = k +\
    \ 1\n                                    \n                                  \
    \  k = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjmzjercs.swift:143:1: error: expected expression in assignment\n\
    }\n^\n/tmp/tmpjmzjercs.swift:164:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjmzjercs.swift:118:36:\
    \ note: to match this opening '{'\n                            } else {\n    \
    \                               ^\n/tmp/tmpjmzjercs.swift:164:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmpjmzjercs.swift:100:32: note: to match this\
    \ opening '{'\n                        } else {\n                            \
    \   ^\n/tmp/tmpjmzjercs.swift:164:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjmzjercs.swift:82:28:\
    \ note: to match this opening '{'\n                    } else {\n            \
    \               ^\n/tmp/tmpjmzjercs.swift:164:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmpjmzjercs.swift:64:24: note: to match this opening '{'\n\
    \                } else {\n                       ^\n/tmp/tmpjmzjercs.swift:164:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpjmzjercs.swift:46:20:\
    \ note: to match this opening '{'\n            } else {\n                   ^\n\
    /tmp/tmpjmzjercs.swift:164:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjmzjercs.swift:32:24:\
    \ note: to match this opening '{'\n        if s["
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qx0tjr_.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp3qx0"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd848pfvq.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpy2j4mtyo/tmpy2j4mtyo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c0964c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c065bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c065b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c065a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2j4mtyo                        0x000055d0ec3894c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab1c0b50460 __libc_start_main +
    245

    6    tmpy2j4mtyo                        0x000055d0ec3890c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = s.characters.count\n\
    \    while i < l {\n        if s.characters[i] == \" \" {\n            i += 1\n\
    \            continue\n        }\n        if s.characters[i] == \"a\" || s.characters[i]\
    \ == \"e\" || s.characters[i] == \"i\" || s.characters[i] == \"o\" || s.characters[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        if\
    \ s.characters[i] == \"y\" {\n            i += 1\n            continue\n     \
    \   }\n        if s.characters[i] == \"s\" {\n            i += 1\n           \
    \ continue\n        }\n        if s.characters[i] == \"d\" || s.characters[i]\
    \ == \"h\" || s.characters[i] == \"l\" || s.characters[i] == \"m\" || s.characters[i]\
    \ == \"n\" || s.characters[i] == \"t\" || s.characters[i] == \"w\" || s.characters[i]\
    \ == \"y\" {\n            i += 1\n            continue\n        }\n        if\
    \ s.characters[i] == \"b\" || s.characters[i] == \"c\" || s.characters[i] == \"\
    f\" || s.characters[i] == \"v\" || s.characters[i] == \"x\" || s.characters[i]\
    \ == \"z\" {\n            i += 1\n            continue\n        }\n        if\
    \ s.characters[i] == \"j\" || s.characters[i] == \"k\" || s.characters[i] == \"\
    q\" || s.characters[i] == \"p\" || s.characters[i] == \"v\" || s.characters[i]\
    \ == \"z\" {\n            i += 1\n            continue\n        }\n        if\
    \ s.characters[i] == \"k\" || s.characters[i] == \"q\" || s.characters[i] == \"\
    p\" || s.characters[i] == \"v\" || s.characters[i] == \"z\" {\n            i +=\
    \ 1\n            continue\n        }\n        if s.characters[i] == \"h\" || s.characters[i]\
    \ == \"l\" || s.characters[i] == \"m\" || s.characters[i] == \"n\" || s.characters[i]\
    \ == \"t\" || s.characters[i] == \"w\" || s.characters[i] == \"y\" {\n       \
    \     i += 1\n            continue\n        }\n        if s.characters[i] == \"\
    a\" || s.characters[i] == \"e\" || s.characters[i] == \"i\" || s.characters[i]\
    \ == \"o\" || s.characters[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        if s.characters[i] == \"b\" || s.characters[i] == \"c\" ||\
    \ s.characters[i] == \"f\" || s.characters[i] == \"v\" || s.characters[i] == \"\
    x\" || s.characters[i] == \"z\" {\n            i += 1\n            continue\n\
    \        }\n        if s.characters[i] == \"j\" || s.characters[i] == \"k\" ||\
    \ s.characters[i] == \"q\" || s.characters[i] == \"p\" || s.characters[i] == \"\
    v\" || s.characters[i] == \"z\" {\n            i += 1\n            continue\n\
    \        }\n        if s.characters[i] == \"k\" || s.characters[i] == \"q\" ||\
    \ s.characters[i] == \"p\" || s.characters[i]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm0rcq748.swift:73:105: error: expected '{' after 'if' condition\n\
    \        if s.characters[i] == \"k\" || s.characters[i] == \"q\" || s.characters[i]\
    \ == \"p\" || s.characters[i]\n                                              \
    \                                                          ^\n/tmp/tmpm0rcq748.swift:95:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpm0rcq748.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpm0rcq748.swift:23:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    var l =\
    \ s.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm0rcq748.swift:25:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s.characters[i] == \" \" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpm0rcq748.swift:25:14: error:\
    \ 'characters' is unavailable: Please use String directly\n        if s.characters[i]\
    \ == \" \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpm0rcq748.swift:29:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s.characters[i] == \"a\" || s.characters[i] == \"e\" || s.characters[i] == \"\
    i\" || s.characters[i] == \"o\" || s.characters[i] == \"u\" {\n           ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0rcq748.swift:29:14:\
    \ erro"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            \n            if i == s.count {\n             \
    \   break\n            }\n            \n            if s[j] == \" \" {\n     \
    \           j += 1\n                \n                if j == n {\n          \
    \          result.append(String(s[i..<s.endIndex]))\n                    break\n\
    \                }\n            }\n        }\n        \n        i += 1\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzixwu71_.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpzixwu71_.swift:36:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s[j] == \" \" {\n               ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpzixwu71_.swift:40:44: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                    result.append(String(s[i..<s.endIndex]))\n              \
    \                             ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var word\
    \ = \"\"\n    var words = [String]()\n    var wordCount = 0\n    var wordLength\
    \ = 0\n    var consonantCount = 0\n    var consonantCount2 = 0\n    var consonantCount3\
    \ = 0\n    var consonantCount4 = 0\n    var consonantCount5 = 0\n    var consonantCount6\
    \ = 0\n    var consonantCount7 = 0\n    var consonantCount8 = 0\n    var consonantCount9\
    \ = 0\n    var consonantCount10 = 0\n    var consonantCount11 = 0\n    var consonantCount12\
    \ = 0\n    var consonantCount13 = 0\n    var consonantCount14 = 0\n    var consonantCount15\
    \ = 0\n    var consonantCount16 = 0\n    var consonantCount17 = 0\n    var consonantCount18\
    \ = 0\n    var consonantCount19 = 0\n    var consonantCount20 = 0\n    var consonantCount21\
    \ = 0\n    var consonantCount22 = 0\n    var consonantCount23 = 0\n    var consonantCount24\
    \ = 0\n    var consonantCount25 = 0\n    var consonantCount26 = 0\n    var consonantCount27\
    \ = 0\n    var consonantCount28 = 0\n    var consonantCount29 = 0\n    var consonantCount30\
    \ = 0\n    var consonantCount31 = 0\n    var consonantCount32 = 0\n    var consonantCount33\
    \ = 0\n    var consonantCount34 = 0\n    var consonantCount35 = 0\n    var consonantCount36\
    \ = 0\n    var consonantCount37 = 0\n    var consonantCount38 = 0\n    var consonantCount39\
    \ = 0\n    var consonantCount40 = 0\n    var consonantCount41 = 0\n    var consonantCount42\
    \ = 0\n    var consonantCount43 = 0\n    var consonantCount44 = 0\n    var consonantCount45\
    \ = 0\n    var consonantCount46 = 0\n    var consonantCount47 = 0\n    var consonantCount48\
    \ = 0\n    var consonantCount49 = 0\n    var consonantCount50 = 0\n    var consonantCount51\
    \ = 0\n    var consonantCount52 = 0\n    var consonantCount53 = 0\n    var consonantCount54\
    \ = 0\n    var consonantCount55 = 0\n    var consonantCount56 = 0\n    var consonantCount57\
    \ = 0\n    var consonantCount58 = 0\n    var consonantCount59 = 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3c9pvyfz.swift:19:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = [String]()\n    ~~~~^~~~~~\n    _\n/tmp/tmp3c9pvyfz.swift:20:9:\
    \ warning: initialization of variable 'i' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmp3c9pvyfz.swift:21:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmp3c9pvyfz.swift:22:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmp3c9pvyfz.swift:23:9:\
    \ warning: initialization of variable 'count' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmp3c9pvyfz.swift:24:9: warning: initialization of variable 'word'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var word = \"\"\n    ~~~~^~~~\n    _\n/tmp/tmp3c9pvyfz.swift:25:9: warning:\
    \ initialization of variable 'words' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var words = [String]()\n    ~~~~^~~~~\n    _\n/tmp/tmp3c9pvyfz.swift:26:9:\
    \ warning: initialization of variable 'wordCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var wordCount = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmp3c9pvyfz.swift:27:9: warning: initialization of variable 'wordLength'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var wordLength = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp3c9pvyfz.swift:28:9:\
    \ warning: initialization of variable 'consonantCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp3c9pvyfz.swift:29:9: warning: initialization\
    \ of variable 'consonantCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consona"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s {\n        if let index = s.firstIndex(of: letter) {\n  \
    \          if index == s.startIndex {\n                result.append(letter)\n\
    \            } else {\n                if index == s.endIndex {\n            \
    \        result.append(letter)\n                } else {\n                   \
    \ if index == s.startIndex + n {\n                        result.append(letter)\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv_m2xwoa.swift:23:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(letter)\n\
    \                              ^\n/tmp/tmpv_m2xwoa.swift:26:35: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \               result.append(letter)\n                                  ^\n/tmp/tmpv_m2xwoa.swift:28:46:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                    if index == s.startIndex + n {\n            \
    \                    ~~~~~~~~~~~~ ^ ~\n/tmp/tmpv_m2xwoa.swift:28:46: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Int, Int)\n  \
    \                  if index == s.startIndex + n {\n                          \
    \                   ^\n/tmp/tmpv_m2xwoa.swift:28:30: error: referencing operator\
    \ function '==' on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \                    if index == s.startIndex + n {\n                        \
    \     ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension\
    \ BinaryInteger {\n          ^\n/tmp/tmpv_m2xwoa.swift:29:39: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \           result.append(letter)\n                                      ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n        }\n        \n        if s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \"n\" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt8xdrbnr.swift:182:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpt8xdrbnr.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpt8xdrbnr.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt8xdrbnr.swift:33:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt8xdrbnr.swift:33:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt8xdrbnr.swift:33:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpt8xdrbnr.swift:33:57: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] ="
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8w845vtg.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8w845vtg.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"\
    i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"h\" || s[i] == \"e\" || s[i] == \"\
    l\" || s[i] == \"l\" || s[i] == \"o\" || s[i] == \"r\" || s[i] == \"s\" || s[i]\
    \ == \"t\" || s[i] == \"w\" || s[i] == \"y\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"d\" || s[i] == \"a\" ||\
    \ s[i] == \"m\" || s[i] == \"p\" || s[i] == \"r\" || s[i] == \"s\" || s[i] ==\
    \ \"t\" || s[i] == \"w\" || s[i] == \"y\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"b\" || s[i] == \"e\" || s[i] == \"\
    l\" || s[i] == \"l\" || s[i] == \"o\" || s[i] == \"r\" || s[i] == \"s\" || s[i]\
    \ == \"t\" || s[i] == \"w\" || s[i] == \"y\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"c\" || s[i] == \"a\" ||\
    \ s[i] == \"m\" || s[i] == \"p\" || s[i] == \"r\" || s[i] == \"s\" || s[i] ==\
    \ \"t\" || s[i] == \"w\" || s[i] == \"y\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"f\" || s[i] == \"l\" || s[i] == \"\
    o\" || s[i] == \"r\" || s[i] == \"u\" || s[i] == \"y\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"g\" || s[i] ==\
    \ \"l\" || s[i] == \"o\" || s[i] == \"r\" || s[i] == \"u\" || s[i] == \"y\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"k\" || s[i] == \"l\" || s[i] == \"o\" || s[i] == \"r\" || s[i] == \"u\"\
    \ || s[i] == \"y\" {\n            i += 1\n            continue\n        }\n  \
    \      \n        if s[i] == \"m\" || s[i] == \"a\" || s[i] == \"p\" || s[i] ==\
    \ \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"w\" || s[i] == \"y\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"p\" || s[i] == \"a\" || s[i] == \"m\" || s[i] == \"p\" || s[i] == \"r\"\
    \ || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"w\" || s[i] == \"y\" \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpypi3hks1.swift:85:143: error: expected '{' after 'if' condition\n\
    \        if s[i] == \"p\" || s[i] == \"a\" || s[i] == \"m\" || s[i] == \"p\" ||\
    \ s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"w\" || s[i] ==\
    \ \"y\" \n                                                                   \
    \                                                                           ^\n\
    /tmp/tmpypi3hks1.swift:107:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpypi3hks1.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpypi3hks1.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpypi3hks1.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpypi3hks1.swift:35:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpypi3hks1.swift:35:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" ||"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \" \" {\n            j = i\n        }\n  \
    \      \n        if char == \"n\" {\n            i = j\n        }\n        \n\
    \        if char == \"t\" {\n            i = j\n        }\n        \n        if\
    \ char == \"h\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"l\" {\n            i = j\n        }\n        \n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n       \
    \     i = j\n        }\n        \n        if char == \"n\" {\n            i =\
    \ j\n        }\n        \n        if char == \"t\" {\n            i = j\n    \
    \    }\n        \n        if char == \"h\" {\n            i = j\n        }\n \
    \       \n        if char == \"l\" {\n            i = j\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"n\" {\n            i = j\n        }\n        \n        if char == \"t\" {\n\
    \            i = j\n        }\n        \n        if char == \"h\" {\n        \
    \    i = j\n        }\n        \n        if char == \"l\" {\n            i = j\n\
    \        }\n        \n        if char == \"a\" || char == \"e\" || char == \"\
    i\" || char == \"o\" || char == \"u\" {\n            i = j\n        }\n      \
    \  \n        if char == \"n\" {\n            i = j\n        }\n        \n    \
    \    if char == \"t\" {\n            i = j\n        }\n        \n        if char\
    \ == \"h\" {\n            i = j\n        }\n        \n        if char == \"l\"\
    \ {\n            i = j\n        }\n        \n        if char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i\
    \ = j\n        }\n        \n        if char == \"n\" {\n            i = j\n  \
    \      }\n        \n        if char == \"t\" {\n            i = j\n        }\n\
    \        \n        if char == \"h\" {\n            i = j\n        }\n        \n\
    \        if char == \"l\" {\n            i = \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp5195ttl.swift:135:1: error: expected expression in assignment\n\
    }\n^\n/tmp/tmpp5195ttl.swift:156:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpp5195ttl.swift:28:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpp5195ttl.swift:156:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpp5195ttl.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpp5195ttl.swift:138:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var count = 0\n    for\
    \ letter in s {\n        if letter == \" \" {\n            count += 1\n      \
    \      if count == n {\n                count = 0\n            }\n        } else\
    \ {\n            count = 0\n        }\n        if count == n {\n            result.append(letter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzobmq8h1.swift:34:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in s.characters {\n        if k\
    \ == ' ' {\n            j = i\n        }\n        \n        if k == 'a' || k ==\
    \ 'e' || k == 'i' || k == 'o' || k == 'u' {\n            i = j\n        }\n  \
    \      \n        if k == 'y' {\n            i = j\n        }\n        \n     \
    \   if k == 's' {\n            i = j\n        }\n        \n        if k == 'h'\
    \ || k == 'l' || k == 'm' || k == 'n' || k == 't' {\n            i = j\n     \
    \   }\n        \n        if k == 'w' {\n            i = j\n        }\n       \
    \ \n        if k == 'd' {\n            i = j\n        }\n        \n        if\
    \ k == 'r' || k == 'g' || k == 'b' || k == 'p' || k == 'v' || k == 'k' {\n   \
    \         i = j\n        }\n        \n        if k == 'f' || k == 'v' || k ==\
    \ 'c' || k == 'm' || k == 'o' || k == 's' {\n            i = j\n        }\n  \
    \      \n        if k == 'j' || k == 'q' || k == 'z' || k == 'x' || k == 'q' ||\
    \ k == 'z' || k == 'x' || k == 'q' || k == 'z' || k == 'x' {\n            i =\
    \ j\n        }\n        \n        if k == 'p' || k == 'b' || k == 'k' || k ==\
    \ 'j' || k == 'q' || k == 'z' || k == 'x' || k == 'q' || k == 'z' || k == 'x'\
    \ {\n            i = j\n        }\n        \n        if k == 'v' || k == 'c' ||\
    \ k == 'm' || k == 'o' || k == 's' {\n            i = j\n        }\n        \n\
    \        if k == 'b' || k == 'k' || k == 'j' || k == 'q' || k == 'z' || k == 'x'\
    \ || k == 'q' || k == 'z' || k == 'x' {\n            i = j\n        }\n      \
    \  \n        if k == 'v' || k == 'c' || k == 'm' || k == 'o' || k == 's' {\n \
    \           i = j\n        }\n        \n        if k == 'b' || k == 'k' || k ==\
    \ 'j' || k == 'q' || k == 'z' || k == 'x' || k == 'q' || k == 'z' || k == 'x'\
    \ {\n            i = j\n        }\n        \n        if k == 'v' || k == 'c' ||\
    \ k == '\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnfi1k8sv.swift:30:17: error: single-quoted string literal found,\
    \ use '\"'\n        if k == ' ' {\n                ^~~\n                \" \"\n\
    /tmp/tmpnfi1k8sv.swift:34:17: error: single-quoted string literal found, use '\"\
    '\n        if k == 'a' || k == 'e' || k == 'i' || k == 'o' || k == 'u' {\n   \
    \             ^~~\n                \"a\"\n/tmp/tmpnfi1k8sv.swift:34:29: error:\
    \ single-quoted string literal found, use '\"'\n        if k == 'a' || k == 'e'\
    \ || k == 'i' || k == 'o' || k == 'u' {\n                            ^~~\n   \
    \                         \"e\"\n/tmp/tmpnfi1k8sv.swift:34:41: error: single-quoted\
    \ string literal found, use '\"'\n        if k == 'a' || k == 'e' || k == 'i'\
    \ || k == 'o' || k == 'u' {\n                                        ^~~\n   \
    \                                     \"i\"\n/tmp/tmpnfi1k8sv.swift:34:53: error:\
    \ single-quoted string literal found, use '\"'\n        if k == 'a' || k == 'e'\
    \ || k == 'i' || k == 'o' || k == 'u' {\n                                    \
    \                ^~~\n                                                    \"o\"\
    \n/tmp/tmpnfi1k8sv.swift:34:65: error: single-quoted string literal found, use\
    \ '\"'\n        if k == 'a' || k == 'e' || k == 'i' || k == 'o' || k == 'u' {\n\
    \                                                                ^~~\n       \
    \                                                         \"u\"\n/tmp/tmpnfi1k8sv.swift:38:17:\
    \ error: single-quoted string literal found, use '\"'\n        if k == 'y' {\n\
    \                ^~~\n                \"y\"\n/tmp/tmpnfi1k8sv.swift:42:17: error:\
    \ single-quoted string literal found, use '\"'\n        if k == 's' {\n      \
    \          ^~~\n                \"s\"\n/tmp/tmpnfi1k8sv.swift:46:17: error: single-quoted\
    \ string literal found, use '\"'\n        if k == 'h' || k == 'l' || k == 'm'\
    \ || k == 'n' || k == 't' {\n                ^~~\n                \"h\"\n/tmp/tmpnfi1k8sv.swift:46:29:\
    \ error: single-quoted string literal found, use '\"'\n        if k == 'h' ||\
    \ k == 'l' || k == 'm' || k == 'n' || k == 't' {\n                           \
    \ ^~~\n                            \"l\"\n/tmp/tmpnfi1k8sv.s"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var index = 0\n    var count = 0\n    for char in s {\n        if char ==\
    \ \" \" {\n            if count < n {\n                result.append(String(s[index]))\n\
    \                count += 1\n            }\n            index++\n            count\
    \ = 0\n        } else {\n            count += 1\n        }\n    }\n    if count\
    \ < n {\n        result.append(String(s[index]))\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp32quwdn9.swift:25:38: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                result.append(String(s[index]))\n\
    \                                     ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp32quwdn9.swift:28:18: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            index++\n   \
    \              ^~\n/tmp/tmp32quwdn9.swift:35:30: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        result.append(String(s[index]))\n\
    \                             ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8w845vtg.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8w845vtg.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    if s == \"\" {\n        return words\n    }\n    \n    for letter in s {\n\
    \        if letter == \" \" {\n            words = append(words, \"\")\n     \
    \   } else {\n            if letter == \"a\" || letter == \"e\" || letter == \"\
    i\" || letter == \"o\" || letter == \"u\" {\n                words = append(words,\
    \ letter)\n            } else {\n                let count = count_consonants(letter)\n\
    \                if count == n {\n                    words = append(words, letter)\n\
    \                }\n            }\n        }\n    }\n    return words\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwvb5tl1h.swift:26:21: error: cannot find 'append' in scope\n  \
    \          words = append(words, \"\")\n                    ^~~~~~\n/tmp/tmpwvb5tl1h.swift:29:25:\
    \ error: cannot find 'append' in scope\n                words = append(words,\
    \ letter)\n                        ^~~~~~\n/tmp/tmpwvb5tl1h.swift:31:29: error:\
    \ cannot find 'count_consonants' in scope\n                let count = count_consonants(letter)\n\
    \                            ^~~~~~~~~~~~~~~~\n/tmp/tmpwvb5tl1h.swift:33:29: error:\
    \ cannot find 'append' in scope\n                    words = append(words, letter)\n\
    \                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i = j\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"y\" {\n            i = j\n        }\n  \
    \      \n        if char == \"s\" {\n            i = j\n        }\n        \n\
    \        if char == \"d\" {\n            i = j\n        }\n        \n        if\
    \ char == \"h\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"l\" {\n            i = j\n        }\n        \n        if char == \"m\" {\n\
    \            i = j\n        }\n        \n        if char == \"n\" {\n        \
    \    i = j\n        }\n        \n        if char == \"t\" {\n            i = j\n\
    \        }\n        \n        if char == \"k\" {\n            i = j\n        }\n\
    \        \n        if char == \"p\" {\n            i = j\n        }\n        \n\
    \        if char == \"r\" {\n            i = j\n        }\n        \n        if\
    \ char == \"f\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"v\" {\n            i = j\n        }\n        \n        if char == \"b\" {\n\
    \            i = j\n        }\n        \n        if char == \"j\" {\n        \
    \    i = j\n        }\n        \n        if char == \"q\" {\n            i = j\n\
    \        }\n        \n        if char == \"g\" {\n            i = j\n        }\n\
    \        \n        if char == \"z\" {\n            i = j\n        }\n        \n\
    \        if char == \"x\" {\n            i = j\n        }\n        \n        if\
    \ char == \"q\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"z\" {\n            i = j\n        }\n        \n        if char == \"c\" {\n\
    \            i = j\n        }\n        \n        if char == \"k\" {\n        \
    \    i = j\n        }\n        \n        if char == \"p\" {\n            i = j\n\
    \        }\n        \n        if char == \"r\" {\n            i = j\n        }\n\
    \        \n        if char == \"f\" {\n            i = j\n        }\n        \n\
    \        if char == \"v\" {\n            i = j\n        }\n        \n        if\
    \ char == \"b\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"j\" {\n            i = j\n        }\n        \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp06xueeb5.swift:174:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp06xueeb5.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp06xueeb5.swift:156:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp06xueeb5.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n/tmp/tmp06xueeb5.swift:25:9:\
    \ warning: variable 'i' was written to, but never read\n    var i = 0\n      \
    \  ^\n/tmp/tmp06xueeb5.swift:26:9: warning: variable 'j' was never mutated; consider\
    \ changing to 'let' constant\n    var j = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n\
    \ {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9r7bo5r9.swift:26:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isConsonant'\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n                                        ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonants {\n            if char.consonants.count\
    \ == n {\n                result.append(String(char))\n            }\n       \
    \ }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdyejay9l.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdyejay9l.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdyejay9l.swift:27:21: error: value\
    \ of type 'Character' has no member 'consonants'\n            if char.consonants.count\
    \ == n {\n               ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = s.characters.count\n    var n =\
    \ n\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = s.characters.count\n\
    \    var s = \"\"\n    var t = \"\"\n    var u = \"\"\n    var v = \"\"\n    var\
    \ w = 0\n    var x = \"\"\n    var y = \"\"\n    var z = \"\"\n    var aa = \"\
    \"\n    var ab = \"\"\n    var ac = \"\"\n    var ad = \"\"\n    var ae = \"\"\
    \n    var af = \"\"\n    var ag = \"\"\n    var ah = \"\"\n    var ai = \"\"\n\
    \    var aj = \"\"\n    var ak = \"\"\n    var al = \"\"\n    var am = \"\"\n\
    \    var an = \"\"\n    var ao = \"\"\n    var ap = \"\"\n    var aq = \"\"\n\
    \    var ar = \"\"\n    var as = \"\"\n    var at = \"\"\n    var au = \"\"\n\
    \    var av = \"\"\n    var aw = \"\"\n    var ax = \"\"\n    var ay = \"\"\n\
    \    var az = \"\"\n    var aA = \"\"\n    var aB = \"\"\n    var aC = \"\"\n\
    \    var aD = \"\"\n    var aE = \"\"\n    var aF = \"\"\n    var aG = \"\"\n\
    \    var aH = \"\"\n    var aI = \"\"\n    var aJ = \"\"\n    var aK = \"\"\n\
    \    var aL = \"\"\n    var aM = \"\"\n    var aN = \"\"\n    var aO = \"\"\n\
    \    var aP = \"\"\n    var aQ = \"\"\n    var aR = \"\"\n    var aS = \"\"\n\
    \    var aT = \"\"\n    var aU = \"\"\n    var aV = \"\"\n    var aW = \"\"\n\
    \    var aX = \"\"\n    var aY = \"\"\n    var aZ = \"\"\n    var aAA = \"\"\n\
    \    var aAB = \"\"\n    var aAC = \"\"\n    var aAD = \"\"\n    var aAE = \"\"\
    \n    var aAF = \"\"\n    var aAG = \"\"\n    var aAH = \"\"\n    var aAI = \"\
    \"\n    var aAJ = \"\"\n    var aAK = \"\"\n    var aAL = \"\"\n    var aAM =\
    \ \"\"\n    var aAN = \"\"\n    var aAO = \"\"\n    var aAP = \"\"\n    var aAQ\
    \ = \"\"\n    var aAR = \"\"\n    var aAS = \"\"\n    var aAT = \"\"\n    var\
    \ aAU = \"\"\n    var aAV = \"\"\n    var aAW = \"\"\n    var aAX = \"\"\n   \
    \ var aAY = \"\"\n    var aAZ = \"\"\n    var aAaA = \"\"\n    var aAaB = \"\"\
    \n    var aAaC = \"\"\n    var aAaD = \"\"\n    var aAaE = \"\"\n    var aAaF\
    \ = \"\"\n    var aAaG = \"\"\n    var aAaH = \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkqfmks99.swift:59:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = \"\"\n        ^\n/tmp/tmpkqfmks99.swift:59:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = \"\"\n       \
    \ ^~\n        `as`\n/tmp/tmpkqfmks99.swift:27:15: error: 'characters' is unavailable:\
    \ Please use String directly\n    var m = s.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkqfmks99.swift:32:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    var r =\
    \ s.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkqfmks99.swift:19:9: warning: variable 'result' was\
    \ never mutated; consider changing to 'let' constant\n    var result = [String]()\n\
    \    ~~~ ^\n    let\n/tmp/tmpkqfmks99.swift:23:9: warning: initialization of variable\
    \ 'i' was never used; consider replacing with assignment to '_' or removing it\n\
    \    var i = 0\n    ~~~~^\n    _\n/tmp/tmpkqfmks99.swift:24:9: warning: initialization\
    \ of variable 'j' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpkqfmks99.swift:25:9: warning:\
    \ initialization of variable 'k' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpkqfmks99.swift:26:9:\
    \ warning: initialization of variable 'l' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var l = 0\n    ~~~~^\n    _\n/tmp/tmpkqfmks99.swift:27:9:\
    \ warning: initialization of variable 'm' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var m = s.characters.count\n    ~~~~^\n\
    \    _\n/tmp/tmpkqfmks99.swift:28:9: warning: initialization of variable 'n' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ n = n\n    ~~~~^\n    _\n/tmp/tmpkqfmks99.swift:29:9: warning: initial"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            \n            while j < s.count &&\
    \ s[j] != \" \" {\n                j += 1\n            }\n            \n     \
    \       if j == s.count {\n                result.append(\"\\n\")\n          \
    \  }\n            \n            i += j - i\n            \n        } else {\n \
    \           k = i\n            \n            while k < s.count && s[k] != \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            i += k - i\n        }\n    }\n    \n    if n <= result.count\
    \ {\n        return result\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2o_68vqg.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp2o_68vqg.swift:33:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmp2o_68vqg.swift:46:34: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   while k < s.count && s[k] != \" \" {\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            words.append(s[i : j])\n            i = j\n           \
    \ j = 0\n            k = i\n        } else {\n            j += 1\n        }\n\
    \    }\n    \n    for i < s.count {\n        if s[k] == \" \" {\n            words.append(s[i\
    \ : k])\n            i = k\n            k = 0\n        } else {\n            k\
    \ += 1\n        }\n    }\n    \n    for i < s.count {\n        if s[k] == \" \"\
    \ {\n            words.append(s[i : k])\n            i = k\n            k = 0\n\
    \        } else {\n            k += 1\n        }\n    }\n    \n    for i < s.count\
    \ {\n        if s[k] == \" \" {\n            words.append(s[i : k])\n        \
    \    i = k\n            k = 0\n        } else {\n            k += 1\n        }\n\
    \    }\n    \n    for i < s.count {\n        if s[k] == \" \" {\n            words.append(s[i\
    \ : k])\n            i = k\n            k = 0\n        } else {\n            k\
    \ += 1\n        }\n    }\n    \n    for i < s.count {\n        if s[k] == \" \"\
    \ {\n            words.append(s[i : k])\n            i = k\n            k = 0\n\
    \        } else {\n            k += 1\n        }\n    }\n    \n    for i < s.count\
    \ {\n        if s[k] == \" \" {\n            words.append(s[i : k])\n        \
    \    i = k\n            k = 0\n        } else {\n            k += 1\n        }\n\
    \    }\n    \n    for i < s.count {\n        if s[k] == \" \" {\n            words.append(s[i\
    \ : k])\n            i = k\n            k = 0\n        } else {\n            k\
    \ += 1\n        }\n    }\n    \n    for i < s.count {\n        if s[k] == \" \"\
    \ {\n            words.append(s[i : k])\n            i = k\n            k = 0\n\
    \        } else {\n            k += 1\n        }\n    }\n    \n    for i < s.count\
    \ {\n        if s[k] == \" \" {\n            words.append(s[i : k])\n        \
    \    i = k\n            k = 0\n        } else {\n            k += 1\n        }\n\
    \    }\n    \n    for i < s.count {\n        if s[k] == \" \" {\n            words.append(s[i\
    \ : k])\n            i = k\n            k = 0\n        } else {\n            k\
    \ += 1\n        }\n    }\n    \n    for i < s.count {\n        if s[k] == \" \"\
    \ {\n            words.append(s[i : k])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwrw0hvyf.swift:30:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:30:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpwrw0hvyf.swift:41:11: error: expected 'in' after\
    \ for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:41:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:51:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:51:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:61:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:61:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:71:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:71:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:81:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:81:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:91:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:91:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:101:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count {\n          ^\n/tmp/tmpwrw0hvyf.swift:101:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.count\
    \ {\n          ^~\n           \n/tmp/tmpwrw0hvyf.swift:111:11: error: expected\
    \ 'in' after for-each pattern\n    for i < s.count"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"a\" {\n            if j == 0 {\n                i += 1\n  \
    \              continue\n            }\n            \n            if s[j-1] ==\
    \ \"a\" {\n                j += 1\n                continue\n            }\n \
    \           \n            if k == 0 {\n                i += 1\n              \
    \  continue\n            }\n            \n            if s[k-1] == \"a\" {\n \
    \               k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if k == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n            }\n            \n\
    \            if j == n {\n                i += 1\n                j += 1\n   \
    \             k += 1\n                continue\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmxj_wa7l.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpmxj_wa7l.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpmxj_wa7l.swift:194:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpmxj_wa7l.swift:35:24: note: to match this opening\
    \ '{'\n        if s[i] == \"a\" {\n                       ^\n/tmp/tmpmxj_wa7l.swift:194:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpmxj_wa7l.swift:29:21:\
    \ note: to match this opening '{'\n    for i < s.count {\n                   \
    \ ^\n/tmp/tmpmxj_wa7l.swift:194:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpmxj_wa7l.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpmxj_wa7l.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i = j\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"y\" || char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"y\" || char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"y\" || char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"y\" || char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"y\" || char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"y\" || char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\
    \            i = j\n        }\n        \n        if char == \"y\" || char == \"\
    a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n  \
    \          i = j\n        }\n        \n        if char == \"y\" || char == \"\
    a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n  \
    \          i = j\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \"y\" || char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9btx_3b8.swift:87:1: error: expected expression in assignment\n\
    }\n^\n/tmp/tmp9btx_3b8.swift:108:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9btx_3b8.swift:28:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmp9btx_3b8.swift:108:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9btx_3b8.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp9btx_3b8.swift:90:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   var i = 0\n    var j = 0\n    \n    for char in s {\n        if char == \"\
    \ \" {\n            i = j\n        }\n        \n        if char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            j\
    \ = i\n        }\n        \n        if char == \"n\" {\n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n                i = j\n            }\n            \n            if i == j\
    \ {\n                j = i\n            }\n            \n            if j == i\
    \ {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1gl8g_te.swift:186:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp1gl8g_te.swift:38:24:\
    \ note: to match this opening '{'\n        if char == \"n\" {\n              \
    \         ^\n/tmp/tmp1gl8g_te.swift:186:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmp1gl8g_te.swift:29:19: note: to match this opening '{'\n    for\
    \ char in s {\n                  ^\n/tmp/tmp1gl8g_te.swift:186:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp1gl8g_te.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp1gl8g_te.swift:168:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp1gl8g_te.swift:20:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qx0tjr_.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp3qx0tjr_.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp3qx0"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    let chars =\
    \ s.characters\n    \n    for char in chars {\n        if char.hasConsonants {\n\
    \            if char.consonants.count == n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd3_b2ac3.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd3_b2ac3.swift:28:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpd3_b2ac3.swift:29:21: error: value\
    \ of type 'Character' has no member 'consonants'\n            if char.consonants.count\
    \ == n {\n               ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   var i = 0\n    var j = 0\n    \n    while i < s.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo8mqmhs_.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpo8mqmhs_.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpo8mqmhs_.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpo8mqmhs_.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpo8mqmhs_.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo8mqmhs_.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo8mqmhs_.swift:40:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo8mqmhs_.swift:45:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo8mqmhs_.swift:50:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014336
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO: Write your\
    \ code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpnh9gddyp/tmpnh9gddyp.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d2b69ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d2b391b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d2b391988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d2b3907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnh9gddyp                        0x0000560226d5a4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b0d2b886460 __libc_start_main +
    245

    6    tmpnh9gddyp                        0x0000560226d5a0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014285
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < n {\n        \
    \        words.append(String(s[j:k]))\n                j = k\n               \
    \ k += 1\n            }\n            \n            i = j\n        }\n        \n\
    \        i += 1\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnpdiyq_l.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpnpdiyq_l.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpnpdiyq_l.swift:33:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpnpdiyq_l.swift:33:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < n {\n                  ^~\n                   \n/tmp/tmpnpdiyq_l.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpnpdiyq_l.swift:33:19: error: '<' is not a prefix unary operator\n\
    \            for k < n {\n                  ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s.isEmpty {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"n\" {\n            i += 1\n            continue\n \
    \       }\n        \n        if s[i] == \"t\" || s[i] == \"s\" || s[i] == \"h\"\
    \ || s[i] == \"r\" || s[i] == \"d\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"\
    m\" || s[i] == \"p\" || s[i] == \"v\" || s[i] == \"f\" || s[i] == \"g\" || s[i]\
    \ == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i] == \"l\" || s[i] == \"m\"\
    \ || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\" || s[i] == \"r\" || s[i]\
    \ == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"w\" || s[i] == \"x\"\
    \ || s[i] == \"y\" || s[i] == \"z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"A\" || s[i] == \"E\" || s[i] == \"\
    I\" || s[i] == \"O\" || s[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"N\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"T\" || s[i] == \"S\"\
    \ || s[i] == \"H\" || s[i] == \"R\" || s[i] == \"D\" {\n            i += 1\n \
    \           continue\n        }\n        \n        if s[i] == \"B\" || s[i] ==\
    \ \"C\" || s[i] == \"M\" || s[i] == \"P\" || s[i] == \"V\" || s[i] == \"F\" ||\
    \ s[i] == \"G\" || s[i] == \"H\" || s[i] == \"J\" || s[i] == \"K\" || s[i] ==\
    \ \"L\" || s[i] == \"M\" || s[i] == \"N\" || s[i] == \"P\" || s[i] == \"Q\" ||\
    \ s[i] == \"R\" || s[i] == \"S\" || s[i] == \"T\" || s[i] == \"V\" || s[i] ==\
    \ \"W\" || s[i] == \"X\" || s[i] == \"Y\" || s[i] == \"Z\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"0\" {\n \
    \           i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"1\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"2\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"3\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"4\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"5\" {\n            i\
    \ += 1\n            continue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdwz62ka6.swift:124:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpdwz62ka6.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpdwz62ka6.swift:124:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpdwz62ka6.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpdwz62ka6.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdwz62ka6.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdwz62ka6.swift:35:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdwz62ka6.swift:35:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                   "
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s.characters {\n        if let index = s.firstIndex(of: letter)\
    \ {\n            if index == s.startIndex {\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \            } else if index == s.endIndex {\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \            } else {\n                result.append(s[s.startIndex..<index])\n\
    \                result.append(s[index..<s.endIndex])\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp41_kptfc.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp41_kptfc.swift:23:32:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \                               ^\nSwift.String:5:12: note: where 'R.Bound' =\
    \ 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:25:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.startIndex..<s.endIndex])\n               \
    \                ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:27:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.startIndex..<index])\n                    \
    \           ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n   \
    \ public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:28:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[index..<s.endIndex])\n                      \
    \         ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = s.count\n    var n = m\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = s.count\n    var s = \"\"\n\
    \    var t = \"\"\n    var u = \"\"\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac\
    \ = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var\
    \ ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n   \
    \ var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n\
    \    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av =\
    \ 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba\
    \ = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var\
    \ bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n   \
    \ var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n\
    \    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var bt =\
    \ 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n    var bx = 0\n    var by\
    \ = 0\n    var bz = 0\n    var ca = 0\n    var cb = 0\n    var cc = 0\n    var\
    \ cd = 0\n    var ce = 0\n    var cf = 0\n    var cg = 0\n    var ch = 0\n   \
    \ var ci = 0\n    var cj = 0\n    var ck = 0\n    var cl = 0\n    var cm = 0\n\
    \    var cn = 0\n    var co = 0\n    var cp = 0\n    var cq = 0\n    var cr =\
    \ 0\n    var cs = 0\n    var ct = 0\n    var cu = 0\n    var cv = 0\n    var cw\
    \ = 0\n    var cx = 0\n    var cy = 0\n    var cz = 0\n    var da = 0\n    var\
    \ db = 0\n    var dc = 0\n    var dd = 0\n    var de = 0\n    var df = 0\n   \
    \ var dg = 0\n    var dh = 0\n    var di = 0\n    var dj = 0\n    var dk = 0\n\
    \    var dl = 0\n    var dm = 0\n    var dn = 0\n    var do = 0\n    var dp =\
    \ 0\n    var dq = 0\n    var dr = 0\n    var ds = 0\n    var dt = 0\n    var du\
    \ = 0\n    var dv = 0\n    var dw = 0\n    var dx = 0\n    var dy = 0\n    var\
    \ dz = 0\n    var ea = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3g0xzn5.swift:59:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpq3g0xzn5.swift:59:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpq3g0xzn5.swift:133:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpq3g0xzn5.swift:133:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpq3g0xzn5.swift:19:9: warning: variable\
    \ 'result' was never mutated; consider changing to 'let' constant\n    var result\
    \ = [String]()\n    ~~~ ^\n    let\n/tmp/tmpq3g0xzn5.swift:23:9: warning: initialization\
    \ of variable 'i' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:24:9: warning:\
    \ initialization of variable 'j' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:25:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:26:9:\
    \ warning: initialization of variable 'l' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var l = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:27:9:\
    \ warning: variable 'm' was never mutated; consider changing to 'let' constant\n\
    \    var m = s.count\n    ~~~ ^\n    let\n/tmp/tmpq3g0xzn5.swift:28:9: warning:\
    \ initialization of variable 'n' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var n = m\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:29:9:\
    \ warning: initialization of variable 'o' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var o = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:30:9:\
    \ warning: initialization of variable 'p' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var p = 0\n    ~~~~^\n    _\n/tmp/tmpq3g0xzn5.swift:31:9:\
    \ warning: initialization of var"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var result =\
    \ [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n \
    \   let vowels = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n      \
    \  if vowels.contains(String(char)) {\n            if result.count < n {\n   \
    \             result.append(String(char))\n            }\n        }\n    }\n \
    \   \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp__tb5488.swift:28:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb0nxozo2.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpb0nxozo2.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpb0nxozo2.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpb0nxozo2.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpb0nxozo2.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpb0nxozo2.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpb0nxozo2.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpb0nxozo2.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpb0nxozo2.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpb0nxozo2.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpb0nxozo2.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpb0nxozo2.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpb0nx"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.characters.count >= n {\n \
    \           result.append(word)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq21wwwex.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s.characters {\n        if let index = s.firstIndex(of: letter)\
    \ {\n            if index == s.startIndex {\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \            } else if index == s.endIndex {\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \            } else {\n                result.append(s[s.startIndex..<index])\n\
    \                result.append(s[index..<s.endIndex])\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp41_kptfc.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp41_kptfc.swift:23:32:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \                               ^\nSwift.String:5:12: note: where 'R.Bound' =\
    \ 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:25:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.startIndex..<s.endIndex])\n               \
    \                ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:27:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.startIndex..<index])\n                    \
    \           ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n   \
    \ public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp41_kptfc.swift:28:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[index..<s.endIndex])\n                      \
    \         ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    if s == \"\" {\n        return words\n    }\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var\
    \ e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o =\
    \ 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n\
    \    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n \
    \   var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n\
    \    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n \
    \   var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n  \
    \  var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n   \
    \ var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var\
    \ y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d\
    \ = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i =\
    \ 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n\
    \    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n \
    \   var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n  \
    \  var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n   \
    \ var d = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphzyg23i1.swift:149:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmphzyg23i1.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmphzyg23i1.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmphzyg23i1.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmphzyg23i1.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmphzyg23i1.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmphzyg23i1.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmphzyg23i1.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmphzyg23i1.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmphzyg23i1.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmphzyg23i1.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmphzyg23i1.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmphzyg23i1.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmphzyg23i1.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmphzyg23i1.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmphzyg23i1.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmphzyg23i1.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmphzyg23i1.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmphzyg23i1.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmphzyg23i1.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmphzyg23i1.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmphzyg23i1.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmphzyg23i1.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmphzyg23i1.swift:60:9: "
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if j == n {\n \
    \           if k == 0 {\n                result.append(String(s[i:j]))\n     \
    \       }\n            \n            i = j\n            j += 1\n            k\
    \ = 0\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n \
    \       }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n        }\n       \
    \ \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n    \
    \    if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjxvahi2j.swift:164:11: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmpjxvahi2j.swift:186:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpjxvahi2j.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpjxvahi2j.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjxvahi2j.swift:36:39:\
    \ error: extraneous argument label 'i:' in subscript\n                result.append(String(s[i:j]))\n\
    \                                      ^~~\n                                 \
    \      \n/tmp/tmpjxvahi2j.swift:44:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpjxvahi2j.swift:48:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjxvahi2j.swift:52:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjxvahi2j.swift:56:12: error: 'subscript(_:)'\
    \ i"
  stdout: ''
  timestamp: 1660014336
