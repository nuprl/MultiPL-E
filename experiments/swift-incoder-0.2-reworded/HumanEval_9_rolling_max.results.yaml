language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number == max {\n  \
    \          result.append(max)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp55ys734m/tmp55ys734m.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0423eb5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0423bacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0423bac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0423bab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55ys734m                        0x000055647092d66d <unavailable> + 5741

    5    libc.so.6                          0x00002b04240a1460 __libc_start_main +
    245

    6    tmp55ys734m                        0x000055647092d189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = -1\n    for\
    \ index in 1..<numbers.count {\n        if numbers[index] > max {\n          \
    \  max = numbers[index]\n            maxIndex = index\n        }\n    }\n    return\
    \ Array(numbers[0..<maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a1249bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a12192561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0a12192286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0a1219213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0a12191bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0a11f91e83 <unavailable> + 188035

    6    tmpm0y12pgq                        0x0000555f7ffdfb78 <unavailable> + 7032

    7    tmpm0y12pgq                        0x0000555f7ffdf64d <unavailable> + 5709

    8    libc.so.6                          0x00002b0a12687460 __libc_start_main +
    245

    9    tmpm0y12pgq                        0x0000555f7ffdf359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_index = -1\n    for\
    \ index in 1..<numbers.count {\n        if numbers[index] > max {\n          \
    \  max = numbers[index]\n            max_index = index\n        }\n    }\n   \
    \ return Array(numbers[0..<max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aec6edd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec6ead0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aec6ead0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aec6ead013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aec6eacfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aec6e8cfe83 <unavailable> + 188035

    6    tmp6bx7bkp9                        0x00005618cd396b78 <unavailable> + 7032

    7    tmp6bx7bkp9                        0x00005618cd39664d <unavailable> + 5709

    8    libc.so.6                          0x00002aec6efc5460 __libc_start_main +
    245

    9    tmp6bx7bkp9                        0x00005618cd396359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for index\
    \ in 1..<numbers.count {\n        if numbers[index] > max {\n            max =\
    \ numbers[index]\n            maxIndex = index\n        }\n    }\n    return Array(numbers[0..<maxIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5987dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5984d6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae5984d6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae5984d613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae5984d5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae5982d5e83 <unavailable> + 188035

    6    tmpi4f1yifq                        0x000055cd8c384b78 <unavailable> + 7032

    7    tmpi4f1yifq                        0x000055cd8c38464d <unavailable> + 5709

    8    libc.so.6                          0x00002ae5989cb460 __libc_start_main +
    245

    9    tmpi4f1yifq                        0x000055cd8c384359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max[index] = number\n\
    \        }\n        index++\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8sf1izgd.swift:13:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = [number, max[index]]\n        }\n       \
    \ index++\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpn561w30m.swift:15:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if index == 0 {\n            max = number\n        } else\
    \ {\n            if number > max[index] {\n                max = [Int]()\n   \
    \             max[index] = number\n            }\n        }\n        index +=\
    \ 1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0sogvgoy.swift:11:19: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = number\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if max != nil {\n            if number > max[0] {\n                max =\
    \ [number]\n            } else {\n                max!.append(number)\n      \
    \      }\n        } else {\n            max = [number]\n        }\n    }\n   \
    \ return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpw8i7yex1.swift:9:16: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns true\n        if max != nil {\n           ~~~\
    \ ^  ~~~\n/tmp/tmpw8i7yex1.swift:13:20: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n                max!.append(number)\n                ~~~^\n  \
    \                 \n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rolling_max = numbers[0]\n\
    \    for number in numbers {\n        if number > max {\n            max = number\n\
    \        } else {\n            rolling_max = number\n        }\n    }\n    return\
    \ rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppudr6ovu.swift:16:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number > max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpxzn6p49v/tmpxzn6p49v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dea86bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dea562b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dea562988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dea5617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzn6p49v                        0x0000562dc2f5d6cd <unavailable> + 5837

    5    libc.so.6                          0x00002b3deaa57460 __libc_start_main +
    245

    6    tmpxzn6p49v                        0x0000562dc2f5d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number > max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpxzn6p49v/tmpxzn6p49v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dea86bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dea562b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dea562988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dea5617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzn6p49v                        0x0000562dc2f5d6cd <unavailable> + 5837

    5    libc.so.6                          0x00002b3deaa57460 __libc_start_main +
    245

    6    tmpxzn6p49v                        0x0000562dc2f5d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(max)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmplbng7qsx/tmplbng7qsx.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e20f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e20c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e20c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e20c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplbng7qsx                        0x000055a7e87fe66d <unavailable> + 5741

    5    libc.so.6                          0x00002b7e21134460 __libc_start_main +
    245

    6    tmplbng7qsx                        0x000055a7e87fe189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number == max {\n  \
    \          result.append(number)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpc706cptz/tmpc706cptz.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52ec915c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52ec60cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52ec60c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52ec60b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc706cptz                        0x000055c9edcf466d <unavailable> + 5741

    5    libc.so.6                          0x00002b52ecb01460 __libc_start_main +
    245

    6    tmpc706cptz                        0x000055c9edcf4189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if max != nil {\n            if number > max[0] {\n                max[0]\
    \ = number\n            }\n        } else {\n            max = [number]\n    \
    \    }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acebcc7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acebc971561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acebc971286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acebc97113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acebc970bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acebc770e83 <unavailable> + 188035

    6    tmp15ll44ou                        0x0000562f2a314b72 <unavailable> + 7026

    7    tmp15ll44ou                        0x0000562f2a314635 <unavailable> + 5685

    8    libc.so.6                          0x00002acebce66460 __libc_start_main +
    245

    9    tmp15ll44ou                        0x0000562f2a314239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rolling_max = numbers[0]\n\
    \    for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n        if number > rolling_max {\n            rolling_max = number\n\
    \        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpa4vl2n3f.swift:17:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(max)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmplbng7qsx/tmplbng7qsx.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e20f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e20c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e20c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e20c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplbng7qsx                        0x000055a7e87fe66d <unavailable> + 5741

    5    libc.so.6                          0x00002b7e21134460 __libc_start_main +
    245

    6    tmplbng7qsx                        0x000055a7e87fe189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if max != nil {\n            if number > max[0] {\n                max =\
    \ [number]\n            } else {\n                max = [number] + max\n     \
    \       }\n        } else {\n            max = [number]\n        }\n    }\n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e08de6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e08add561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0e08add286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0e08add13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0e08adcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0e088dce83 <unavailable> + 188035

    6    tmpu01j8rdp                        0x000055c9006a0b57 <unavailable> + 6999

    7    tmpu01j8rdp                        0x000055c9006a0635 <unavailable> + 5685

    8    libc.so.6                          0x00002b0e08fd2460 __libc_start_main +
    245

    9    tmpu01j8rdp                        0x000055c9006a0239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        \
    \    maxIndex = numbers.indexOf(max)\n        }\n    }\n    return numbers.suffix(maxIndex).prefix(numbers.indexOf(max))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpdlvv383_.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(max)\n                   \
    \    ~~~~~~~ ^~~~~~~\n/tmp/tmpdlvv383_.swift:15:44: error: missing argument label\
    \ 'while:' in call\n    return numbers.suffix(maxIndex).prefix(numbers.indexOf(max))\n\
    \                                           ^\n                              \
    \             while: \n/tmp/tmpdlvv383_.swift:15:52: error: value of type '[Int]'\
    \ has no member 'indexOf'\n    return numbers.suffix(maxIndex).prefix(numbers.indexOf(max))\n\
    \                                           ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(max)\n            max = number\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmptu19wr6y/tmptu19wr6y.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2084805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20844fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20844fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20844fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptu19wr6y                        0x00005582a68ed66d <unavailable> + 5741

    5    libc.so.6                          0x00002b20849f1460 __libc_start_main +
    245

    6    tmptu19wr6y                        0x00005582a68ed189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max: Int = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number > max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpm6vch6yf/tmpm6vch6yf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7b6ad6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7b67cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7b67cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7b67cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm6vch6yf                        0x00005580d55786cd <unavailable> + 5837

    5    libc.so.6                          0x00002ad7b6cc2460 __libc_start_main +
    245

    6    tmpm6vch6yf                        0x00005580d55781e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var rolling_max_index\
    \ = 0\n    for number in numbers {\n        if number > rolling_max[rolling_max_index]\
    \ {\n            rolling_max[rolling_max_index] = number\n            rolling_max_index\
    \ += 1\n        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a89d35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a89a2c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6a89a2c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6a89a2c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6a89a2bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6a8982be83 <unavailable> + 188035

    6    tmp11y4j5n_                        0x000055dc41faab1d <unavailable> + 6941

    7    tmp11y4j5n_                        0x000055dc41faa635 <unavailable> + 5685

    8    libc.so.6                          0x00002b6a89f21460 __libc_start_main +
    245

    9    tmp11y4j5n_                        0x000055dc41faa239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        \
    \    maxIndex = numbers.indexOf(max)\n        }\n    }\n    return numbers.suffix(maxIndex\
    \ + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpnv05t4ie.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(max)\n                   \
    \    ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_index = -1\n    for\
    \ index in 1..<numbers.count {\n        if numbers[index] > max {\n          \
    \  max = numbers[index]\n            max_index = index\n        }\n    }\n   \
    \ return Array(numbers[0..<max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aec6edd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec6ead0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aec6ead0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aec6ead013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aec6eacfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aec6e8cfe83 <unavailable> + 188035

    6    tmp6bx7bkp9                        0x00005618cd396b78 <unavailable> + 7032

    7    tmp6bx7bkp9                        0x00005618cd39664d <unavailable> + 5709

    8    libc.so.6                          0x00002aec6efc5460 __libc_start_main +
    245

    9    tmp6bx7bkp9                        0x00005618cd396359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var max_number = 0\n \
    \   for number in numbers {\n        if number > max_number {\n            rolling_max\
    \ = [number]\n            max_number = number\n        } else {\n            rolling_max\
    \ = [max_number, number]\n        }\n    }\n    return rolling_max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpnvz76rxs/tmpnvz76rxs.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73df880c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73df577b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73df577988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73df5767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnvz76rxs                        0x000055601db1366d <unavailable> + 5741

    5    libc.so.6                          0x00002b73dfa6c460 __libc_start_main +
    245

    6    tmpnvz76rxs                        0x000055601db13189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [Int](repeating:\
    \ number, count: index + 1)\n        }\n        max[index] = number\n        index\
    \ += 1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1723365c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b172305c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b172305c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b172305c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b172305bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1722e5be83 <unavailable> + 188035

    6    tmpo54492z1                        0x000055981dd34b83 <unavailable> + 7043

    7    tmpo54492z1                        0x000055981dd34695 <unavailable> + 5781

    8    libc.so.6                          0x00002b1723551460 __libc_start_main +
    245

    9    tmpo54492z1                        0x000055981dd34299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for n in numbers\
    \ {\n        if index == 0 {\n            max = n\n        } else {\n        \
    \    if n > max[index] {\n                max = [n]\n            } else {\n  \
    \              max[index] = n\n            }\n        }\n        index++\n   \
    \ }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpjbds0izn.swift:11:19: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = n\n                  ^\n/tmp/tmpjbds0izn.swift:19:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max[index] = number\n\
    \        }\n        index++\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8sf1izgd.swift:13:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number > max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpxzn6p49v/tmpxzn6p49v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dea86bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dea562b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dea562988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dea5617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzn6p49v                        0x0000562dc2f5d6cd <unavailable> + 5837

    5    libc.so.6                          0x00002b3deaa57460 __libc_start_main +
    245

    6    tmpxzn6p49v                        0x0000562dc2f5d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > rolling_max {\n            rolling_max = numbers[i]\n\
    \        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp250xh_h7.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        \
    \    maxIndex = numbers.indexOf(max)\n        }\n    }\n    var result = [Int]()\n\
    \    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    result.remove(at: maxIndex + 1)\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpg67hwtsv.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(max)\n                   \
    \    ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(max)\n            max = number\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmptu19wr6y/tmptu19wr6y.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2084805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20844fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20844fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20844fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptu19wr6y                        0x00005582a68ed66d <unavailable> + 5741

    5    libc.so.6                          0x00002b20849f1460 __libc_start_main +
    245

    6    tmptu19wr6y                        0x00005582a68ed189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(number)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpic_tr7wj/tmpic_tr7wj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b474de27c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b474db1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b474db1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b474db1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpic_tr7wj                        0x00005571797bb66d <unavailable> + 5741

    5    libc.so.6                          0x00002b474e013460 __libc_start_main +
    245

    6    tmpic_tr7wj                        0x00005571797bb189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        \
    \    maxIndex = numbers.indexOf(max)\n        }\n    }\n    var result = [Int]()\n\
    \    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5k20fmp0.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(max)\n                   \
    \    ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for n in numbers\
    \ {\n        if index == 0 {\n            max = n\n        } else {\n        \
    \    if n > max[index] {\n                max[index] = n\n            }\n    \
    \    }\n        index++\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpnq39wpd_.swift:11:19: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = n\n                  ^\n/tmp/tmpnq39wpd_.swift:17:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if max != nil {\n            if number > max[0] {\n                max =\
    \ [number]\n            } else {\n                max = [number] + max\n     \
    \       }\n        } else {\n            max = [number]\n        }\n    }\n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e08de6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e08add561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0e08add286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0e08add13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0e08adcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0e088dce83 <unavailable> + 188035

    6    tmpu01j8rdp                        0x000055c9006a0b57 <unavailable> + 6999

    7    tmpu01j8rdp                        0x000055c9006a0635 <unavailable> + 5685

    8    libc.so.6                          0x00002b0e08fd2460 __libc_start_main +
    245

    9    tmpu01j8rdp                        0x000055c9006a0239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for index\
    \ in 1..<numbers.count {\n        if numbers[index] > max {\n            max =\
    \ numbers[index]\n            maxIndex = index\n        }\n    }\n    return Array(numbers[0..<maxIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5987dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5984d6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae5984d6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae5984d613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae5984d5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae5982d5e83 <unavailable> + 188035

    6    tmpi4f1yifq                        0x000055cd8c384b78 <unavailable> + 7032

    7    tmpi4f1yifq                        0x000055cd8c38464d <unavailable> + 5709

    8    libc.so.6                          0x00002ae5989cb460 __libc_start_main +
    245

    9    tmpi4f1yifq                        0x000055cd8c384359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number > max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpxzn6p49v/tmpxzn6p49v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dea86bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dea562b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dea562988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dea5617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzn6p49v                        0x0000562dc2f5d6cd <unavailable> + 5837

    5    libc.so.6                          0x00002b3deaa57460 __libc_start_main +
    245

    6    tmpxzn6p49v                        0x0000562dc2f5d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_index = -1\n    for\
    \ index in 1..<numbers.count {\n        if numbers[index] > max {\n          \
    \  max = numbers[index]\n            max_index = index\n        }\n    }\n   \
    \ return Array(numbers[0..<max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aec6edd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec6ead0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aec6ead0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aec6ead013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aec6eacfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aec6e8cfe83 <unavailable> + 188035

    6    tmp6bx7bkp9                        0x00005618cd396b78 <unavailable> + 7032

    7    tmp6bx7bkp9                        0x00005618cd39664d <unavailable> + 5709

    8    libc.so.6                          0x00002aec6efc5460 __libc_start_main +
    245

    9    tmp6bx7bkp9                        0x00005618cd396359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if index == 0 {\n            max = number\n        } else\
    \ {\n            if number > max[index] {\n                max = [Int]()\n   \
    \         }\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpe_jwv98q.swift:11:19: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = number\n                  ^~~~~~\n/tmp/tmpe_jwv98q.swift:16:19:\
    \ error: cannot find 'append' in scope\n            max = append(max, number)\n\
    \                  ^~~~~~\n/tmp/tmpe_jwv98q.swift:18:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(max)\n\
    \        } else {\n            result.append(number)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp11b410ag/tmp11b410ag.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af28f8aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af28f5a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af28f5a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af28f5a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp11b410ag                        0x0000558f4be91816 <unavailable> + 6166

    5    libc.so.6                          0x00002af28fa9a460 __libc_start_main +
    245

    6    tmp11b410ag                        0x0000558f4be911e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_index = -1\n    for\
    \ index in 1..<numbers.count {\n        if numbers[index] > max {\n          \
    \  max = numbers[index]\n            max_index = index\n        }\n    }\n   \
    \ var result = [Int]()\n    result.append(max)\n    result.append(numbers[max_index])\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac75b4dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac75b1d1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac75b1d1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac75b1d113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac75b1d0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac75afd0e83 <unavailable> + 188035

    6    tmpt85xarul                        0x000055f26d384ae8 <unavailable> + 6888

    7    tmpt85xarul                        0x000055f26d3845ad <unavailable> + 5549

    8    libc.so.6                          0x00002ac75b6c6460 __libc_start_main +
    245

    9    tmpt85xarul                        0x000055f26d3842b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [Int](repeating:\
    \ number, count: index + 1)\n        }\n        max[index] = number\n        index\
    \ = (index + 1) % number.count\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpkdch26lk.swift:14:38: error: value of type 'Int' has no member\
    \ 'count'\n        index = (index + 1) % number.count\n                      \
    \        ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for number in numbers\
    \ {\n        if number > rolling_max {\n            rolling_max = number\n   \
    \     }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpum5eum5w.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \    }\n    for number in numbers {\n        if number == max {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpbik51lk6/tmpbik51lk6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67bc604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67bc2fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67bc2fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67bc2fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbik51lk6                        0x00005637423c06cd <unavailable> + 5837

    5    libc.so.6                          0x00002b67bc7f0460 __libc_start_main +
    245

    6    tmpbik51lk6                        0x00005637423c01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = 0\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n    }\n    for number in numbers {\n        if number > max {\n   \
    \         result.append(max)\n            max = number\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmptu19wr6y/tmptu19wr6y.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2084805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20844fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20844fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20844fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptu19wr6y                        0x00005582a68ed66d <unavailable> + 5741

    5    libc.so.6                          0x00002b20849f1460 __libc_start_main +
    245

    6    tmptu19wr6y                        0x00005582a68ed189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [number]\n\
    \        } else {\n            max = append(max, number)\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_x03emuh.swift:13:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n/tmp/tmp_x03emuh.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for index\
    \ in 1..<numbers.count {\n        if numbers[index] > max {\n            max =\
    \ numbers[index]\n            maxIndex = index\n        }\n    }\n    return Array(numbers[0..<maxIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5987dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5984d6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae5984d6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae5984d613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae5984d5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae5982d5e83 <unavailable> + 188035

    6    tmpi4f1yifq                        0x000055cd8c384b78 <unavailable> + 7032

    7    tmpi4f1yifq                        0x000055cd8c38464d <unavailable> + 5709

    8    libc.so.6                          0x00002ae5989cb460 __libc_start_main +
    245

    9    tmpi4f1yifq                        0x000055cd8c384359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMax = [Int]()\n\
    \    for number in numbers {\n        if number > max {\n            rollingMax.append(max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    rollingMax.append(max)\n    return rollingMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8ee2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8eb25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c8eb25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c8eb2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c8eb24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9c8e924e83 <unavailable> + 188035

    6    tmplvz1ibk2                        0x0000556aafef4a52 <unavailable> + 6738

    7    tmplvz1ibk2                        0x0000556aafef452d <unavailable> + 5421

    8    libc.so.6                          0x00002b9c8f01a460 __libc_start_main +
    245

    9    tmplvz1ibk2                        0x0000556aafef4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if number > max[index] {\n            max = [Int](repeating:\
    \ number, count: index + 1)\n        }\n        max[index] = number\n        index\
    \ += 1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1723365c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b172305c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b172305c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b172305c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b172305bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1722e5be83 <unavailable> + 188035

    6    tmpo54492z1                        0x000055981dd34b83 <unavailable> + 7043

    7    tmpo54492z1                        0x000055981dd34695 <unavailable> + 5781

    8    libc.so.6                          0x00002b1723551460 __libc_start_main +
    245

    9    tmpo54492z1                        0x000055981dd34299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > max[maxIndex] {\n      \
    \      max[maxIndex] = numbers[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d00d4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d00a45561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d00a45286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d00a4513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d00a44bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d00844e83 <unavailable> + 188035

    6    tmpu244gqf3                        0x000055bcaaafbbf4 <unavailable> + 7156

    7    tmpu244gqf3                        0x000055bcaaafb6a5 <unavailable> + 5797

    8    libc.so.6                          0x00002b9d00f3a460 __libc_start_main +
    245

    9    tmpu244gqf3                        0x000055bcaaafb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        if number > max[maxIndex] {\n            max[maxIndex]\
    \ = number\n            maxIndex += 1\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a2ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a2ebfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a2ebfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a2ebfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a2ebfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a2e9fde83 <unavailable> + 188035

    6    tmpv_ej2k2n                        0x0000560e46036b1d <unavailable> + 6941

    7    tmpv_ej2k2n                        0x0000560e46036635 <unavailable> + 5685

    8    libc.so.6                          0x00002b8a2f0f3460 __libc_start_main +
    245

    9    tmpv_ej2k2n                        0x0000560e46036239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824827
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if number > max[0] {\n            max = [number]\n        } else {\n    \
    \        max = append(max, number)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprzgc5nq5.swift:12:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, number)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824826
