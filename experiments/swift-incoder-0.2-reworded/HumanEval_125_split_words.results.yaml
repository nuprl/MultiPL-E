language: swift
name: HumanEval_125_split_words
results:
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ .failure(Int(arc4random_uniform(25) + 1))\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpaiouzumu.swift:16:29: error: cannot find 'arc4random_uniform' in\
    \ scope\n        return .failure(Int(arc4random_uniform(25) + 1))\n          \
    \                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpaiouzumu.swift:15:11: error: initializer\
    \ for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaiouzumu.swift:18:21:\
    \ error: cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n    return .success(words)\n         \
    \           ^\n/tmp/tmpaiouzumu.swift:18:21: note: arguments to generic parameter\
    \ 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are expected\
    \ to be equal\n    return .success(words)\n                    ^\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    \n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    \n    if words.count % 2 == 1 {\n\
    \        return .success(words.prefix(words.count / 2))\n    }\n    \n    return\
    \ .success(words.prefix(words.count / 2 + 1))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6wsu_4bb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 1 {\n        return .success(words)\n    }\n    \n\
    \    let firstWord = words[0]\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) == nil {\n        return .success(words)\n    }\n   \
    \ \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespacesAndNewlines) != nil {\n        return .failure(Int(0))\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) !=\
    \ nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespacesAndNewlines) != nil {\n        return .success(words)\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) !=\
    \ nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines)\
    \ != nil {\n        return .failure(Int(0))\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil {\n        return .success(words)\n    }\n   \
    \ \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespacesAndNewlines) != nil {\n        return .failure(Int(0))\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) !=\
    \ nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines)\
    \ != nil {\n        return .failure(Int(0))\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil {\n        return .success(words)\n    }\n   \
    \ \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespacesAndNewlines) != nil {\n        return .failure(Int(0))\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) !=\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyq94vmay.swift:81:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpyq94vmay.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyq94vmay.swift:28:41: error: cannot find 'CharacterSet'\
    \ in scope\n    if firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines)\
    \ != nil {\n                                        ^~~~~~~~~~~~\n/tmp/tmpyq94vmay.swift:32:41:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) == nil {\n                                        ^~~~~~~~~~~~\n\
    /tmp/tmpyq94vmay.swift:36:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.newlines) != nil || firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespacesAndNewlines) != nil {\n                            \
    \            ^~~~~~~~~~~~\n/tmp/tmpyq94vmay.swift:36:107: error: cannot find 'CharacterSet'\
    \ in scope\n    if firstWord.rangeOfCharacter(from: CharacterSet.newlines) !=\
    \ nil || firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines)\
    \ != nil {\n                                                                 \
    \                                         ^~~~~~~~~~~~\n/tmp/tmpyq94vmay.swift:40:41:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil {\n                                        ^~~~~~~~~~~~\n\
    /tmp/tmpyq94vmay.swift:44:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines) !=\
    \ nil {\n                                        ^~~~~~~~~~~~\n/tmp/tmpyq94vmay.swift:48:41:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.newlines) != nil {\n                                        ^~~~~~~~~~~~\n\
    /tmp/tmpyq94vmay.swift:52:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.newlines) != nil || firstWord.rangeOfCh"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(txt.count)\n    }\n    \n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 2 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 3 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 4 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return .success(words)\n    }\n    \n    if wordCount == 6 {\n\
    \        return .success(words)\n    }\n    \n    if wordCount == 7 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 8 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 9 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 10 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 11 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 12 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 13 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 14 {\n        return .success(words)\n    }\n    \n    if wordCount == 15\
    \ {\n        return .success(words)\n    }\n    \n    if wordCount == 16 {\n \
    \       return .success(words)\n    }\n    \n    if wordCount == 17 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 18 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 19 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 20 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 21 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 22 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 23 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 24 {\n        return .success(words)\n    }\n    \n    if wordCount == 25\
    \ {\n        return .success(words)\n    }\n    \n    return .failure(wordCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq2fq4o01.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(25) + 1))\n    }\n    \n    var\
    \ result: [String] = []\n    \n    for word in words {\n        guard let letters\
    \ = word.components(separatedBy: \",\") else {\n            return .failure(Int(arc4random_uniform(25)\
    \ + 1))\n        }\n        \n        for letter in letters {\n            guard\
    \ let letter = letter.lowercased() else {\n                return .failure(Int(arc4random_uniform(25)\
    \ + 1))\n            }\n            \n            if letters.count % 2 == 1 {\n\
    \                result.append(letter)\n            } else {\n               \
    \ result.append(letter)\n            }\n        }\n    }\n    \n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxmcuh7cf.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpxmcuh7cf.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(25)\
    \ + 1))\n                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n   \
    \     return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpajtu5tqo.swift:92:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpajtu5tqo.swift:91:24: note: to match this opening '('\n        return\
    \ .success(words.dropFirst\n                       ^\n/tmp/tmpajtu5tqo.swift:114:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpajtu5tqo.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpajtu5tqo.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpajtu5tqo.swift:95:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    var result: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.components(separatedBy: \",\") else {\n            return\
    \ .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n        }\n        \n\
    \        for letter in letters {\n            guard let letter = letter.lowercased(),\
    \ letter != letter else {\n                return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    result.append(letter)\n            }\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return .success(result)\n    }\n    \n    if result.count %\
    \ 2 == 1 {\n        return .success(result)\n    }\n    \n    return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmqe5fot2.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpmqe5fot2.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpmqe5fot2.swift:45:25:\
    \ error: cannot find 'arc4random_uniform' in scope\n    return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                        ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last\n\
    \    let letters = words.dropLast()\n    let letterCount = letters.count\n   \
    \ if letterCount == 0 {\n        return .failure(letterCount)\n    }\n    if letterCount\
    \ == 1 {\n        return .success(letters)\n    }\n    if letterCount == 2 {\n\
    \        return .success(letters + [comma])\n    }\n    if letterCount == 3 {\n\
    \        return .success(letters + [comma] + letters)\n    }\n    if letterCount\
    \ == 4 {\n        return .success(letters + [comma] + letters + [comma])\n   \
    \ }\n    if letterCount == 5 {\n        return .success(letters + [comma] + letters\
    \ + [comma] + letters)\n    }\n    if letterCount == 6 {\n        return .success(letters\
    \ + [comma] + letters + [comma] + letters + [comma])\n    }\n    if letterCount\
    \ == 7 {\n        return .success(letters + [comma] + letters + [comma] + letters\
    \ + [comma] + letters)\n    }\n    if letterCount == 8 {\n        return .success(letters\
    \ + [comma] + letters + [comma] + letters + [comma] + letters + [comma])\n   \
    \ }\n    if letterCount == 9 {\n        return .success(letters + [comma] + letters\
    \ + [comma] + letters + [comma] + letters + [comma] + letters)\n    }\n    if\
    \ letterCount == 10 {\n        return .success(letters + [comma] + letters + [comma]\
    \ + letters + [comma] + letters + [comma] + letters + [comma])\n    }\n    if\
    \ letterCount == 11 {\n        return .success(letters + [comma] + letters + [comma]\
    \ + letters + [comma] + letters + [comma] + letters + [comma] + letters)\n   \
    \ }\n    if letterCount == 12 {\n        return .success(letters + [comma] + letters\
    \ + [comma] + letters + [comma] + letters + [comma] + letters + [comma] + letters\
    \ + [comma])\n    }\n    if letterCount == 13 {\n        return .success(letters\
    \ + [comma] + letters + [comma] + letters + [comma] + letters + [comma] + letters\
    \ + [comma] + letters + [comma] + letters)\n    }\n    if letterCount == 14 {\n\
    \        return .success(letters + [comma] + letters + [comma] + letters + [comma]\
    \ + letters + [comma] + letters + [comma] + letters + [comma] + letters + [comma])\n\
    \    }\n    if letterCount == 15 {\n        return .success(letter\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpnsbf56ck.swift:69:1: error: expected ')' in expression list\n}\n^\n/tmp/tmpnsbf56ck.swift:68:24:\
    \ note: to match this opening '('\n        return .success(letter\n          \
    \             ^\n/tmp/tmpnsbf56ck.swift:91:44: error: expected '}' at end of brace\
    \ statement\nassert(split_words(txt: \"\") == .failure(0))\n                 \
    \                          ^\n/tmp/tmpnsbf56ck.swift:14:56: note: to match this\
    \ opening '{'\nfunc split_words(txt: String) -> Result<[String], Int> {\n    \
    \                                                   ^\n/tmp/tmpnsbf56ck.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpnsbf56ck.swift:41:16: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        return .success(letters\
    \ + [comma] + letters + [comma] + letters + [comma])\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054183
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    \n    if words.count ==\
    \ 1 {\n        return .success(words)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 2 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 3 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 4 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return .success(words)\n    }\n    \n    if wordCount == 6 {\n\
    \        return .success(words)\n    }\n    \n    if wordCount == 7 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 8 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 9 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 10 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 11 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 12 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 13 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 14 {\n        return .success(words)\n    }\n    \n    if wordCount == 15\
    \ {\n        return .success(words)\n    }\n    \n    if wordCount == 16 {\n \
    \       return .success(words)\n    }\n    \n    if wordCount == 17 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 18 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 19 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 20 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 21 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 22 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 23 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 24 {\n        return .success(words)\n    }\n    \n    if wordCount == 25\
    \ {\n        return .success(words)\n    }\n    \n    return .failure(Int(wordCount))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpodzedmdk.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let firstWord = words[0]\n    let lastWord = words[wordCount - 1]\n    if\
    \ firstWord.hasPrefix(\" \") {\n        return .success(words.dropFirst())\n \
    \   }\n    if lastWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasPrefix(\" \") {\n        return .success(words.dropFirst())\n\
    \    }\n    if lastWord.hasPrefix(\" \") {\n        return .success(words.dropFirst())\n\
    \    }\n    if firstWord.hasPrefix(\" \") {\n        return .success(words.dropFirst())\n\
    \    }\n    if lastWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n        return .success(words.dropLast())\n\
    \    }\n    if firstWord.hasSuffix(\" \") {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpy9cl_xey.swift:115:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpy9cl_xey.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpy9cl_xey.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpy9cl_xey.swift:96:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.characters.count\n    let oddLetterCount\
    \ = letterCount - wordCount\n    let oddLetterCountString = String(oddLetterCount)\n\
    \    if oddLetterCountString.isEmpty {\n        return .success(words)\n    }\n\
    \    if oddLetterCountString.contains(\",\") {\n        return .success(words.map\
    \ { $0.components(separatedBy: \",\") })\n    }\n    return .success(words.map\
    \ { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1_uy01b3.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp1_uy01b3.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1_uy01b3.swift:20:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterCount = txt.characters.count\n   \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { $0 + count($1, lowercaseLetter)\
    \ }\n    \n    if wordCount == 0 || letterCount % 2 == 1 {\n        return .failure(letterCount)\n\
    \    }\n    \n    return .success(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphtd2_ork.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphtd2_ork.swift:17:46: error: cannot find 'count'\
    \ in scope\n    let letterCount = words.reduce(0) { $0 + count($1, lowercaseLetter)\
    \ }\n                                             ^~~~~\n/tmp/tmphtd2_ork.swift:17:56:\
    \ error: cannot find 'lowercaseLetter' in scope\n    let letterCount = words.reduce(0)\
    \ { $0 + count($1, lowercaseLetter) }\n                                      \
    \                 ^~~~~~~~~~~~~~~\n/tmp/tmphtd2_ork.swift:23:60: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    return\
    \ .success(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n\
    \                                                          ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return .failure(words.count)\n    }\n    \n    let wordArray\
    \ = words.map { $0.lowercased() }\n    \n    let letters = wordArray.count\n \
    \   \n    if letters % 2 == 1 {\n        return .success(wordArray)\n    }\n \
    \   \n    return .success(wordArray.prefix(letters / 2))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprzoxzmao.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    if words.count % 2 == 1 {\n  \
    \      return .failure(words.count)\n    }\n    let evenWords = words.filter{$0.count\
    \ % 2 == 0}\n    let oddWords = words.filter{$0.count % 2 != 0}\n    return .success(evenWords\
    \ + oddWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp97lsq1cu.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp97lsq1cu.swift:27:31: error: cannot convert value\
    \ of type 'String' to expected argument type '[String]'\n    return .success(evenWords\
    \ + oddWords)\n                              ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.dropLast())\n\
    \    }\n    return .success(words.dropLast().append(comma))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnp2k1jk7.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words = txt.components(separatedBy: \" \")\n    \n   \
    \ if words.count == 0 {\n        return .failure(Int(1))\n    }\n    \n    if\
    \ words.count == 1 {\n        return .success(words)\n    }\n    \n    let commaIndex\
    \ = words.count - 1\n    \n    if words.last!.characters.count == 0 {\n      \
    \  return .success(words)\n    }\n    \n    if words.last!.characters.count ==\
    \ 1 {\n        return .success(words.dropLast())\n    }\n    \n    let lastChar\
    \ = words.last!.characters.last!\n    \n    if lastChar == \",\" {\n        return\
    \ .success(words.dropLast())\n    }\n    \n    if lastChar == \".\" {\n      \
    \  return .success(words.dropLast())\n    }\n    \n    if lastChar == \"!\" {\n\
    \        return .success(words.dropLast())\n    }\n    \n    if lastChar == \"\
    ?\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \",\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \",\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \",\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \",\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \",\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \"-\" {\n        return .success(words.dropLast())\n    }\n    \n    if lastChar\
    \ == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp4xm9ni8.swift:119:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpp4xm9ni8.swift:16:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordsCount\
    \ = words.count\n    \n    if wordsCount == 0 {\n        return .failure(wordsCount)\n\
    \    }\n    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if\
    \ wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n    \n\
    \    let alphabet = Array(wordArray.prefix(wordArray.count / 2)).map { String($0)\
    \ }\n    \n    if alphabet.count % 2 == 1 {\n        return .success(alphabet)\n\
    \    }\n    \n    return .failure(alphabet.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_i5j476a.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(Int(wordArrayCount))\n\
    \    }\n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let evenWordArrayCount\
    \ = evenWordArray.count\n    if evenWordArrayCount % 2 == 1 {\n        return\
    \ .failure(Int(evenWordArrayCount))\n    }\n    return .success(evenWordArray)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd9miwqrz.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let comma =\
    \ words.last!.components(separatedBy: \",\")\n    let letters = words.count -\
    \ comma.count\n    if letters % 2 != 0 {\n        return .failure(letters)\n \
    \   }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjki66h_9.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let firstWord = words[0]\n   \
    \ let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n\
    \        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    let letters = firstWord.unicodeScalars.filter({\
    \ $0.isLetter}).map({ $0.value })\n    if letters.count % 2 == 1 {\n        return\
    \ .success(words.dropFirst())\n    }\n    return .success(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpn7i5qstt.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.components(separatedBy:\
    \ \",\")\n    if commaWords.count == 0 {\n        return .success(words.map {\
    \ $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased() })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp29dqu5y_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last?.components(separatedBy:\
    \ \",\")\n    if comma?.count < 2 {\n        return .failure(words.count)\n  \
    \  }\n    let letters = words.map { $0.lowercased() }\n    return .success(letters)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_j7ykf9t.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_j7ykf9t.swift:20:15: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n    if comma?.count\
    \ < 2 {\n              ^\n/tmp/tmp_j7ykf9t.swift:20:15: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    if comma?.count\
    \ < 2 {\n              ^\n                    ?? <#default value#>\n/tmp/tmp_j7ykf9t.swift:20:15:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if comma?.count < 2 {\n              ^\n       (           )!\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    if words.count == 2\
    \ {\n        return .success(words)\n    }\n    \n    if words.count == 3 {\n\
    \        return .success(words)\n    }\n    \n    if words.count == 4 {\n    \
    \    return .success(words)\n    }\n    \n    if words.count == 5 {\n        return\
    \ .success(words)\n    }\n    \n    if words.count == 6 {\n        return .success(words)\n\
    \    }\n    \n    if words.count == 7 {\n        return .success(words)\n    }\n\
    \    \n    if words.count == 8 {\n        return .success(words)\n    }\n    \n\
    \    if words.count == 9 {\n        return .success(words)\n    }\n    \n    if\
    \ words.count == 10 {\n        return .success(words)\n    }\n    \n    if words.count\
    \ == 11 {\n        return .success(words)\n    }\n    \n    if words.count ==\
    \ 12 {\n        return .success(words)\n    }\n    \n    if words.count == 13\
    \ {\n        return .success(words)\n    }\n    \n    if words.count == 14 {\n\
    \        return .success(words)\n    }\n    \n    if words.count == 15 {\n   \
    \     return .success(words)\n    }\n    \n    if words.count == 16 {\n      \
    \  return .success(words)\n    }\n    \n    if words.count == 17 {\n        return\
    \ .success(words)\n    }\n    \n    if words.count == 18 {\n        return .success(words)\n\
    \    }\n    \n    if words.count == 19 {\n        return .success(words)\n   \
    \ }\n    \n    if words.count == 20 {\n        return .success(words)\n    }\n\
    \    \n    if words.count == 21 {\n        return .success(words)\n    }\n   \
    \ \n    if words.count == 22 {\n        return .success(words)\n    }\n    \n\
    \    if words.count == 23 {\n        return .success(words)\n    }\n    \n   \
    \ if words.count == 24 {\n        return .success(words)\n    }\n    \n    if\
    \ words.count == 25 {\n        return .success(words)\n    }\n    \n    if words.count\
    \ == 26 {\n        return .success(words)\n    }\n    \n    if words.count ==\
    \ 27 {\n        return .success(words)\n    }\n    \n    if words.count == 28\
    \ {\n        return .success(words)\n    }\n    \n    if words.count == 29 {\n\
    \        return .success(words)\n    }\n    \n    if words.count == 30 {\n   \
    \     return .success(words)\n    }\n    \n    if words.count == 31 {\n      \
    \  return .success(words)\n    }\n    \n    if words.count == 32 {\n        return\
    \ .success(words)\n    }\n    \n    if words.count == 33 {\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3qenj5j8.swift:173:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmp3qenj5j8.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmp3qenj5j8.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp3qenj5j8.swift:154:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.failure))\n    }\n    \n    var result: [String] = []\n    \n    for\
    \ word in words {\n        if let word = word.lowercased() {\n            result.append(word)\n\
    \        }\n    }\n    \n    if result.count % 2 == 1 {\n        return Err(Int(.failure))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9gju2a23.swift:16:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.failure))\n               ^~~\n/tmp/tmp9gju2a23.swift:16:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp9gju2a23.swift:15:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9gju2a23.swift:22:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9gju2a23.swift:28:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.failure))\n               ^~~\n/tmp/tmp9gju2a23.swift:28:24: error:\
    \ missing argument label 'bitPattern:' in call\n        return Err(Int(.failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp9gju2a23.swift:31:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { $0 + $1.count }\n    if letterCount %\
    \ 2 != 0 {\n        return .failure(letterCount)\n    }\n    return .success(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpe_tiz634.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpe_tiz634.swift:24:60: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    return .success(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n                  \
    \                                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.components(separatedBy:\
    \ \",\")\n    if commaWords.count == 0 {\n        return .failure(words.count)\n\
    \    }\n    let letters = words.map { $0.lowercased().count }\n    if letters.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if letters.count ==\
    \ 1 {\n        return .success(words)\n    }\n    if letters.count % 2 == 1 {\n\
    \        return .success(words)\n    }\n    return .success(letters.filter { $0\
    \ % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwdni_nli.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let count =\
    \ words.count\n    if count > 0 {\n        return .success(words)\n    }\n   \
    \ if count == 0 {\n        return .success(words)\n    }\n    if count % 2 ==\
    \ 1 {\n        return .failure(count)\n    }\n    return .success(words.prefix(count\
    \ / 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps7o_aq73.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    if words.count == 2\
    \ {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    var result: [String] = []\n    var lastWord = \"\"\n    for word in words\
    \ {\n        if word == \"\" {\n            continue\n        }\n        if lastWord\
    \ == \"\" {\n            lastWord = word\n            continue\n        }\n  \
    \      if lastWord.lowercased() != word.lowercased() {\n            if lastWord.lowercased()\
    \ > word.lowercased() {\n                result.appendContentsOf(words[wordCount..<wordCount\
    \ + 1])\n            } else {\n                result.appendContentsOf(words[0..<wordCount])\n\
    \            }\n            lastWord = word\n            continue\n        }\n\
    \        lastWord = word\n    }\n    if lastWord != \"\" {\n        result.appendContentsOf(words[wordCount..<wordCount\
    \ + 1])\n    }\n    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmzfsqnqi.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmzfsqnqi.swift:45:16: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n        result.appendContentsOf(words[wordCount..<wordCount\
    \ + 1])\n        ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter({\
    \ $0 == \",\" })\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp14o13ii_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let chars = words.map(String.init)\n\
    \    let count = chars.filter({ $0.isEmpty }).count\n    if count == 0 {\n   \
    \     return .success(chars.map { $0.lowercased() })\n    }\n    if chars.count\
    \ % 2 == 1 {\n        return .success(chars.map { $0.lowercased() })\n    }\n\
    \    return .success(chars.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7il13l7i.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp7il13l7i.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let chars = words.map { $0.characters.count\
    \ }\n    if chars.count == 0 {\n        return .failure(Int(txt.characters.count))\n\
    \    }\n    if chars.count == 1 {\n        return .success(words)\n    }\n   \
    \ if chars.count == 2 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 3 {\n        return .success(words)\n    }\n    if chars.count == 4 {\n \
    \       return .success(words)\n    }\n    if chars.count == 5 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 6 {\n        return .success(words)\n\
    \    }\n    if chars.count == 7 {\n        return .success(words)\n    }\n   \
    \ if chars.count == 8 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 9 {\n        return .success(words)\n    }\n    if chars.count == 10 {\n\
    \        return .success(words)\n    }\n    if chars.count == 11 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 12 {\n        return .success(words)\n\
    \    }\n    if chars.count == 13 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 14 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 15 {\n        return .success(words)\n    }\n    if chars.count == 16 {\n\
    \        return .success(words)\n    }\n    if chars.count == 17 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 18 {\n        return .success(words)\n\
    \    }\n    if chars.count == 19 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 20 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 21 {\n        return .success(words)\n    }\n    if chars.count == 22 {\n\
    \        return .success(words)\n    }\n    if chars.count == 23 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 24 {\n        return .success(words)\n\
    \    }\n    if chars.count == 25 {\n        return .success(words)\n    }\n  \
    \  return .failure(Int(txt.characters.count))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwbhs8iu4.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwbhs8iu4.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpwbhs8iu4.swift:24:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpwbhs8iu4.swift:101:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    return .failure(Int(txt.characters.count))\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    if words.count % 2 == 1 {\n  \
    \      return .failure(words.count)\n    }\n    let even = words.filter{$0.isUppercase}\n\
    \    let odd = words.filter{$0.isLowercase}\n    if even.count == odd.count {\n\
    \        return .success(even)\n    }\n    return .failure(words.count)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvy68plib.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  return .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppqj872fr.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmppqj872fr.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let comma = words.last?.characters.first\n\
    \    if comma == nil {\n        return .success(words)\n    }\n    let commaCount\
    \ = txt.characters.count - words.last!.characters.count - comma!.characters.count\n\
    \    if commaCount % 2 == 1 {\n        return .success(words)\n    }\n    return\
    \ .failure(Int(txt.characters.count))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpn8zl5g7d.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpn8zl5g7d.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn8zl5g7d.swift:22:40: error: type of expression is\
    \ ambiguous without more context\n    let comma = words.last?.characters.first\n\
    \                ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpn8zl5g7d.swift:30:29: error:\
    \ 'characters' is unavailable: Please use String directly\n    return .failure(Int(txt.characters.count))\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { $0 + $1.count }\n    if letterCount %\
    \ 2 != 0 {\n        return .failure(letterCount)\n    }\n    return .success(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpds3w2y_y.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpds3w2y_y.swift:27:60: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    return .success(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n                  \
    \                                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { (result, word) -> Int in\n        let\
    \ letters = word.components(separatedBy: \",\")\n        if letters.count < 2\
    \ {\n            return letters.count\n        }\n        return letters.reduce(0)\
    \ { (result, letter) -> Int in\n            if let letter = letter.lowercased()\
    \ {\n                return result + 1\n            }\n            return result\n\
    \        }\n    }\n    if letterCount % 2 == 1 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpswjbi6ko.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let commaWords\
    \ = words.filter({ $0.isEmpty == false })\n    let letterWords = words.filter({\
    \ $0.isEmpty == false && $0.lowercased() != $0 })\n    let letterWordsCount =\
    \ letterWords.count\n    let commaWordsCount = commaWords.count\n    \n    if\
    \ letterWordsCount == 0 {\n        return .failure(letterWordsCount)\n    } else\
    \ if commaWordsCount == 0 {\n        return .failure(commaWordsCount)\n    } else\
    \ {\n        return .success(letterWords + commaWords)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeeebiylo.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpeeebiylo.swift:26:37: error: cannot convert value\
    \ of type 'String' to expected argument type '[String]'\n        return .success(letterWords\
    \ + commaWords)\n                                    ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    \n    let wordArray = words.map\
    \ { $0.lowercased() }\n    \n    if wordArray.count % 2 == 1 {\n        return\
    \ .failure(wordArray.count)\n    }\n    \n    let evenWordArray = wordArray.filter\
    \ { $0 % 2 == 0 }\n    let oddWordArray = wordArray.filter { $0 % 2 != 0 }\n \
    \   \n    return .success(evenWordArray.count + oddWordArray.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwali1nn9.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    let chars = words.map(String.init)\n\
    \    let charsCount = chars.count\n    \n    let charsCountUpper = chars.filter({\
    \ $0.isUppercase }).count\n    let charsCountLower = chars.filter({ $0.isLowercase\
    \ }).count\n    \n    let charsCountOdd = chars.filter({ $0.isOdd }).count\n \
    \   \n    if charsCountUpper == charsCount {\n        return .success(chars)\n\
    \    }\n    \n    if charsCountLower == charsCount {\n        return .success(chars)\n\
    \    }\n    \n    if charsCountOdd == charsCount {\n        return .success(chars)\n\
    \    }\n    \n    return .failure(Int(txt.characters.count))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprxajs4bq.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmprxajs4bq.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprxajs4bq.swift:43:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    return .failure(Int(txt.characters.count))\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    let commaWords\
    \ = words.filter { $0 == \",\" }\n    if commaWords.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    \n    let letters = words.map\
    \ { $0.lowercased() }\n    let odd = letters.filter { $0 % 2 == 1 }\n    if odd.count\
    \ == 0 {\n        return .success(letters)\n    }\n    \n    return .failure(letters.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpr9qgr_yq.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    \n  \
    \  let wordCount = words.count\n    \n    if words.count == 1 {\n        return\
    \ .success(words)\n    }\n    \n    if words.count % 2 == 1 {\n        return\
    \ .success(words.prefix(wordCount/2))\n    }\n    \n    return .success(words.prefix(wordCount/2\
    \ + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpaqp1_zgv.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpaqp1_zgv.swift:18:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let chars\
    \ = txt.characters\n    let wordCount = words.count\n    let charCount = chars.count\n\
    \    let oddCount = chars.filter { $0 % 2 == 1 }.count\n    if chars.count > wordCount\
    \ {\n        return .failure(Int(txt.characters.count))\n    }\n    if chars.count\
    \ < wordCount {\n        return .failure(Int(txt.characters.count))\n    }\n \
    \   if oddCount > wordCount {\n        return .failure(Int(txt.characters.count))\n\
    \    }\n    if oddCount < wordCount {\n        return .failure(Int(txt.characters.count))\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8v03if_r.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8v03if_r.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8v03if_r.swift:19:21: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = txt.characters\n               \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp8v03if_r.swift:22:35:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'Int'\n    let oddCount = chars.filter { $0 % 2 == 1 }.count\n\
    \                                  ^\n/tmp/tmp8v03if_r.swift:24:33: error: 'characters'\
    \ is unavailable: Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8v03if_r.swift:27:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8v03if_r.swift:30:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8v03if_r.swift:33:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failur"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter\
    \ { $0.isEmpty == false }\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppyivh9qj.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.count))\n    }\n    \n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    \n   \
    \ if wordArray.count == 0 {\n        return .failure(Int(txt.count))\n    }\n\
    \    \n    let wordArrayCount = wordArray.count\n    \n    if wordArrayCount %\
    \ 2 == 1 {\n        return .failure(Int(txt.count))\n    }\n    \n    let evenWordArray\
    \ = wordArray.filter{$0.isEven()}\n    let oddWordArray = wordArray.filter{$0.isOdd()}\n\
    \    \n    if evenWordArray.count == 0 {\n        return .success(evenWordArray)\n\
    \    }\n    \n    if oddWordArray.count == 0 {\n        return .success(oddWordArray)\n\
    \    }\n    \n    return .success(evenWordArray.dropLast())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4xblu1cn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ letterCount = words.map { $0.characters.count }.reduce(0, +)\n    let oddLetterCount\
    \ = letterCount % 2\n    if oddLetterCount > 0 {\n        return .failure(Int(letterCount))\n\
    \    }\n    return .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmvvcnxti.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let comma = words.last.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count % 2 != 0 ? $0.lowercased() : $0 }\n    return\
    \ .success(letters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1mo_zzxi.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    return .success(wordArray.prefix(wordArrayCount/2))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4isi1yt9.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter\
    \ {$0 == \",\"}\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ {String($0)})\n    }\n    return .success(words.map {String($0)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpett0ne3k.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter{\
    \ $0 == \",\" }\n    let commaWordsCount = commaWords.count\n    if commaWordsCount\
    \ == 0 {\n        return .success(words)\n    }\n    let letters = words.filter{\
    \ $0.lowercased() != \"a\" && $0.lowercased() != \"b\" && $0.lowercased() != \"\
    c\" && $0.lowercased() != \"d\" && $0.lowercased() != \"e\" && $0.lowercased()\
    \ != \"f\" && $0.lowercased() != \"g\" && $0.lowercased() != \"h\" && $0.lowercased()\
    \ != \"i\" && $0.lowercased() != \"j\" && $0.lowercased() != \"k\" && $0.lowercased()\
    \ != \"l\" && $0.lowercased() != \"m\" && $0.lowercased() != \"n\" && $0.lowercased()\
    \ != \"o\" && $0.lowercased() != \"p\" && $0.lowercased() != \"q\" && $0.lowercased()\
    \ != \"r\" && $0.lowercased() != \"s\" && $0.lowercased() != \"t\" && $0.lowercased()\
    \ != \"u\" && $0.lowercased() != \"v\" && $0.lowercased() != \"w\" && $0.lowercased()\
    \ != \"x\" && $0.lowercased() != \"y\" && $0.lowercased() != \"z\" }\n    let\
    \ letterCount = letters.count\n    if letterCount == 0 {\n        return .success(letterCount)\n\
    \    }\n    let oddLetters = letters.filter{ $0.lowercased() % 2 == 1 }\n    let\
    \ oddLettersCount = oddLetters.count\n    if oddLettersCount == 0 {\n        return\
    \ .success(letterCount)\n    }\n    return .success(letterCount + oddLettersCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp24k44os0.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp24k44os0.swift:24:19: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    let letters = words.filter{ $0.lowercased()\
    \ != \"a\" && $0.lowercased() != \"b\" && $0.lowercased() != \"c\" && $0.lowercased()\
    \ != \"d\" && $0.lowercased() != \"e\" && $0.lowercased() != \"f\" && $0.lowercased()\
    \ != \"g\" && $0.lowercased() != \"h\" && $0.lowercased() != \"i\" && $0.lowercased()\
    \ != \"j\" && $0.lowercased() != \"k\" && $0.lowercased() != \"l\" && $0.lowercased()\
    \ != \"m\" && $0.lowercased() != \"n\" && $0.lowercased() != \"o\" && $0.lowercased()\
    \ != \"p\" && $0.lowercased() != \"q\" && $0.lowercased() != \"r\" && $0.lowercased()\
    \ != \"s\" && $0.lowercased() != \"t\" && $0.lowercased() != \"u\" && $0.lowercased()\
    \ != \"v\" && $0.lowercased() != \"w\" && $0.lowercased() != \"x\" && $0.lowercased()\
    \ != \"y\" && $0.lowercased() != \"z\" }\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp24k44os0.swift:34:33: error: cannot convert value of type 'String' to\
    \ expected argument type '[String]'\n    return .success(letterCount + oddLettersCount)\n\
    \                                ^\n"
  stdout: ''
  timestamp: 1660053898
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    guard let letters = words.map(String.init).map({ $0.lowercased()\
    \ }).reduce(into: []) {\n        letters.append(contentsOf: [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"])\n    }\n    return .success(letters)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd263qur2.swift:18:90: error: expected 'else' after 'guard' condition\n\
    \    guard let letters = words.map(String.init).map({ $0.lowercased() }).reduce(into:\
    \ []) {\n                                                                    \
    \                     ^\n                                                    \
    \                                     else \n/tmp/tmpd263qur2.swift:15:21: error:\
    \ value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpd263qur2.swift:19:9: error:\
    \ cannot find 'letters' in scope\n        letters.append(contentsOf: [\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"])\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    if words.count == 2\
    \ {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count < 2 {\n        return .failure(comma.count)\n   \
    \ }\n    if comma.count == 2 {\n        return .success(words)\n    }\n    let\
    \ letters = words.map { $0.lowercased().characters.count }\n    return .success(letters.filter\
    \ { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyzx34n5y.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let commaWords\
    \ = txt.components(separatedBy: \",\")\n    \n    if words.count == 0 {\n    \
    \    return .failure(words.count)\n    }\n    \n    if commaWords.count == 0 {\n\
    \        return .success(words)\n    }\n    \n    if words.count != commaWords.count\
    \ {\n        return .failure(words.count)\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6h9876yk.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp6h9876yk.swift:16:26: error: value of type 'String'\
    \ has no member 'components'\n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n                     ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    let oddWords\
    \ = wordArray.filter { $0 % 2 == 1 }\n    let evenWords = wordArray.filter { $0\
    \ % 2 == 0 }\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    if wordCount == 1 {\n        return .success(wordArray)\n  \
    \  }\n    \n    if wordCount == 2 {\n        return .success(oddWords)\n    }\n\
    \    \n    if wordCount == 3 {\n        return .success(evenWords)\n    }\n  \
    \  \n    if wordCount == 4 {\n        return .success(oddWords + evenWords)\n\
    \    }\n    \n    if wordCount == 5 {\n        return .success(oddWords + evenWords\
    \ + wordArray)\n    }\n    \n    if wordCount == 6 {\n        return .success(oddWords\
    \ + evenWords + wordArray + wordArray)\n    }\n    \n    if wordCount == 7 {\n\
    \        return .success(oddWords + evenWords + wordArray + wordArray + wordArray)\n\
    \    }\n    \n    if wordCount == 8 {\n        return .success(oddWords + evenWords\
    \ + wordArray + wordArray + wordArray + wordArray)\n    }\n    \n    if wordCount\
    \ == 9 {\n        return .success(oddWords + evenWords + wordArray + wordArray\
    \ + wordArray + wordArray + wordArray)\n    }\n    \n    if wordCount == 10 {\n\
    \        return .success(oddWords + evenWords + wordArray + wordArray + wordArray\
    \ + wordArray + wordArray + wordArray)\n    }\n    \n    if wordCount == 11 {\n\
    \        return .success(oddWords + evenWords + wordArray + wordArray + wordArray\
    \ + wordArray + wordArray + wordArray + wordArray)\n    }\n    \n    if wordCount\
    \ == 12 {\n        return .success(oddWords + evenWords + wordArray + wordArray\
    \ + wordArray + wordArray + wordArray + wordArray + wordArray + wordArray)\n \
    \   }\n    \n    if wordCount == 13 {\n        return .success(oddWords + evenWords\
    \ + wordArray + wordArray + wordArray + wordArray + wordArray + wordArray + wordArray\
    \ + wordArray + wordArray)\n    }\n    \n    if wordCount == 14 {\n        return\
    \ .success(oddWords + evenWords + wordArray + wordArray + wordArray + wordArray\
    \ + wordArray + wordArray + wordArray + wordArray + wordArray + wordArray)\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpkk_tx2vr.swift:102:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpkk_tx2vr.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpkk_tx2vr.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpkk_tx2vr.swift:38:34: error:\
    \ cannot convert value of type 'String' to expected argument type '[String]'\n\
    \        return .success(oddWords + evenWords)\n                             \
    \    ^\n"
  stdout: ''
  timestamp: 1660054197
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let firstWord = words[0]\n   \
    \ let lastWord = words[words.count - 1]\n    let firstLetter = firstWord.unicodeScalars.first!\n\
    \    let lastLetter = lastWord.unicodeScalars.last!\n    let letterCount = lastLetter.value\
    \ - firstLetter.value\n    if letterCount % 2 == 1 {\n        return .success(words)\n\
    \    }\n    return .failure(letterCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv1ig4v79.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count }\n    if letters.count == 0 {\n       \
    \ return .failure(words.count)\n    }\n    if letters.count == 1 {\n        return\
    \ .success(letters)\n    }\n    if letters.count % 2 == 1 {\n        return .failure(letters.count)\n\
    \    }\n    return .success(letters.filter { $0 % 2 == 1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphm61rvs2.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(rawValue: 1))\n    }\n    \n    guard let commaWords = words.components(separatedBy:\
    \ \",\") else {\n        return Err(Int(rawValue: 2))\n    }\n    \n    guard\
    \ let lowercaseWords = commaWords.components(separatedBy: \"\") else {\n     \
    \   return Err(Int(rawValue: 3))\n    }\n    \n    let lowercaseWordsCount = lowercaseWords.count\n\
    \    let lowercaseWordsCountOdd = lowercaseWordsCount % 2\n    \n    if lowercaseWordsCountOdd\
    \ > 0 {\n        return Err(Int(rawValue: 4))\n    }\n    \n    return Ok([lowercaseWords,\
    \ commaWords])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbtman1hm.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpbtman1hm.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmpbtman1hm.swift:16:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpbtman1hm.swift:20:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(rawValue: 2))\n               ^~~\n/tmp/tmpbtman1hm.swift:20:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 2))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpbtman1hm.swift:24:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 3))\n  \
    \             ^~~\n/tmp/tmpbtman1hm.swift:24:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 3))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpbtman1hm.swift:31:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 4))\n         \
    \      ^~~\n/tmp/tmpbtman1hm.swift:31:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 4))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpbtman1hm.swift:34:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok([lowercaseWords, commaWords])\n           ^~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let wordCount = words.count\n    let wordCountWithCommas\
    \ = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder = wordCountWithCommas\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetter = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetterWithOddLetter\
    \ = wordCountWithCommasWithOddOrderWithOddLetter + words.count - 1\n    \n   \
    \ if wordCount == 0 {\n        return .success(words)\n    } else if wordCount\
    \ == 1 {\n        return .success([\"\\(words[0])\"])\n    } else if wordCount\
    \ == 2 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\"])\n    }\
    \ else if wordCount == 3 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\"\
    , \"\\(words[2])\"])\n    } else if wordCount == 4 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\"])\n    }\
    \ else if wordCount == 5 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\"\
    , \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\"])\n    } else if wordCount\
    \ == 6 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\"\
    , \"\\(words[3])\", \"\\(words[4])\", \"\\(words[5])\"])\n    } else if wordCount\
    \ == 7 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\"\
    , \"\\(words[3])\", \"\\(words[4])\", \"\\(words[5])\", \"\\(words[6])\"])\n \
    \   } else if wordCount == 8 {\n        return .success([\"\\(words[0])\", \"\\\
    (words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\", \"\\(words[5])\"\
    , \"\\(words[6])\", \"\\(words[7])\"])\n    } else if wordCount == 9 {\n     \
    \   return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\\
    (words[3])\", \"\\(words[4])\", \"\\(words[5])\", \"\\(words[6])\", \"\\(words[7])\"\
    , \"\\(words[8])\"])\n    } else if wordCount == 10 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1wf2a19r.swift:44:86: error: unterminated string literal\n    \
    \    return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\
    \\(words[3])\", \"\\(words[4])\n                                             \
    \                                        ^\n/tmp/tmp1wf2a19r.swift:67:44: error:\
    \ expected '}' at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n\
    \                                           ^\n/tmp/tmp1wf2a19r.swift:14:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmp1wf2a19r.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp1wf2a19r.swift:48:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.alphabet))\n    }\n    \n    guard let comma = words.first(where: {\
    \ $0 == \",\" }) else {\n        return Err(Int(.alphabet))\n    }\n    \n   \
    \ guard let lowercase = words.dropFirst(where: { $0.lowercased() == $0 }) else\
    \ {\n        return Err(Int(.alphabet))\n    }\n    \n    let odd = lowercase.count{\
    \ $0 % 2 == 1 }\n    \n    return .success(lowercase)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb8b_52ik.swift:16:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.alphabet))\n               ^~~\n/tmp/tmpb8b_52ik.swift:16:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.alphabet))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpb8b_52ik.swift:15:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb8b_52ik.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.alphabet))\n    \
    \           ^~~\n/tmp/tmpb8b_52ik.swift:20:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.alphabet))\n                       ^\n    \
    \                   bitPattern: \n/tmp/tmpb8b_52ik.swift:23:33: error: no exact\
    \ matches in call to instance method 'dropFirst'\n    guard let lowercase = words.dropFirst(where:\
    \ { $0.lowercased() == $0 }) else {\n                                ^\n/tmp/tmpb8b_52ik.swift:23:33:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(String)\
    \ -> Bool')\n    guard let lowercase = words.dropFirst(where: { $0.lowercased()\
    \ == $0 }) else {\n                                ^\n/tmp/tmpb8b_52ik.swift:23:33:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(String)\
    \ -> Bool')\n    guard let lowercase = words.dropFirst(where: { $0.lowercased()\
    \ == $0 }) else {\n                                ^\n/tmp/tmpb8b_52ik.swift:24:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.alphabet))\n    \
    \           ^~~\n/tmp/tmpb8b_52ik.swift:24:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.alphabet))\n                       ^\n    \
    \                   bitPattern: \n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let firstWord = words[0]\n\
    \    if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) == nil {\n\
    \        return .success(words.dropFirst())\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n        return .failure(words.count)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ == nil {\n        return .success(words.dropFirst())\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n        return .failure(words.count)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n        return .failure(words.count)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n        return .failure(words.count)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n        return .failure(words.count)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt9b9qwag.swift:42:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpt9b9qwag.swift:41:182: note: to match this opening '('\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted\n\
    \                                                                            \
    \                                                                            \
    \                             ^\n/tmp/tmpt9b9qwag.swift:15:21: error: value of\
    \ type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpt9b9qwag.swift:20:41: error:\
    \ cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) == nil {\n                                       \
    \ ^~~~~~~~~~~~\n/tmp/tmpt9b9qwag.swift:23:41: error: cannot find 'CharacterSet'\
    \ in scope\n    if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces)\
    \ != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n                                        ^~~~~~~~~~~~\n/tmp/tmpt9b9qwag.swift:23:110:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ != nil {\n                                                                 \
    \                                            ^~~~~~~~~~~~\n/tmp/tmpt9b9qwag.swift:26:41:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ == nil {\n                                        ^~~~~~~~~~~~\n/tmp/tmpt9b9qwag.swift:26:110:\
    \ error: cannot find 'CharacterSet' in scope\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil && firstWord.rangeOfCharacter(from: CharacterSet.whitespaces!.inverted)\
    \ == nil {\n "
  stdout: ''
  timestamp: 1660053820
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let evenWordArrayCount\
    \ = evenWordArray.count\n    if evenWordArrayCount % 2 == 1 {\n        return\
    \ .failure(evenWordArrayCount)\n    }\n    return .success(evenWordArray)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzhmywp1n.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let chars = words.map { $0.characters.count\
    \ }\n    if chars.count == 0 {\n        return .failure(Int(0))\n    }\n    if\
    \ chars.count == 1 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 2 {\n        return .success(words)\n    }\n    if chars.count == 3 {\n \
    \       return .success(words)\n    }\n    if chars.count == 4 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 5 {\n        return .success(words)\n\
    \    }\n    if chars.count == 6 {\n        return .success(words)\n    }\n   \
    \ if chars.count == 7 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 8 {\n        return .success(words)\n    }\n    if chars.count == 9 {\n \
    \       return .success(words)\n    }\n    if chars.count == 10 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 11 {\n        return .success(words)\n\
    \    }\n    if chars.count == 12 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 13 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 14 {\n        return .success(words)\n    }\n    if chars.count == 15 {\n\
    \        return .success(words)\n    }\n    if chars.count == 16 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 17 {\n        return .success(words)\n\
    \    }\n    if chars.count == 18 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 19 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 20 {\n        return .success(words)\n    }\n    if chars.count == 21 {\n\
    \        return .success(words)\n    }\n    if chars.count == 22 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 23 {\n        return .success(words)\n\
    \    }\n    if chars.count == 24 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 25 {\n        return .success(words)\n    }\n    return .failure(Int(0))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp07magikd.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().characters.count }\n    return .success(letters.filter\
    \ { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8pb7sy3p.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ .failure(Int(arc4random_uniform(25) + 1))\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpaiouzumu.swift:16:29: error: cannot find 'arc4random_uniform' in\
    \ scope\n        return .failure(Int(arc4random_uniform(25) + 1))\n          \
    \                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpaiouzumu.swift:15:11: error: initializer\
    \ for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaiouzumu.swift:18:21:\
    \ error: cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n    return .success(words)\n         \
    \           ^\n/tmp/tmpaiouzumu.swift:18:21: note: arguments to generic parameter\
    \ 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are expected\
    \ to be equal\n    return .success(words)\n                    ^\n"
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ > 0 {\n        let commaWords = words.filter { $0 == \",\" }\n        if commaWords.count\
    \ > 0 {\n            return .success(commaWords)\n        }\n    }\n    let lowercaseLetters\
    \ = words.filter { $0.lowercased().count % 2 == 1 }\n    if lowercaseLetters.count\
    \ > 0 {\n        return .success(lowercaseLetters)\n    }\n    return .failure(lowercaseLetters.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbvof7xc_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let wordCount = words.count\n    let wordCountWithCommas\
    \ = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder = wordCountWithCommas\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetter = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    \n    if wordCountWithCommasWithOddOrderWithOddLetter\
    \ % 2 == 1 {\n        return .success(words.map { $0.lowercased() })\n    } else\
    \ {\n        return .success(words.map { $0.lowercased() })\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpapp9zimt.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    let wordArrayOdd = wordArray[wordArrayCount / 2 - 1..<wordArrayCount]\n\
    \    let wordArrayEven = wordArray[wordArrayCount / 2..<wordArrayCount]\n    return\
    \ .success(wordArrayOdd + wordArrayEven)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptutbe6k8.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptutbe6k8.swift:27:34: error: cannot convert value\
    \ of type 'String' to expected argument type '[String]'\n    return .success(wordArrayOdd\
    \ + wordArrayEven)\n                                 ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let firstWord = words[0]\n\
    \    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\")\
    \ {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpepygehu8.swift:90:28: error: unterminated string literal\n    if\
    \ firstWord.hasPrefix(\"\n                           ^\n/tmp/tmpepygehu8.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ wordCount = wordCount.map { $0.count }\n    let wordCount = wordCount.reduce(0,\
    \ +)\n    let wordCount = wordCount.map { $0 % 2 != 0 ? $0 + 1 : $0 }\n    return\
    \ .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8z3ym6gb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let odd\
    \ = comma.last!.characters.filter { $0 % 2 == 1 }.count\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpf1h8jngn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpf1h8jngn.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let comma = words.last?.components(separatedBy:\
    \ \",\")\n    if comma?.count == 0 {\n        return .failure(words.last!.count)\n\
    \    }\n    return .success(words.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv21kj2fx.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.dropLast())\n\
    \    }\n    if comma.count == 1 {\n        return .success(words)\n    }\n   \
    \ let letters = words.dropLast().map({ $0.lowercased().characters.count })\n \
    \   return .success(letters.filter { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7o23x0fl.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    let lowercaseLetters = words.filter { $0.lowercased().count\
    \ % 2 == 1 }\n    \n    if lowercaseLetters.count == 0 {\n        return .success(lowercaseLetters)\n\
    \    }\n    \n    let evenLetters = lowercaseLetters.filter { $0.lowercased().count\
    \ % 2 == 0 }\n    \n    if evenLetters.count == 0 {\n        return .success(lowercaseLetters)\n\
    \    }\n    \n    let oddLetters = evenLetters.filter { $0.lowercased().count\
    \ % 2 == 1 }\n    \n    if oddLetters.count == 0 {\n        return .success(evenLetters)\n\
    \    }\n    \n    return .success(oddLetters)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8xlvmcvn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ .failure(Int(arc4random_uniform(25) + 1))\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwgeufztu.swift:16:29: error: cannot find 'arc4random_uniform' in\
    \ scope\n        return .failure(Int(arc4random_uniform(25) + 1))\n          \
    \                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwgeufztu.swift:15:11: error: initializer\
    \ for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwgeufztu.swift:19:21:\
    \ error: cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n    return .success(words)\n         \
    \           ^\n/tmp/tmpwgeufztu.swift:19:21: note: arguments to generic parameter\
    \ 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are expected\
    \ to be equal\n    return .success(words)\n                    ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().characters.count }\n    return .success(letters.filter\
    \ { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8pb7sy3p.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid argument\"\
    ))\n    }\n    \n    var result: [String] = []\n    \n    for word in words {\n\
    \        if let word = word.trimmingCharacters(in: .whitespacesAndNewlines), !word.isEmpty\
    \ {\n            result.append(word)\n        }\n    }\n    \n    if result.isEmpty\
    \ {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message:\
    \ \"Invalid argument\"))\n    }\n    \n    if result.count % 2 == 1 {\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n    }\n    \n    let alphabet = Array(1...26).map { String($0)\
    \ }\n    \n    for i in 0..<result.count {\n        let index = alphabet.index(of:\
    \ result[i])!\n        if i % 2 == 0 {\n            result[index] = result[index].lowercased()\n\
    \        }\n    }\n    \n    return .success(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpclljwzed.swift:16:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"\
    Invalid argument\"))\n               ^~~\n/tmp/tmpclljwzed.swift:16:35: error:\
    \ cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpclljwzed.swift:16:80: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpclljwzed.swift:15:11: error: initializer for conditional binding must\
    \ have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n  \
    \  guard let words = txt.split(separator: \" \") else {\n          ^         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpclljwzed.swift:22:28: error: value of type\
    \ 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        if let word = word.trimmingCharacters(in: .whitespacesAndNewlines), !word.isEmpty\
    \ {\n                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpclljwzed.swift:22:52:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \        if let word = word.trimmingCharacters(in: .whitespacesAndNewlines), !word.isEmpty\
    \ {\n                                                  ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpclljwzed.swift:28:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid argument\"\
    ))\n               ^~~\n/tmp/tmpclljwzed.swift:28:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpclljwzed.swift:28:80: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n                   "
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count }\n    if letters.count == 0 {\n       \
    \ return .failure(letters.count)\n    }\n    if letters.count == 1 {\n       \
    \ return .success(letters)\n    }\n    let odd = letters.filter { $0 % 2 == 1\
    \ }\n    if odd.count == 0 {\n        return .success(letters)\n    }\n    return\
    \ .success(odd)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz_g8e7zx.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count % 2 != 0 ? $0.lowercased() : $0 }\n    return\
    \ .success(letters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpziej5mum.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    let oddOrderWords\
    \ = wordArray.filter { $0.count % 2 == 1 }\n    let evenOrderWords = wordArray.filter\
    \ { $0.count % 2 == 0 }\n    \n    switch wordCount {\n    case 0:\n        return\
    \ .failure(wordCount)\n    case 1:\n        return .success(wordArray)\n    case\
    \ 2:\n        return .success(evenOrderWords)\n    case 3:\n        return .success(oddOrderWords)\n\
    \    default:\n        return .failure(wordCount)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp48bezbmx.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let comma =\
    \ words.last!.components(separatedBy: \",\")\n    let letters = words.count -\
    \ comma.count\n    \n    if words.count == 0 || comma.count == 0 || letters ==\
    \ 0 {\n        return .failure(letters)\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz9gapb80.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    if wordCount == 1 {\n        return .success(words)\n    }\n\
    \    \n    let firstWord = words[0]\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespaces) != nil {\n        return .success(words)\n    }\n    \n    if\
    \ firstWord.rangeOfCharacter(from: .whitespacesAndNewlines) != nil {\n       \
    \ return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) == nil {\n        return .success(words)\n    }\n \
    \   \n    if firstWord.rangeOfCharacter(from: .whitespacesAndNewlinesAndComma)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndComma) == nil {\n        return .success(words)\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: .whitespacesAndNewlinesAndCommaAndUppercase)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercase) == nil {\n        return .success(words)\n\
    \    }\n    \n    if firstWord.rangeOfCharacter(from: .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbers)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbers) == nil {\n        return\
    \ .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from: .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbersAndUppercase)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbersAndUppercase) == nil {\n\
    \        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbersAndUppercaseAndNumbers)\
    \ != nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercaseAndNumbersAndUppercaseAndNumbers)\
    \ == nil {\n        return .success(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercase\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjwpz1h5h.swift:81:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpjwpz1h5h.swift:80:34: note: to match this opening '('\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercase\n                              \
    \   ^\n/tmp/tmpjwpz1h5h.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjwpz1h5h.swift:28:42: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespaces) != nil {\n                                        ~^~~~~~~~~~~\n\
    /tmp/tmpjwpz1h5h.swift:32:42: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil {\n                                        ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjwpz1h5h.swift:36:42: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) == nil {\n                                        ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjwpz1h5h.swift:40:42: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlinesAndComma'\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndComma) != nil {\n                                \
    \        ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjwpz1h5h.swift:44:42: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlinesAndComma'\n\
    \    if firstWord.rangeOfCharacter(from: .whitespacesAndNewlinesAndComma) == nil\
    \ {\n                                        ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjwpz1h5h.swift:48:42: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlinesAndCommaAndUppercase'\n    if firstWord.rangeOfCharacter(from:\
    \ .whitespacesAndNewlinesAndCommaAndUppercase) != nil {\n                    \
    \                    ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjwpz1h5h.swift:52:42:\
    \ error: cann"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(bitPattern: 0xFFFFFFFF))\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 1 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 2 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 3 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 4 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return .success(words)\n    }\n    \n    if wordCount == 6 {\n\
    \        return .success(words)\n    }\n    \n    if wordCount == 7 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 8 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 9 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 10 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 11 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 12 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 13 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 14 {\n        return .success(words)\n    }\n    \n    if wordCount == 15\
    \ {\n        return .success(words)\n    }\n    \n    if wordCount == 16 {\n \
    \       return .success(words)\n    }\n    \n    if wordCount == 17 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 18 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 19 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 20 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 21 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 22 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 23 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 24 {\n        return .success(words)\n    }\n    \n    if wordCount == 25\
    \ {\n        return .success(words)\n    }\n    \n    return .failure(Int(bitPattern:\
    \ 0xFFFFFFFF))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl7a6ah6s.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    guard let first = words.first else { return .failure(0) }\n\
    \    guard let last = words.last else { return .failure(0) }\n    let count =\
    \ words.count / 2\n    return .success(words.prefix(count).map { $0.trimmingCharacters(in:\
    \ .whitespaces) }.suffix(count).map { $0.trimmingCharacters(in: .whitespaces)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2axjib0h.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp2axjib0h.swift:21:74: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n    return .success(words.prefix(count).map\
    \ { $0.trimmingCharacters(in: .whitespaces) }.suffix(count).map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                         \
    \               ~^~~~~~~~~~~\n/tmp/tmp2axjib0h.swift:21:136: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n    return .success(words.prefix(count).map\
    \ { $0.trimmingCharacters(in: .whitespaces) }.suffix(count).map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                         \
    \                                                                            \
    \ ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count }\n    return .success(letters.filter {\
    \ $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0zw3cbdx.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter\
    \ { $0 == \",\" }\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppas_qff8.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let numWords\
    \ = words.count\n    \n    if numWords == 0 {\n        return .failure(Int(numWords))\n\
    \    }\n    \n    if numWords == 1 {\n        return .success(words)\n    }\n\
    \    \n    if numWords == 2 {\n        return .success([\"\\(words[0])\", \"\\\
    (words[1])\"])\n    }\n    \n    if numWords == 3 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\"])\n    }\n    \n    if numWords\
    \ == 4 {\n        return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\"\
    , \"\\(words[3])\"])\n    }\n    \n    if numWords == 5 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\"\
    ])\n    }\n    \n    if numWords == 6 {\n        return .success([\"\\(words[0])\"\
    , \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\", \"\\\
    (words[5])\"])\n    }\n    \n    if numWords == 7 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\"\
    , \"\\(words[5])\", \"\\(words[6])\"])\n    }\n    \n    if numWords == 8 {\n\
    \        return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\"\
    , \"\\(words[3])\", \"\\(words[4])\", \"\\(words[5])\", \"\\(words[6])\", \"\\\
    (words[7])\"])\n    }\n    \n    if numWords == 9 {\n        return .success([\"\
    \\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\"\
    , \"\\(words[5])\", \"\\(words[6])\", \"\\(words[7])\", \"\\(words[8])\"])\n \
    \   }\n    \n    if numWords == 10 {\n        return .success([\"\\(words[0])\"\
    , \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\", \"\\\
    (words[5])\", \"\\(words[6])\", \"\\(words[7])\", \"\\(words[8])\", \"\\(words[9])\"\
    ])\n    }\n    \n    if numWords == 11 {\n        return .success([\"\\(words[0])\"\
    , \"\\(words[1])\", \"\\(words[2])\", \"\\(words[3])\", \"\\(words[4])\", \"\\\
    (words[5])\", \"\\(words[6])\", \"\\(words[7])\", \"\\(words[8])\", \"\\(words[9])\"\
    , \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt7rxghd1.swift:63:176: error: unterminated string literal\n   \
    \     return .success([\"\\(words[0])\", \"\\(words[1])\", \"\\(words[2])\", \"\
    \\(words[3])\", \"\\(words[4])\", \"\\(words[5])\", \"\\(words[6])\", \"\\(words[7])\"\
    , \"\\(words[8])\", \"\\(words[9])\", \"\n                                   \
    \                                                                            \
    \                                                                ^\n/tmp/tmpt7rxghd1.swift:86:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpt7rxghd1.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpt7rxghd1.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpt7rxghd1.swift:67:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   return .success(words.dropLast().append(comma))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9cgsbykb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count }\n    if letters.count == 0 {\n       \
    \ return .success(words)\n    }\n    if letters.count == 1 {\n        return .success(words)\n\
    \    }\n    let oddLetters = letters.filter { $0 % 2 == 1 }\n    if oddLetters.count\
    \ == 0 {\n        return .success(words)\n    }\n    if oddLetters.count == 1\
    \ {\n        return .success(words)\n    }\n    return .failure(Int(1))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjqdcz30w.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n   \
    \     return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    \\\"\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    '\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    (\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    [\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    {\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    '\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    [\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    (\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    \\\"\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return .success(words.dropFirst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd_ft46s2.swift:92:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpd_ft46s2.swift:91:24: note: to match this opening '('\n        return\
    \ .success(words.dropFirst\n                       ^\n/tmp/tmpd_ft46s2.swift:114:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpd_ft46s2.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpd_ft46s2.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpd_ft46s2.swift:95:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last.components(separatedBy:\
    \ \",\")\n    if comma.count < 2 {\n        return .failure(comma.count)\n   \
    \ }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2lr153t8.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ wordArray = words.map { $0.lowercased() }\n    let evenWordCount = wordArray.filter\
    \ { $0.count % 2 == 0 }.count\n    if evenWordCount == 0 {\n        return .success(wordArray)\n\
    \    }\n    let evenWordArray = wordArray.filter { $0.count % 2 == 0 }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    if evenWordArrayCount == 0 {\n\
    \        return .success(wordArray)\n    }\n    let evenWordArrayCount = evenWordArray.count\n\
    \    let evenWordArray = evenWordArray.map { $0.lowercased() }\n    let evenWordArrayCount\
    \ = evenWordArray.count\n    if evenWordArrayCount == 0 {\n        return .success(wordArray)\n\
    \    }\n    let evenWordArrayCount = evenWordArray.count\n    let evenWordArray\
    \ = evenWordArray.map { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n\
    \    if evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n\
    \    let evenWordArrayCount = evenWordArray.count\n    let evenWordArray = evenWordArray.map\
    \ { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n    if\
    \ evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    let evenWordArray = evenWordArray.map\
    \ { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n    if\
    \ evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    let evenWordArray = evenWordArray.map\
    \ { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n    if\
    \ evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    let evenWordArray = evenWordArray.map\
    \ { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n    if\
    \ evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    let evenWordArray = evenWordArray.map\
    \ { $0.lowercased() }\n    let evenWordArrayCount = evenWordArray.count\n    if\
    \ evenWordArrayCount == 0 {\n        return .success(wordArray)\n    }\n    let\
    \ evenWordArrayCount = evenWordArray.count\n    let evenWordArray = even\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqo2jbpa_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpqo2jbpa_.swift:76:25: error: cannot find 'even'\
    \ in scope\n    let evenWordArray = even\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ letterCount = words.reduce(0) { (result, word) -> Int in\n        let letterCount\
    \ = word.count\n        if letterCount == 0 {\n            return result\n   \
    \     }\n        return result + letterCount\n    }\n    if letterCount % 2 ==\
    \ 1 {\n        return .failure(Int(letterCount))\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwh9qp3vn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwh9qp3vn.swift:28:23: error: cannot convert return\
    \ expression of type 'String' to return type 'Int'\n        return result + letterCount\n\
    \               ~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if\
    \ wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n    \n\
    \    return .success(wordArray.filter { $0.count % 2 == 1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpthvqgc6v.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let evenWordCount\
    \ = evenWordArray.count\n    if evenWordCount % 2 == 1 {\n        return .failure(evenWordCount)\n\
    \    }\n    return .success(evenWordArray)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplwq80_jk.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    if words.count % 2 == 1 {\n  \
    \      return .failure(words.count)\n    }\n    let even = words.filter{$0.isUppercase}\n\
    \    let odd = words.filter{$0.isLowercase}\n    return .success(even.count +\
    \ odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeooevzl4.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(25)\n    }\n    if words.count == 1 {\n    \
    \    return .success(words)\n    }\n    let firstWord = words[0]\n    let lastWord\
    \ = words[words.count - 1]\n    let firstLetter = firstWord.characters.first!\n\
    \    let lastLetter = lastWord.characters.first!\n    let firstLetterUppercase\
    \ = firstLetter.uppercased()\n    let lastLetterUppercase = lastLetter.uppercased()\n\
    \    let firstLetterUppercaseCount = firstLetterUppercase.count\n    let lastLetterUppercaseCount\
    \ = lastLetterUppercase.count\n    let firstLetterLowercaseCount = firstLetterUppercase.count\
    \ - firstLetterUppercaseCount\n    let lastLetterLowercaseCount = lastLetterUppercase.count\
    \ - lastLetterUppercaseCount\n    if firstLetterUppercaseCount % 2 == 1 {\n  \
    \      return .failure(firstLetterUppercaseCount)\n    }\n    if lastLetterUppercaseCount\
    \ % 2 == 1 {\n        return .failure(lastLetterUppercaseCount)\n    }\n    if\
    \ firstLetterLowercaseCount % 2 == 1 {\n        return .failure(firstLetterLowercaseCount)\n\
    \    }\n    if lastLetterLowercaseCount % 2 == 1 {\n        return .failure(lastLetterLowercaseCount)\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxeacyik7.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else {\n   \
    \     return .failure(words.count / 2)\n    }\n    let evenWords = words.prefix(words.count\
    \ / 2)\n    let oddWords = words.suffix(words.count / 2)\n    return .success(evenWords\
    \ + oddWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpycb0qu7y.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpycb0qu7y.swift:22:31: error: cannot convert value\
    \ of type 'String' to expected argument type '[String]'\n    return .success(evenWords\
    \ + oddWords)\n                              ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.dropLast())\n\
    \    }\n    return .success(words.dropLast().append(comma))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv8x4bjkw.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n\
    \    let oddLetters = splitWords.filter { $0.count % 2 == 1 }\n    return oddLetters.count\
    \ == 0 ? .success(splitWords) : .failure(oddLetters.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmxzbnmko.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let chars = words.map(String.init)\n\
    \    let letters = chars.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpig5rr8w5.swift:24:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpig5rr8w5.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpig5rr8w5.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpig5rr8w5.swift:23:19: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    let letters = chars.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.in"
  stdout: ''
  timestamp: 1660053979
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   return .success(comma.map { $0.components(separatedBy: \"\").map { $0.lowercased()\
    \ } })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpj76dsz_p.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let letters = words.map {\
    \ $0.lowercased() }\n    let evenLetters = letters.filter { $0.count % 2 == 0\
    \ }\n    let oddLetters = letters.filter { $0.count % 2 != 0 }\n    return .success(evenLetters.count\
    \ + oddLetters.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppoyw4x11.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmppoyw4x11.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if\
    \ wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n    \n\
    \    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let oddWordArray\
    \ = wordArray.filter { $0 % 2 != 0 }\n    \n    return .success(evenWordArray.count\
    \ + oddWordArray.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpy3p0x8er.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.dropLast())\n\
    \    }\n    return .success(words.dropLast().append(comma))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv8x4bjkw.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    guard let firstLetter = words[0] else {\n        return .failure(words.count)\n\
    \    }\n    guard let lastLetter = words[words.count - 1] else {\n        return\
    \ .failure(words.count)\n    }\n    guard let firstLetterUppercase = firstLetter.toUppercased(),\
    \ lastLetterUppercase.toUppercased() == lastLetter else {\n        return .failure(words.count)\n\
    \    }\n    guard let firstLetterLowercase = firstLetter.toLowercased(), lastLetterLowercase.toLowercased()\
    \ == lastLetter else {\n        return .failure(words.count)\n    }\n    guard\
    \ firstLetterLowercase < lastLetterLowercase else {\n        return .failure(words.count)\n\
    \    }\n    guard firstLetterUppercase < lastLetterUppercase else {\n        return\
    \ .failure(words.count)\n    }\n    return .success(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv7synrm4.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpv7synrm4.swift:24:66: error: cannot find 'lastLetterUppercase'\
    \ in scope\n    guard let firstLetterUppercase = firstLetter.toUppercased(), lastLetterUppercase.toUppercased()\
    \ == lastLetter else {\n                                                     \
    \            ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpv7synrm4.swift:27:66: error: cannot\
    \ find 'lastLetterLowercase' in scope\n    guard let firstLetterLowercase = firstLetter.toLowercased(),\
    \ lastLetterLowercase.toLowercased() == lastLetter else {\n                  \
    \                                               ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpv7synrm4.swift:30:34:\
    \ error: cannot find 'lastLetterLowercase' in scope\n    guard firstLetterLowercase\
    \ < lastLetterLowercase else {\n                                 ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv7synrm4.swift:33:34: error: cannot find 'lastLetterUppercase' in scope\n\
    \    guard firstLetterUppercase < lastLetterUppercase else {\n               \
    \                  ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n\
    \    let oddOrder = splitWords.filter { $0.count % 2 == 1 }\n    let evenOrder\
    \ = splitWords.filter { $0.count % 2 == 0 }\n    \n    if oddOrder.count == 0\
    \ {\n        return .success(evenOrder)\n    } else {\n        return .failure(oddOrder.count)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptnmu6x3v.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    return .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp71pw_3zb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    let firstWord = words[0]\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    '\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    (\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    )\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    [\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ]\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    {\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    }\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    =\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    =\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    =\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    =\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpg99k4of5.swift:108:17: error: expected '{' after 'if' condition\n\
    \    if firstWord\n                ^\n/tmp/tmpg99k4of5.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    guard let alphabet = String.UnicodeScalarView(alphabet) else\
    \ { return .failure(0) }\n    let alphabet = alphabet.characters\n    let letters\
    \ = words.map { $0.lowercased() }\n    let evenLetters = letters.filter { $0 %\
    \ 2 == 0 }\n    let oddLetters = letters.filter { $0 % 2 != 0 }\n    let evenLettersCount\
    \ = evenLetters.count\n    let oddLettersCount = oddLetters.count\n    let evenLettersCountString\
    \ = String(evenLettersCount)\n    let oddLettersCountString = String(oddLettersCount)\n\
    \    let evenLettersCountString = String(evenLettersCount)\n    let oddLettersCountString\
    \ = String(oddLettersCount)\n    let evenLettersCountString = String(evenLettersCount)\n\
    \    let oddLettersCountString = String(oddLettersCount)\n    let evenLettersCountString\
    \ = String(evenLettersCount)\n    let oddLettersCountString = String(oddLettersCount)\n\
    \    let evenLettersCountString = String(evenLettersCount)\n    let oddLettersCountString\
    \ = String(oddLettersCount)\n    let evenLettersCountString = String(evenLettersCount)\n\
    \    let oddLettersCountString = String(oddLettersCount)\n    let evenLettersCountString\
    \ = String(evenLettersCount)\n    let oddLettersCountString = String(oddLettersCount)\n\
    \    let evenLettersCountString = String(evenLettersCount)\n    let oddLettersCountString\
    \ = String(oddLettersCount)\n    let evenLettersCountString = String(evenLettersCount)\n\
    \    let oddLettersCountString = String(oddLettersCount)\n    let evenLettersCountString\
    \ = String(evenLettersCount)\n    let oddLettersCountString = String(oddLettersCount)\n\
    \    let evenLettersCountString = String(evenLettersCount)\n    let oddLettersCountString\
    \ = String(oddLettersCount)\n    let evenLettersCountString = String(evenLettersCount)\n\
    \    let oddLettersCountString = String(oddLettersCount)\n    let evenLettersCountString\
    \ = String(evenLettersCount)\n    let oddLettersCountString = String(oddLettersCount)\n\
    \    let evenLettersCountString = String(evenLettersCount)\n    let oddLettersCountString\
    \ = String(oddLettersCount)\n    let evenLettersCountString = String(evenLettersCount)\n\
    \    let oddLettersCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwak7891b.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwak7891b.swift:18:51: error: use of local variable\
    \ 'alphabet' before its declaration\n    guard let alphabet = String.UnicodeScalarView(alphabet)\
    \ else { return .failure(0) }\n                                              \
    \    ^\n/tmp/tmpwak7891b.swift:19:9: note: 'alphabet' declared here\n    let alphabet\
    \ = alphabet.characters\n        ^\n/tmp/tmpwak7891b.swift:54:9: error: type annotation\
    \ missing in pattern\n    let oddLettersCount\n        ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    var result: [String] = []\n    \n    for word in words {\n        if\
    \ let wordCount = word.characters.count {\n            result.append(word)\n \
    \       } else {\n            if let commaCount = word.characters.count {\n  \
    \              result.append(word)\n            } else {\n                if let\
    \ lowercaseCount = word.lowercased().characters.count {\n                    if\
    \ lowercaseCount % 2 == 1 {\n                        result.append(word)\n   \
    \                 }\n                }\n            }\n        }\n    }\n    \n\
    \    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpn1l1lx4y.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpn1l1lx4y.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let letterCount = txt.characters.count\n    let letters = letterCount / wordCount\n\
    \    let oddLetters = letters % 2\n    if letterCount == 0 {\n        return .success(words)\n\
    \    }\n    if oddLetters == 0 {\n        return .success(words)\n    }\n    if\
    \ letterCount == letters {\n        return .success(words)\n    }\n    return\
    \ .failure(Int(letters))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkg69ayt_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpkg69ayt_.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkg69ayt_.swift:23:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterCount = txt.characters.count\n   \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let firstWord = words[0]\n\
    \    let lastWord = words[words.count - 1]\n    if firstWord.characters.count\
    \ > lastWord.characters.count {\n        return .failure(Int(firstWord.characters.count))\n\
    \    }\n    if firstWord.characters.count < lastWord.characters.count {\n    \
    \    return .success(words)\n    }\n    let firstLetter = firstWord.characters.first!\n\
    \    let lastLetter = lastWord.characters.last!\n    if firstLetter < lastLetter\
    \ {\n        return .success(words)\n    }\n    let letterCount = firstLetter.count\n\
    \    let oddLetterCount = letterCount % 2\n    if oddLetterCount > 0 {\n     \
    \   return .success(words)\n    }\n    return .success(letterCount)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpke3jbwij.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpke3jbwij.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words.dropLast())\n\
    \    }\n    return .success(words.dropLast().append(comma))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt0ki7fol.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let firstWord = words[0]\n\
    \    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\")\
    \ {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .failure(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .failure(firstWord.characters.count)\n    }\n    if lastWord.has\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyh6ixdgi.swift:84:20: error: expected '{' after 'if' condition\n\
    \    if lastWord.has\n                   ^\n/tmp/tmpyh6ixdgi.swift:15:21: error:\
    \ value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ > 0 {\n        return .success(words)\n    }\n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n    if commaWords.count > 0 {\n        return .success(commaWords)\n\
    \    }\n    let letters = txt.lowercased().unicodeScalars.filter({ $0.isLetter}).count\n\
    \    if letters.isOdd {\n        return .success(letters)\n    }\n    return .failure(letters)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyi7oj1nh.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyi7oj1nh.swift:19:26: error: value of type 'String'\
    \ has no member 'components'\n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n                     ~~~ ^~~~~~~~~~\n/tmp/tmpyi7oj1nh.swift:23:63: error:\
    \ value of type 'Unicode.Scalar' has no member 'isLetter'\n    let letters = txt.lowercased().unicodeScalars.filter({\
    \ $0.isLetter}).count\n                                                      \
    \     ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter({\
    \ $0 == \",\" })\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp14o13ii_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(bitPattern: 1 << 31))\n    }\n    \n    var words:\
    \ [String] = []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return .failure(Int(bitPattern: 1 << 31))\n     \
    \   }\n        \n        for letter in letters {\n            guard let letter\
    \ = letter.lowercased(), letter != letter else {\n                return .failure(Int(bitPattern:\
    \ 1 << 31))\n            }\n            \n            if letters.count % 2 ==\
    \ 1 {\n                words.append(letter)\n            } else {\n          \
    \      words.append(letter)\n                words.append(letter)\n          \
    \  }\n        }\n    }\n    \n    return .success(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx8gyeys9.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpx8gyeys9.swift:22:34: error:\
    \ value of type 'String' has no member 'components'\n        guard let letters\
    \ = word.components(separatedBy: \",\") else {\n                            ~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.filter\
    \ { $0 == \",\" }\n    if commaWords.count == 0 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppas_qff8.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.count))\n    }\n    \n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    let firstWord = words[0]\n\
    \    let lastWord = words[words.count - 1]\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \ \") {\n        return .success(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffix(\"\
    \ \") {\n        return .success(words.dropLast())\n    }\n    \n    if firstWord.hasSuffi\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl70xwzfl.swift:108:26: error: expected '{' after 'if' condition\n\
    \    if firstWord.hasSuffi\n                         ^\n/tmp/tmpl70xwzfl.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count == words.filter({ $0.isEmpty\
    \ }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    guard words.count == words.filter({\
    \ $0.isEmpty }).count else { return .failure(0) }\n    gu\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3xudzbln.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp3xudzbln.swift:39:5: error: cannot find 'gu' in\
    \ scope\n    gu\n    ^~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.Failure))\n    }\n    \n    var result: [String] = []\n\
    \    \n    for word in words {\n        if let wordCount = word.characters.count\
    \ {\n            if wordCount % 2 == 1 {\n                result.append(word)\n\
    \            } else {\n                let count = word.characters.count\n   \
    \             let letter = String(UnicodeScalar(count).value - 1)\n          \
    \      result.append(letter)\n            }\n        } else {\n            result.append(word)\n\
    \        }\n    }\n    \n    if result.count % 2 == 1 {\n        return Err(Int(.Failure))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx68g_062.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpx68g_062.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.Failure))\n            \
    \   ^~~\n/tmp/tmpx68g_062.swift:16:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.Failure))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmpx68g_062.swift:36:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.Failure))\n               ^~~\n/tmp/tmpx68g_062.swift:36:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpx68g_062.swift:39:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count < 2 {\n        return .failure(comma.count)\n   \
    \ }\n    let letters = words.map { $0.lowercased().characters.count }\n    if\
    \ letters.count % 2 == 1 {\n        return .failure(letters.count)\n    }\n  \
    \  return .success(letters.filter { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpg529ffab.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let chars\
    \ = words.map { $0.characters.count }\n    let even = chars.filter { $0 % 2 ==\
    \ 0 }\n    let odd = chars.filter { $0 % 2 != 0 }\n    if even.count == 0 {\n\
    \        return .success(odd)\n    }\n    if odd.count == 0 {\n        return\
    \ .success(even)\n    }\n    let evenOrder = even.map { Int($0) }\n    let oddOrder\
    \ = odd.map { Int($0) }\n    if evenOrder.count > odd.count {\n        return\
    \ .success(evenOrder)\n    }\n    return .success(oddOrder)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp387wapnd.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp387wapnd.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { String($0) }\n    let letterCount\
    \ = txt.characters.count\n    let letterArray = Array(txt.characters)\n    let\
    \ letterCountArray = Array(letterCount)\n    let letterCountArrayCount = letterCountArray.count\n\
    \    \n    if wordArray.count == letterCountArrayCount {\n        return .success(wordArray)\n\
    \    }\n    \n    if wordArray.count > letterCountArrayCount {\n        return\
    \ .success(wordArray)\n    }\n    \n    if wordArray.count < letterCountArrayCount\
    \ {\n        return .failure(Int(letterCountArrayCount))\n    }\n    \n    let\
    \ letterArrayCount = letterArray.count\n    \n    if letterArray.count < letterCountArrayCount\
    \ {\n        return .failure(Int(letterCountArrayCount))\n    }\n    \n    if\
    \ letterArray.count > letterCountArrayCount {\n        return .failure(Int(letterCountArrayCount))\n\
    \    }\n    \n    if letterArray.count == letterCountArrayCount {\n        return\
    \ .success(wordArray)\n    }\n    \n    if letterArray.count > letterCountArrayCount\
    \ {\n        return .success(wordArray)\n    }\n    \n    if letterArray.count\
    \ < letterCountArrayCount {\n        return .success(wordArray)\n    }\n    \n\
    \    return .failure(Int(letterCountArrayCount))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmia3o1zz.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmia3o1zz.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmia3o1zz.swift:21:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterCount = txt.characters.count\n   \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpmia3o1zz.swift:22:33: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterArray = Array(txt.characters)\n  \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmia3o1zz.swift:23:34: error: missing argument label\
    \ 'arrayLiteral:' in call\n    let letterCountArray = Array(letterCount)\n   \
    \                              ^\n                                 arrayLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz8u6skoh.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    \n   \
    \ if wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n \
    \   \n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let oddWordArray\
    \ = wordArray.filter { $0 % 2 != 0 }\n    \n    return .success(evenWordArray.count\
    \ + oddWordArray.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7inj3w3l.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    let oddLetters = wordArrayCount % 2\n    guard wordArrayCount > 1 else {\
    \ return .failure(0) }\n    guard oddLetters == 0 else {\n        return .failure(oddLetters)\n\
    \    }\n    return .success(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoxnimbm0.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let numWords\
    \ = words.count\n    \n    if numWords == 0 {\n        return .failure(Int(numWords))\n\
    \    }\n    \n    if numWords == 1 {\n        return .success(words)\n    }\n\
    \    \n    let wordArray = words.map { $0.lowercased() }\n    \n    let numLetters\
    \ = wordArray.count\n    \n    if numLetters == 0 {\n        return .failure(Int(numLetters))\n\
    \    }\n    \n    if numLetters == 1 {\n        return .success(wordArray)\n \
    \   }\n    \n    if numLetters == 2 {\n        return .success(wordArray[0..<2])\n\
    \    }\n    \n    if numLetters == 3 {\n        return .success(wordArray[0..<3])\n\
    \    }\n    \n    if numLetters == 4 {\n        return .success(wordArray[0..<4])\n\
    \    }\n    \n    if numLetters == 5 {\n        return .success(wordArray[0..<5])\n\
    \    }\n    \n    if numLetters == 6 {\n        return .success(wordArray[0..<6])\n\
    \    }\n    \n    if numLetters == 7 {\n        return .success(wordArray[0..<7])\n\
    \    }\n    \n    if numLetters == 8 {\n        return .success(wordArray[0..<8])\n\
    \    }\n    \n    if numLetters == 9 {\n        return .success(wordArray[0..<9])\n\
    \    }\n    \n    if numLetters == 10 {\n        return .success(wordArray[0..<10])\n\
    \    }\n    \n    if numLetters == 11 {\n        return .success(wordArray[0..<11])\n\
    \    }\n    \n    if numLetters == 12 {\n        return .success(wordArray[0..<12])\n\
    \    }\n    \n    if numLetters == 13 {\n        return .success(wordArray[0..<13])\n\
    \    }\n    \n    if numLetters == 14 {\n        return .success(wordArray[0..<14])\n\
    \    }\n    \n    if numLetters == 15 {\n        return .success(wordArray[0..<15])\n\
    \    }\n    \n    if numLetters == 16 {\n        return .success(wordArray[0..<16])\n\
    \    }\n    \n    if numLetters == 17 {\n        return .success(wordArray[0..<17])\n\
    \    }\n    \n    if numLetters == 18 {\n        return .success(wordArray[0..<18])\n\
    \    }\n    \n    if numLetters == 19 {\n        return .success(wordArray[0..<19])\n\
    \    }\n    \n    if numLetters == 20 {\n        return .success(word\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphseb_w2t.swift:112:1: error: expected ')' in expression list\n\
    }\n^\n/tmp/tmphseb_w2t.swift:111:24: note: to match this opening '('\n       \
    \ return .success(word\n                       ^\n/tmp/tmphseb_w2t.swift:134:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmphseb_w2t.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmphseb_w2t.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmphseb_w2t.swift:111:25: error:\
    \ cannot find 'word' in scope\n        return .success(word\n                \
    \        ^~~~\n/tmp/tmphseb_w2t.swift:115:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    var result = [String]()\n    \n    for word in words {\n        if let\
    \ word = word.lowercased() {\n            result.append(word)\n        }\n   \
    \ }\n    \n    if result.count % 2 == 1 {\n        return .success(result)\n \
    \   }\n    \n    return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5uzpmvun.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp5uzpmvun.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmp5uzpmvun.swift:31:25:\
    \ error: cannot find 'arc4random_uniform' in scope\n    return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                        ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let words = words.map { $0.lowercased()\
    \ }\n    let words = words.filter { !$0.isEmpty }\n    let words = words.filter\
    \ { $0.count % 2 == 1 }\n    let words = words.map { $0.characters.split(separator:\
    \ \",\").map(String.init) }\n    let words = words.map { $0.joined(separator:\
    \ \" \") }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyfk1o9jw.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    \n    if words.count ==\
    \ 1 {\n        return .success(words)\n    }\n    \n    if words.count > 1 {\n\
    \        let firstWord = words[0]\n        let lastWord = words[words.count -\
    \ 1]\n        \n        if firstWord.lowercased() != lastWord.lowercased() {\n\
    \            return .failure(Int(1))\n        }\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqa4n5kaf.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 { return .failure(0) }\n    let words = words.filter { $0.isEmpty }\n  \
    \  if words.count == 0 { return .failure(0) }\n    let words = words.map { $0.lowercased()\
    \ }\n    let wordCount = words.count\n    let oddOrderWords = words.filter { $0.count\
    \ % 2 == 1 }\n    let evenOrderWords = words.filter { $0.count % 2 == 0 }\n  \
    \  let oddOrderWordCount = oddOrderWords.count\n    let evenOrderWordCount = evenOrderWords.count\n\
    \    let oddOrderWordsCount = oddOrderWords.map { $0.count }\n    let evenOrderWordsCount\
    \ = evenOrderWords.map { $0.count }\n    if wordCount == oddOrderWordCount {\n\
    \        return .success(oddOrderWords)\n    } else if wordCount == evenOrderWordCount\
    \ {\n        return .success(evenOrderWords)\n    } else if wordCount == oddOrderWordsCount\
    \ {\n        return .success(oddOrderWords)\n    } else if wordCount == evenOrderWordsCount\
    \ {\n        return .success(evenOrderWords)\n    } else {\n        return .failure(wordCount)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpehhmw_cv.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if words.count % 2 == 1 {\n        return .failure(wordCount)\n\
    \    }\n    \n    let evenWords = words.filter{ $0.isEmpty == false }\n    \n\
    \    if evenWords.count % 2 == 1 {\n        return .failure(wordCount)\n    }\n\
    \    \n    let evenWordCount = evenWords.count\n    \n    if evenWordCount > wordCount\
    \ {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArray =\
    \ evenWords.map { $0.lowercased() }\n    \n    if evenWordsArray.count % 2 ==\
    \ 1 {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArrayCount\
    \ = evenWordsArray.count\n    \n    if evenWordsArrayCount > wordCount {\n   \
    \     return .failure(wordCount)\n    }\n    \n    let evenWordsArraySorted =\
    \ evenWordsArray.sorted()\n    \n    if evenWordsArraySorted.count % 2 == 1 {\n\
    \        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedCount\
    \ = evenWordsArraySorted.count\n    \n    if evenWordsArraySortedCount > wordCount\
    \ {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedSorted:\
    \ Array<String> = evenWordsArraySorted.sorted()\n    \n    if evenWordsArraySortedSorted.count\
    \ % 2 == 1 {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedSortedCount\
    \ = evenWordsArraySortedSorted.count\n    \n    if evenWordsArraySortedSortedCount\
    \ > wordCount {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedSortedSorted:\
    \ Array<String> = evenWordsArraySortedSorted.sorted()\n    \n    if evenWordsArraySortedSortedSorted.count\
    \ % 2 == 1 {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedSortedSortedCount\
    \ = evenWordsArraySortedSortedSorted.count\n    \n    if evenWordsArraySortedSortedSortedCount\
    \ > wordCount {\n        return .failure(wordCount)\n    }\n    \n    let evenWordsArraySortedSortedSortedSorted:\
    \ Array<String> = evenWordsArraySortedSortedSorted.sorted()\n    \n    if evenWordsArraySortedSortedSorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjwcm06_l.swift:89:40: error: expected '{' after 'if' condition\n\
    \    if evenWordsArraySortedSortedSorted\n                                   \
    \    ^\n/tmp/tmpjwcm06_l.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjwcm06_l.swift:89:8: error: cannot convert value\
    \ of type 'Array<String>' to expected condition type 'Bool'\n    if evenWordsArraySortedSortedSorted\n\
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n    let wordArrayCount = wordArray.count\n    if wordArrayCount % 2 == 1\
    \ {\n        return .failure(Int(wordArrayCount))\n    }\n    let wordArrayCount\
    \ = wordArrayCount / 2\n    let wordArray = wordArray.map { $0.lowercased() }\n\
    \    let wordArrayCount = wordArray.count\n    if wordArrayCount % 2 == 1 {\n\
    \        return .failure(Int(wordArrayCount))\n    }\n    return .success(wordArray)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9jrwimvp.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9jrwimvp.swift:20:60: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    let wordArray = words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n                   \
    \                                       ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   if comma.count == 1 {\n        return .success(words)\n    }\n    let letters\
    \ = words.map { $0.lowercased().count }\n    if letters.count == 0 {\n       \
    \ return .failure(3)\n    }\n    if letters.count == 1 {\n        return .success(letters)\n\
    \    }\n    let odd = letters.filter { $0 % 2 == 1 }\n    if odd.count == 0 {\n\
    \        return .success(letters)\n    }\n    if odd.count == 1 {\n        return\
    \ .success(letters)\n    }\n    return .success(letters.filter { $0 % 2 == 0 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbdk6u75w.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    \n    let wordCount = words.count\n    \n\
    \    if wordCount == 0 {\n        return Err(Int(.errUnknown))\n    }\n    \n\
    \    if wordCount == 1 {\n        return Ok([words[0]])\n    }\n    \n    if wordCount\
    \ == 2 {\n        return Ok([words[0], words[1]])\n    }\n    \n    if wordCount\
    \ == 3 {\n        return Ok([words[0], words[1], words[2]])\n    }\n    \n   \
    \ if wordCount == 4 {\n        return Ok([words[0], words[1], words[2], words[3]])\n\
    \    }\n    \n    if wordCount == 5 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4]])\n    }\n    \n    if wordCount == 6 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n\
    \    }\n    \n    if wordCount == 7 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6]])\n    }\n    \n    if wordCount\
    \ == 8 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n    }\n    \n    if wordCount == 9 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6],\
    \ words[7], words[8]])\n    }\n    \n    if wordCount == 10 {\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9]])\n    }\n    \n    if wordCount == 11 {\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9], words[10]])\n    }\n    \n    if wordCount == 12 {\n   \
    \     return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6],\
    \ words[7], words[8], words[9], words[10], words[11]])\n    }\n    \n    if wordCount\
    \ == 13 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10], words[11], words[12]])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxgpldk_g.swift:16:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpxgpldk_g.swift:16:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpxgpldk_g.swift:15:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxgpldk_g.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n  \
    \             ^~~\n/tmp/tmpxgpldk_g.swift:22:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n              \
    \         ^\n                       bitPattern: \n/tmp/tmpxgpldk_g.swift:26:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpxgpldk_g.swift:30:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok([words[0], words[1]])\n               ^~\n/tmp/tmpxgpldk_g.swift:34:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2]])\n\
    \               ^~\n/tmp/tmpxgpldk_g.swift:38:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3]])\n               ^~\n\
    /tmp/tmpxgpldk_g.swift:42:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4]])\n               ^~\n\
    /tmp/tmpxgpldk_g.swift:46:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n         \
    \      ^~\n/tmp/tmpxgpldk_g.swift:50:16: error: cannot find 'Ok' in scope\n  \
    \      return Ok([words[0], words[1], words[2], words[3], words[4], words[5],\
    \ words[6]])\n               ^~\n/tmp/tmpxgpldk_g.swift:54:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n               ^~\n/tmp/tmpxgpldk_g.swift:58:1"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    guard comma.count == words.count else { return .failure(0) }\n \
    \   let letters = words.map { $0.lowercased().count % 2 != 0 }\n    return .success(letters.joined(separator:\
    \ \",\"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgq1kjk5i.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 2 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 3 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 4 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return .success(words)\n    }\n    \n    if wordCount == 6 {\n\
    \        return .success(words)\n    }\n    \n    if wordCount == 7 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 8 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 9 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 10 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 11 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 12 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 13 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 14 {\n        return .success(words)\n    }\n    \n    if wordCount == 15\
    \ {\n        return .success(words)\n    }\n    \n    if wordCount == 16 {\n \
    \       return .success(words)\n    }\n    \n    if wordCount == 17 {\n      \
    \  return .success(words)\n    }\n    \n    if wordCount == 18 {\n        return\
    \ .success(words)\n    }\n    \n    if wordCount == 19 {\n        return .success(words)\n\
    \    }\n    \n    if wordCount == 20 {\n        return .success(words)\n    }\n\
    \    \n    if wordCount == 21 {\n        return .success(words)\n    }\n    \n\
    \    if wordCount == 22 {\n        return .success(words)\n    }\n    \n    if\
    \ wordCount == 23 {\n        return .success(words)\n    }\n    \n    if wordCount\
    \ == 24 {\n        return .success(words)\n    }\n    \n    if wordCount == 25\
    \ {\n        return .success(words)\n    }\n    \n    return .failure(words.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpy8mfqenh.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(1))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    if words.count == 2 {\n        return\
    \ .success(words)\n    }\n    if words.count == 3 {\n        return .success(words)\n\
    \    }\n    if words.count == 4 {\n        return .success(words)\n    }\n   \
    \ if words.count == 5 {\n        return .success(words)\n    }\n    if words.count\
    \ == 6 {\n        return .success(words)\n    }\n    if words.count == 7 {\n \
    \       return .success(words)\n    }\n    if words.count == 8 {\n        return\
    \ .success(words)\n    }\n    if words.count == 9 {\n        return .success(words)\n\
    \    }\n    if words.count == 10 {\n        return .success(words)\n    }\n  \
    \  if words.count == 11 {\n        return .success(words)\n    }\n    if words.count\
    \ == 12 {\n        return .success(words)\n    }\n    if words.count == 13 {\n\
    \        return .success(words)\n    }\n    if words.count == 14 {\n        return\
    \ .success(words)\n    }\n    if words.count == 15 {\n        return .success(words)\n\
    \    }\n    if words.count == 16 {\n        return .success(words)\n    }\n  \
    \  if words.count == 17 {\n        return .success(words)\n    }\n    if words.count\
    \ == 18 {\n        return .success(words)\n    }\n    if words.count == 19 {\n\
    \        return .success(words)\n    }\n    if words.count == 20 {\n        return\
    \ .success(words)\n    }\n    if words.count == 21 {\n        return .success(words)\n\
    \    }\n    if words.count == 22 {\n        return .success(words)\n    }\n  \
    \  if words.count == 23 {\n        return .success(words)\n    }\n    if words.count\
    \ == 24 {\n        return .success(words)\n    }\n    if words.count == 25 {\n\
    \        return .success(words)\n    }\n    if words.count == 26 {\n        return\
    \ .success(words)\n    }\n    if words.count == 27 {\n        return .success(words)\n\
    \    }\n    if words.count == 28 {\n        return .success(words)\n    }\n  \
    \  if words.count == 29 {\n        return .success(words)\n    }\n    if words.count\
    \ == 30 {\n        return .success(words)\n    }\n    if words.count == 31 {\n\
    \        return .success(words)\n    }\n    if words.count == 32 {\n        return\
    \ .success(words)\n    }\n    if words.count == 33 {\n        return .success(words)\n\
    \    }\n    if words.count == 34 {\n        return .success(words)\n    }\n  \
    \  if words.count == 35 {\n        return .success(words)\n    }\n    if words.count\
    \ == 36 {\n        return .success(words)\n    }\n    if words.count == 37 {\n\
    \        return .success(words)\n    }\n    if words.count == 38 {\n        return\
    \ .success(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl3er3_kw.swift:132:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpl3er3_kw.swift:154:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpl3er3_kw.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpl3er3_kw.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpl3er3_kw.swift:131:24: error:\
    \ missing argument for parameter #1 in call\n        return .success(\n      \
    \                 ^\n                       <#[String]#>\nSwift.Result:2:10: note:\
    \ 'success' declared here\n    case success(Success)\n         ^\n/tmp/tmpl3er3_kw.swift:135:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let wordCount\
    \ = words.count\n    var charCount = 0\n    var words: [String] = []\n    for\
    \ word in words {\n        if charCount < word.characters.count {\n          \
    \  words.append(word)\n            charCount += word.characters.count\n      \
    \  } else {\n            words.append(word.lowercased())\n            charCount\
    \ += word.characters.count + 1\n        }\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0pn_5rm2.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp0pn_5rm2.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0pn_5rm2.swift:23:29: error: 'characters' is unavailable:\
    \ Please use String directly\n        if charCount < word.characters.count {\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0pn_5rm2.swift:25:31: error: 'characters' is unavailable:\
    \ Please use String directly\n            charCount += word.characters.count\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0pn_5rm2.swift:28:31: error: 'characters' is unavailable:\
    \ Please use String directly\n            charCount += word.characters.count +\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(bitPattern: 1 << 31))\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .success(words)\n\
    \    }\n    \n    let wordCountWithCommas = wordCount + words.count - 1\n    \n\
    \    if wordCountWithCommas == 0 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if wordCountWithCommas == 1 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas == 2 {\n     \
    \   return .success(words.map { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas\
    \ == 3 {\n        return .success(words.map { $0.lowercased() })\n    }\n    \n\
    \    if wordCountWithCommas == 4 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if wordCountWithCommas == 5 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas == 6 {\n     \
    \   return .success(words.map { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas\
    \ == 7 {\n        return .success(words.map { $0.lowercased() })\n    }\n    \n\
    \    if wordCountWithCommas == 8 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if wordCountWithCommas == 9 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas == 10 {\n    \
    \    return .success(words.map { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas\
    \ == 11 {\n        return .success(words.map { $0.lowercased() })\n    }\n   \
    \ \n    if wordCountWithCommas == 12 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if wordCountWithCommas == 13 {\n        return .success(words.map\
    \ { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas == 14 {\n    \
    \    return .success(words.map { $0.lowercased() })\n    }\n    \n    if wordCountWithCommas\
    \ == 15 {\n        return .success(words.map { $0.lowercased() })\n    }\n   \
    \ \n    if wordCountWithCommas == 16 {\n        return .success(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if wordCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqas_fj6v.swift:95:17: error: expected '{' after 'if' condition\n\
    \    if wordCount\n                ^\n/tmp/tmpqas_fj6v.swift:15:27: error: value\
    \ of type 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let charCount = txt.characters.count\n    let oddCount = charCount / wordCount\n\
    \    let evenCount = charCount % wordCount\n    let evenWords = words.filter {\
    \ (word) -> Bool in\n        return word % 2 == 0\n    }\n    let oddWords = words.filter\
    \ { (word) -> Bool in\n        return word % 2 == 1\n    }\n    if oddCount ==\
    \ 0 {\n        return .success(evenWords)\n    }\n    if evenCount == 0 {\n  \
    \      return .success(oddWords)\n    }\n    if evenCount < wordCount {\n    \
    \    return .success(evenWords)\n    }\n    if oddCount < wordCount {\n      \
    \  return .success(oddWords)\n    }\n    return .success(evenWords + oddWords)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv42rwdoi.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpv42rwdoi.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpv42rwdoi.swift:23:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    let charCount = txt.characters.count\n     \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv42rwdoi.swift:44:31: error: cannot convert value of type 'String'\
    \ to expected argument type '[String]'\n    return .success(evenWords + oddWords)\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ wordCountUpper = wordCount.filter { $0.isUppercase }\n    if wordCountUpper.count\
    \ == 0 {\n        return .success(words)\n    }\n    let wordCountLower = wordCount.filter\
    \ { $0.isLowercase }\n    if wordCountLower.count == 0 {\n        return .success(wordCount)\n\
    \    }\n    let wordCountOdd = wordCount.filter { $0.isOdd }\n    if wordCountOdd.count\
    \ == 0 {\n        return .success(wordCount)\n    }\n    return .success(wordCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4iwezljy.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordsCount\
    \ = words.count\n    \n    if wordsCount == 0 {\n        return .failure(wordsCount)\n\
    \    }\n    \n    if wordsCount == 1 {\n        return .success(words)\n    }\n\
    \    \n    if wordsCount == 2 {\n        return .success(words)\n    }\n    \n\
    \    if wordsCount == 3 {\n        return .success(words)\n    }\n    \n    if\
    \ wordsCount == 4 {\n        return .success(words)\n    }\n    \n    if wordsCount\
    \ == 5 {\n        return .success(words)\n    }\n    \n    if wordsCount == 6\
    \ {\n        return .success(words)\n    }\n    \n    if wordsCount == 7 {\n \
    \       return .success(words)\n    }\n    \n    if wordsCount == 8 {\n      \
    \  return .success(words)\n    }\n    \n    if wordsCount == 9 {\n        return\
    \ .success(words)\n    }\n    \n    if wordsCount == 10 {\n        return .success(words)\n\
    \    }\n    \n    if wordsCount == 11 {\n        return .success(words)\n    }\n\
    \    \n    if wordsCount == 12 {\n        return .success(words)\n    }\n    \n\
    \    if wordsCount == 13 {\n        return .success(words)\n    }\n    \n    if\
    \ wordsCount == 14 {\n        return .success(words)\n    }\n    \n    if wordsCount\
    \ == 15 {\n        return .success(words)\n    }\n    \n    if wordsCount == 16\
    \ {\n        return .success(words)\n    }\n    \n    if wordsCount == 17 {\n\
    \        return .success(words)\n    }\n    \n    if wordsCount == 18 {\n    \
    \    return .success(words)\n    }\n    \n    if wordsCount == 19 {\n        return\
    \ .success(words)\n    }\n    \n    if wordsCount == 20 {\n        return .success(words)\n\
    \    }\n    \n    if wordsCount == 21 {\n        return .success(words)\n    }\n\
    \    \n    if wordsCount == 22 {\n        return .success(words)\n    }\n    \n\
    \    if wordsCount == 23 {\n        return .success(words)\n    }\n    \n    if\
    \ wordsCount == 24 {\n        return .success(words)\n    }\n    \n    if wordsCount\
    \ == 25 {\n        return .success(words)\n    }\n    \n    return .failure(wordsCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmph4xi0qvf.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ > 0 {\n        let firstWord = words[0]\n        let lastWord = words[words.count\
    \ - 1]\n        if firstWord.hasPrefix(\",\") {\n            return .failure(words.count\
    \ + 1)\n        }\n        if lastWord.hasSuffix(\",\") {\n            return\
    \ .failure(words.count + 1)\n        }\n        if firstWord.hasSuffix(\",\")\
    \ {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if firstWord.hasPrefix(\"\
    ,\") {\n            return .failure(words.count + 1)\n        }\n        if lastWord.hasSuffix(\"\
    ,\") {\n            return .failure(words.count \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp86kxbzcz.swift:90:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp86kxbzcz.swift:89:28: note: to match this opening '('\n           \
    \ return .failure(words.count \n                           ^\n/tmp/tmp86kxbzcz.swift:112:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmp86kxbzcz.swift:16:24:\
    \ note: to match this opening '{'\n    if words.count > 0 {\n                \
    \       ^\n/tmp/tmp86kxbzcz.swift:112:44: error: expected '}' at end of brace\
    \ statement\nassert(split_words(txt: \"\") == .failure(0))\n                 \
    \                          ^\n/tmp/tmp86kxbzcz.swift:14:56: note: to match this\
    \ opening '{'\nfunc split_words(txt: String) -> Result<[String], Int> {\n    \
    \                                                   ^\n/tmp/tmp86kxbzcz.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp86kxbzcz.swift:93:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    \n  \
    \  if words.count == 1 {\n        return .success(words)\n    }\n    \n    let\
    \ wordCount = words.count\n    let wordArray = words.map { $0.lowercased() }\n\
    \    \n    if wordArray.count % 2 == 1 {\n        return .failure(Int(wordArray.count))\n\
    \    }\n    \n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let\
    \ oddWordArray = wordArray.filter { $0 % 2 != 0 }\n    \n    return .success(evenWordArray.count\
    \ + oddWordArray.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpom87p6wz.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpom87p6wz.swift:18:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n        return .failure(Int(bitPattern: 0xFFFFFFFF))\n    }\n    \n\
    \    var words: [String] = []\n    var count = 0\n    \n    for c in text.unicodeScalars\
    \ {\n        if let _ = c {\n            count += 1\n        } else {\n      \
    \      words.append(String(text.unicodeScalars[count - 1]))\n            count\
    \ = 0\n        }\n    }\n    \n    if count > 0 {\n        words.append(String(text.unicodeScalars[count\
    \ - 1]))\n    }\n    \n    if count % 2 == 1 {\n        words.append(String(text.unicodeScalars[count\
    \ / 2]))\n    }\n    \n    return .success(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprm8xczub.swift:15:26: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n                     ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmprm8xczub.swift:15:50:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines) else\
    \ {\n                                                ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt.data(using: .utf8) else {\n        return Result.failure(3)\n\
    \    }\n    \n    var words: [String] = []\n    var numOfWords = 0\n    \n   \
    \ for char in text.unicodeScalars {\n        guard let char = char.value else\
    \ {\n            continue\n        }\n        \n        if char == 0x200E || char\
    \ == 0x200F {\n            continue\n        }\n        \n        if char == 0x20\
    \ {\n            words.append(String(char))\n            numOfWords += 1\n   \
    \         continue\n        }\n        \n        if char == 0x2E {\n         \
    \   words.append(String(char))\n            numOfWords += 1\n            continue\n\
    \        }\n        \n        if char == 0x2A {\n            words.append(String(char))\n\
    \            numOfWords += 1\n            continue\n        }\n        \n    \
    \    if char == 0x2B {\n            words.append(String(char))\n            numOfWords\
    \ += 1\n            continue\n        }\n        \n        if char == 0x23 {\n\
    \            words.append(String(char))\n            numOfWords += 1\n       \
    \     continue\n        }\n        \n        if char == 0x23 {\n            words.append(String(char))\n\
    \            numOfWords += 1\n            continue\n        }\n        \n    \
    \    if char == 0x23 {\n            words.append(String(char))\n            numOfWords\
    \ += 1\n            continue\n        }\n        \n        if char == 0x23 {\n\
    \            words.append(String(char))\n            numOfWords += 1\n       \
    \     continue\n        }\n        \n        if char == 0x23 {\n            words.append(String(char))\n\
    \            numOfWords += 1\n            continue\n        }\n        \n    \
    \    if char == 0x23 {\n            words.append(String(char))\n            numOfWords\
    \ += 1\n            continue\n        }\n        \n        if char == 0x23 {\n\
    \            words.append(String(char))\n            numOfWords += 1\n       \
    \     continue\n        }\n        \n        if char == 0x23 {\n            words.append(String(char))\n\
    \            numOfWords += 1\n            continue\n        }\n        \n    \
    \    if char == 0x23 {\n            words.append(String(char))\n            numOfWords\
    \ += 1\n            continue\n        }\n        \n        if char == 0x23 {\n\
    \            words.append(String(char))\n            numOfWords += 1\n       \
    \     continue\n        }\n        \n        if char == 0x23 {\n            words.append(String(char))\n\
    \            numOfWords += 1\n            continue\n        }\n        \n    \
    \    if char == 0x23 {\n            words.append(String(char))\n            numOfWords\
    \ += 1\n            continue\n        }\n        \n        if char == 0x23 {\n\
    \            words.append(String(char))\n            numOfWords += 1\n       \
    \     continue\n        }\n        \n        if char == 0x\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6uzx0ocg.swift:133:22: error: '\n' is not a valid hexadecimal digit\
    \ (0-9, A-F) in integer literal\n        if char == 0x\n                     ^\n\
    /tmp/tmp6uzx0ocg.swift:156:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmp6uzx0ocg.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmp6uzx0ocg.swift:15:26: error: value\
    \ of type 'String' has no member 'data'\n    guard let text = txt.data(using:\
    \ .utf8) else {\n                     ~~~ ^~~~\n/tmp/tmp6uzx0ocg.swift:15:39:\
    \ error: cannot infer contextual base in reference to member 'utf8'\n    guard\
    \ let text = txt.data(using: .utf8) else {\n                                 \
    \    ~^~~~\n/tmp/tmp6uzx0ocg.swift:137:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053818
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    if wordArray.count ==\
    \ 0 {\n        return .failure(Int(0))\n    }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(Int(wordArrayCount))\n\
    \    }\n    let evenWordArrayCount = wordArrayCount / 2\n    let evenWordArray\
    \ = wordArray.prefix(evenWordArrayCount)\n    let oddWordArrayCount = wordArrayCount\
    \ - evenWordArrayCount\n    let oddWordArray = wordArray.suffix(oddWordArrayCount)\n\
    \    return .success(evenWordArray + oddWordArray)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqh72u696.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpqh72u696.swift:32:35: error: cannot convert value\
    \ of type 'String' to expected argument type '[String]'\n    return .success(evenWordArray\
    \ + oddWordArray)\n                                  ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt.data(using: .utf8) else {\n        return .failure(Int(errorCode:\
    \ ErrorCode.invalidArgument.rawValue))\n    }\n    \n    var words: [String] =\
    \ []\n    var word = \"\"\n    var isWordStarted = false\n    \n    for c in text\
    \ {\n        if c == \" \" {\n            if isWordStarted {\n               \
    \ words.append(word)\n                word = \"\"\n                isWordStarted\
    \ = false\n            } else {\n                isWordStarted = true\n      \
    \      }\n        } else {\n            word += String(c)\n        }\n    }\n\
    \    \n    if isWordStarted {\n        words.append(word)\n    }\n    \n    if\
    \ words.count % 2 == 1 {\n        return .success(words)\n    } else {\n     \
    \   return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkm3xqsvj.swift:15:26: error: value of type 'String' has no member\
    \ 'data'\n    guard let text = txt.data(using: .utf8) else {\n               \
    \      ~~~ ^~~~\n/tmp/tmpkm3xqsvj.swift:15:39: error: cannot infer contextual\
    \ base in reference to member 'utf8'\n    guard let text = txt.data(using: .utf8)\
    \ else {\n                                     ~^~~~\n/tmp/tmpkm3xqsvj.swift:16:40:\
    \ error: cannot find 'ErrorCode' in scope\n        return .failure(Int(errorCode:\
    \ ErrorCode.invalidArgument.rawValue))\n                                     \
    \  ^~~~~~~~~\n/tmp/tmpkm3xqsvj.swift:16:25: error: no exact matches in call to\
    \ initializer \n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Float16) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Float) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Double) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Float80) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Builtin.Int64) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:16:25: note: found candidate\
    \ with type '(Builtin.Word) -> Int'\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                        ^\n/tmp/tmpkm3xqsvj.swift:44:40: error: cannot find 'ErrorCode'\
    \ in scope\n        return .failure(Int(errorCode: ErrorCode.invalidArgument.rawValue))\n\
    \                                       ^~~~~~~~~\n/tmp/tmpkm3xqsvj.swi"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { $0 + count($1, \",\") }\n    if letterCount\
    \ % 2 != 0 {\n        return .failure(letterCount)\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl0hbpy7l.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpl0hbpy7l.swift:20:46: error: cannot find 'count'\
    \ in scope\n    let letterCount = words.reduce(0) { $0 + count($1, \",\") }\n\
    \                                             ^~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let chars = words.map { $0.characters.count\
    \ }\n    if chars.count == 0 {\n        return .failure(Int(txt.characters.count))\n\
    \    }\n    if chars.count == 1 {\n        return .success(words)\n    }\n   \
    \ if chars.count == 2 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 3 {\n        return .success(words)\n    }\n    if chars.count == 4 {\n \
    \       return .success(words)\n    }\n    if chars.count == 5 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 6 {\n        return .success(words)\n\
    \    }\n    if chars.count == 7 {\n        return .success(words)\n    }\n   \
    \ if chars.count == 8 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 9 {\n        return .success(words)\n    }\n    if chars.count == 10 {\n\
    \        return .success(words)\n    }\n    if chars.count == 11 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 12 {\n        return .success(words)\n\
    \    }\n    if chars.count == 13 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 14 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 15 {\n        return .success(words)\n    }\n    if chars.count == 16 {\n\
    \        return .success(words)\n    }\n    if chars.count == 17 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 18 {\n        return .success(words)\n\
    \    }\n    if chars.count == 19 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 20 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 21 {\n        return .success(words)\n    }\n    if chars.count == 22 {\n\
    \        return .success(words)\n    }\n    if chars.count == 23 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 24 {\n        return .success(words)\n\
    \    }\n    if chars.count == 25 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 26 {\n        return .success(words)\n    }\n    if chars.count\
    \ == 27 {\n        return .success(words)\n    }\n    if chars.count == 28 {\n\
    \        return .success(words)\n    }\n    if chars.count == 29 {\n        return\
    \ .success(words)\n    }\n    if chars.count == 30 {\n        return .success(words)\n\
    \    }\n    if chars.count == 31 {\n        return .success(words)\n    }\n  \
    \  if chars.count == 32 {\n        return .success(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb02uae2d.swift:143:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpb02uae2d.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpb02uae2d.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpb02uae2d.swift:17:33: error:\
    \ 'characters' is unavailable: Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb02uae2d.swift:24:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb02uae2d.swift:124:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordsCount\
    \ = words.count\n    let lettersCount = words.reduce(0) { $0 + count($1, lower:\
    \ true) }\n    \n    if wordsCount == 0 {\n        return .failure(lettersCount)\n\
    \    }\n    \n    if lettersCount % 2 == 1 {\n        return .failure(lettersCount)\n\
    \    }\n    \n    return .success(words.map { $0.trimmingCharacters(in: .whitespaces)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp98kza5s2.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp98kza5s2.swift:17:47: error: cannot find 'count'\
    \ in scope\n    let lettersCount = words.reduce(0) { $0 + count($1, lower: true)\
    \ }\n                                              ^~~~~\n/tmp/tmp98kza5s2.swift:27:60:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   return .success(words.map { $0.trimmingCharacters(in: .whitespaces) })\n \
    \                                                         ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count < 2 {\n        return .failure(comma.count)\n   \
    \ }\n    let letters = words.map { $0.lowercased() }\n    let odd = letters.filter\
    \ { $0 % 2 == 1 }\n    if odd.count < 2 {\n        return .failure(odd.count)\n\
    \    }\n    return .success(odd)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpheevk926.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(25)\n    }\n    if words.count == 1 {\n    \
    \    return .success(words)\n    }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { $0 + $1.count }\n    if letterCount % 2 == 1 {\n       \
    \ return .failure(letterCount)\n    }\n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkoaxt1z3.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let commaWords = words.components(separatedBy:\
    \ \",\")\n    if commaWords.count == 0 {\n        return .failure(words.count)\n\
    \    }\n    return .success(commaWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpe3sd1sba.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    }\n    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if\
    \ wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n    \n\
    \    return .success(wordArray.prefix(wordArray.count / 2))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8il6a367.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(25) + 1))\n    }\n    \n    return\
    \ .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp32tanmy8.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp32tanmy8.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(25)\
    \ + 1))\n                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    var result: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.components(separatedBy: \",\") else {\n            return\
    \ .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n        }\n        \n\
    \        for letter in letters {\n            guard let letter = letter.lowercased(),\
    \ letter != letter else {\n                return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \            }\n            \n            if result.contains(letter) {\n     \
    \           return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    \
    \        }\n            \n            result.append(letter)\n        }\n    }\n\
    \    \n    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd50nbzv7.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpd50nbzv7.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let charCount = txt.characters.count\n    let oddCharCount = charCount -\
    \ wordCount\n    let oddCharCountInt = Int(oddCharCount)\n    let oddCharCountIntUpper\
    \ = oddCharCountInt.uppercased()\n    let oddCharCountIntUpperString = String(oddCharCountIntUpper)\n\
    \    let oddCharCountIntUpperStringLength = oddCharCountIntUpperString.length\n\
    \    let oddCharCountIntUpperStringLength = oddCharCountIntUpperString.length\n\
    \    let oddCharCountIntUpperStringLength2 = oddCharCountIntUpperString.length\
    \ * 2\n    let oddCharCountIntUpperStringLength3 = oddCharCountIntUpperString.length\
    \ * 3\n    let oddCharCountIntUpperStringLength4 = oddCharCountIntUpperString.length\
    \ * 4\n    let oddCharCountIntUpperStringLength5 = oddCharCountIntUpperString.length\
    \ * 5\n    let oddCharCountIntUpperStringLength6 = oddCharCountIntUpperString.length\
    \ * 6\n    let oddCharCountIntUpperStringLength7 = oddCharCountIntUpperString.length\
    \ * 7\n    let oddCharCountIntUpperStringLength8 = oddCharCountIntUpperString.length\
    \ * 8\n    let oddCharCountIntUpperStringLength9 = oddCharCountIntUpperString.length\
    \ * 9\n    let oddCharCountIntUpperStringLength10 = oddCharCountIntUpperString.length\
    \ * 10\n    let oddCharCountIntUpperStringLength11 = oddCharCountIntUpperString.length\
    \ * 11\n    let oddCharCountIntUpperStringLength12 = oddCharCountIntUpperString.length\
    \ * 12\n    let oddCharCountIntUpperStringLength13 = oddCharCountIntUpperString.length\
    \ * 13\n    let oddCharCountIntUpperStringLength14 = oddCharCountIntUpperString.length\
    \ * 14\n    let oddCharCountIntUpperStringLength15 = oddCharCountIntUpperString.length\
    \ * 15\n    let oddCharCountIntUpperStringLength16 = oddCharCountIntUpperString.length\
    \ * 16\n    let oddCharCountIntUpperStringLength17 = oddCharCountIntUpperString.length\
    \ * 17\n    let oddCharCountIntUpperStringLength18 = oddCharCountIntUpperString.length\
    \ * 18\n    let oddCharCountIntUpperStringLength19 = oddCharCountIntUpperString.length\
    \ * 19\n    let oddCharCountIntUpperStringLength20 = oddCharCountIntUpperString.length\
    \ * 20\n    let oddCharCountIntUpperStringLength\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcn_meg__.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpcn_meg__.swift:23:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    let charCount = txt.characters.count\n     \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcn_meg__.swift:49:9: error: type annotation missing in pattern\n\
    \    let oddCharCountIntUpperStringLength\n        ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    if words.count > 2 {\n\
    \        return .failure(words.count)\n    }\n    if words.count == 2 {\n    \
    \    return .success(words)\n    }\n    if words.count == 1 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    return .success(words.map\
    \ { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1eh6tnns.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    if words.count == 2\
    \ {\n        return .success(words)\n    }\n    if words.count > 2 {\n       \
    \ let firstWord = words[0]\n        let secondWord = words[1]\n        if firstWord.hasPrefix(secondWord)\
    \ {\n            return .success(firstWord.components(separatedBy: \",\"))\n \
    \       }\n        return .success(firstWord.components(separatedBy: \" \"))\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjkf8ndvh.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let numWords\
    \ = words.count\n    \n    if numWords == 0 {\n        return .failure(Int(numWords))\n\
    \    }\n    \n    let numLetters = words.map { $0.characters.count }.reduce(0,\
    \ +)\n    \n    if numLetters % 2 != 0 {\n        return .failure(Int(numLetters))\n\
    \    }\n    \n    return .success(words.map { $0.lowercased() })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb6vumaoo.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let charCount = txt.characters.count\n    if charCount % wordCount != 0 {\n\
    \        return .failure(Int(txt.characters.count))\n    }\n    let chars = Array(txt.characters)\n\
    \    let wordCount = chars.count\n    let charCount = chars.count\n    if charCount\
    \ % wordCount != 0 {\n        return .failure(Int(txt.characters.count))\n   \
    \ }\n    let chars = Array(txt.characters)\n    let wordCount = chars.count\n\
    \    let charCount = chars.count\n    if charCount % wordCount != 0 {\n      \
    \  return .failure(Int(txt.characters.count))\n    }\n    let chars = Array(txt.characters)\n\
    \    let wordCount = chars.count\n    let charCount = chars.count\n    if charCount\
    \ % wordCount != 0 {\n        return .failure(Int(txt.characters.count))\n   \
    \ }\n    let chars = Array(txt.characters)\n    let wordCount = chars.count\n\
    \    let charCount = chars.count\n    if charCount % wordCount != 0 {\n      \
    \  return .failure(Int(txt.characters.count))\n    }\n    let chars = Array(txt.characters)\n\
    \    let wordCount = chars.count\n    let charCount = chars.count\n    if charCount\
    \ % wordCount != 0 {\n        return .failure(Int(txt.characters.count))\n   \
    \ }\n    let chars = Array(txt.characters)\n    let wordCount = chars.count\n\
    \    let charCount = chars.count\n    if charCount % wordCount != 0 {\n      \
    \  return .failure(Int(txt.characters.count))\n    }\n    let chars = Array(txt.characters)\n\
    \    let wordCount = chars.count\n    let charCount = chars.count\n    if charCount\
    \ % wordCount != 0 {\n        return .failure(Int(txt.characters.count))\n   \
    \ }\n    let chars = Array(txt.characters)\n    let wordCount = chars.count\n\
    \    let charCount = chars.count\n    if charCount % wordCount != 0 {\n      \
    \  return .failure(Int(txt.characters.count))\n    }\n    let chars = Array(txt.characters)\n\
    \    let wordCount = chars.count\n    let charCount = chars.count\n    if charCount\
    \ % wordCount != 0 {\n        return .failure(Int(txt.characters.count))\n   \
    \ }\n    let chars = Array(txt.characters)\n    let wordCount = chars.count\n\
    \    let charCount = chars.count\n    if charCount % wordCount != 0 {\n      \
    \  return .failure(Int(txt.characters.\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptx4k8hwf.swift:85:43: error: expected member name following '.'\n\
    \        return .failure(Int(txt.characters.\n                               \
    \           ^\n/tmp/tmptx4k8hwf.swift:86:1: error: expected ')' in expression\
    \ list\n}\n^\n/tmp/tmptx4k8hwf.swift:85:28: note: to match this opening '('\n\
    \        return .failure(Int(txt.characters.\n                           ^\n/tmp/tmptx4k8hwf.swift:108:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmptx4k8hwf.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmptx4k8hwf.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmptx4k8hwf.swift:17:33: error:\
    \ 'characters' is unavailable: Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptx4k8hwf.swift:23:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    let charCount = txt.characters.count\n     \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptx4k8hwf.swift:25:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        return .failure(Int(txt.characters.count))\n  \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptx4k8hwf.swift:27:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = Array(txt.characters)\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public v"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    let commaIndex = words.count - 1\n    let\
    \ comma = words.last\n    let lowercaseIndex = commaIndex - 1\n    let lowercase\
    \ = comma.first\n    let letters = lowercaseIndex < 0 ? lowercaseIndex : lowercaseIndex\
    \ + 1\n    let oddLetters = letters % 2\n    let evenLetters = letters / 2\n \
    \   if oddLetters == 0 {\n        return .success(words.dropLast())\n    }\n \
    \   if evenLetters == 0 {\n        return .success(words.dropFirst())\n    }\n\
    \    return .success(words.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_0sovsqb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let words = words.compactMap\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n    if words.count ==\
    \ 0 {\n        return .success(words)\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ .success(words.map { $0.lowercased() })\n    }\n    let words = words.compactMap\
    \ { $\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp41ipri74.swift:71:36: error: '$' is not an identifier; use backticks\
    \ to escape it\n    let words = words.compactMap { $\n                       \
    \            ^\n                                   `$`\n/tmp/tmp41ipri74.swift:94:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmp41ipri74.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmp41ipri74.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp41ipri74.swift:19:63: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = words.compactMap { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                             ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp41ipri74.swift:71:36: error: cannot find '$' in scope\n    let words =\
    \ words.compactMap { $\n                                   ^\n/tmp/tmp41ipri74.swift:75:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ > 0 {\n        return .success(words)\n    }\n    if words.count == 0 {\n  \
    \      return .failure(words.count)\n    }\n    let comma = txt.components(separatedBy:\
    \ \",\")\n    if comma.count > 0 {\n        return .success(comma)\n    }\n  \
    \  return .failure(words.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfbe3rmdu.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpfbe3rmdu.swift:22:21: error: value of type 'String'\
    \ has no member 'components'\n    let comma = txt.components(separatedBy: \",\"\
    )\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let commaWords\
    \ = txt.components(separatedBy: \",\")\n    \n    if words.count > 0 && commaWords.count\
    \ == 0 {\n        return .success(words)\n    } else if words.count == 0 && commaWords.count\
    \ > 0 {\n        return .success(commaWords)\n    } else if words.count > 0 &&\
    \ commaWords.count > 0 {\n        return .failure(words.count + commaWords.count)\n\
    \    }\n    \n    return .failure(words.count + commaWords.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpsru020uz.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpsru020uz.swift:16:26: error: value of type 'String'\
    \ has no member 'components'\n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n                     ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let charCount = txt.characters.count\n    let charsPerWord = charCount /\
    \ wordCount\n    let charsPerWord2 = charsPerWord * charsPerWord\n    let charsPerWord3\
    \ = charsPerWord2 * charsPerWord\n    let charsPerWord4 = charsPerWord3 * charsPerWord\n\
    \    let charsPerWord5 = charsPerWord4 * charsPerWord\n    let charsPerWord6 =\
    \ charsPerWord5 * charsPerWord\n    let charsPerWord7 = charsPerWord6 * charsPerWord\n\
    \    let charsPerWord8 = charsPerWord7 * charsPerWord\n    let charsPerWord9 =\
    \ charsPerWord8 * charsPerWord\n    let charsPerWord10 = charsPerWord9 * charsPerWord\n\
    \    let charsPerWord11 = charsPerWord10 * charsPerWord\n    let charsPerWord12\
    \ = charsPerWord11 * charsPerWord\n    let charsPerWord13 = charsPerWord12 * charsPerWord\n\
    \    let charsPerWord14 = charsPerWord13 * charsPerWord\n    let charsPerWord15\
    \ = charsPerWord14 * charsPerWord\n    let charsPerWord16 = charsPerWord15 * charsPerWord\n\
    \    let charsPerWord17 = charsPerWord16 * charsPerWord\n    let charsPerWord18\
    \ = charsPerWord17 * charsPerWord\n    let charsPerWord19 = charsPerWord18 * charsPerWord\n\
    \    let charsPerWord20 = charsPerWord19 * charsPerWord\n    let charsPerWord21\
    \ = charsPerWord20 * charsPerWord\n    let charsPerWord22 = charsPerWord21 * charsPerWord\n\
    \    let charsPerWord23 = charsPerWord22 * charsPerWord\n    let charsPerWord24\
    \ = charsPerWord23 * charsPerWord\n    let charsPerWord25 = charsPerWord24 * charsPerWord\n\
    \    let charsPerWord26 = charsPerWord25 * charsPerWord\n    let charsPerWord27\
    \ = charsPerWord26 * charsPerWord\n    let charsPerWord28 = charsPerWord27 * charsPerWord\n\
    \    let charsPerWord29 = charsPerWord28 * charsPerWord\n    let charsPerWord30\
    \ = charsPerWord29 * charsPerWord\n    let charsPerWord31 = charsPerWord30 * charsPerWord\n\
    \    let charsPerWord32 = charsPerWord31 * charsPerWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdhdioyz9.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdhdioyz9.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdhdioyz9.swift:23:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    let charCount = txt.characters.count\n     \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    if wordArrayCount % 2 == 0 {\n        return .success(wordArray)\n\
    \    }\n    return .success(wordArray.prefix(wordArrayCount / 2))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpillzqvli.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { String($0) }\n    let wordArrayCount\
    \ = wordArray.count\n    let alphabet = Array(Array(UnicodeScalar.lowercaseLetters))\n\
    \    let alphabetCount = alphabet.count\n    let oddLetters = wordArrayCount %\
    \ alphabetCount\n    let evenLetters = wordArrayCount - oddLetters\n    let oddLettersArray\
    \ = Array(alphabet[0 ..< oddLetters])\n    let evenLettersArray = Array(alphabet[0\
    \ ..< evenLetters])\n    let result = wordArray.map { word in\n        if let\
    \ index = wordArray.firstIndex(of: word) {\n            let firstLetter = wordArray[index\
    \ - 1]\n            let lastLetter = wordArray[index + 1]\n            if firstLetter\
    \ == lastLetter {\n                return word\n            }\n            if\
    \ firstLetter in oddLettersArray {\n                return word\n            }\n\
    \            if lastLetter in evenLettersArray {\n                return word\n\
    \            }\n        }\n        return word\n    }\n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp91rn051s.swift:35:28: error: expected '{' after 'if' condition\n\
    \            if firstLetter in oddLettersArray {\n                           ^\n\
    /tmp/tmp91rn051s.swift:38:27: error: expected '{' after 'if' condition\n     \
    \       if lastLetter in evenLettersArray {\n                          ^\n/tmp/tmp91rn051s.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp91rn051s.swift:17:33: error:\
    \ 'characters' is unavailable: Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp91rn051s.swift:22:46: error: type 'UnicodeScalar' (aka\
    \ 'Unicode.Scalar') has no member 'lowercaseLetters'\n    let alphabet = Array(Array(UnicodeScalar.lowercaseLetters))\n\
    \                               ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return .success(words)\n    }\n \
    \   return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_zudp2yq.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    var wordCount = 0\n    var words: [String] = []\n    for word in words\
    \ {\n        if let word = word.lowercased() {\n            if word.isEmpty {\n\
    \                continue\n            }\n            wordCount += 1\n       \
    \     words.append(word)\n        }\n    }\n    \n    if wordCount == 0 {\n  \
    \      return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n  \
    \  \n    if wordCount % 2 == 1 {\n        return .success(words)\n    }\n    \n\
    \    return .success(wordCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp084vghbc.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp084vghbc.swift:16:29: error:\
    \ cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmp084vghbc.swift:22:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp084vghbc.swift:32:29: error: cannot find 'arc4random_uniform' in scope\n\
    \        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n       \
    \                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmp084vghbc.swift:39:21: error:\
    \ cannot convert value of type 'Int' to expected argument type '[String]'\n  \
    \  return .success(wordCount)\n                    ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    let even = words.count / 2\n    let odd = words.count - even\n\
    \    let letters = words.map { $0.lowercased() }\n    let evenLetters = letters.filter\
    \ { $0.count % 2 == 0 }\n    let oddLetters = letters.filter { $0.count % 2 !=\
    \ 0 }\n    return .success(evenLetters + oddLetters + even)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplh6xuq1r.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    \n    if words.count\
    \ == 2 {\n        return .success(words)\n    }\n    \n    if words.count == 3\
    \ {\n        return .success(words)\n    }\n    \n    if words.count > 3 {\n \
    \       return .success(words)\n    }\n    \n    return .success(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyerm2pxy.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    if wordArrayCount % 2 == 1 {\n        return .failure(wordArrayCount)\n \
    \   }\n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    let evenWordArrayCount\
    \ = evenWordArray.count\n    if evenWordArrayCount % 2 == 1 {\n        return\
    \ .failure(evenWordArrayCount)\n    }\n    return .success(evenWordArray)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzhmywp1n.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053817
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\") }\n    let splitWordsCount =\
    \ splitWords.count\n    let splitWordsCount = splitWords.count < 2 ? splitWordsCount\
    \ : splitWordsCount + 1\n    \n    if splitWordsCount == 0 {\n        return .failure(splitWordsCount)\n\
    \    }\n    \n    if splitWordsCount == 1 {\n        return .success(splitWords)\n\
    \    }\n    \n    let splitWordsCount = splitWords.count\n    let splitWordsCount\
    \ = splitWords.count < 2 ? splitWordsCount : splitWordsCount + 1\n    \n    if\
    \ splitWordsCount == 2 {\n        return .success(splitWords)\n    }\n    \n \
    \   if splitWordsCount == 3 {\n        return .success(splitWords)\n    }\n  \
    \  \n    if splitWordsCount == 4 {\n        return .success(splitWords)\n    }\n\
    \    \n    if splitWordsCount == 5 {\n        return .success(splitWords)\n  \
    \  }\n    \n    if splitWordsCount == 6 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 7 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 8 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 9 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 10 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 11 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 12 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 13 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 14 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 15 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 16 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 17 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 18 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 19 {\n        return .success(splitWords)\n\
    \    }\n    \n    if splitWordsCount == 20 {\n        return .\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptf4c0_jm.swift:105:1: error: expected identifier after '.' expression\n\
    }\n^\n/tmp/tmptf4c0_jm.swift:127:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmptf4c0_jm.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmptf4c0_jm.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmptf4c0_jm.swift:108:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return .failure(words.count)\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        let trimmed = word.trimmingCharacters(in:\
    \ .whitespaces)\n        if trimmed.isEmpty {\n            continue\n        }\n\
    \        \n        if trimmed.rangeOfCharacter(from: .lowercaseLetters) != nil\
    \ {\n            result.append(trimmed)\n            continue\n        }\n   \
    \     \n        let count = trimmed.unicodeScalars.filter({ $0.isLetter }).count\n\
    \        if count % 2 == 1 {\n            result.append(trimmed)\n        }\n\
    \    }\n    \n    if result.count == 0 {\n        return .failure(words.count)\n\
    \    }\n    \n    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl2ej09le.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpl2ej09le.swift:23:52: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n        let trimmed = word.trimmingCharacters(in:\
    \ .whitespaces)\n                                                  ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 {\n        return .failure(words.count)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count < 2 {\n        return .failure(comma.count)\n   \
    \ }\n    let letters = words.count / 2\n    let odd = letters % 2\n    let letter\
    \ = odd.map { $0.unicodeScalars.first!.value }\n    return .success(letter)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwetjglqq.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n        return .failure(Int(arc4random_uniform(25) + 1))\n    }\n  \
    \  \n    var words: [String] = []\n    var count = 0\n    \n    for char in text.unicodeScalars\
    \ {\n        if char.value > 0xFF {\n            return .failure(Int(arc4random_uniform(25)\
    \ + 1))\n        }\n        \n        if char.value > 0x20 {\n            count\
    \ += 1\n        }\n        \n        words.append(String(char))\n    }\n    \n\
    \    if count % 2 == 1 {\n        return .success(words)\n    }\n    \n    return\
    \ .success(words.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa8ao7rt1.swift:15:26: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n                     ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpa8ao7rt1.swift:15:50:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    guard let text = txt.trimmingCharacters(in: .whitespacesAndNewlines) else\
    \ {\n                                                ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa8ao7rt1.swift:16:29: error: cannot find 'arc4random_uniform' in scope\n\
    \        return .failure(Int(arc4random_uniform(25) + 1))\n                  \
    \          ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    let commaWords = words.filter({ $0.contains(\"\
    ,\") })\n    let commaWordCount = commaWords.count\n    let lowercaseLetters =\
    \ words.filter({ $0.lowercased().count % 2 == 1 })\n    let lowercaseLetterCount\
    \ = lowercaseLetters.count\n    let oddLetterCount = lowercaseLetters.filter({\
    \ $0.lowercased().count % 2 == 0 }).count\n    return .success(commaWordCount\
    \ + lowercaseLetterCount + oddLetterCount)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwgq6zhfu.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    \n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    \n   \
    \ if wordArray.count % 2 == 1 {\n        return .success(wordArray)\n    }\n \
    \   \n    let wordArrayCount = wordArray.count\n    \n    if wordArrayCount %\
    \ 2 == 0 {\n        return .success(wordArray)\n    }\n    \n    return .failure(wordArrayCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkizheecw.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    if words.count % 2 == 1 {\n\
    \        return .failure(Int(txt.characters.count))\n    }\n    let even = words.filter{$0.isUppercase}.count\n\
    \    let odd = words.filter{$0.isLowercase}.count\n    if even % 2 == 1 {\n  \
    \      return .failure(Int(txt.characters.count))\n    }\n    if odd % 2 == 1\
    \ {\n        return .success(words.map { $0.lowercased() })\n    }\n    return\
    \ .success(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3a1vr60g.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp3a1vr60g.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3a1vr60g.swift:23:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3a1vr60g.swift:28:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let result =\
    \ words.map { $0.lowercased() }\n    \n    if words.count % 2 == 1 {\n       \
    \ return .failure(words.count / 2)\n    }\n    \n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjg0w_jvy.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    let commaWords = words.filter {$0 == \"\
    ,\"}\n    if commaWords.count == 0 {\n        return .success(words.map {String($0)})\n\
    \    }\n    return .success(words.map {String($0)})\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptm6wzxna.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    let wordCount = words.count\n\
    \    let alphabet = Array(txt.characters)\n    let letterCount = alphabet.count\n\
    \    let oddLetterCount = letterCount - wordCount\n    let evenLetterCount = letterCount\
    \ - oddLetterCount\n    let oddLetters = Array(alphabet[..<letterCount])\n   \
    \ let evenLetters = Array(alphabet[letterCount..<alphabet.count])\n    let letters\
    \ = oddLetters + evenLetters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letters = letters\n    let wordCount = wordCount\n    let letterCount\
    \ = letterCount\n    let oddLetterCount = oddLetterCount\n    let evenLetterCount\
    \ = evenLetterCount\n    let oddLetters = oddLetters\n    let evenLetters = evenLetters\n\
    \    let letter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyrmgnobb.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyrmgnobb.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyrmgnobb.swift:23:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabet = Array(txt.characters)\n     \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpyrmgnobb.swift:31:9: error: invalid redeclaration of 'letterCount'\n\
    \    let letterCount = letterCount\n        ^\n/tmp/tmpyrmgnobb.swift:24:9: note:\
    \ 'letterCount' previously declared here\n    let letterCount = alphabet.count\n\
    \        ^\n/tmp/tmpyrmgnobb.swift:34:9: error: invalid redeclaration of 'oddLetters'\n\
    \    let oddLetters = oddLetters\n        ^\n/tmp/tmpyrmgnobb.swift:27:9: note:\
    \ 'oddLetters' previously declared here\n    let oddLetters = Array(alphabet[..<letterCount])\n\
    \        ^\n/tmp/tmpyrmgnobb.swift:35:9: error: invalid redeclaration of 'evenLetters'\n\
    \    let evenLetters = evenLetters\n        ^\n/tmp/tmpyrmgnobb.swift:28:9: note:\
    \ 'evenLetters' previously declared here\n    let evenLetters = Array(alphabet[letterCount..<alphabet.count])\n\
    \        ^\n/tmp/tmpyrmgnobb.swift:36:9: error: invalid redeclaration of 'letters'\n\
    \    let letters = letters\n        ^\n/tmp/tmpyrmgnobb.swift:29:9: note: 'letters'\
    \ previously declared here\n    let letters = oddLetters + evenLetters\n     \
    \   ^\n/tmp/tmpyrmgnobb.swift:85:9: error: type annotation missing in pattern\n\
    \    let letter\n        ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    \n    let wordCount = words.count\n\
    \    var words: [String] = []\n    \n    for word in words {\n        if let wordCount\
    \ = word.characters.count {\n            if wordCount % 2 == 1 {\n           \
    \     return .failure(Int(wordCount))\n            }\n            \n         \
    \   words.append(word)\n        }\n    }\n    \n    return .success(words)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8uwbityn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8uwbityn.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8uwbityn.swift:27:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        if let wordCount = word.characters.count\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8uwbityn.swift:27:12: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n        if let wordCount = word.characters.count\
    \ {\n           ^               ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(25)\n    }\n    if words.count == 1 {\n    \
    \    return .success(words)\n    }\n    let firstWord = words[0]\n    let lastWord\
    \ = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n        return\
    \ .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\",\") {\n   \
    \     return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcv6zytx2.swift:114:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpcv6zytx2.swift:14:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpcv6zytx2.swift:15:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpcv6zytx2.swift:95:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    let words = words.compactMap\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n    if words.count ==\
    \ 0 {\n        return .failure(Int(0))\n    }\n    let words = words.map { $0.lowercased()\
    \ }\n    let wordCount = words.count\n    let oddLetters = words.filter { $0.count\
    \ % 2 == 1 }\n    let evenLetters = words.filter { $0.count % 2 == 0 }\n    let\
    \ evenLettersCount = evenLetters.count\n    if wordCount == 0 {\n        return\
    \ .failure(Int(0))\n    }\n    if wordCount == 1 {\n        return .success(words)\n\
    \    }\n    if wordCount == oddLetters.count {\n        return .success(words)\n\
    \    }\n    if wordCount == evenLettersCount {\n        return .success(words)\n\
    \    }\n    return .failure(Int(0))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpza92dup_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpza92dup_.swift:19:63: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    let words = words.compactMap\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n                   \
    \                                          ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { (acc, word) -> Int in\n\
    \        let letter = word.unicodeScalars.first?.value ?? \"\"\n        return\
    \ acc + Int(letter)\n    }\n    \n    if letterCount == 0 {\n        return .failure(letterCount)\n\
    \    }\n    \n    if letterCount % 2 == 1 {\n        return .failure(letterCount)\n\
    \    }\n    \n    return .success(words.map { $0.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmporkimqh_.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmporkimqh_.swift:30:59: error: cannot find 'CharacterSet'\
    \ in scope\n    return .success(words.map { $0.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ })\n                                                          ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.init(rawValue: 10)))\n    }\n    \n    let wordCount =\
    \ words.count\n    let letterCount = words.reduce(0) { (result, word) -> Int in\n\
    \        let count = word.characters.count\n        return count > result ? count\
    \ : result\n    }\n    \n    if letterCount % 2 == 1 {\n        return Err(Int(.init(rawValue:\
    \ 10)))\n    }\n    \n    return Ok([words])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpy5e3fito.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpy5e3fito.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n \
    \              ^~~\n/tmp/tmpy5e3fito.swift:16:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpy5e3fito.swift:26:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n        \
    \       ^~~\n/tmp/tmpy5e3fito.swift:26:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpy5e3fito.swift:29:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([words])\n           ^~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message:\
    \ \"Invalid argument\"))\n    }\n    \n    var result: [String] = []\n    \n \
    \   for word in words {\n        if let word = word.lowercased() {\n         \
    \   if result.contains(word) {\n                return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Duplicate word\"))\n            }\n            result.append(word)\n\
    \        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeboetr0g.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpeboetr0g.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n               ^~~\n/tmp/tmpeboetr0g.swift:16:35:\
    \ error: cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpeboetr0g.swift:16:80: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeboetr0g.swift:30:12: error: cannot find 'Ok' in scope\n    return Ok(result)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(words.count)\n    }\n    if words.count == 1\
    \ {\n        return .success(words)\n    }\n    let firstWord = words[0]\n   \
    \ let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n\
    \        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return .success(words.dropFirst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmk_h0imm.swift:92:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmk_h0imm.swift:91:24: note: to match this opening '('\n        return\
    \ .success(words.dropFirst\n                       ^\n/tmp/tmpmk_h0imm.swift:114:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpmk_h0imm.swift:14:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpmk_h0imm.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpmk_h0imm.swift:95:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return .failure(0) }\n    guard words.count % 2 == 0 else { return\
    \ .failure(0) }\n    let letters = words.count / 2\n    let result = words.enumerated().map\
    \ { (index, word) in\n        let letter = word.lowercased().unicodeScalars.first!\n\
    \        return letter == letters.lowercased().unicodeScalars.first! ? letter\
    \ : letters.lowercased().unicodeScalars.first!\n    }\n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp53vge9_a.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let wordCount = words.count\n    let\
    \ wordCountWithCommas = wordCount + words.count - 1\n    let letterCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n    let letterCountWithCommas = letterCount + letterCount\
    \ - 1\n    if letterCountWithCommas == 0 {\n        return .success(words)\n \
    \   }\n    if letterCountWithCommas == letterCount {\n        return .success(words)\n\
    \    }\n    if letterCountWithCommas == wordCount {\n        return .success(words)\n\
    \    }\n    if letterCountWithCommas == wordCountWithCommas {\n        return\
    \ .success(words)\n    }\n    return .failure(Int(letterCountWithCommas))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpazl70x26.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpazl70x26.swift:24:54: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n    let letterCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n                                                  ~~ ^~~~~~~~\n\
    /tmp/tmpazl70x26.swift:25:45: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n    let letterCountWithCommas = letterCount +\
    \ letterCount - 1\n                                            ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(bitPattern: 1 << 63))\n    }\n    \n    var result:\
    \ [String] = []\n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return .failure(Int(bitPattern: 1 << 63))\n     \
    \   }\n        \n        for letter in letters {\n            let lowercaseLetter\
    \ = String(letter).lowercased()\n            if lowercaseLetter != letter {\n\
    \                guard let index = result.index(of: lowercaseLetter) else {\n\
    \                    result.append(lowercaseLetter)\n                }\n     \
    \       }\n        }\n    }\n    \n    guard result.count % 2 == 0 else {\n  \
    \      return .failure(Int(bitPattern: 1 << 63))\n    }\n    \n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi96g7fbv.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(0))\n    }\n    if words.count == 1 {\n\
    \        return .success(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n   \
    \     return .success(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return .success(words.dropLast())\n    }\n    let lowercaseLetters\
    \ = firstWord.unicodeScalars.filter({ $0.isLower }).count\n    return .success(words.prefix(lowercaseLetters))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptyw692h0.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \    }\n    guard words.count <= 25 && words.count > 0 else {\n        return\
    \ .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n    }\n    guard words.count\
    \ % 2 == 0 else {\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa11uo5up.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpa11uo5up.swift:17:29: error: cannot find 'arc4random_uniform'\
    \ in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpa11uo5up.swift:20:29:\
    \ error: cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpa11uo5up.swift:23:29:\
    \ error: cannot find 'arc4random_uniform' in scope\n        return .failure(Int(arc4random_uniform(UInt32(UInt8.max))))\n\
    \                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(Int(txt.characters.count))\n    }\n    let letters\
    \ = txt.lowercased().characters\n    let oddLetters = letters.filter{ $0 % 2 ==\
    \ 1 }\n    let evenLetters = letters.filter{ $0 % 2 == 0 }\n    let evenLettersCount\
    \ = evenLetters.count\n    let oddLettersCount = oddLetters.count\n    if evenLettersCount\
    \ == 0 {\n        return .success(words)\n    }\n    if oddLettersCount == 0 {\n\
    \        return .success(letters)\n    }\n    if evenLettersCount == oddLettersCount\
    \ {\n        return .success(letters)\n    }\n    return .failure(Int(txt.characters.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwvvthxkn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwvvthxkn.swift:17:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        return .failure(Int(txt.characters.count))\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpwvvthxkn.swift:19:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letters = txt.lowercased().characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpwvvthxkn.swift:20:38: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'Int'\n  \
    \  let oddLetters = letters.filter{ $0 % 2 == 1 }\n                          \
    \           ^\n/tmp/tmpwvvthxkn.swift:21:39: error: cannot convert value of type\
    \ 'String.Element' (aka 'Character') to expected argument type 'Int'\n    let\
    \ evenLetters = letters.filter{ $0 % 2 == 0 }\n                              \
    \        ^\n/tmp/tmpwvvthxkn.swift:28:25: error: cannot convert value of type\
    \ 'String' to expected argument type '[String]'\n        return .success(letters)\n\
    \                        ^\n/tmp/tmpwvvthxkn.swift:31:25: error: cannot convert\
    \ value of type 'String' to expected argument type '[String]'\n        return\
    \ .success(letters)\n                        ^\n/tmp/tmpwvvthxkn.swift:33:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    return .failure(Int(txt.characters.count))\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return .failure(3)\n    }\n    if words.count == 1 {\n     \
    \   return .success(words)\n    }\n    if words.count == 2 {\n        return .success(words)\n\
    \    }\n    if words.count == 3 {\n        return .success(words)\n    }\n   \
    \ if words.count == 4 {\n        return .success(words)\n    }\n    if words.count\
    \ == 5 {\n        return .success(words)\n    }\n    if words.count == 6 {\n \
    \       return .success(words)\n    }\n    if words.count == 7 {\n        return\
    \ .success(words)\n    }\n    if words.count == 8 {\n        return .success(words)\n\
    \    }\n    if words.count == 9 {\n        return .success(words)\n    }\n   \
    \ if words.count == 10 {\n        return .success(words)\n    }\n    if words.count\
    \ == 11 {\n        return .success(words)\n    }\n    if words.count == 12 {\n\
    \        return .success(words)\n    }\n    if words.count == 13 {\n        return\
    \ .success(words)\n    }\n    if words.count == 14 {\n        return .success(words)\n\
    \    }\n    if words.count == 15 {\n        return .success(words)\n    }\n  \
    \  if words.count == 16 {\n        return .success(words)\n    }\n    if words.count\
    \ == 17 {\n        return .success(words)\n    }\n    if words.count == 18 {\n\
    \        return .success(words)\n    }\n    if words.count == 19 {\n        return\
    \ .success(words)\n    }\n    if words.count == 20 {\n        return .success(words)\n\
    \    }\n    if words.count == 21 {\n        return .success(words)\n    }\n  \
    \  if words.count == 22 {\n        return .success(words)\n    }\n    if words.count\
    \ == 23 {\n        return .success(words)\n    }\n    if words.count == 24 {\n\
    \        return .success(words)\n    }\n    if words.count == 25 {\n        return\
    \ .success(words)\n    }\n    return .failure(25)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpc2sn4ncr.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(bitPattern: 1 << 31))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return .failure(Int(bitPattern: 1 << 31))\n     \
    \   }\n        \n        for letter in letters {\n            guard let letter\
    \ = letter.lowercased(), letter != letter else {\n                return .failure(Int(bitPattern:\
    \ 1 << 31))\n            }\n            \n            if letter != letter {\n\
    \                result.append(letter)\n            }\n        }\n    }\n    \n\
    \    if result.count % 2 != 0 {\n        return .failure(Int(bitPattern: 1 <<\
    \ 31))\n    }\n    \n    return .success(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpu22ib49m.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053819
