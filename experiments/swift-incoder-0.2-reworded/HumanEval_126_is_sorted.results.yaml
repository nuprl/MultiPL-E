language: swift
name: HumanEval_126_is_sorted
results:
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpp0pb9oq4/tmpp0pb9oq4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e0af76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e0ac6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e0ac6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e0ac6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pb9oq4                        0x0000563813e825f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b6e0b162460 __libc_start_main +
    245

    6    tmpp0pb9oq4                        0x0000563813e820d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ x == prev {\n            return false\n        }\n        prev = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpccum1v61/tmpccum1v61.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbce2c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbcdfc0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbcdfc0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbcdfbf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpccum1v61                        0x0000556f46019577 <unavailable> + 5495

    5    libc.so.6                          0x00002acbce4b5460 __libc_start_main +
    245

    6    tmpccum1v61                        0x0000556f46019129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 { return\
    \ true }\n    if lst.count == 1 { return false }\n    if lst.count > 1 {\n   \
    \     var seen = [Int]()\n        for v in lst {\n            if !seen[v] {\n\
    \                seen[v] = true\n                return false\n            }\n\
    \        }\n        return true\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprjcur_oe.swift:28:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmprjcur_oe.swift:29:27: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n                seen[v] = true\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen[v] {\n                return false\n            }\n    \
    \        seen[v] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb4a4m0ip.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmpb4a4m0ip.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] != nil {\n            return false\n        }\n\
    \        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee25f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee25c46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee25c46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee25c4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee25c45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee25a45e83 <unavailable> + 188035

    6    tmp58zbjwzx                        0x0000561b91da5137 <unavailable> + 8503

    7    tmp58zbjwzx                        0x0000561b91da44e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aee2613b460 __libc_start_main +
    245

    9    tmp58zbjwzx                        0x0000561b91da41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        for idx in lst.indices\
    \ {\n            if idx == last {\n                return false\n            }\n\
    \            last = idx\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpmhp_m54r/tmpmhp_m54r.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4997fddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4997cd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4997cd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4997cd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhp_m54r                        0x00005572f72cf597 <unavailable> + 5527

    5    libc.so.6                          0x00002b49981c9460 __libc_start_main +
    245

    6    tmpmhp_m54r                        0x00005572f72cf149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ {\n        return true\n    }\n    var i = 0\n    var j = 0\n    var k = lst.count\
    \ - 1\n    while i < k {\n        if lst[i] < lst[j] {\n            return false\n\
    \        }\n        i += 1\n        j += 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp9u_2va6e/tmp9u_2va6e.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32f5a4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32f5742b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32f5742988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32f57417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9u_2va6e                        0x0000556cae94a536 <unavailable> + 5430

    5    libc.so.6                          0x00002b32f5c37460 __libc_start_main +
    245

    6    tmp9u_2va6e                        0x0000556cae94a019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        }\n        seen.insert(num)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbk2gh2su/tmpbk2gh2su.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fca84ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fca541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fca541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fca5407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbk2gh2su                        0x00005581132c1746 <unavailable> + 5958

    5    libc.so.6                          0x00002b1fcaa36460 __libc_start_main +
    245

    6    tmpbk2gh2su                        0x00005581132c1229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] != nil {\n            return false\n        }\n\
    \        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee25f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee25c46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee25c46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee25c4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee25c45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee25a45e83 <unavailable> + 188035

    6    tmp58zbjwzx                        0x0000561b91da5137 <unavailable> + 8503

    7    tmp58zbjwzx                        0x0000561b91da44e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aee2613b460 __libc_start_main +
    245

    9    tmp58zbjwzx                        0x0000561b91da41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgtdrikfg/tmpgtdrikfg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06e211c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06df08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06df08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06df077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgtdrikfg                        0x00005566232a3646 <unavailable> + 5702

    5    libc.so.6                          0x00002ae06e3fd460 __libc_start_main +
    245

    6    tmpgtdrikfg                        0x00005566232a3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if !seen.contains(num) {\n                return false\n        \
    \    }\n            seen.append(num)\n        }\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpofmd5w1r/tmpofmd5w1r.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f58244c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f57f3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f57f3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f57f3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpofmd5w1r                        0x000055a1bf4f2697 <unavailable> + 5783

    5    libc.so.6                          0x00002b3f58430460 __libc_start_main +
    245

    6    tmpofmd5w1r                        0x000055a1bf4f2249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var found: Bool = false\n\
    \    for num in lst {\n        if num == last {\n            found = true\n  \
    \      } else {\n            last = num\n            found = false\n        }\n\
    \    }\n    return found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpivswkkz6/tmpivswkkz6.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a641cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a63ec1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a63ec1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a63ec07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpivswkkz6                        0x000055ed2859a4aa <unavailable> + 5290

    5    libc.so.6                          0x00002b8a643b6460 __libc_start_main +
    245

    6    tmpivswkkz6                        0x000055ed2859a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ prev == x {\n            return false\n        }\n        prev = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmph24hzlbz/tmph24hzlbz.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e2f25ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e2ef51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e2ef51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e2ef507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph24hzlbz                        0x000055c5d5fcd646 <unavailable> + 5702

    5    libc.so.6                          0x00002b7e2f446460 __libc_start_main +
    245

    6    tmph24hzlbz                        0x000055c5d5fcd129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = Set<Int>()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                return false\n          \
    \  }\n            seen.insert(v)\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpmicualec/tmpmicualec.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc0e62cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc0e323b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc0e323988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc0e3227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmicualec                        0x000055e3e42f86d7 <unavailable> + 5847

    5    libc.so.6                          0x00002adc0e818460 __libc_start_main +
    245

    6    tmpmicualec                        0x000055e3e42f8289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_less)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4zrq0apw.swift:23:27: error: cannot find 'is_less' in scope\n \
    \   return is_sorted(lst, is_less)\n                          ^~~~~~~\n/tmp/tmp4zrq0apw.swift:23:27:\
    \ error: extra argument in call\n    return is_sorted(lst, is_less)\n        \
    \            ~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var set = Set<Int>()\n  \
    \  for num in lst {\n        if !set.contains(num) {\n            set.insert(num)\n\
    \        }\n    }\n    return set.count == lst.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpd8ujcqb5/tmpd8ujcqb5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b499cf66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b499cc5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b499cc5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b499cc5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8ujcqb5                        0x0000560c5c9737f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b499d152460 __libc_start_main +
    245

    6    tmpd8ujcqb5                        0x0000560c5c9732d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    if lst[0] < lst[1]\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpjfh6_c5h/tmpjfh6_c5h.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8246c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8243beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8243be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8243bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjfh6_c5h                        0x0000564510bfb467 <unavailable> + 5223

    5    libc.so.6                          0x00002af8248b3460 __libc_start_main +
    245

    6    tmpjfh6_c5h                        0x0000564510bfb019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return lst.sorted() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkfreh1ln.swift:29:25: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return lst.sorted() == true\n  \
    \         ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpkfreh1ln.swift:29:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool)\n\
    \    return lst.sorted() == true\n                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgtdrikfg/tmpgtdrikfg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06e211c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06df08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06df08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06df077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgtdrikfg                        0x00005566232a3646 <unavailable> + 5702

    5    libc.so.6                          0x00002ae06e3fd460 __libc_start_main +
    245

    6    tmpgtdrikfg                        0x00005566232a3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   }\n            seen.insert(num)\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp20yu67w0.swift:35:28: error: missing argument for parameter 'at'\
    \ in call\n            seen.insert(num)\n                           ^\n      \
    \                     , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc218ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc1e81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bc1e81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bc1e8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bc1e80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bc1c80e83 <unavailable> + 188035

    6    tmpf1kimgp7                        0x000055fd15c34153 <unavailable> + 8531

    7    tmpf1kimgp7                        0x000055fd15c334e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b9bc2376460 __libc_start_main +
    245

    9    tmpf1kimgp7                        0x000055fd15c331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen[v] {\n                return false\n            }\n\
    \            seen[v] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn80yc3fa.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmpn80yc3fa.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_1l1ws_3.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count == 2 {\n        return lst[0] == lst[1]\n    }\n    if\
    \ lst.count > 2 {\n        var prev: Int = 0\n        var found: Bool = false\n\
    \        for i in 0..<lst.count {\n            if lst[i] == prev {\n         \
    \       found = true\n            } else {\n                prev = lst[i]\n  \
    \              found = false\n            }\n        }\n        return found\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqo4cbdon/tmpqo4cbdon.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafca316c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafca00db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafca00d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafca00c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqo4cbdon                        0x00005593b016852a <unavailable> + 5418

    5    libc.so.6                          0x00002aafca502460 __libc_start_main +
    245

    6    tmpqo4cbdon                        0x00005593b01681a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ prev > x {\n            return false\n        }\n        prev = x\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwmo5r1f0/tmpwmo5r1f0.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeedcdfcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeedcaf3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeedcaf3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeedcaf27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwmo5r1f0                        0x000056069f5d6c7b <unavailable> + 7291

    5    libc.so.6                          0x00002aeedcfe8460 __libc_start_main +
    245

    6    tmpwmo5r1f0                        0x000056069f5d6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var last: Int = 0\n        var lastCount:\
    \ Int = 0\n        for idx in 0..<lst.count {\n            if lst[idx] == last\
    \ {\n                lastCount++\n            } else {\n                last =\
    \ lst[idx]\n                lastCount = 1\n            }\n            if lastCount\
    \ > 1 {\n                return false\n            }\n        }\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6e3gva6e.swift:34:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                lastCount++\n                        \
    \ ^~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for i : Int in lst {\n  \
    \      if last > i {\n            return false\n        }\n        last = i\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwhdwhm_w/tmpwhdwhm_w.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb3e8fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb3e5f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb3e5f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb3e5f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwhdwhm_w                        0x0000558236e1ac7b <unavailable> + 7291

    5    libc.so.6                          0x00002aeb3eae6460 __libc_start_main +
    245

    6    tmpwhdwhm_w                        0x0000558236e1a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var last: Int = 0\n    for idx in lst.indices {\n\
    \        if idx == last {\n            return false\n        }\n        last =\
    \ idx\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpz1eqmqdy/tmpz1eqmqdy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7adbf36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7adbc2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7adbc2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7adbc2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz1eqmqdy                        0x000055c31a778597 <unavailable> + 5527

    5    libc.so.6                          0x00002b7adc122460 __libc_start_main +
    245

    6    tmpz1eqmqdy                        0x000055c31a778149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var prev: Int = 0\n    var next: Int = 0\n    var\
    \ found: Bool = false\n    for idx in lst.indices {\n        if idx == 0 {\n \
    \           prev = lst[idx]\n            found = true\n        } else {\n    \
    \        if prev == lst[idx] {\n                found = true\n            } else\
    \ {\n                found = false\n            }\n        }\n        if found\
    \ {\n            next = idx\n            break\n        }\n        prev = lst[idx]\n\
    \    }\n    return !found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1y7wgpwq/tmp1y7wgpwq.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19a2ce2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19a29d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19a29d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19a29d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1y7wgpwq                        0x000055a51b6b25e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b19a2ece460 __libc_start_main +
    245

    6    tmp1y7wgpwq                        0x000055a51b6b2199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc218ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc1e81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bc1e81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bc1e8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bc1e80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bc1c80e83 <unavailable> + 188035

    6    tmpf1kimgp7                        0x000055fd15c34153 <unavailable> + 8531

    7    tmpf1kimgp7                        0x000055fd15c334e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b9bc2376460 __libc_start_main +
    245

    9    tmpf1kimgp7                        0x000055fd15c331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if num != last {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwdgduec0/tmpwdgduec0.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87f3102c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87f2df9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87f2df9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87f2df87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwdgduec0                        0x000055c7e443445a <unavailable> + 5210

    5    libc.so.6                          0x00002b87f32ee460 __libc_start_main +
    245

    6    tmpwdgduec0                        0x000055c7e44340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = 0\n    for x in\
    \ lst {\n        if x == last {\n            return false\n        }\n       \
    \ last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp12pn7c0t/tmp12pn7c0t.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22ef554c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22ef24bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22ef24b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22ef24a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp12pn7c0t                        0x0000558e5993a5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b22ef740460 __libc_start_main +
    245

    6    tmp12pn7c0t                        0x0000558e5993a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0sqtwiqt.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmp0sqtwiqt.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for idx in lst {\n        if idx == last {\n            lastCount++\n   \
    \     } else {\n            last = idx\n            lastCount = 1\n        }\n\
    \    }\n    if lastCount > 1 {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn1n_4wyr.swift:30:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for idx in lst {\n\
    \            if seen[idx] == true {\n                return false\n          \
    \  }\n            seen[idx] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmqjy3m9p.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[idx] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmpmqjy3m9p.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[idx] == true {\n                         ^\n\
    /tmp/tmpmqjy3m9p.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[idx] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x]\
    \ != x {\n            return false\n        }\n        seen[x] = x\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bf6c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bf6989561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bf6989286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bf698913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bf6988bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bf6788e83 <unavailable> + 188035

    6    tmpe6qa2uvq                        0x00005583a917718b <unavailable> + 8587

    7    tmpe6qa2uvq                        0x00005583a9176602 <unavailable> + 5634

    8    libc.so.6                          0x00002b9bf6e7e460 __libc_start_main +
    245

    9    tmpe6qa2uvq                        0x00005583a9176229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] != nil {\n            return false\n        }\n\
    \        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee25f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee25c46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee25c46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee25c4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee25c45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee25a45e83 <unavailable> + 188035

    6    tmp58zbjwzx                        0x0000561b91da5137 <unavailable> + 8503

    7    tmp58zbjwzx                        0x0000561b91da44e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aee2613b460 __libc_start_main +
    245

    9    tmp58zbjwzx                        0x0000561b91da41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    guard lst.count <= lst.max() else { return false }\n  \
    \  var last: Int = 0\n    for idx in lst {\n        if idx == last {\n       \
    \     return false\n        }\n        last = idx\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9_0ngbkr.swift:24:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard lst.count <= lst.max() else\
    \ { return false }\n                           ^\n/tmp/tmp9_0ngbkr.swift:24:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                 ?? <#default value#>\n/tmp/tmp9_0ngbkr.swift:24:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                !\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x]\
    \ != x {\n            return false\n        }\n        seen[x] = x\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bf6c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bf6989561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bf6989286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bf698913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bf6988bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bf6788e83 <unavailable> + 188035

    6    tmpe6qa2uvq                        0x00005583a917718b <unavailable> + 8587

    7    tmpe6qa2uvq                        0x00005583a9176602 <unavailable> + 5634

    8    libc.so.6                          0x00002b9bf6e7e460 __libc_start_main +
    245

    9    tmpe6qa2uvq                        0x00005583a9176229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc218ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc1e81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bc1e81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bc1e8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bc1e80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bc1c80e83 <unavailable> + 188035

    6    tmpf1kimgp7                        0x000055fd15c34153 <unavailable> + 8531

    7    tmpf1kimgp7                        0x000055fd15c334e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b9bc2376460 __libc_start_main +
    245

    9    tmpf1kimgp7                        0x000055fd15c331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen[v] {\n                return false\n            }\n    \
    \        seen[v] = true\n        }\n        return true\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3x3ilae4.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmp3x3ilae4.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqvkjct3j/tmpqvkjct3j.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7660355c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b766004cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b766004c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b766004b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvkjct3j                        0x000056336858d697 <unavailable> + 5783

    5    libc.so.6                          0x00002b7660541460 __libc_start_main +
    245

    6    tmpqvkjct3j                        0x000056336858d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = Set<Int>()\n        for num in lst\
    \ {\n            if seen.contains(num) {\n                return false\n     \
    \       }\n            seen.insert(num)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1ni768b_/tmp1ni768b_.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7510230c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b750ff27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b750ff27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b750ff267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ni768b_                        0x0000562dd47a27a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b751041c460 __libc_start_main +
    245

    6    tmp1ni768b_                        0x0000562dd47a2289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        for idx in 0..<lst.count\
    \ {\n            if lst[idx] != last {\n                return false\n       \
    \     }\n            last = idx\n        }\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7mjt5htz/tmp7mjt5htz.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe64d00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe649f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe649f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe649f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7mjt5htz                        0x000056240544d5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002abe64eec460 __libc_start_main +
    245

    6    tmp7mjt5htz                        0x000056240544d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpp0pb9oq4/tmpp0pb9oq4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e0af76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e0ac6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e0ac6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e0ac6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pb9oq4                        0x0000563813e825f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b6e0b162460 __libc_start_main +
    245

    6    tmpp0pb9oq4                        0x0000563813e820d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_1l1ws_3.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgtdrikfg/tmpgtdrikfg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06e211c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06df08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06df08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06df077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgtdrikfg                        0x00005566232a3646 <unavailable> + 5702

    5    libc.so.6                          0x00002ae06e3fd460 __libc_start_main +
    245

    6    tmpgtdrikfg                        0x00005566232a3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return lst.sorted() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkfreh1ln.swift:29:25: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return lst.sorted() == true\n  \
    \         ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpkfreh1ln.swift:29:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool)\n\
    \    return lst.sorted() == true\n                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_less)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4zrq0apw.swift:23:27: error: cannot find 'is_less' in scope\n \
    \   return is_sorted(lst, is_less)\n                          ^~~~~~~\n/tmp/tmp4zrq0apw.swift:23:27:\
    \ error: extra argument in call\n    return is_sorted(lst, is_less)\n        \
    \            ~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for x in lst {\n        if !seen.contains(x) {\n            seen.add(x)\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6zlbzks0.swift:26:18: error: value of type 'Set<Int>' has no member\
    \ 'add'\n            seen.add(x)\n            ~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        let seen = Set<Int>()\n        for num in lst\
    \ {\n            if seen.contains(num) {\n                return false\n     \
    \       }\n            seen.insert(num)\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyjcnxcro.swift:35:18: error: cannot use mutating member on immutable\
    \ value: 'seen' is a 'let' constant\n            seen.insert(num)\n          \
    \  ~~~~ ^\n/tmp/tmpyjcnxcro.swift:30:9: note: change 'let' to 'var' to make it\
    \ mutable\n        let seen = Set<Int>()\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    let last = lst.last\n    for x in lst {\n        if x ==\
    \ last { return false }\n        last = x\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph_rhevyo.swift:27:9: error: cannot assign to value: 'last' is a\
    \ 'let' constant\n        last = x\n        ^~~~\n/tmp/tmph_rhevyo.swift:24:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let last = lst.last\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1vseie2i/tmp1vseie2i.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae613c82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae613979b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae613979988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6139787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1vseie2i                        0x000055773c615467 <unavailable> + 5223

    5    libc.so.6                          0x00002ae613e6e460 __libc_start_main +
    245

    6    tmp1vseie2i                        0x000055773c615019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var i = 0\n    for x in lst {\n        if i == 0\
    \ {\n            i = x\n            continue\n        }\n        if x != lst[i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpsgvssk3i/tmpsgvssk3i.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06facedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06fa9e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06fa9e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06fa9e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsgvssk3i                        0x000056501539a5d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b06faed9460 __libc_start_main +
    245

    6    tmpsgvssk3i                        0x000056501539a189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    if lst[0] < lst[1]\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpjfh6_c5h/tmpjfh6_c5h.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8246c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8243beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8243be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8243bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjfh6_c5h                        0x0000564510bfb467 <unavailable> + 5223

    5    libc.so.6                          0x00002af8248b3460 __libc_start_main +
    245

    6    tmpjfh6_c5h                        0x0000564510bfb019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqvkjct3j/tmpqvkjct3j.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7660355c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b766004cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b766004c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b766004b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvkjct3j                        0x000056336858d697 <unavailable> + 5783

    5    libc.so.6                          0x00002b7660541460 __libc_start_main +
    245

    6    tmpqvkjct3j                        0x000056336858d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] == nil {\n            seen[x] = true\n      \
    \      return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpq5cbkdpm.swift:25:20: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[x] == nil {\n    \
    \       ~~~~~~~ ^  ~~~\n/tmp/tmpq5cbkdpm.swift:26:23: error: cannot assign value\
    \ of type 'Bool' to subscript of type 'Int'\n            seen[x] = true\n    \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnq5y7ke7.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmpnq5y7ke7.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqvkjct3j/tmpqvkjct3j.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7660355c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b766004cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b766004c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b766004b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvkjct3j                        0x000056336858d697 <unavailable> + 5783

    5    libc.so.6                          0x00002b7660541460 __libc_start_main +
    245

    6    tmpqvkjct3j                        0x000056336858d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    guard lst.count <= lst.sorted else { return false }\n \
    \   for i in 0 ..< lst.count - 1 {\n        if lst[i] != lst[i+1] {\n        \
    \    return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw4n5jq5a.swift:24:21: error: type '() -> [Int]' cannot conform\
    \ to 'BinaryInteger'\n    guard lst.count <= lst.sorted else { return false }\n\
    \                    ^\n/tmp/tmpw4n5jq5a.swift:24:21: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n    guard lst.count\
    \ <= lst.sorted else { return false }\n                    ^\n/tmp/tmpw4n5jq5a.swift:24:21:\
    \ note: required by operator function '<=' where 'Other' = '() -> [Int]'\n   \
    \ guard lst.count <= lst.sorted else { return false }\n                    ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc218ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc1e81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bc1e81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bc1e8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bc1e80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bc1c80e83 <unavailable> + 188035

    6    tmpf1kimgp7                        0x000055fd15c34153 <unavailable> + 8531

    7    tmpf1kimgp7                        0x000055fd15c334e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b9bc2376460 __libc_start_main +
    245

    9    tmpf1kimgp7                        0x000055fd15c331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var seen = [Int]()\n    for num in lst {\n     \
    \   if seen.contains(num) {\n            return false\n        }\n        seen.insert(num)\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_pzgei9e.swift:31:24: error: missing argument for parameter 'at'\
    \ in call\n        seen.insert(num)\n                       ^\n              \
    \         , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)' declared here\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for idx in\
    \ lst {\n            if seen[idx] == nil {\n                return false\n   \
    \         }\n            seen[idx] = true\n        }\n        return true\n  \
    \  }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwcq6_esp.swift:32:26: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n            if seen[idx] == nil {\n\
    \               ~~~~~~~~~ ^  ~~~\n/tmp/tmpwcq6_esp.swift:35:25: error: cannot\
    \ assign value of type 'Bool' to subscript of type 'Int'\n            seen[idx]\
    \ = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   }\n            seen.insert(num)\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp20yu67w0.swift:35:28: error: missing argument for parameter 'at'\
    \ in call\n            seen.insert(num)\n                           ^\n      \
    \                     , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst: lst.drop(2))\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvz0_5ygc.swift:30:35: error: no exact matches in call to instance\
    \ method 'drop'\n        return is_sorted(lst: lst.drop(2))\n                \
    \                  ^\n/tmp/tmpvz0_5ygc.swift:30:35: note: candidate expects value\
    \ of type '(Int) throws -> Bool' for parameter #1 (got 'Int')\n        return\
    \ is_sorted(lst: lst.drop(2))\n                                  ^\n/tmp/tmpvz0_5ygc.swift:30:35:\
    \ note: candidate expects value of type '(Int) throws -> Bool' for parameter #1\
    \ (got 'Int')\n        return is_sorted(lst: lst.drop(2))\n                  \
    \                ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var last: Int = 0\n        for idx in\
    \ 0..<lst.count {\n            if lst[idx] != last {\n                return false\n\
    \            }\n            last = idx\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7vzpmcwm/tmp7vzpmcwm.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab89948ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab899185b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab899185988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8991847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7vzpmcwm                        0x000056499823052a <unavailable> + 5418

    5    libc.so.6                          0x00002ab89967a460 __libc_start_main +
    245

    6    tmp7vzpmcwm                        0x00005649982301a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   } else {\n                seen[num] = true\n            }\n        }\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkiid2m3o.swift:35:29: error: cannot assign value of type 'Bool'\
    \ to subscript of type 'Int'\n                seen[num] = true\n             \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ x == prev {\n            return false\n        }\n        prev = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpds2bomz1/tmpds2bomz1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dc3411c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dc3108b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dc3108988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dc31077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpds2bomz1                        0x00005654d7f6b646 <unavailable> + 5702

    5    libc.so.6                          0x00002b9dc35fd460 __libc_start_main +
    245

    6    tmpds2bomz1                        0x00005654d7f6b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 { return\
    \ true }\n    if lst.count == 1 { return false }\n    if lst.count > 1 {\n   \
    \     let last = lst.last\n        for idx in 0..<lst.count {\n            if\
    \ lst[idx] == last {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpcqpb9fxj/tmpcqpb9fxj.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a640b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a63dacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a63dac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a63dab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcqpb9fxj                        0x000056282889a5ba <unavailable> + 5562

    5    libc.so.6                          0x00002b1a642a1460 __libc_start_main +
    245

    6    tmpcqpb9fxj                        0x000056282889a239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    var curr: Int = 0\n    var\
    \ found: Bool = false\n    for curr in lst {\n        if prev == curr {\n    \
    \        found = true\n            break\n        }\n        prev = curr\n   \
    \ }\n    return found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpw0vrny0x/tmpw0vrny0x.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ad33fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ad30f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ad30f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ad30f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw0vrny0x                        0x00005598967e14aa <unavailable> + 5290

    5    libc.so.6                          0x00002b1ad35e8460 __libc_start_main +
    245

    6    tmpw0vrny0x                        0x00005598967e1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_sorted(lst))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnqg8j4tf.swift:23:27: error: extra argument in call\n    return\
    \ is_sorted(lst, is_sorted(lst))\n                    ~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpnqg8j4tf.swift:23:37: error: missing argument label 'lst:' in call\n \
    \   return is_sorted(lst, is_sorted(lst))\n                                  \
    \  ^\n                                    lst: \n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        } else {\n            seen.insert(num)\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmprnqes1lt/tmprnqes1lt.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee2f00ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee2ed01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee2ed01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee2ed007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprnqes1lt                        0x000055fd24838746 <unavailable> + 5958

    5    libc.so.6                          0x00002aee2f1f6460 __libc_start_main +
    245

    6    tmprnqes1lt                        0x000055fd24838229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, by:\
    \ &identity)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpod4fc2vs.swift:23:32: error: cannot find 'identity' in scope\n\
    \    return is_sorted(lst, by: &identity)\n                               ^~~~~~~~\n\
    /tmp/tmpod4fc2vs.swift:23:31: error: extra argument 'by' in call\n    return is_sorted(lst,\
    \ by: &identity)\n                    ~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_less)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4zrq0apw.swift:23:27: error: cannot find 'is_less' in scope\n \
    \   return is_sorted(lst, is_less)\n                          ^~~~~~~\n/tmp/tmp4zrq0apw.swift:23:27:\
    \ error: extra argument in call\n    return is_sorted(lst, is_less)\n        \
    \            ~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                return false\n      \
    \      }\n            seen.append(v)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzh7osec4/tmpzh7osec4.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad33eaa4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad33e79bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad33e79b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad33e79a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzh7osec4                        0x00005647a9ddb61a <unavailable> + 5658

    5    libc.so.6                          0x00002ad33ec90460 __libc_start_main +
    245

    6    tmpzh7osec4                        0x00005647a9ddb299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return lst.sorted() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkfreh1ln.swift:29:25: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return lst.sorted() == true\n  \
    \         ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpkfreh1ln.swift:29:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool)\n\
    \    return lst.sorted() == true\n                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var i = 0\n    var j = 0\n    var k = lst.count -\
    \ 1\n    while i < k {\n        if lst[i] < lst[j] {\n            return false\n\
    \        }\n        if lst[i] > lst[j] {\n            j = k\n        } else {\n\
    \            i += 1\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp01iq5jmh/tmp01iq5jmh.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b394171fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3941416b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3941416988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b39414157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01iq5jmh                        0x0000562763460467 <unavailable> + 5223

    5    libc.so.6                          0x00002b394190b460 __libc_start_main +
    245

    6    tmp01iq5jmh                        0x0000562763460019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    guard lst.count <= lst.max() else { return false }\n  \
    \  var i = 0\n    var j = 0\n    var k = lst.count - 1\n    while i < k {\n  \
    \      if lst[i] < lst[j] {\n            return false\n        }\n        i +=\
    \ 1\n        j += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpak1mxrc2.swift:24:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard lst.count <= lst.max() else\
    \ { return false }\n                           ^\n/tmp/tmpak1mxrc2.swift:24:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                 ?? <#default value#>\n/tmp/tmpak1mxrc2.swift:24:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                !\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] < lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for idx in\
    \ lst {\n            if seen[idx] == nil {\n                seen[idx] = true\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwchwkwic.swift:32:26: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n            if seen[idx] == nil {\n\
    \               ~~~~~~~~~ ^  ~~~\n/tmp/tmpwchwkwic.swift:33:29: error: cannot\
    \ assign value of type 'Bool' to subscript of type 'Int'\n                seen[idx]\
    \ = true\n                            ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    var last = 0\n    for x in lst {\n        if x == last {\n       \
    \     return false\n        }\n        last = x\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmphlmzorwm/tmphlmzorwm.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05e0c26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05e091db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05e091d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05e091c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlmzorwm                        0x000055871239250a <unavailable> + 5386

    5    libc.so.6                          0x00002b05e0e12460 __libc_start_main +
    245

    6    tmphlmzorwm                        0x0000558712392189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpp0pb9oq4/tmpp0pb9oq4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e0af76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e0ac6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e0ac6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e0ac6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pb9oq4                        0x0000563813e825f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b6e0b162460 __libc_start_main +
    245

    6    tmpp0pb9oq4                        0x0000563813e820d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpoabvufzg/tmpoabvufzg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accb6a67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accb675eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accb675e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accb675d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoabvufzg                        0x00005634fb0c4646 <unavailable> + 5702

    5    libc.so.6                          0x00002accb6c53460 __libc_start_main +
    245

    6    tmpoabvufzg                        0x00005634fb0c4129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if !seen.contains(num) {\n                seen.append(num)\n    \
    \        }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzuo42xh6/tmpzuo42xh6.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07b6d53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07b6a4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07b6a4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07b6a497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzuo42xh6                        0x000055705ad86697 <unavailable> + 5783

    5    libc.so.6                          0x00002b07b6f3f460 __libc_start_main +
    245

    6    tmpzuo42xh6                        0x000055705ad86249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    var prev: Int = 0\n    var found: Bool = false\n    for x in lst {\n\
    \        if x == prev {\n            found = true\n        } else {\n        \
    \    if found {\n                return false\n            }\n            found\
    \ = false\n        }\n        prev = x\n    }\n    return found\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpcfeonlcm/tmpcfeonlcm.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b526bed7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b526bbceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b526bbce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b526bbcd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcfeonlcm                        0x000056240f12a50a <unavailable> + 5386

    5    libc.so.6                          0x00002b526c0c3460 __libc_start_main +
    245

    6    tmpcfeonlcm                        0x000056240f12a189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] != nil {\n            return false\n        }\n\
    \        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee25f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee25c46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee25c46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee25c4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee25c45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee25a45e83 <unavailable> + 188035

    6    tmp58zbjwzx                        0x0000561b91da5137 <unavailable> + 8503

    7    tmp58zbjwzx                        0x0000561b91da44e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aee2613b460 __libc_start_main +
    245

    9    tmp58zbjwzx                        0x0000561b91da41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen[v] {\n                return false\n            }\n\
    \            seen[v] = true\n        }\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplkhwiwrj.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmplkhwiwrj.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst: lst.dropFirst())\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb3qji0et.swift:30:35: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return is_sorted(lst: lst.dropFirst())\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqvkjct3j/tmpqvkjct3j.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7660355c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b766004cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b766004c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b766004b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvkjct3j                        0x000056336858d697 <unavailable> + 5783

    5    libc.so.6                          0x00002b7660541460 __libc_start_main +
    245

    6    tmpqvkjct3j                        0x000056336858d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for idx in lst {\n\
    \            if seen[idx] == true {\n                return false\n          \
    \  }\n            seen[idx] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmqjy3m9p.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[idx] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmpmqjy3m9p.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[idx] == true {\n                         ^\n\
    /tmp/tmpmqjy3m9p.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[idx] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        var lastCount: Int\
    \ = 0\n        for idx in 0..<lst.count {\n            if lst[idx] == last {\n\
    \                lastCount++\n            } else {\n                last = lst[idx]\n\
    \                lastCount = 1\n            }\n            if lastCount > 1 {\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7ctk7tuj.swift:34:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                lastCount++\n                        \
    \ ^~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpp0pb9oq4/tmpp0pb9oq4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e0af76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e0ac6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e0ac6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e0ac6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pb9oq4                        0x0000563813e825f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b6e0b162460 __libc_start_main +
    245

    6    tmpp0pb9oq4                        0x0000563813e820d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = Set<Int>()\n        for v in\
    \ lst {\n            if seen.contains(v) {\n                return false\n   \
    \         }\n            seen.insert(v)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp41m3bcu6/tmp41m3bcu6.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0828541c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0828238b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0828238988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08282377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp41m3bcu6                        0x0000555d070cb65a <unavailable> + 5722

    5    libc.so.6                          0x00002b082872d460 __libc_start_main +
    245

    6    tmp41m3bcu6                        0x0000555d070cb2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev: Int = 0\n    for\
    \ num in lst {\n        if prev > num {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpjj4gaevc/tmpjj4gaevc.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada01cf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada019eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada019ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada019e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjj4gaevc                        0x0000556af5497c2b <unavailable> + 7211

    5    libc.so.6                          0x00002ada01edf460 __libc_start_main +
    245

    6    tmpjj4gaevc                        0x0000556af54970d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last < num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmps2zmm6n5/tmps2zmm6n5.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b546cdb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b546caaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b546caaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b546caa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps2zmm6n5                        0x000055bf1a21645a <unavailable> + 5210

    5    libc.so.6                          0x00002b546cf9f460 __libc_start_main +
    245

    6    tmps2zmm6n5                        0x000055bf1a2160d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    var prev: Int = 0\n    var next: Int = 0\n    var\
    \ last: Int = 0\n    for idx in lst.indices {\n        if idx == 0 {\n       \
    \     last = idx\n        } else {\n            if prev == last {\n          \
    \      return false\n            }\n            prev = last\n            last\
    \ = idx\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpskznahje/tmpskznahje.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e9fbfdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e9f8f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e9f8f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e9f8f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpskznahje                        0x0000562140005597 <unavailable> + 5527

    5    libc.so.6                          0x00002b0e9fde9460 __libc_start_main +
    245

    6    tmpskznahje                        0x0000562140005149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x]\
    \ != nil {\n            return false\n        }\n        seen[x] = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af95f17ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95ee75561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af95ee75286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af95ee7513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af95ee74bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af95ec74e83 <unavailable> + 188035

    6    tmpfvfz6mnq                        0x0000559a84a8519d <unavailable> + 8605

    7    tmpfvfz6mnq                        0x0000559a84a84602 <unavailable> + 5634

    8    libc.so.6                          0x00002af95f36a460 __libc_start_main +
    245

    9    tmpfvfz6mnq                        0x0000559a84a84229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst: lst.dropFirst())\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb3qji0et.swift:30:35: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return is_sorted(lst: lst.dropFirst())\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ prev > x {\n            return false\n        }\n        prev = x\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmphiq3yzwf/tmphiq3yzwf.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b7d9fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b7d6f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b7d6f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b7d6f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphiq3yzwf                        0x0000555cb85b1577 <unavailable> + 5495

    5    libc.so.6                          0x00002b2b7dbe6460 __libc_start_main +
    245

    6    tmphiq3yzwf                        0x0000555cb85b1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for i := 0; i < lst.count;\
    \ i++ {\n        if lst[i] != last {\n            return false\n        }\n  \
    \      last = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphx5l9vy4.swift:27:12: error: expected type\n    for i := 0; i <\
    \ lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmphx5l9vy4.swift:27:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmphx5l9vy4.swift:27:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < lst.count; i++ {\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !contains(seen, v) {\n                seen.append(v)\n       \
    \     }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuw31falg.swift:32:17: error: cannot find 'contains' in scope\n\
    \            if !contains(seen, v) {\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2da182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2da1524561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2da1524286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2da152413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2da1523bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2da1323e83 <unavailable> + 188035

    6    tmpytkfs4yb                        0x000055676b642137 <unavailable> + 8503

    7    tmpytkfs4yb                        0x000055676b6414e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b2da1a19460 __libc_start_main +
    245

    9    tmpytkfs4yb                        0x000055676b6411d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = Set<Int>()\n        for num in lst\
    \ {\n            if seen.contains(num) {\n                return false\n     \
    \       }\n            seen.insert(num)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1ni768b_/tmp1ni768b_.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7510230c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b750ff27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b750ff27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b750ff267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ni768b_                        0x0000562dd47a27a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b751041c460 __libc_start_main +
    245

    6    tmp1ni768b_                        0x0000562dd47a2289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   }\n            seen.insert(num)\n        }\n        return true\n    }\n \
    \   return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnyf1_jit.swift:35:28: error: missing argument for parameter 'at'\
    \ in call\n            seen.insert(num)\n                           ^\n      \
    \                     , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                return false\n      \
    \      }\n            seen.append(v)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzh7osec4/tmpzh7osec4.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad33eaa4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad33e79bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad33e79b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad33e79a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzh7osec4                        0x00005647a9ddb61a <unavailable> + 5658

    5    libc.so.6                          0x00002ad33ec90460 __libc_start_main +
    245

    6    tmpzh7osec4                        0x00005647a9ddb299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for idx in lst {\n\
    \            if seen[idx] == true {\n                return false\n          \
    \  }\n            seen[idx] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmqjy3m9p.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[idx] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmpmqjy3m9p.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[idx] == true {\n                         ^\n\
    /tmp/tmpmqjy3m9p.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[idx] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        for idx in 0..<lst.count\
    \ {\n            if lst[idx] == last {\n                return false\n       \
    \     }\n            last = lst[idx]\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpxb_xz35c/tmpxb_xz35c.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba343104c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba342dfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba342dfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba342dfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxb_xz35c                        0x0000557bdd9a06c6 <unavailable> + 5830

    5    libc.so.6                          0x00002ba3432f0460 __libc_start_main +
    245

    6    tmpxb_xz35c                        0x0000557bdd9a01a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return true\n    }\n    if lst.count == 3 {\n\
    \        return true\n    }\n    if lst.count == 4 {\n        return true\n  \
    \  }\n    if lst.count == 5 {\n        return true\n    }\n    if lst.count ==\
    \ 6 {\n        return true\n    }\n    if lst.count == 7 {\n        return true\n\
    \    }\n    if lst.count == 8 {\n        return true\n    }\n    if lst.count\
    \ == 9 {\n        return true\n    }\n    if lst.count == 10 {\n        return\
    \ true\n    }\n    if lst.count == 11 {\n        return true\n    }\n    if lst.count\
    \ == 12 {\n        return true\n    }\n    if lst.count == 13 {\n        return\
    \ true\n    }\n    if lst.count == 14 {\n        return true\n    }\n    if lst.count\
    \ == 15 {\n        return true\n    }\n    if lst.count == 16 {\n        return\
    \ true\n    }\n    if lst.count == 17 {\n        return true\n    }\n    if lst.count\
    \ == 18 {\n        return true\n    }\n    if lst.count == 19 {\n        return\
    \ true\n    }\n    if lst.count == 20 {\n        return true\n    }\n    if lst.count\
    \ == 21 {\n        return true\n    }\n    if lst.count == 22 {\n        return\
    \ true\n    }\n    if lst.count == 23 {\n        return true\n    }\n    if lst.count\
    \ == 24 {\n        return true\n    }\n    if lst.count == 25 {\n        return\
    \ true\n    }\n    if lst.count == 26 {\n        return true\n    }\n    if lst.count\
    \ == 27 {\n        return true\n    }\n    if lst.count == 28 {\n        return\
    \ true\n    }\n    if lst.count == 29 {\n        return true\n    }\n    if lst.count\
    \ == 30 {\n        return true\n    }\n    if lst.count == 31 {\n        return\
    \ true\n    }\n    if lst.count == 32 {\n        return true\n    }\n    if lst.count\
    \ == 33 {\n        return true\n    }\n    if lst.count == 34 {\n        return\
    \ true\n    }\n    if lst.count == 35 {\n        return true\n    }\n    if lst.count\
    \ == 36 {\n        return true\n    }\n    if lst.count == 37 {\n        return\
    \ true\n    }\n    if lst.count == 38 {\n        return true\n    }\n    if lst.count\
    \ == 39 {\n        return true\n    }\n    if lst.count == 40 {\n        return\
    \ true\n    }\n    if lst.count == 41 {\n        return true\n    }\n    if lst.count\
    \ == 42 {\n        return true\n    }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfqtd8haw.swift:152:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        for idx in 0..<lst.count\
    \ {\n            if lst[idx] != last {\n                return false\n       \
    \     }\n            last = idx\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp3n8nw1kt/tmp3n8nw1kt.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af295e00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af295af7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af295af7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af295af67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3n8nw1kt                        0x000055ce9fd3a5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002af295fec460 __libc_start_main +
    245

    6    tmp3n8nw1kt                        0x000055ce9fd3a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] != nil {\n            return false\n        }\n\
    \        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee25f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee25c46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee25c46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee25c4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee25c45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee25a45e83 <unavailable> + 188035

    6    tmp58zbjwzx                        0x0000561b91da5137 <unavailable> + 8503

    7    tmp58zbjwzx                        0x0000561b91da44e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aee2613b460 __libc_start_main +
    245

    9    tmp58zbjwzx                        0x0000561b91da41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2da182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2da1524561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2da1524286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2da152413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2da1523bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2da1323e83 <unavailable> + 188035

    6    tmpytkfs4yb                        0x000055676b642137 <unavailable> + 8503

    7    tmpytkfs4yb                        0x000055676b6414e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b2da1a19460 __libc_start_main +
    245

    9    tmpytkfs4yb                        0x000055676b6411d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if !seen.contains(num) {\n                return false\n        \
    \    }\n            seen.append(num)\n        }\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpofmd5w1r/tmpofmd5w1r.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f58244c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f57f3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f57f3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f57f3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpofmd5w1r                        0x000055a1bf4f2697 <unavailable> + 5783

    5    libc.so.6                          0x00002b3f58430460 __libc_start_main +
    245

    6    tmpofmd5w1r                        0x000055a1bf4f2249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x\
    \ - 1] != nil {\n            return false\n        }\n        seen[x] = x\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac301a9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac301793561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac301793286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac30179313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac301792bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac301592e83 <unavailable> + 188035

    6    tmpwdiux0py                        0x000055d2edaea1b9 <unavailable> + 8633

    7    tmpwdiux0py                        0x000055d2edae9602 <unavailable> + 5634

    8    libc.so.6                          0x00002ac301c88460 __libc_start_main +
    245

    9    tmpwdiux0py                        0x000055d2edae9229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x\
    \ - 1] != nil {\n            return false\n        }\n        seen[x] = x\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac301a9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac301793561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac301793286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac30179313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac301792bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac301592e83 <unavailable> + 188035

    6    tmpwdiux0py                        0x000055d2edaea1b9 <unavailable> + 8633

    7    tmpwdiux0py                        0x000055d2edae9602 <unavailable> + 5634

    8    libc.so.6                          0x00002ac301c88460 __libc_start_main +
    245

    9    tmpwdiux0py                        0x000055d2edae9229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc_fuf5k3.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpc_fuf5k3.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpp0pb9oq4/tmpp0pb9oq4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e0af76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e0ac6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e0ac6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e0ac6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pb9oq4                        0x0000563813e825f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b6e0b162460 __libc_start_main +
    245

    6    tmpp0pb9oq4                        0x0000563813e820d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   }\n            seen.insert(num)\n        }\n        return true\n    }\n \
    \   return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnyf1_jit.swift:35:28: error: missing argument for parameter 'at'\
    \ in call\n            seen.insert(num)\n                           ^\n      \
    \                     , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgtdrikfg/tmpgtdrikfg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06e211c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06df08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06df08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06df077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgtdrikfg                        0x00005566232a3646 <unavailable> + 5702

    5    libc.so.6                          0x00002ae06e3fd460 __libc_start_main +
    245

    6    tmpgtdrikfg                        0x00005566232a3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc218ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc1e81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9bc1e81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9bc1e8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9bc1e80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9bc1c80e83 <unavailable> + 188035

    6    tmpf1kimgp7                        0x000055fd15c34153 <unavailable> + 8531

    7    tmpf1kimgp7                        0x000055fd15c334e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b9bc2376460 __libc_start_main +
    245

    9    tmpf1kimgp7                        0x000055fd15c331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        }\n        seen.insert(num)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbk2gh2su/tmpbk2gh2su.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fca84ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fca541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fca541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fca5407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbk2gh2su                        0x00005581132c1746 <unavailable> + 5958

    5    libc.so.6                          0x00002b1fcaa36460 __libc_start_main +
    245

    6    tmpbk2gh2su                        0x00005581132c1229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !contains(seen, v) {\n                return false\n     \
    \       }\n            seen.append(v)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn5ylfjll.swift:32:17: error: cannot find 'contains' in scope\n\
    \            if !contains(seen, v) {\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprq_q_rax.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmprq_q_rax.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for i := 0; i < lst.count; i++ {\n        if lst[i] == last {\n         \
    \   lastCount++\n        } else {\n            last = lst[i]\n            lastCount\
    \ = 1\n        }\n        if lastCount > 1 {\n            return false\n     \
    \   }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy7ex8caf.swift:28:12: error: expected type\n    for i := 0; i <\
    \ lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpy7ex8caf.swift:28:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpy7ex8caf.swift:28:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < lst.count; i++ {\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst: lst.dropFirst())\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb3qji0et.swift:30:35: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return is_sorted(lst: lst.dropFirst())\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last == num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpm0mxyp_i/tmpm0mxyp_i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65793d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65790cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65790cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65790cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm0mxyp_i                        0x00005603cfa365f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b65795c2460 __libc_start_main +
    245

    6    tmpm0mxyp_i                        0x00005603cfa360d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        } else {\n            seen.insert(num)\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmprnqes1lt/tmprnqes1lt.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee2f00ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee2ed01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee2ed01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee2ed007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprnqes1lt                        0x000055fd24838746 <unavailable> + 5958

    5    libc.so.6                          0x00002aee2f1f6460 __libc_start_main +
    245

    6    tmprnqes1lt                        0x000055fd24838229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return lst.sorted() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkfreh1ln.swift:29:25: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return lst.sorted() == true\n  \
    \         ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpkfreh1ln.swift:29:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool)\n\
    \    return lst.sorted() == true\n                        ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var lastVal = lst[0]\n        for val in lst\
    \ {\n            if val == lastVal {\n                return false\n         \
    \   }\n            lastVal = val\n        }\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpl1zbmn48/tmpl1zbmn48.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f56c48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f5693fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f5693f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f5693e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1zbmn48                        0x000055734b46b5d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b1f56e34460 __libc_start_main +
    245

    6    tmpl1zbmn48                        0x000055734b46b189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if seen[v] == nil {\n                seen[v] = true\n       \
    \         return false\n            }\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpulhx5e1m.swift:32:24: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n            if seen[v] == nil {\n\
    \               ~~~~~~~ ^  ~~~\n/tmp/tmpulhx5e1m.swift:33:27: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n                seen[v] = true\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660013917
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9acvkut.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqvkjct3j/tmpqvkjct3j.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7660355c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b766004cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b766004c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b766004b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvkjct3j                        0x000056336858d697 <unavailable> + 5783

    5    libc.so.6                          0x00002b7660541460 __libc_start_main +
    245

    6    tmpqvkjct3j                        0x000056336858d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return true\n    }\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpu8tjzflb/tmpu8tjzflb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4c934bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4c9042b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4c9042988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4c90417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8tjzflb                        0x00005585ac01d467 <unavailable> + 5223

    5    libc.so.6                          0x00002ad4c9537460 __libc_start_main +
    245

    6    tmpu8tjzflb                        0x00005585ac01d019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013917
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp04jke5q6/tmp04jke5q6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b30eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b30bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b30bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b30baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04jke5q6                        0x0000558ed63e54d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b3b310a5460 __libc_start_main +
    245

    6    tmp04jke5q6                        0x0000558ed63e5089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013916
