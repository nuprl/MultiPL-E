language: swift
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(into:\
    \ \"\") { $0.isEmpty ? $1 : $0 + $1.count < $1.count ? $1 : $0 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpeokzgo75.swift:12:57: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    return strings.reduce(into: \"\") { $0.isEmpty\
    \ ? $1 : $0 + $1.count < $1.count ? $1 : $0 }\n                              \
    \                          ^\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0, false)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpu48wyopw.swift:11:19: error: extra arguments at positions #2, #3\
    \ in call\n    return longest(strings, 0, false)\n                  ^\n/tmp/tmpu48wyopw.swift:10:6:\
    \ note: 'longest(strings:)' declared here\nfunc longest(strings: [String]) ->\
    \ String? {\n     ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, options: .longestEffectiveLength)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgks3ou3.swift:11:39: error: extra argument 'options' in call\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \     ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfgks3ou3.swift:11:39:\
    \ error: cannot infer contextual base in reference to member 'longestEffectiveLength'\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0, strings)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpkysfnx1x.swift:11:19: error: extra arguments at positions #2, #3\
    \ in call\n    return longest(strings, 0, strings)\n                  ^\n/tmp/tmpkysfnx1x.swift:10:6:\
    \ note: 'longest(strings:)' declared here\nfunc longest(strings: [String]) ->\
    \ String? {\n     ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longest: 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp199unfh5.swift:11:38: error: extra argument 'longest' in call\n\
    \    return longest(strings, longest: 1)\n                  ~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3juz6rx.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpc3juz6rx.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") {\n        if $0.count < $1.count {\n            return $1\n        } else\
    \ {\n            return $0\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(\"\
    \") { (longest, s) in\n        return longest.characters.count < s.characters.count\
    \ ? s : longest\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpz_21cw_0.swift:13:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        return longest.characters.count < s.characters.count\
    \ ? s : longest\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpz_21cw_0.swift:13:45: error: 'characters' is unavailable:\
    \ Please use String directly\n        return longest.characters.count < s.characters.count\
    \ ? s : longest\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") {\n        if $0.count < $1.count {\n            return $1\n        } else\
    \ {\n            return $0\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.filter({ $0.count > 0 }))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_xd1qxk.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.filter({ $0.count > 0 }))\n            \
    \       ^\n                   strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longest: 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp199unfh5.swift:11:38: error: extra argument 'longest' in call\n\
    \    return longest(strings, longest: 1)\n                  ~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map(String.init))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpg8to1k0y.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map(String.init))\n                   ^\n\
    \                   strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted(byLength))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8y6b5w7.swift:11:35: error: cannot find 'byLength' in scope\n\
    \    return longest(strings.sorted(byLength))\n                              \
    \    ^~~~~~~~\n/tmp/tmpl8y6b5w7.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted(byLength))\n                   ^\n\
    \                   strings: \n/tmp/tmpl8y6b5w7.swift:11:35: error: missing argument\
    \ label 'by:' in call\n    return longest(strings.sorted(byLength))\n        \
    \                          ^\n                                  by: \n/tmp/tmpl8y6b5w7.swift:11:35:\
    \ error: converting non-escaping value to '(String, String) throws -> Bool' may\
    \ allow it to escape\n    return longest(strings.sorted(byLength))\n         \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, options: .longestEffectiveLength)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgks3ou3.swift:11:39: error: extra argument 'options' in call\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \     ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfgks3ou3.swift:11:39:\
    \ error: cannot infer contextual base in reference to member 'longestEffectiveLength'\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map(String.init))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpg8to1k0y.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map(String.init))\n                   ^\n\
    \                   strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") {\n        if $0.count < $1.count {\n            return $1\n        } else\
    \ {\n            return $0\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") { $0 + $1 }\n    return strings.filter({ $0.count == longest.count }).first\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpct2vvsgp/tmpct2vvsgp.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0a5c2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0a5921b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0a5921988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0a59207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpct2vvsgp                        0x00005649151d3a6a <unavailable> + 6762

    5    libc.so.6                          0x00002ac0a5e16460 __libc_start_main +
    245

    6    tmpct2vvsgp                        0x00005649151d3359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpa01hgq53.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpa01hgq53.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longest: 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp199unfh5.swift:11:38: error: extra argument 'longest' in call\n\
    \    return longest(strings, longest: 1)\n                  ~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted(byLength))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8y6b5w7.swift:11:35: error: cannot find 'byLength' in scope\n\
    \    return longest(strings.sorted(byLength))\n                              \
    \    ^~~~~~~~\n/tmp/tmpl8y6b5w7.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted(byLength))\n                   ^\n\
    \                   strings: \n/tmp/tmpl8y6b5w7.swift:11:35: error: missing argument\
    \ label 'by:' in call\n    return longest(strings.sorted(byLength))\n        \
    \                          ^\n                                  by: \n/tmp/tmpl8y6b5w7.swift:11:35:\
    \ error: converting non-escaping value to '(String, String) throws -> Bool' may\
    \ allow it to escape\n    return longest(strings.sorted(byLength))\n         \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map(String.init))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpg8to1k0y.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map(String.init))\n                   ^\n\
    \                   strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") { (result, string) in\n        if result.count < string.count {\n        \
    \    return string\n        }\n        return result\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength: 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp44wx6u0f.swift:11:50: error: extra argument 'longestStringLength'\
    \ in call\n    return longest(strings, longestStringLength: 0)\n             \
    \     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map({ $0.count }))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpp49vlxb2.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map({ $0.count }))\n                   ^\n\
    \                   strings: \n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, options: .longestEffectiveLength)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgks3ou3.swift:11:39: error: extra argument 'options' in call\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \     ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfgks3ou3.swift:11:39:\
    \ error: cannot infer contextual base in reference to member 'longestEffectiveLength'\n\
    \    return longest(strings, options: .longestEffectiveLength)\n             \
    \                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0, strings)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpkysfnx1x.swift:11:19: error: extra arguments at positions #2, #3\
    \ in call\n    return longest(strings, 0, strings)\n                  ^\n/tmp/tmpkysfnx1x.swift:10:6:\
    \ note: 'longest(strings:)' declared here\nfunc longest(strings: [String]) ->\
    \ String? {\n     ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted(byLength))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8y6b5w7.swift:11:35: error: cannot find 'byLength' in scope\n\
    \    return longest(strings.sorted(byLength))\n                              \
    \    ^~~~~~~~\n/tmp/tmpl8y6b5w7.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted(byLength))\n                   ^\n\
    \                   strings: \n/tmp/tmpl8y6b5w7.swift:11:35: error: missing argument\
    \ label 'by:' in call\n    return longest(strings.sorted(byLength))\n        \
    \                          ^\n                                  by: \n/tmp/tmpl8y6b5w7.swift:11:35:\
    \ error: converting non-escaping value to '(String, String) throws -> Bool' may\
    \ allow it to escape\n    return longest(strings.sorted(byLength))\n         \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpa01hgq53.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpa01hgq53.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") { (longest, s) in\n        return s.count > longest.count ? s : longest\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i71kp5g.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3juz6rx.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpc3juz6rx.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
