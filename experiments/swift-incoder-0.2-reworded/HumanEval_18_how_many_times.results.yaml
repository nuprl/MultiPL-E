language: swift
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = endIndex + 1\n        } else {\n            count +=\
    \ 1\n            startIndex = endIndex + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp99hs3n_x.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmp99hs3n_x.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmp99hs3n_x.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    while i < string.count {\n        if string[i]\
    \ == substring[j] {\n            count += 1\n            i += 1\n            j\
    \ += 1\n            if j == substring.count {\n                j = 0\n       \
    \     }\n        } else {\n            i = 0\n            j += 1\n           \
    \ if j == substring.count {\n                j = 0\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjvb3e6_6.swift:17:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjvb3e6_6.swift:17:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.startIndex.advanced(by: start)\n\
    \        end = string.endIndex.advanced(by: end)\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpphasco40.swift:20:35: error: value of type 'String.Index' has no\
    \ member 'advanced'\n        start = string.startIndex.advanced(by: start)\n \
    \               ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpphasco40.swift:21:31: error:\
    \ value of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ end)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpphasco40.swift:22:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpphasco40.swift:22:60: error: value of type 'String' has no member 'length'\n\
    \        if string.substring(from: start, length: substring.length) == substring\
    \ {\n                                                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).contains(substring) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm4mun4rb.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpm4mun4rb.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.count\n    var k = substring.count\n    while i < j && k < string.count\
    \ {\n        if string[i] == substring[k] {\n            count = count + 1\n \
    \           i = i + 1\n            k = k + 1\n        }\n        else {\n    \
    \        i = i + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi5__atz1.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpi5__atz1.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpi5__atz1.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var last = 0\n    var found = false\n    for i < string.count {\n\
    \        if string[i] == substring[0] {\n            found = true\n          \
    \  j = i\n            for k < substring.count {\n                if string[i+k]\
    \ == substring[k] {\n                    found = true\n                    last\
    \ = k\n                    k += last\n                } else {\n             \
    \       found = false\n                }\n            }\n            if found\
    \ {\n                count += last - j\n                i += last - j\n      \
    \      } else {\n                count += 1\n                i += 1\n        \
    \    }\n        } else {\n            count += 1\n            i += 1\n       \
    \ }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd8q9n3a6.swift:22:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmpd8q9n3a6.swift:22:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmpd8q9n3a6.swift:26:19: error: expected\
    \ 'in' after for-each pattern\n            for k < substring.count {\n       \
    \           ^\n/tmp/tmpd8q9n3a6.swift:26:19: error: unary operator cannot be separated\
    \ from its operand\n            for k < substring.count {\n                  ^~\n\
    \                   \n/tmp/tmpd8q9n3a6.swift:14:16: error: use of local variable\
    \ 'count' before its declaration\n        return count(string)\n             \
    \  ^\n/tmp/tmpd8q9n3a6.swift:16:9: note: 'count' declared here\n    var count\
    \ = 0\n        ^\n/tmp/tmpd8q9n3a6.swift:22:11: error: '<' is not a prefix unary\
    \ operator\n    for i < string.count {\n          ^\n/tmp/tmpd8q9n3a6.swift:26:19:\
    \ error: '<' is not a prefix unary operator\n            for k < substring.count\
    \ {\n                  ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        if string[start] == substring[0] {\n       \
    \     count += 1\n            start += 1\n            if start == end {\n    \
    \            return count\n            }\n        }\n        if string[end] ==\
    \ substring[0] {\n            count -= 1\n            end -= 1\n            if\
    \ start == end {\n                return count\n            }\n        }\n   \
    \     start += 1\n        end -= 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph20foh7k.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmph20foh7k.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmph20foh7k.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmph20foh7k.swift:20:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[start] == substring[0] {\n           ^~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph20foh7k.swift:20:29:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[start] == substring[0] {\n  \
    \                          ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var startIndex = 0\n    var endIndex = 0\n    var lastCharIndex = 0\n\n \
    \   for char in string {\n        if char == substring[lastCharIndex] {\n    \
    \        count += 1\n            lastCharIndex += 1\n        } else {\n      \
    \      if lastCharIndex != 0 {\n                endIndex = startIndex + lastCharIndex\n\
    \                count += endIndex - startIndex\n                startIndex =\
    \ endIndex\n            }\n            lastCharIndex = 0\n            startIndex\
    \ = endIndex\n            endIndex += 1\n        }\n    }\n\n    if lastCharIndex\
    \ != 0 {\n        endIndex = startIndex + lastCharIndex\n        count += endIndex\
    \ - startIndex\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphq3ftpgc.swift:20:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if char ==\
    \ substring[lastCharIndex] {\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.startIndex\n    var k = string.endIndex\n    while i < j {\n\
    \        if string[i] == substring[0] {\n            count = countOccurrences(string,\
    \ substring)\n            i += substring.length - 1\n        } else {\n      \
    \      i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpozxdue3p.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpozxdue3p.swift:20:13: error: operator function '<' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n    while i < j {\n            ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpozxdue3p.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpozxdue3p.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpozxdue3p.swift:22:21:\
    \ error: cannot find 'countOccurrences' in scope\n            count = countOccurrences(string,\
    \ substring)\n                    ^~~~~~~~~~~~~~~~\n/tmp/tmpozxdue3p.swift:23:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var start = 0\n    var end = string.count\n\n    while start < end {\n  \
    \      start = string.index(substring, start) + 1\n        end = string.index(substring,\
    \ end) + end\n        count += 1\n    }\n\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpaxi0ts8n.swift:19:24: error: no exact matches in call to instance\
    \ method 'index'\n        start = string.index(substring, start) + 1\n       \
    \                ^\n/tmp/tmpaxi0ts8n.swift:19:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpaxi0ts8n.swift:19:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpaxi0ts8n.swift:19:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpaxi0ts8n.swift:19:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpaxi0ts8n.swift:20:22: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        end =\
    \ string.index(substring, end) + end\n                     ^\n/tmp/tmpaxi0ts8n.swift:20:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + end\n                     ^\n/tmp/tmpaxi0ts8n.swift:20:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + end\n                     ^\n/tmp/tmpaxi0ts8n.swift:20:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + end\n                   \
    \  ^\n/tmp/tmpaxi0ts8n.swift:20:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + end\n                     ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += substring.length - 1\n        } else if string[i] ==\
    \ substring[1] {\n            count += 1\n            i += substring.length -\
    \ 1\n        } else if string[i] == substring[2] {\n            count += 1\n \
    \           i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4io1nzol.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp4io1nzol.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmp4io1nzol.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmp4io1nzol.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmp4io1nzol.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp4io1nzol.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4io1nzol.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmp4io1nzol.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4io1nzol.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    return string.distance(from: start, to: end) + 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3yj1w__h.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp3yj1w__h.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            if i == string.endIndex\
    \ {\n                j = string.endIndex\n            } else {\n             \
    \   i += 1\n            }\n        } else {\n            count = 0\n         \
    \   i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptlar6c2k.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmptlar6c2k.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmptlar6c2k.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmptlar6c2k.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmptlar6c2k.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptlar6c2k.swift:23:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if i == string.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = string.startIndex\n\
    \    while i < string.endIndex {\n        j = string.startIndex\n        while\
    \ j < string.endIndex {\n            if string[j] != substring[k] {\n        \
    \        break\n            }\n            j += 1\n            k += 1\n      \
    \  }\n        if j == string.endIndex {\n            count += 1\n        }\n \
    \       i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzlvs25j2.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpzlvs25j2.swift:21:20: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        j = string.startIndex\n\
    \            ~~~~~~~^~~~~~~~~~\n/tmp/tmpzlvs25j2.swift:22:17: error: operator\
    \ function '<' requires that 'String.Index' conform to 'BinaryInteger'\n     \
    \   while j < string.endIndex {\n                ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpzlvs25j2.swift:23:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if string[j]\
    \ != substring[k] {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzlvs25j2.swift:27:15: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n\
    \            k += 1\n            ~ ^  ~\n/tmp/tmpzlvs25j2.swift:29:14: error:\
    \ operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        if j == string.endIndex {\n             ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += substring.length - 1\n        } else if string[i] ==\
    \ substring[1] {\n            count += 1\n            i += substring.length -\
    \ 1\n        } else if string[i] == substring[2] {\n            count += 1\n \
    \           i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqexw9c4p.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpqexw9c4p.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpqexw9c4p.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpqexw9c4p.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpqexw9c4p.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpqexw9c4p.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpqexw9c4p.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqexw9c4p.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqexw9c4p.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n/tmp/tmpqexw9c4p.swift:23:19: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been exp"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n \
    \   var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n  \
    \  var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n   \
    \ var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\
    \ u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z\
    \ = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e =\
    \ 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var\
    \ e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o =\
    \ 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n\
    \    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n \
    \   var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var a = 0\n    var b = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv8bivfcm.swift:43:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv8bivfcm.swift:17:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv8bivfcm.swift:44:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv8bivfcm.swift:18:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv8bivfcm.swift:45:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv8bivfcm.swift:19:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv8bivfcm.swift:46:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv8bivfcm.swift:20:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv8bivfcm.swift:47:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv8bivfcm.swift:21:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv8bivfcm.swift:48:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv8bivfcm.swift:22:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv8bivfcm.swift:49:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv8bivfcm.swift:23:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv8bivfcm.swift:50:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv8bivfcm.swift:24:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv8bivfcm.swift:51:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv8bivfcm.swift:25:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv8bivfcm.swift:52:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv8bivfcm.swift:26:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv8bivfcm.swift:53:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv8bivfcm.swift:27:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv8bivfcm.swift:54:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv8bi"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\", true)\n    }\n    var count = 0\n    var last\
    \ = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ 1) == substring {\n            count += 1\n            last = index\n      \
    \  }\n    }\n    if last < string.characters.count {\n        count += countOccurrences(string,\
    \ string.substring(last, string.characters.count), true)\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptuczrc1g.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\", true)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptuczrc1g.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmptuczrc1g.swift:19:19: error: value of type 'String' has no member 'substring'\n\
    \        if string.substring(index, 1) == substring {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmptuczrc1g.swift:24:22: error: 'characters' is unavailable: Please use String\
    \ directly\n    if last < string.characters.count {\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptuczrc1g.swift:25:18:\
    \ error: cannot find 'countOccurrences' in scope\n        count += countOccurrences(string,\
    \ string.substring(last, string.characters.count), true)\n                 ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptuczrc1g.swift:25:50: error: value of type 'String' has no member 'substring'\n\
    \        count += countOccurrences(string, string.substring(last, string.characters.count),\
    \ true)\n                                          ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.index(of: substring)\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!.offsetByIndex(of: substring)) : 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqrssbeo1.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.index(of: substring)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += how_many_times(string: String(string[i..<j]), substring: substring[1:])\n\
    \            i += substring.length - 1\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6eiu66hr.swift:21:90: error: expected ',' separator\n         \
    \   count += how_many_times(string: String(string[i..<j]), substring: substring[1:])\n\
    \                                                                            \
    \             ^\n                                                            \
    \                             ,\n/tmp/tmp6eiu66hr.swift:21:90: error: expected\
    \ expression in list of expressions\n            count += how_many_times(string:\
    \ String(string[i..<j]), substring: substring[1:])\n                         \
    \                                                                ^\n/tmp/tmp6eiu66hr.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6eiu66hr.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6eiu66hr.swift:21:88:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            count += how_many_times(string: String(string[i..<j]), substring:\
    \ substring[1:])\n                                                           \
    \                            ^\n/tmp/tmp6eiu66hr.swift:22:28: error: value of\
    \ type 'String' has no member 'length'\n            i += substring.length - 1\n\
    \                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\", true)\n    }\n    var count = 0\n    var startIndex\
    \ = 0\n    var endIndex = string.characters.count\n    var substringIndex = string.characters.startIndex\n\
    \    while substringIndex < endIndex {\n        if string.characters.contains(substringIndex,\
    \ substringIndex) {\n            count += 1\n        }\n        substringIndex\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpikg5y7z0.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\", true)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpikg5y7z0.swift:18:27: error: 'characters' is unavailable: Please use String\
    \ directly\n    var endIndex = string.characters.count\n                     \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpikg5y7z0.swift:19:33:\
    \ error: 'characters' is unavailable: Please use String directly\n    var substringIndex\
    \ = string.characters.startIndex\n                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpikg5y7z0.swift:20:26:\
    \ error: referencing operator function '<' on 'BinaryInteger' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n    while substringIndex < endIndex {\n        \
    \                 ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmpikg5y7z0.swift:21:30: error: no\
    \ exact matches in call to instance method 'contains'\n        if string.characters.contains(substringIndex,\
    \ substringIndex) {\n                             ^\n/tmp/tmpikg5y7z0.swift:21:30:\
    \ note: found candidate with type '(String.Index) -> Bool'\n        if string.characters.contains(substringIndex,\
    \ substringIndex) {\n                             ^\n/tmp/tmpikg5y7z0.swift:24:24:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        substringIndex += 1\n        ~~~~~~~~~~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else if string[i] == substring[1]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[2] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[3] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[4] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[5] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[6]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[7] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[8] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[9] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[10] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[11]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[12] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[13] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[14] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[15] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[16]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[17] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[18] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[19] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[20] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[21]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[22] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[23] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[24] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[25] {\n            count += 1\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprk9_b0mh.swift:116:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmprk9_b0mh.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmprk9_b0mh.swift:116:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmprk9_b0mh.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmprk9_b0mh.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmprk9_b0mh.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprk9_b0mh.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmprk9_b0mh.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprk9_b0mh.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\", true)\n    }\n    var count = 0\n    var startIndex\
    \ = 0\n    var endIndex = string.count\n    while startIndex < endIndex {\n  \
    \      let index = string.index(startIndex, offsetBy: substring.count)\n     \
    \   if index == startIndex {\n            count += 1\n            startIndex +=\
    \ substring.count\n        } else if index == endIndex {\n            count +=\
    \ 1\n            endIndex -= substring.count\n        } else {\n            count\
    \ += 1\n            startIndex = index\n            endIndex = index\n       \
    \ }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq29dway8.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\", true)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpq29dway8.swift:20:34: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        let index = string.index(startIndex, offsetBy:\
    \ substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpik07zbhd.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpik07zbhd.swift:19:31:\
    \ note: to match this opening '{'\n    while i < string.endIndex {\n         \
    \                     ^\n/tmp/tmpik07zbhd.swift:114:67: error: expected '}' at\
    \ end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmpik07zbhd.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmpik07zbhd.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpik07zbhd.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpik07zbhd.swift:19:13: error:\
    \ operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpik07zbhd.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpik07zbhd.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpik07zbhd.swift:22:28:\
    \ error: value of t"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgwvodik2.swift:17:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpgwvodik2.swift:17:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpgwvodik2.swift:17:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgwvodik2.swift:20:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpgwvodik2.swift:20:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpgwvodik2.swift:20:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpgwvodik2.swift:20:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpgwvodik2.swift:20:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string, substring.dropLast(substring.length))\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpan3_fsas.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpan3_fsas.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpan3_fsas.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpan3_fsas.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string, substring.dropLast(substring.length))\n\
    \                                 ^\n                                  string:\
    \ substring: \n/tmp/tmpan3_fsas.swift:20:53: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \        return 1 + how_many_times(string, substring.dropLast(substring.length))\n\
    \                                                    ^\n                     \
    \                     String(                             )\n/tmp/tmpan3_fsas.swift:20:72:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string,\
    \ substring.dropLast(substring.length))\n                                    \
    \                         ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, options: .caseInsensitive)\n\
    \        if index == nil {\n            break\n        }\n        count += 1\n\
    \        start = index! + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprlqiv612.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmprlqiv612.swift:17:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmprlqiv612.swift:17:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmprlqiv612.swift:17:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let range = start..<end\n    return range.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxf6p9u9l.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpxf6p9u9l.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpxf6p9u9l.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpxf6p9u9l.swift:11:63: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for c in string.unicodeScalars {\n        if c == substring {\n     \
    \       count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjj1za6b0.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph5xy48d5.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmph5xy48d5.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmph5xy48d5.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmph5xy48d5.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string.characters[i]\
    \ == substring.characters[k] {\n            count += 1\n            i += k\n \
    \           k -= 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp14qmxht7.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp14qmxht7.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp14qmxht7.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp14qmxht7.swift:21:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp14qmxht7.swift:21:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp14qmxht7.swift:21:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp14qmxht7.swift:18:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < string.count\
    \ {\n        if string[i] == substring[j] {\n            count += 1\n        \
    \    i += 1\n            j += 1\n            if j == substring.count {\n     \
    \           j = 0\n            }\n        } else {\n            j = 0\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbkxavud2.swift:19:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmpbkxavud2.swift:19:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmpbkxavud2.swift:19:11: error: '<' is not\
    \ a prefix unary operator\n    for i < string.count {\n          ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ ho\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpczt9ig8a.swift:81:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpczt9ig8a.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpczt9ig8a.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpczt9ig8a.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpczt9ig8a.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpczt9ig8a.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpczt9ig8a.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                    "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprj7z67ll.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring, true)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else if string[i] == substring[1]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgnshsyjo.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgnshsyjo.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgnshsyjo.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpgnshsyjo.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgnshsyjo.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] == substring[1] {\n\
    \                               ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgnshsyjo.swift:25:28: error: value\
    \ of type 'String' has no member 'length'\n            i += substring.length -\
    \ 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var last = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ 1) == substring {\n            count += 1\n            if last < index {\n \
    \               last = index\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpn8k2av81.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpn8k2av81.swift:16:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, 1) == substring {\n        \
    \   ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  let index = string.index(start, offsetBy: substring.count)\n        if index\
    \ == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ substring.count)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi6ccwfkv.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string.characters[i] != substring.characters[j]\
    \ {\n            count += 1\n            i = j\n        } else {\n           \
    \ i += 1\n            j += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2j4_21ml.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp2j4_21ml.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp2j4_21ml.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp2j4_21ml.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[j] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2j4_21ml.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[j] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2j4_21ml.swift:20:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[j] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp2j4_21ml.swift:20:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[j] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let substrings\
    \ = substring.characters\n    var count = 0\n    for char in string.characters\
    \ {\n        if substrings.contains(char) {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp04yjdeuo.swift:10:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let substrings = substring.characters\n           \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp04yjdeuo.swift:12:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbj8zxg0x.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpbj8zxg0x.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpbj8zxg0x.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpbj8zxg0x.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpbj8zxg0x.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpbj8zxg0x.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = string.startIndex\n    while i < string.endIndex {\n        if string[k]\
    \ == substring[j] {\n            count += 1\n            i += 1\n            j\
    \ += 1\n            if j == substring.endIndex {\n                j = 0\n    \
    \            k += 1\n            }\n        } else {\n            j = 0\n    \
    \        k += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy8qf2mop.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpy8qf2mop.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpy8qf2mop.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpy8qf2mop.swift:21:25: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[k] == substring[j]\
    \ {\n                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy8qf2mop.swift:25:18: error: operator\
    \ function '==' requires that 'String.Index' conform to 'BinaryInteger'\n    \
    \        if j == substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpy8qf2mop.swift:27:19: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n                k += 1\n     \
    \           ~ ^  ~\n/tmp/tmpy8qf2mop.swift:31:15: error: binary operator '+='\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n           \
    \ k += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n \
    \   var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n\
    \    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al =\
    \ 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq\
    \ = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var\
    \ av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n   \
    \ var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n\
    \    var bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj =\
    \ 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo\
    \ = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var\
    \ bt = 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n    var bx = 0\n   \
    \ var by = 0\n    var bz = 0\n    var ca = 0\n    var cb = 0\n    var cc = 0\n\
    \    var cd = 0\n    var ce = 0\n    var cf = 0\n    var cg = 0\n    var ch =\
    \ 0\n    var ci = 0\n    var cj = 0\n    var ck = 0\n    var cl = 0\n    var cm\
    \ = 0\n    var cn = 0\n    var co = 0\n    var cp = 0\n    var cq = 0\n    var\
    \ cr = 0\n    var cs = 0\n    var ct = 0\n    var cu = 0\n    var cv = 0\n   \
    \ var cw = 0\n    var cx = 0\n    var cy = 0\n    var cz = 0\n    var da = 0\n\
    \    var db = 0\n    var dc = 0\n    var dd = 0\n    var de = 0\n    var df =\
    \ 0\n    var dg = 0\n    var dh = 0\n    var di = 0\n    var dj = 0\n    var dk\
    \ = 0\n    var dl = 0\n    var dm = 0\n    var dn = 0\n    var do = 0\n    var\
    \ dp = 0\n    var dq = 0\n    var dr = 0\n    var ds = 0\n    var dt = 0\n   \
    \ var du = 0\n    var dv = 0\n    var dw = 0\n    var dx = 0\n    var dy = 0\n\
    \    var dz = 0\n    var ea = 0\n    var eb = 0\n    var ec = 0\n    var ed =\
    \ 0\n    var ee = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppwm5prxu.swift:47:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmppwm5prxu.swift:47:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmppwm5prxu.swift:121:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmppwm5prxu.swift:121:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmppwm5prxu.swift:10:9: warning: initialization\
    \ of variable 'count' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmppwm5prxu.swift:11:9:\
    \ warning: initialization of variable 'i' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:12:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:13:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:14:9:\
    \ warning: initialization of variable 'l' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var l = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:15:9:\
    \ warning: initialization of variable 'm' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var m = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:16:9:\
    \ warning: initialization of variable 'n' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var n = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:17:9:\
    \ warning: initialization of variable 'o' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var o = 0\n    ~~~~^\n    _\n/tmp/tmppwm5prxu.swift:18:9:\
    \ warning: initialization of variable 'p' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var p = 0\n    ~~~~^\n    _\n/tmp"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    if index == nil {\n        return 0\n\
    \    }\n    let start = index!\n    let end = string.index(start, offsetBy: substring.count)\n\
    \    return string.distance(from: start, to: end) + 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8775glzk.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ = count + 1\n        }\n        i += 1\n        k += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8pvguo63.swift:12:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8pvguo63.swift:13:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8pvguo63.swift:15:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8pvguo63.swift:15:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp8pvguo63.swift:12:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae =\
    \ 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj\
    \ = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var\
    \ ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n   \
    \ var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n\
    \    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc =\
    \ 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh\
    \ = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var\
    \ bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n   \
    \ var br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n\
    \    var bw = 0\n    var bx = 0\n    var by = 0\n    var bz = 0\n    var ca =\
    \ 0\n    var cb = 0\n    var cc = 0\n    var cd = 0\n    var ce = 0\n    var cf\
    \ = 0\n    var cg = 0\n    var ch = 0\n    var ci = 0\n    var cj = 0\n    var\
    \ ck = 0\n    var cl = 0\n    var cm = 0\n    var cn = 0\n    var co = 0\n   \
    \ var cp = 0\n    var cq = 0\n    var cr = 0\n    var cs = 0\n    var ct = 0\n\
    \    var cu = 0\n    var cv = 0\n    var cw = 0\n    var cx = 0\n    var cy =\
    \ 0\n    var cz = 0\n    var da = 0\n    var db = 0\n    var dc = 0\n    var dd\
    \ = 0\n    var de = 0\n    var df = 0\n    var dg = 0\n    var dh = 0\n    var\
    \ di = 0\n    var dj = 0\n    var dk = 0\n    var dl = 0\n    var dm = 0\n   \
    \ var dn = 0\n    var do = 0\n    var dp = 0\n    var dq = 0\n    var dr = 0\n\
    \    var ds = 0\n    var dt = 0\n    var du = 0\n    var dv = 0\n    var dw =\
    \ 0\n    var dx = 0\n    var dy = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl4sg42am.swift:53:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpl4sg42am.swift:53:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpl4sg42am.swift:127:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpl4sg42am.swift:127:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpl4sg42am.swift:14:16: error: use of local\
    \ variable 'count' before its declaration\n        return count(string)\n    \
    \           ^\n/tmp/tmpl4sg42am.swift:16:9: note: 'count' declared here\n    var\
    \ count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = 0\n    var lastCharIndex = 0\n    var\
    \ lastChar = string[0]\n    var lastSubstringIndex = 0\n    var lastSubstring\
    \ = substring[0]\n    for i = 0; i < len(string); i++ {\n        if string[i]\
    \ == lastChar {\n            count++\n            lastCharIndex = i\n        }\n\
    \        if substring[j] == lastSubstring {\n            lastSubstringIndex =\
    \ j\n            j++\n        }\n        if j == len(substring) {\n          \
    \  count++\n            lastSubstringIndex = i\n            j = 0\n        }\n\
    \    }\n    if lastCharIndex == 0 {\n        return count\n    }\n    if lastSubstringIndex\
    \ == 0 {\n        return count + 1\n    }\n    if lastCharIndex < lastSubstringIndex\
    \ {\n        return count + how_many_times(string[lastCharIndex..], substring[lastSubstringIndex..])\n\
    \    }\n    return count + how_many_times(string[lastCharIndex..], substring[lastSubstringIndex..])\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplk45pudv.swift:21:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i < len(string); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplk45pudv.swift:18:20: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n    var lastChar = string[0]\n\
    \                   ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplk45pudv.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    var lastSubstring = substring[0]\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplk45pudv.swift:43:59:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        return\
    \ count + how_many_times(string[lastCharIndex..], substring[lastSubstringIndex..])\n\
    \                                                          ^~\n              \
    \                                            ...\n/tmp/tmplk45pudv.swift:43:92:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        return\
    \ count + how_many_times(string[lastCharIndex..], substring[lastSubstringIndex..])\n\
    \                                                                            \
    \               ^~\n                                                         \
    \                                  ...\n/tmp/tmplk45pudv.swift:43:38: error: missing\
    \ argument labels 'string:substring:' in call\n        return count + how_many_times(string[lastCharIndex..],\
    \ substring[lastSubstringIndex..])\n                                     ^\n \
    \                                     string:                  substring: \n/tmp/tmplk45pudv.swift:45:55:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    return count\
    \ + how_many_times(string[lastCharIndex..], substring[lastSubstringIndex..]) +\
    \ 1\n              "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = string.characters.count\n    var m =\
    \ substring.characters.count\n    for (i; i < l; i++ {\n        if string[i] ==\
    \ substring[j] {\n            count++\n            j = j + 1\n            if j\
    \ == m {\n                j = 0\n                k = k + 1\n            }\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe6di3ow8.swift:22:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i; i < l; i++ {\n    ^   ~~~~~~~~~~~~~~~~\n/tmp/tmpe6di3ow8.swift:32:17:\
    \ error: expected '{' to start the body of for-each loop\n    return count\n \
    \               ^\n/tmp/tmpe6di3ow8.swift:14:16: error: cannot find 'countOccurrences'\
    \ in scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpe6di3ow8.swift:20:20: error: 'characters' is unavailable: Please use String\
    \ directly\n    var l = string.characters.count\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe6di3ow8.swift:21:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var m =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var start = 0\n    var end = string.count\n\n    while start < end {\n  \
    \      let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp00key762.swift:19:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[k] == substring[j] {\n   \
    \         count += 1\n            j += 1\n            if j == substring.count\
    \ {\n                j = 0\n                k += 1\n            }\n        } else\
    \ {\n            j = 0\n            k += 1\n        }\n        i += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnufhh6dp.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpnufhh6dp.swift:21:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnufhh6dp.swift:26:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                k += 1\n                ~ ^  ~\n/tmp/tmpnufhh6dp.swift:30:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            k += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4oy53fls.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp4oy53fls.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp4oy53fls.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp4oy53fls.swift:20:24: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24: error: no\
    \ exact matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp4oy53fls.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:21:22: error: no\
    \ exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp4oy53fls.swift:21:22: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp4oy53fls.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[index] {\n            count += 1\n        } else {\n\
    \            if count > 0 {\n                count -= 1\n            }\n     \
    \       last = index\n        }\n    }\n    return count + last - string.characters.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwe1i08iv.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpwe1i08iv.swift:16:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[index] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwe1i08iv.swift:16:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpwe1i08iv.swift:16:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[index] {\n      \
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwe1i08iv.swift:16:50:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                                         \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwe1i08iv.swift:25:34:\
    \ error: 'characters' is unavailable: Please use String directly\n    return count\
    \ + last - string.characters.count\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n            if k == substring.characters.count {\n                k =\
    \ 0\n            }\n        } else {\n            i += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobfpykl3.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpobfpykl3.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpobfpykl3.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpobfpykl3.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpobfpykl3.swift:25:31: error: 'characters' is\
    \ unavailable: Please use String directly\n            if k == substring.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpobfpykl3.swift:18:9: warning: variable 'j' was never\
    \ mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = string.characters.count\n\
    \    var m = substring.characters.count\n    while i < l && j < m {\n        if\
    \ string[i] != substring[j] {\n            count += 1\n            i += 1\n  \
    \          j += 1\n        } else {\n            i += 1\n            j += 1\n\
    \        }\n    }\n    while i < l {\n        count += 1\n        i += 1\n   \
    \ }\n    while j < m {\n        count += 1\n        j += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpckt4y4o_.swift:14:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var l = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpckt4y4o_.swift:15:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var m =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpckt4y4o_.swift:17:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpckt4y4o_.swift:17:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpckt4y4o_.swift:13:9: warning: initialization\
    \ of variable 'k' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpckt4y4o_.swift:14:9: warning:\
    \ variable 'l' was never mutated; consider changing to 'let' constant\n    var\
    \ l = string.characters.count\n    ~~~ ^\n    let\n/tmp/tmpckt4y4o_.swift:15:9:\
    \ warning: variable 'm' was never mutated; consider changing to 'let' constant\n\
    \    var m = substring.characters.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string.characters[i] != substring.characters[k]\
    \ {\n            count += 1\n        }\n        i += 1\n        k += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw3rfwmng.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpw3rfwmng.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpw3rfwmng.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpw3rfwmng.swift:18:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpw3rfwmng.swift:18:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpw3rfwmng.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw3rfwmng.swift:15:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string, substring.dropLast())\n    }\n    if string.hasPrefix(substring)\
    \ || string.hasSuffix(substring) {\n        return how_many_times(string.dropFirst(),\
    \ substring) + how_many_times(string, substring.dropLast())\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp75r7ye8r.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                 ^\n                                  string:\
    \             substring: \n/tmp/tmp75r7ye8r.swift:17:42: error: cannot convert\
    \ value of type 'String.SubSequence' (aka 'Substring') to expected argument type\
    \ 'String'\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                         ^\n                                \
    \  String(           )\n/tmp/tmp75r7ye8r.swift:20:34: error: missing argument\
    \ labels 'string:substring:' in call\n        return 1 + how_many_times(string,\
    \ substring.dropLast())\n                                 ^\n                \
    \                  string: substring: \n/tmp/tmp75r7ye8r.swift:20:53: error: cannot\
    \ convert value of type 'String.SubSequence' (aka 'Substring') to expected argument\
    \ type 'String'\n        return 1 + how_many_times(string, substring.dropLast())\n\
    \                                                    ^\n                     \
    \                     String(             )\n/tmp/tmp75r7ye8r.swift:23:30: error:\
    \ missing argument labels 'string:substring:' in call\n        return how_many_times(string.dropFirst(),\
    \ substring) + how_many_times(string, substring.dropLast())\n                \
    \             ^\n                              string:             substring:\
    \ \n/tmp/tmp75r7ye8r.swift:23:38: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        return how_many_times(string.dropFirst(),\
    \ substring) + how_many_times(string, substring.dropLast())\n                \
    \                     ^\n                              String(           )\n/tmp/tmp75r7ye8r.swift:23:78:\
    \ error: missing argument labels 'string:substring:' in call\n        return how_many_times(string.dropFirst(),\
    \ substring) + how_many_times(string, substring.dropLast())\n                \
    \                                                             ^\n            \
    \            "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    return index == nil ? 0 : index!.distance(string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph6scgauy.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    if index == nil {\n        return 0\n\
    \    }\n    let substringLength = substring.length\n    let stringLength = string.length\n\
    \    let substringIndex = index!\n    let stringIndex = substringIndex\n    let\
    \ substringEnd = substringIndex + substringLength\n    let stringEnd = stringIndex\
    \ + stringLength\n    let substringRange = string.substring(to: substringIndex)\n\
    \    let stringRange = string.substring(to: stringIndex)\n    let substringRangeEnd\
    \ = substringRange.endIndex\n    let stringRangeEnd = stringRange.endIndex\n \
    \   let overlap = substringRangeEnd >= stringRangeEnd\n    let count = substringRange.distance(from:\
    \ stringRange)\n    if overlap {\n        count += substringLength\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzlky9gjy.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmpzlky9gjy.swift:14:37: error: value of type 'String' has no member 'length'\n\
    \    let substringLength = substring.length\n                          ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpzlky9gjy.swift:15:31: error: value of type 'String' has no member\
    \ 'length'\n    let stringLength = string.length\n                       ~~~~~~\
    \ ^~~~~~\n/tmp/tmpzlky9gjy.swift:20:33: error: value of type 'String' has no member\
    \ 'substring'\n    let substringRange = string.substring(to: substringIndex)\n\
    \                         ~~~~~~ ^~~~~~~~~\n/tmp/tmpzlky9gjy.swift:21:30: error:\
    \ value of type 'String' has no member 'substring'\n    let stringRange = string.substring(to:\
    \ stringIndex)\n                      ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae =\
    \ 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj\
    \ = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var\
    \ ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n   \
    \ var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n\
    \    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc =\
    \ 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh\
    \ = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var\
    \ bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n   \
    \ var br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n\
    \    var bw = 0\n    var bx = 0\n    var by = 0\n    var bz = 0\n    var ca =\
    \ 0\n    var cb = 0\n    var cc = 0\n    var cd = 0\n    var ce = 0\n    var cf\
    \ = 0\n    var cg = 0\n    var ch = 0\n    var ci = 0\n    var cj = 0\n    var\
    \ ck = 0\n    var cl = 0\n    var cm = 0\n    var cn = 0\n    var co = 0\n   \
    \ var cp = 0\n    var cq = 0\n    var cr = 0\n    var cs = 0\n    var ct = 0\n\
    \    var cu = 0\n    var cv = 0\n    var cw = 0\n    var cx = 0\n    var cy =\
    \ 0\n    var cz = 0\n    var da = 0\n    var db = 0\n    var dc = 0\n    var dd\
    \ = 0\n    var de = 0\n    var df = 0\n    var dg = 0\n    var dh = 0\n    var\
    \ di = 0\n    var dj = 0\n    var dk = 0\n    var dl = 0\n    var dm = 0\n   \
    \ var dn = 0\n    var do = 0\n    var dp = 0\n    var dq = 0\n    var dr = 0\n\
    \    var ds = 0\n    var dt = 0\n    var du = 0\n    var dv = 0\n    var dw =\
    \ 0\n    var dx = 0\n    var dy = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl4sg42am.swift:53:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpl4sg42am.swift:53:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpl4sg42am.swift:127:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpl4sg42am.swift:127:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpl4sg42am.swift:14:16: error: use of local\
    \ variable 'count' before its declaration\n        return count(string)\n    \
    \           ^\n/tmp/tmpl4sg42am.swift:16:9: note: 'count' declared here\n    var\
    \ count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpu1s49fc8.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwuurfxzp.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpwuurfxzp.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwuurfxzp.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpwuurfxzp.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    if\
    \ string.hasPrefix(substring) || string.hasSuffix(substring) {\n        return\
    \ how_many_times(string.dropFirst(substring.length), substring) + how_many_times(string.dropLast(substring.length),\
    \ substring)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuox4r_2z.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpuox4r_2z.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpuox4r_2z.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpuox4r_2z.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpuox4r_2z.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:23:30: error: missing argument labels 'string:substring:'\
    \ in call\n        return how_many_times(string.dropFirst(substring.length), substring)\
    \ + how_many_times(string.dropLast(substring.length), substring)\n           \
    \                  ^\n                              string:                  \
    \           substring: \n/tmp/tmpuo"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j && k < string.count {\n        if string[i]\
    \ != substring[k] {\n            count = count + 1\n        }\n        i = i +\
    \ 1\n        k = k + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7mhk9bef.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7mhk9bef.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7mhk9bef.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4oy53fls.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp4oy53fls.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp4oy53fls.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp4oy53fls.swift:20:24: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24: error: no\
    \ exact matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp4oy53fls.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp4oy53fls.swift:21:22: error: no\
    \ exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp4oy53fls.swift:21:22: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp4oy53fls.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var last = 0\n    for i := 0; i < len(string); i++ {\n        if string[i]\
    \ == substring[0] {\n            count++\n            last = i\n        }\n  \
    \  }\n    for i := 0; i < len(substring); i++ {\n        if string[last+i] !=\
    \ substring[i] {\n            count = 0\n            break\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2y_kv3pf.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp2y_kv3pf.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmp2y_kv3pf.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmp2y_kv3pf.swift:21:12: error: expected type\n    for i := 0;\
    \ i < len(substring); i++ {\n           ^\n            <#type#>\n/tmp/tmp2y_kv3pf.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(substring);\
    \ i++ {\n           ^\n/tmp/tmp2y_kv3pf.swift:21:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(substring); i++ {\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += k\n        } else {\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoi8qauzp.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpoi8qauzp.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpoi8qauzp.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpoi8qauzp.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpoi8qauzp.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoi8qauzp.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return string.count(substring)\
    \ + how_many_times(string.dropLast(), substring)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsryz44f8.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpsryz44f8.swift:13:19: error: cannot call value of non-function type 'Int'\n\
    \    return string.count(substring) + how_many_times(string.dropLast(), substring)\n\
    \                  ^\n/tmp/tmpsryz44f8.swift:13:52: error: missing argument labels\
    \ 'string:substring:' in call\n    return string.count(substring) + how_many_times(string.dropLast(),\
    \ substring)\n                                                   ^\n         \
    \                                           string:            substring: \n/tmp/tmpsryz44f8.swift:13:60:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n    return string.count(substring) + how_many_times(string.dropLast(),\
    \ substring)\n                                                           ^\n \
    \                                                   String(          )\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j && k < string.count {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n        }\n        if string[i] == substring[k] {\n            count +=\
    \ 1\n            i += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n        }\n        if string[i] == substring[k] {\n      \
    \      i += 1\n            k += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqwbqbe8a.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpqwbqbe8a.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqwbqbe8a.swift:26:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpqwbqbe8a.swift:26:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqwbqbe8a.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpqwbqbe8a.swift:30:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph5xy48d5.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmph5xy48d5.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmph5xy48d5.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmph5xy48d5.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end + 1)\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpehtc2xtd.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpehtc2xtd.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpehtc2xtd.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpehtc2xtd.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpehtc2xtd.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var lastIndex = string.startIndex\n    var index = string.startIndex\n  \
    \  while index != string.endIndex {\n        if string[index] == substring[0]\
    \ {\n            count += 1\n            lastIndex = index\n        }\n      \
    \  index++\n    }\n\n    if lastIndex != string.endIndex {\n        count += 1\n\
    \    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoat_8a6b.swift:18:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[index]\
    \ == substring[0] {\n                            ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpoat_8a6b.swift:22:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let mid = start + (end - start) / 2\n      \
    \  if string.substring(from: mid).lowercased() == substring.lowercased() {\n \
    \           count += 1\n            start = mid + 1\n        } else {\n      \
    \      end = mid\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6xmasa62.swift:21:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: mid).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else if string[i] == substring[1]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[2] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[3] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[4] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[5] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[6]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[7] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[8] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[9] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[10] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[11]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[12] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[13] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[14] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[15] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[16]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[17] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[18] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[19] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[20] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[21]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[22] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[23] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[24] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[25] {\n            count += 1\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprk9_b0mh.swift:116:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmprk9_b0mh.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmprk9_b0mh.swift:116:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmprk9_b0mh.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmprk9_b0mh.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmprk9_b0mh.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprk9_b0mh.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmprk9_b0mh.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprk9_b0mh.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for char in string {\n        if char == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5ja7d1ao.swift:12:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmp5ja7d1ao.swift:12:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = string.startIndex(of: substring, range:\
    \ start..<end)\n        end = string.endIndex(of: substring, range: start..<end)\n\
    \        if start == end {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph76ed7uz.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmph76ed7uz.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmph76ed7uz.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmph76ed7uz.swift:20:24: error: cannot call value of non-function\
    \ type 'String.Index'\n        start = string.startIndex(of: substring, range:\
    \ start..<end)\n                       ^\n/tmp/tmph76ed7uz.swift:21:22: error:\
    \ cannot call value of non-function type 'String.Index'\n        end = string.endIndex(of:\
    \ substring, range: start..<end)\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsl3pwsck.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpsl3pwsck.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:23:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' ="
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string[string.startIndex.advanced(by: 0)] == substring[0] {\n\
    \        return how_many_times(string: String(string.dropFirst()), substring:\
    \ String(substring.dropFirst()))\n    }\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[1] {\n        return how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst()))\n    }\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[2] {\n        return how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst()))\n    }\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[3] {\n        return how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst()))\n    }\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[4] {\n        return how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw0cmwfy1.swift:48:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpw0cmwfy1.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpw0cmwfy1.swift:16:33: error: value of type 'String.Index' has\
    \ no member 'advanced'\n    if string[string.startIndex.advanced(by: 0)] == substring[0]\
    \ {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw0cmwfy1.swift:19:33: error:\
    \ value of type 'String.Index' has no member 'advanced'\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[1] {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw0cmwfy1.swift:22:33:\
    \ error: value of type 'String.Index' has no member 'advanced'\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[2] {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw0cmwfy1.swift:25:33:\
    \ error: value of type 'String.Index' has no member 'advanced'\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[3] {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw0cmwfy1.swift:28:33:\
    \ error: value of type 'String.Index' has no member 'advanced'\n    if string[string.startIndex.advanced(by:\
    \ 0)] == substring[4] {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw0cmwfy1.swift:29:301:\
    \ error: cannot find 'how_' in scope\n        return how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_many_times(string: String(string.dropFirst()),\
    \ substring: String(substring.dropFirst())) + how_\n                         \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                             "
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += count(substring)\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9zmq5i99.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp9zmq5i99.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp9zmq5i99.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp9zmq5i99.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9zmq5i99.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp9zmq5i99.swift:22:18: error: cannot call value\
    \ of non-function type 'Int'\n            i += count(substring)\n            \
    \     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsl3pwsck.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpsl3pwsck.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:23:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' ="
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasSuffix(substring) {\n        return 1 + how_many_times(string.dropLast(),\
    \ substring)\n    }\n    if string.hasPrefix(substring) {\n        return 1 +\
    \ how_many_times(substring, string.dropFirst())\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq_dlqacc.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(), substring)\n \
    \                                ^\n                                  string:\
    \            substring: \n/tmp/tmpq_dlqacc.swift:17:42: error: cannot convert\
    \ value of type 'String.SubSequence' (aka 'Substring') to expected argument type\
    \ 'String'\n        return 1 + how_many_times(string.dropLast(), substring)\n\
    \                                         ^\n                                \
    \  String(          )\n/tmp/tmpq_dlqacc.swift:20:34: error: missing argument labels\
    \ 'string:substring:' in call\n        return 1 + how_many_times(substring, string.dropFirst())\n\
    \                                 ^\n                                  string:\
    \    substring: \n/tmp/tmpq_dlqacc.swift:20:53: error: cannot convert value of\
    \ type 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \        return 1 + how_many_times(substring, string.dropFirst())\n          \
    \                                          ^\n                               \
    \              String(           )\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += k\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp65qg7dr9.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp65qg7dr9.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp65qg7dr9.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmp65qg7dr9.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.split(substring).count\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe3a9ntfo.swift:10:25: error: missing argument label 'separator:'\
    \ in call\n    return string.split(substring).count + 1\n                    \
    \    ^\n                        separator: \n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += 1\n            if k == substring.characters.count {\n                k =\
    \ 0\n            }\n        } else {\n            i += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptilt2g5k.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmptilt2g5k.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmptilt2g5k.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmptilt2g5k.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptilt2g5k.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmptilt2g5k.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptilt2g5k.swift:25:31:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if k == substring.characters.count {\n                              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            if i == string.endIndex\
    \ {\n                i += 1\n                j = string.startIndex\n         \
    \   }\n        } else {\n            i = j\n            j += 1\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp38w3nzag.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp38w3nzag.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp38w3nzag.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp38w3nzag.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp38w3nzag.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp38w3nzag.swift:23:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if i == string.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmp38w3nzag.swift:28:17: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            i = j\n                ^\n/tmp/tmp38w3nzag.swift:29:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let range = start..<end\n    return count(string.unicodeScalars.filter({\
    \ $0.isASCII }) + string.unicodeScalars.filter({ !$0.isASCII }), range)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprl8xo8x9.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmprl8xo8x9.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmprl8xo8x9.swift:13:12: error:\
    \ cannot find 'count' in scope\n    return count(string.unicodeScalars.filter({\
    \ $0.isASCII }) + string.unicodeScalars.filter({ !$0.isASCII }), range)\n    \
    \       ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += k\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpficcwbjl.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpficcwbjl.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpficcwbjl.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpficcwbjl.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j && k < string.characters.count {\n        if string.characters[i]\
    \ == substring.characters[k] {\n            count += 1\n            i += 1\n \
    \           k += 1\n        }\n        if string.characters[i] == substring.characters[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string.characters[i]\
    \ == substring.characters[k] {\n            i += 1\n            k += 1\n     \
    \   }\n        if string.characters[i] == substring.characters[k] {\n        \
    \    i += 1\n            k += 1\n        }\n        if string.characters[i] ==\
    \ substring.characters[k] {\n            i += 1\n            k += 1\n        }\n\
    \        if string.characters[i] == substring.characters[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string.characters[i] == substring.characters[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string.characters[i]\
    \ == substring.characters[k] {\n            i += 1\n            k += 1\n     \
    \   }\n        if string.characters[i] == substring.characters[k] {\n        \
    \    i += 1\n            k += 1\n        }\n        if string.characters[i] ==\
    \ substring.characters[k] {\n            i += 1\n            k += 1\n        }\n\
    \        if string.characters[i] == substring.characters[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string.characters[i] == substring.characters[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string.characters[i]\
    \ == substring.characters[k] {\n            i += 1\n            k += 1\n     \
    \   }\n        if string.characters[i] == substring.characters[k] {\n        \
    \    i += 1\n            k += 1\n        }\n        if string.characters[i] ==\
    \ substring.characters[k] {\n            i += 1\n            k += 1\n        }\n\
    \        if string.characters[i] == substring.characters[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string.characters[i] == substring.characters[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string.characters[i]\
    \ == substring.characters[k] {\n            i += 1\n            k += 1\n     \
    \   }\n        if string.characters[i] == substring.characters[k] {\n        \
    \    i += 1\n            k += 1\n        }\n        if string.characters[i] ==\
    \ substring.characters[k] {\n            i += 1\n            k += 1\n        }\n\
    \        if string.characters[i] == substring.characters[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string.characters[i] == substring.characters[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string.characters[i]\
    \ == substring.characters[k] {\n            i += 1\n            k += 1\n     \
    \   }\n        if string.characters[i] == \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8t06so1c.swift:112:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp8t06so1c.swift:130:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp8t06so1c.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmp8t06so1c.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8t06so1c.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8t06so1c.swift:17:31: error: 'characters'\
    \ is unavailable: Please use String directly\n    while i < j && k < string.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8t06so1c.swift:18:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8t06so1c.swift:18:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n           "
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    if\
    \ string.hasPrefix(substring) || string.hasSuffix(substring) {\n        return\
    \ how_many_times(string.dropFirst(substring.length), substring) + how_many_times(string.dropLast(substring.length),\
    \ substring)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuox4r_2z.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpuox4r_2z.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpuox4r_2z.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpuox4r_2z.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpuox4r_2z.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:23:30: error: missing argument labels 'string:substring:'\
    \ in call\n        return how_many_times(string.dropFirst(substring.length), substring)\
    \ + how_many_times(string.dropLast(substring.length), substring)\n           \
    \                  ^\n                              string:                  \
    \           substring: \n/tmp/tmpuo"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy5d55zja.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: error: no exact\
    \ matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmpy5d55zja.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph5xy48d5.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmph5xy48d5.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmph5xy48d5.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmph5xy48d5.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advanced(by: substring.startIndex)\n    let end = string.endIndex.advanced(by:\
    \ substring.startIndex.successor())\n    let count = string.distance(from: start,\
    \ to: end)\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmjc8wwg_.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advanced'\n    let start = string.startIndex.advanced(by: substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpmjc8wwg_.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advanced'\n    let end = string.endIndex.advanced(by:\
    \ substring.startIndex.successor())\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n\
    /tmp/tmpmjc8wwg_.swift:11:65: error: value of type 'String.Index' has no member\
    \ 'successor'\n    let end = string.endIndex.advanced(by: substring.startIndex.successor())\n\
    \                                           ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var last = 0\n    var last2 = 0\n    var last3 = 0\n    var last4 = 0\n  \
    \  var last5 = 0\n    var last6 = 0\n    var last7 = 0\n    var last8 = 0\n  \
    \  var last9 = 0\n    var last10 = 0\n    var last11 = 0\n    var last12 = 0\n\
    \    var last13 = 0\n    var last14 = 0\n    var last15 = 0\n    var last16 =\
    \ 0\n    var last17 = 0\n    var last18 = 0\n    var last19 = 0\n    var last20\
    \ = 0\n    var last21 = 0\n    var last22 = 0\n    var last23 = 0\n    var last24\
    \ = 0\n    var last25 = 0\n    var last26 = 0\n    var last27 = 0\n    var last28\
    \ = 0\n    var last29 = 0\n    var last30 = 0\n    var last31 = 0\n    var last32\
    \ = 0\n    var last33 = 0\n    var last34 = 0\n    var last35 = 0\n    var last36\
    \ = 0\n    var last37 = 0\n    var last38 = 0\n    var last39 = 0\n    var last40\
    \ = 0\n    var last41 = 0\n    var last42 = 0\n    var last43 = 0\n    var last44\
    \ = 0\n    var last45 = 0\n    var last46 = 0\n    var last47 = 0\n    var last48\
    \ = 0\n    var last49 = 0\n    var last50 = 0\n    var last51 = 0\n    var last52\
    \ = 0\n    var last53 = 0\n    var last54 = 0\n    var last55 = 0\n    var last56\
    \ = 0\n    var last57 = 0\n    var last58 = 0\n    var last59 = 0\n    var last60\
    \ = 0\n    var last61 = 0\n    var last62 = 0\n    var last63 = 0\n    var last64\
    \ = 0\n    var last65 = 0\n    var last66 = 0\n    var last67 = 0\n    var last68\
    \ = 0\n    var last69 = 0\n    var last70 = 0\n    var last71 = 0\n    var last72\
    \ = 0\n    var last73 = 0\n    var last74 = 0\n    var last75 = 0\n    var last76\
    \ = 0\n    var last77 = 0\n    var last78 = 0\n    var last79 = 0\n    var last80\
    \ = 0\n    var last81 = 0\n    var last82 = 0\n    var last83 = 0\n    var last84\
    \ = 0\n    var last85 = 0\n    var last86 = 0\n    var last87 = 0\n    var last88\
    \ = 0\n    var last89 = 0\n    var last90 = 0\n    var last91 = 0\n    var last92\
    \ = 0\n    var last93 = 0\n    var last94 = 0\n    var last95 = 0\n    var last96\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmrwg5nm_.swift:115:9: error: type annotation missing in pattern\n\
    \    var last96\n        ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  let index = string.index(start, offsetBy: substring.count)\n        if index\
    \ == nil {\n            break\n        }\n        start = index!\n        count\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf9li5dtg.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        if index == string.endIndex {\n            break\n\
    \        }\n        let substringIndex = string.index(index, offsetBy: substring.count)\n\
    \        if substringIndex == string.endIndex {\n            break\n        }\n\
    \        if substringIndex < index {\n            count += 1\n            start\
    \ = substringIndex\n        } else {\n            start = index\n        }\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbf0cz6kp.swift:30:21: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            start = substringIndex\n                    ^~~~~~~~~~~~~~\n\
    /tmp/tmpbf0cz6kp.swift:32:21: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            start = index\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i = j\n            j = string.startIndex\n \
    \       } else {\n            j += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1qroo4hy.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp1qroo4hy.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp1qroo4hy.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp1qroo4hy.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp1qroo4hy.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1qroo4hy.swift:22:17:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  i = j\n                ^\n/tmp/tmp1qroo4hy.swift:25:15: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \      j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[j] != substring[i] {\n   \
    \         count += 1\n            i = string.startIndex\n        } else {\n  \
    \          i += 1\n        }\n        j += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps33yvtd7.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmps33yvtd7.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmps33yvtd7.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmps33yvtd7.swift:20:25: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[j] != substring[i]\
    \ {\n                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmps33yvtd7.swift:22:24: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            i = string.startIndex\n\
    \                ~~~~~~~^~~~~~~~~~\n/tmp/tmps33yvtd7.swift:26:11: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n\
    \        j += 1\n        ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    return countOccurrences(string, substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9xcm4qkd.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp9xcm4qkd.swift:16:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3al3aj8p.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp3al3aj8p.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp3al3aj8p.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp3al3aj8p.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            return count\n        }\n        start\
    \ = index!.advanced(by: substring.count)\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpestcpcea.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string.characters.contains(substring.characters.suffix(from:\
    \ i)) {\n            count += 1\n            i += substring.characters.count -\
    \ 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyz8tvmj5.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpyz8tvmj5.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpyz8tvmj5.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpyz8tvmj5.swift:20:73: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n        if string.characters.contains(substring.characters.suffix(from:\
    \ i)) {\n                                                                    \
    \    ^\n/tmp/tmpyz8tvmj5.swift:22:28: error: 'characters' is unavailable: Please\
    \ use String directly\n            i += substring.characters.count - 1\n     \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j && k < string.characters.count {\n        if string.characters[i]\
    \ == substring.characters[k] {\n            count += 1\n            i += 1\n \
    \           k += 1\n        } else if string.characters[i] < substring.characters[k]\
    \ {\n            i += 1\n        } else {\n            k += 1\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvhwy20my.swift:12:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpvhwy20my.swift:13:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvhwy20my.swift:14:31: error: 'characters'\
    \ is unavailable: Please use String directly\n    while i < j && k < string.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvhwy20my.swift:15:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvhwy20my.swift:15:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvhwy20my.swift:15:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvhwy20my.swift:15:46: error: 'characters'\
    \ is unavailable: Ple"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return string.countSubstrings(substring)\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppec4qd_l.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppec4qd_l.swift:13:19: error: value of\
    \ type 'String' has no member 'countSubstrings'\n    return string.countSubstrings(substring)\
    \ + 1\n           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsl3pwsck.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpsl3pwsck.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpsl3pwsck.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpsl3pwsck.swift:23:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' ="
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex += 1\n        } else {\n            count += endIndex -\
    \ startIndex\n            startIndex = endIndex + 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9x8mcjip.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmp9x8mcjip.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmp9x8mcjip.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, options: .caseInsensitive)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n        end -= (index!.distance(from: string.startIndex))\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_aeu9ig5.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_aeu9ig5.swift:17:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp_aeu9ig5.swift:17:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmp_aeu9ig5.swift:17:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).contains(substring) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm4mun4rb.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpm4mun4rb.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_occurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0mthzj1n.swift:10:12: error: cannot find 'count_occurrences' in\
    \ scope\n    return count_occurrences(string, substring)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += 1\n        \
    \    if k == substring.count {\n                j -= 1\n                k = 0\n\
    \            }\n        } else {\n            i += 1\n            k += 1\n   \
    \         if k == substring.count {\n                j -= 1\n                k\
    \ = 0\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpieogfval.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpieogfval.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpieogfval.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpieogfval.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.characters.count\n\
    \    while start < end {\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        if index == string.endIndex {\n            break\n\
    \        }\n        let index2 = string.index(index, offsetBy: substring.characters.count)\n\
    \        if index2 == string.endIndex {\n            break\n        }\n      \
    \  if string.substring(with: index2) == substring {\n            count += 1\n\
    \        }\n        start = index2 + 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkwt_kwq_.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpkwt_kwq_.swift:24:62:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ index2 = string.index(index, offsetBy: substring.characters.count)\n       \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkwt_kwq_.swift:28:19: error: value of\
    \ type 'String' has no member 'substring'\n        if string.substring(with: index2)\
    \ == substring {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpkwt_kwq_.swift:31:17: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \        start = index2 + 1\n                ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.startIndex.advanced(by: start)\n\
    \        end = string.endIndex.advanced(by: end)\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpphasco40.swift:20:35: error: value of type 'String.Index' has no\
    \ member 'advanced'\n        start = string.startIndex.advanced(by: start)\n \
    \               ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpphasco40.swift:21:31: error:\
    \ value of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ end)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpphasco40.swift:22:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpphasco40.swift:22:60: error: value of type 'String' has no member 'length'\n\
    \        if string.substring(from: start, length: substring.length) == substring\
    \ {\n                                                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfh8y13ri.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppuhv0jy_.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppuhv0jy_.swift:14:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += count(substring)\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmxtdtck2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpmxtdtck2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpmxtdtck2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpmxtdtck2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmxtdtck2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    var k = string.endIndex\n    while i < k {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += 1\n            while i < k {\n \
    \               if string[i] == substring[1] {\n                    count += 1\n\
    \                    i += 1\n                } else {\n                    break\n\
    \                }\n            }\n        } else {\n            i += 1\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8lysynu9.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8lysynu9.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8lysynu9.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < k {\n            ^\nSwift.BinaryInteger:4:24: note: where 'Other'\
    \ = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other) ->\
    \ Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp8lysynu9.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp8lysynu9.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8lysynu9.swift:24:21:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            while i < k {\n                    ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp8lysynu9.swift:25:20: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n                if string[i]\
    \ == substring[1] {\n                   ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8lysynu9.swift:25:33: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with a"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i = j\n            j = string.startIndex\n \
    \       } else {\n            j += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1qroo4hy.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp1qroo4hy.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp1qroo4hy.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp1qroo4hy.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp1qroo4hy.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1qroo4hy.swift:22:17:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  i = j\n                ^\n/tmp/tmp1qroo4hy.swift:25:15: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \      j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += 1\n        \
    \    if k == substring.count {\n                j -= 1\n                k = 0\n\
    \            }\n        } else {\n            i += 1\n            k += 1\n   \
    \         if k == substring.count {\n                j -= 1\n                k\
    \ = 0\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpieogfval.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpieogfval.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpieogfval.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpieogfval.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = string.index(substring, startIndex) + 1\n        } else\
    \ {\n            count += endIndex - startIndex\n            startIndex = endIndex\
    \ + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvk1_fli8.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpvk1_fli8.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpvk1_fli8.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvk1_fli8.swift:23:33: error: no exact matches in call to instance method\
    \ 'index'\n            startIndex = string.index(substring, startIndex) + 1\n\
    \                                ^\n/tmp/tmpvk1_fli8.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n/tmp/tmpvk1_fli8.swift:23:33: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpvk1_fli8.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpvk1_fli8.swift:23:33:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            startIndex = string.index(substring, startIndex) + 1\n  \
    \                              ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  let index = string.index(start, offsetBy: substring.count)\n        if index\
    \ == nil {\n            break\n        }\n        start = index!\n        count\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf9li5dtg.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else {\n            i += 1\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp53tha8d4.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp53tha8d4.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp53tha8d4.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = string.count\n    var m = substring.count\n    while i < l {\n   \
    \     if string[i] == substring[j] {\n            count += 1\n            i +=\
    \ k\n            j += m\n            k = 0\n        }\n        if string[i] ==\
    \ substring[k] {\n            count += 1\n            i += m\n            k +=\
    \ m\n            m = 0\n        }\n        if string[i] == substring[j] {\n  \
    \          count += 1\n            i += k\n            j += m\n            k =\
    \ 0\n        }\n        if string[i] == substring[k] {\n            count += 1\n\
    \            i += m\n            k += m\n            m = 0\n        }\n      \
    \  if string[i] == substring[j] {\n            count += 1\n            i += k\n\
    \            j += m\n            k = 0\n        }\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += m\n            k += m\n        \
    \    m = 0\n        }\n        if string[i] == substring[j] {\n            count\
    \ += 1\n            i += k\n            j += m\n            k = 0\n        }\n\
    \        if string[i] == substring[k] {\n            count += 1\n            i\
    \ += m\n            k += m\n            m = 0\n        }\n        if string[i]\
    \ == substring[j] {\n            count += 1\n            i += k\n            j\
    \ += m\n            k = 0\n        }\n        if string[i] == substring[k] {\n\
    \            count += 1\n            i += m\n            k += m\n            m\
    \ = 0\n        }\n        if string[i] == substring[j] {\n            count +=\
    \ 1\n            i += k\n            j += m\n            k = 0\n        }\n  \
    \      if string[i] == substring[k] {\n            count += 1\n            i +=\
    \ m\n            k += m\n            m = 0\n        }\n        if string[i] ==\
    \ substring[j] {\n            count += 1\n            i += k\n            j +=\
    \ m\n            k = 0\n        }\n        if string[i] == substring[k] {\n  \
    \          count += 1\n            i += m\n            k += m\n            m =\
    \ 0\n        }\n        if string[i] == substring[j] {\n            count += 1\n\
    \            i += k\n            j += m\n            k = 0\n        }\n      \
    \  if string[i] == substring[k] {\n            count += 1\n            i += m\n\
    \            k += m\n            m = 0\n        }\n        if string[i] == substring[j]\
    \ {\n            count += 1\n            i += k\n            j += m\n        \
    \    k = 0\n        }\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += m\n            k += m\n            m = 0\n        }\n\
    \        if string[i] == substring[j] {\n            count += 1\n            i\
    \ += k\n            j += m\n            k = 0\n        }\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += m\n            \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi1ho3tes.swift:159:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpi1ho3tes.swift:22:17:\
    \ note: to match this opening '{'\n    while i < l {\n                ^\n/tmp/tmpi1ho3tes.swift:159:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpi1ho3tes.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpi1ho3tes.swift:23:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[j] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpi1ho3tes.swift:23:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi1ho3tes.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpi1ho3tes.swift:29:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i = string.startIndex\n            j = string.startIndex\n\
    \        } else {\n            j += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp39twptbp.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp39twptbp.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp39twptbp.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp39twptbp.swift:22:24: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            i = string.startIndex\n  \
    \              ~~~~~~~^~~~~~~~~~\n/tmp/tmp39twptbp.swift:25:15: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n\
    \            j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.count(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9khowagm.swift:10:19: error: cannot call value of non-function\
    \ type 'Int'\n    return string.count(substring)\n                  ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    for ; i < len(string);\
    \ i++ {\n        if string[i] == substring[0] {\n            count++\n       \
    \     for ; j < len(substring); j++ {\n                if string[i+j] != substring[j]\
    \ {\n                    break\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgw729ay8.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; i < len(string); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgw729ay8.swift:22:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for ; j < len(substring); j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string.characters[i] == substring.characters[k]\
    \ {\n            count += 1\n            i += 1\n            k += 1\n        \
    \    if k == substring.characters.count {\n                k = 0\n           \
    \ }\n        } else {\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzclzsasg.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzclzsasg.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzclzsasg.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzclzsasg.swift:18:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzclzsasg.swift:18:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzclzsasg.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzclzsasg.swift:22:31:\
    \ error: 'char"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = string.characters.count\n    var m = substring.characters.count\n\
    \    while i < l {\n        if string[i] == substring[j] {\n            count\
    \ += 1\n            i += 1\n            j += 1\n            if j == m {\n    \
    \            j = 0\n                k += 1\n            }\n        } else {\n\
    \            i = 0\n            j += 1\n            if j == m {\n            \
    \    j = 0\n                k += 1\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc0_cg6vr.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var l = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpc0_cg6vr.swift:21:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var m =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpc0_cg6vr.swift:23:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc0_cg6vr.swift:23:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpc0_cg6vr.swift:20:9: warning: variable 'l' was\
    \ never mutated; consider changing to 'let' constant\n    var l = string.characters.count\n\
    \    ~~~ ^\n    let\n/tmp/tmpc0_cg6vr.swift:21:9: warning: variable 'm' was never\
    \ mutated; consider changing to 'let' constant\n    var m = substring.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count += 1\n        }\n        i += 1\n     \
    \   k += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm2v4erds.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpm2v4erds.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpm2v4erds.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm2v4erds.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpm2v4erds.swift:18:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    while i < j {\n       \
    \ if string.characters[i] != substring.characters[i] {\n            count += 1\n\
    \        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1o6iu2bo.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp1o6iu2bo.swift:17:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string.characters[i] != substring.characters[i]\
    \ {\n           ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp1o6iu2bo.swift:17:19: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[i] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp1o6iu2bo.swift:17:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[i] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp1o6iu2bo.swift:17:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[i] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1o6iu2bo.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.characters.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ = count + 1\n        }\n        i = i + 1\n        k = k - 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplz5rlgst.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmplz5rlgst.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmplz5rlgst.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplz5rlgst.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplz5rlgst.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    var substringIndex = string.startIndex.distance(stringIndex, substringIndex)\n\
    \    while substringIndex < end {\n        if string[substringIndex] == substring[0]\
    \ {\n            count += 1\n            substringIndex += 1\n            start\
    \ = substringIndex\n            substringIndex = string.startIndex.distance(stringIndex,\
    \ substringIndex)\n        } else {\n            substringIndex += 1\n       \
    \ }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3nip0myx.swift:19:53: error: cannot find 'stringIndex' in scope\n\
    \    var substringIndex = string.startIndex.distance(stringIndex, substringIndex)\n\
    \                                                    ^~~~~~~~~~~\n/tmp/tmp3nip0myx.swift:19:66:\
    \ error: use of local variable 'substringIndex' before its declaration\n    var\
    \ substringIndex = string.startIndex.distance(stringIndex, substringIndex)\n \
    \                                                                ^\n/tmp/tmp3nip0myx.swift:19:9:\
    \ note: 'substringIndex' declared here\n    var substringIndex = string.startIndex.distance(stringIndex,\
    \ substringIndex)\n        ^\n/tmp/tmp3nip0myx.swift:19:44: error: value of type\
    \ 'String.Index' has no member 'distance'\n    var substringIndex = string.startIndex.distance(stringIndex,\
    \ substringIndex)\n                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp3nip0myx.swift:25:57:\
    \ error: cannot find 'stringIndex' in scope\n            substringIndex = string.startIndex.distance(stringIndex,\
    \ substringIndex)\n                                                        ^~~~~~~~~~~\n\
    /tmp/tmp3nip0myx.swift:25:48: error: value of type 'String.Index' has no member\
    \ 'distance'\n            substringIndex = string.startIndex.distance(stringIndex,\
    \ substringIndex)\n                             ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n            if k == substring.characters.count {\n                k =\
    \ 0\n            }\n        } else {\n            i += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobfpykl3.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpobfpykl3.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpobfpykl3.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpobfpykl3.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpobfpykl3.swift:25:31: error: 'characters' is\
    \ unavailable: Please use String directly\n            if k == substring.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpobfpykl3.swift:18:9: warning: variable 'j' was never\
    \ mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.rangeOfString(substring) == nil {\n        return 0\n\
    \    }\n    var count = 0\n    var start = 0\n    var end = string.count\n   \
    \ while start < end {\n        start = string.rangeOfString(substring, options:\
    \ .BackwardsSearch, range: NSMakeRange(start, substring.length)).location\n  \
    \      end = string.rangeOfString(substring, options: .BackwardsSearch, range:\
    \ NSMakeRange(start + substring.length, substring.length)).location\n        if\
    \ start == end {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkfq2pwv6.swift:16:15: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if string.rangeOfString(substring) == nil {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:23:83: error: cannot find 'NSMakeRange'\
    \ in scope\n        start = string.rangeOfString(substring, options: .BackwardsSearch,\
    \ range: NSMakeRange(start, substring.length)).location\n                    \
    \                                                              ^~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:23:24:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        start =\
    \ string.rangeOfString(substring, options: .BackwardsSearch, range: NSMakeRange(start,\
    \ substring.length)).location\n                ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:23:59:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \        start = string.rangeOfString(substring, options: .BackwardsSearch, range:\
    \ NSMakeRange(start, substring.length)).location\n                           \
    \                              ~^~~~~~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:23:112:\
    \ error: value of type 'String' has no member 'length'\n        start = string.rangeOfString(substring,\
    \ options: .BackwardsSearch, range: NSMakeRange(start, substring.length)).location\n\
    \                                                                            \
    \                         ~~~~~~~~~ ^~~~~~\n/tmp/tmpkfq2pwv6.swift:24:81: error:\
    \ cannot find 'NSMakeRange' in scope\n        end = string.rangeOfString(substring,\
    \ options: .BackwardsSearch, range: NSMakeRange(start + substring.length, substring.length)).location\n\
    \                                                                            \
    \    ^~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:24:22: error: value of type 'String'\
    \ has no member 'rangeOfString'\n        end = string.rangeOfString(substring,\
    \ options: .BackwardsSearch, range: NSMakeRange(start + substring.length, substring.length)).location\n\
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkfq2pwv6.swift:24:111: error: value\
    \ of type 'String' has no member 'length'\n        end = string.rang"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8k_gcm8.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpm8k_gcm8.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    for ; i < len(string);\
    \ i++ {\n        if string[i] == substring[j] {\n            count++\n       \
    \     j++\n            if j == len(substring) {\n                j = 0\n     \
    \       }\n        } else {\n            j = 0\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpaes2t_gb.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; i < len(string); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            j = i\n            while\
    \ i < string.endIndex && string[i] == substring[1] {\n                i += 1\n\
    \            }\n            if i == string.endIndex {\n                count +=\
    \ 1\n                j = i\n            }\n        } else {\n            j +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7hxir0h8.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp7hxir0h8.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7hxir0h8.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp7hxir0h8.swift:23:17: error: cannot assign value\
    \ of type 'Int' to type 'String.Index'\n            j = i\n                ^\n\
    /tmp/tmp7hxir0h8.swift:24:21: error: operator function '<' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n            while i < string.endIndex && string[i]\
    \ == substring[1] {\n                    ^\nSwift.BinaryInteger:4:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp7hxir0h8.swift:27:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if i == string.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmp7hxir0h8.swift:29:21: error: cannot assign value of type 'Int'\
    \ to type 'String.Index'\n                j = i\n                    ^"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppuhv0jy_.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppuhv0jy_.swift:14:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy5d55zja.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: error: no exact\
    \ matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmpy5d55zja.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var index = string.startIndex\n    while index != string.endIndex {\n\
    \        index = string.index(substring, startIndex: index)\n        if index\
    \ != string.endIndex {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7vl01ifg.swift:13:29: error: incorrect argument label in call (have\
    \ '_:startIndex:', expected '_:offsetBy:')\n        index = string.index(substring,\
    \ startIndex: index)\n                            ^           ~~~~~~~~~~\n   \
    \                                     offsetBy\n/tmp/tmp7vl01ifg.swift:13:30:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \        index = string.index(substring, startIndex: index)\n                \
    \             ^\n/tmp/tmp7vl01ifg.swift:13:17: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n        index = string.index(substring,\
    \ startIndex: index)\n                ^\nSwift.Collection:3:17: note: where 'T'\
    \ = 'String.Index'\n    public func index<T>(_ i: Self.Index, offsetBy n: T) ->\
    \ Self.Index where T : BinaryInteger\n                ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = string.startIndex\n\
    \    while i < string.endIndex {\n        if k == string.startIndex {\n      \
    \      j = string.startIndex\n        } else {\n            j = k\n        }\n\
    \        if string.substringWithRange(k) == substring {\n            count +=\
    \ 1\n        }\n        k = j\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5jk1n2m7.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp5jk1n2m7.swift:22:24: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n            j = string.startIndex\n\
    \                ~~~~~~~^~~~~~~~~~\n/tmp/tmp5jk1n2m7.swift:24:17: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            j = k\n     \
    \           ^\n/tmp/tmp5jk1n2m7.swift:26:19: error: value of type 'String' has\
    \ no member 'substringWithRange'\n        if string.substringWithRange(k) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp5jk1n2m7.swift:29:13: error:\
    \ cannot assign value of type 'Int' to type 'String.Index'\n        k = j\n  \
    \          ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.characters.count\n    while i < j {\n        if string.characters[i]\
    \ == substring.characters[0] {\n            count += countOccurrences(string.substringFromIndex(i\
    \ + 1), substring)\n            i += 1\n        } else if string.characters[i]\
    \ == substring.characters[1] {\n            count += countOccurrences(string.substringFromIndex(i),\
    \ substring)\n            i += 1\n        } else {\n            i += 1\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpca66z7y_.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpca66z7y_.swift:18:20: error: 'characters' is unavailable: Please use String\
    \ directly\n    var j = string.characters.count\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpca66z7y_.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string.characters[i] == substring.characters[0]\
    \ {\n           ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpca66z7y_.swift:20:19: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpca66z7y_.swift:20:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[0] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpca66z7y_.swift:20:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[0] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpca66z7y_.swift:21:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(string.substringFromIndex(i\
    \ + 1), substring)\n                     ^"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp16n0_oq4.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp16n0_oq4.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp16n0_oq4.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var last = 0\n    var last2 = 0\n    var last3 = 0\n    var last4\
    \ = 0\n    var last5 = 0\n    var last6 = 0\n    var last7 = 0\n    var last8\
    \ = 0\n    var last9 = 0\n    var last10 = 0\n    var last11 = 0\n    var last12\
    \ = 0\n    var last13 = 0\n    var last14 = 0\n    var last15 = 0\n    var last16\
    \ = 0\n    var last17 = 0\n    var last18 = 0\n    var last19 = 0\n    var last20\
    \ = 0\n    var last21 = 0\n    var last22 = 0\n    var last23 = 0\n    var last24\
    \ = 0\n    var last25 = 0\n    var last26 = 0\n    var last27 = 0\n    var last28\
    \ = 0\n    var last29 = 0\n    var last30 = 0\n    var last31 = 0\n    var last32\
    \ = 0\n    var last33 = 0\n    var last34 = 0\n    var last35 = 0\n    var last36\
    \ = 0\n    var last37 = 0\n    var last38 = 0\n    var last39 = 0\n    var last40\
    \ = 0\n    var last41 = 0\n    var last42 = 0\n    var last43 = 0\n    var last44\
    \ = 0\n    var last45 = 0\n    var last46 = 0\n    var last47 = 0\n    var last48\
    \ = 0\n    var last49 = 0\n    var last50 = 0\n    var last51 = 0\n    var last52\
    \ = 0\n    var last53 = 0\n    var last54 = 0\n    var last55 = 0\n    var last56\
    \ = 0\n    var last57 = 0\n    var last58 = 0\n    var last59 = 0\n    var last60\
    \ = 0\n    var last61 = 0\n    var last62 = 0\n    var last63 = 0\n    var last64\
    \ = 0\n    var last65 = 0\n    var last66 = 0\n    var last67 = 0\n    var last68\
    \ = 0\n    var last69 = 0\n    var last70 = 0\n    var last71 = 0\n    var last72\
    \ = 0\n    var last73 = 0\n    var last74 = 0\n    var last75 = 0\n    var last76\
    \ = 0\n    var last77 = 0\n    var last78 = 0\n    var last79 = 0\n    var last80\
    \ = 0\n    var last81 = 0\n    var last82 = 0\n    var last83 = 0\n    var last84\
    \ = 0\n    var last85 = 0\n    var last86 = 0\n    var last87 = 0\n    var last88\
    \ = 0\n    var last89 = 0\n    var last90 = 0\n    var last91 = 0\n    var last92\
    \ = 0\n    var last93 = 0\n    var last94 = 0\n    var last95 = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcc__a50k.swift:115:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpcc__a50k.swift:16:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpcc__a50k.swift:17:9: warning:\
    \ initialization of variable 'i' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmpcc__a50k.swift:18:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpcc__a50k.swift:19:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpcc__a50k.swift:20:9:\
    \ warning: initialization of variable 'last' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var last = 0\n    ~~~~^~~~\n    _\n\
    /tmp/tmpcc__a50k.swift:21:9: warning: initialization of variable 'last2' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var last2\
    \ = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpcc__a50k.swift:22:9: warning: initialization\
    \ of variable 'last3' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var last3 = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpcc__a50k.swift:23:9:\
    \ warning: initialization of variable 'last4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var last4 = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmpcc__a50k.swift:24:9: warning: initialization of variable 'last5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var last5 = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpcc__a50k.swift:25:9: warning:\
    \ initialization of variable 'last6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var last6 = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpcc__a50k.swift:26:9:\
    \ warning: initialization of variable 'last7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var last7 = 0\n    ~~~~^~~"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n  \
    \  var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n   \
    \ var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var\
    \ aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n   \
    \ var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n\
    \    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao =\
    \ 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at\
    \ = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var\
    \ ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n   \
    \ var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n\
    \    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm =\
    \ 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br\
    \ = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var\
    \ bw = 0\n    var bx = 0\n    var by = 0\n    var bz = 0\n    var ca = 0\n   \
    \ var cb = 0\n    var cc = 0\n    var cd = 0\n    var ce = 0\n    var cf = 0\n\
    \    var cg = 0\n    var ch = 0\n    var ci = 0\n    var cj = 0\n    var ck =\
    \ 0\n    var cl = 0\n    var cm = 0\n    var cn = 0\n    var co = 0\n    var cp\
    \ = 0\n    var cq = 0\n    var cr = 0\n    var cs = 0\n    var ct = 0\n    var\
    \ cu = 0\n    var cv = 0\n    var cw = 0\n    var cx = 0\n    var cy = 0\n   \
    \ var cz = 0\n    var da = 0\n    var db = 0\n    var dc = 0\n    var dd = 0\n\
    \    var de = 0\n    var df = 0\n    var dg = 0\n    var dh = 0\n    var di =\
    \ 0\n    var dj = 0\n    var dk = 0\n    var dl = 0\n    var dm = 0\n    var dn\
    \ = 0\n    var do = 0\n    var dp = 0\n    var dq = 0\n    var dr = 0\n    var\
    \ ds = 0\n    var dt = 0\n    var du = 0\n    var dv = 0\n    var dw = 0\n   \
    \ var dx = 0\n    var dy = 0\n    var dz\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd1iv0lei.swift:53:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpd1iv0lei.swift:53:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpd1iv0lei.swift:127:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpd1iv0lei.swift:127:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpd1iv0lei.swift:138:9: error: type annotation\
    \ missing in pattern\n    var dz\n        ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i = j\n            j = string.startIndex\n \
    \       } else {\n            j += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1qroo4hy.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp1qroo4hy.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp1qroo4hy.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp1qroo4hy.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp1qroo4hy.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1qroo4hy.swift:22:17:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  i = j\n                ^\n/tmp/tmp1qroo4hy.swift:25:15: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \      j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\", true)\n    }\n    var count = 0\n    var i =\
    \ 0\n    var j = string.count\n    var k = substring.count\n    while i < j {\n\
    \        if string[i] == substring[k] {\n            count += 1\n            i\
    \ += k\n            k -= 1\n        }\n        i += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj_qllezf.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\", true)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpj_qllezf.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpj_qllezf.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string.characters[i] == substring.characters[0]\
    \ {\n            count += 1\n            i += 1\n        } else if string.characters[i]\
    \ == substring.characters[1] {\n            count += 1\n            i += 1\n \
    \           j += 1\n        } else if string.characters[i] == substring.characters[2]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        \
    \    i += 1\n        } else if string.characters[i] == substring.characters[3]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        \
    \    i += 1\n            j += 1\n        } else if string.characters[i] == substring.characters[4]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        \
    \    i += 1\n            j += 1\n            i += 1\n            j += 1\n    \
    \    } else if string.characters[i] == substring.characters[5] {\n           \
    \ count += 1\n            i += 1\n            j += 1\n            i += 1\n   \
    \         j += 1\n            i += 1\n            j += 1\n            i += 1\n\
    \            j += 1\n        } else if string.characters[i] == substring.characters[6]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        \
    \    i += 1\n            j += 1\n            i += 1\n            j += 1\n    \
    \        i += 1\n            j += 1\n            i += 1\n            j += 1\n\
    \            i += 1\n            j += 1\n        } else if string.characters[i]\
    \ == substring.characters[7] {\n            count += 1\n            i += 1\n \
    \           j += 1\n            i += 1\n            j += 1\n            i += 1\n\
    \            j += 1\n            i += 1\n            j += 1\n            i +=\
    \ 1\n            j += 1\n            i += 1\n            j += 1\n            i\
    \ += 1\n            j += 1\n            i += 1\n            j += 1\n         \
    \   i += 1\n            j += 1\n            i += 1\n            j += 1\n     \
    \       i += 1\n            j += 1\n            i += 1\n            j += 1\n \
    \           i += 1\n            j += 1\n            i += 1\n            j += 1\n\
    \            i += 1\n            j += 1\n            i += 1\n            j +=\
    \ 1\n            i += 1\n            j += 1\n            i += 1\n            j\
    \ += 1\n            i += 1\n            j += 1\n            i += 1\n         \
    \   j += 1\n            i += 1\n            j += 1\n            i += 1\n     \
    \       j += 1\n            i += 1\n            j += 1\n            i += 1\n \
    \           j += 1\n            i += 1\n            j += 1\n            i += 1\n\
    \            j += 1\n            i += 1\n            j += 1\n            i +=\
    \ 1\n            j += 1\n            i += 1\n            j += 1\n            i\
    \ += 1\n            j += 1\n            i += 1\n            j += 1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplufe0ti9.swift:152:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmplufe0ti9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmplufe0ti9.swift:152:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmplufe0ti9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmplufe0ti9.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmplufe0ti9.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmplufe0ti9.swift:18:20: error:\
    \ 'characters' is unavailable: Please use String directly\n    var j = string.characters.count\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplufe0ti9.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[i]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplufe0ti9.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmplufe0ti9.swift:20:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        i"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    for ; i < len(string);\
    \ i++ {\n        if string[i] == substring[0] {\n            count++\n       \
    \     for ; j < len(substring); j++ {\n                if string[i+j] != substring[j]\
    \ {\n                    break\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgw729ay8.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; i < len(string); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgw729ay8.swift:22:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for ; j < len(substring); j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n  \
    \  var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n   \
    \ var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var\
    \ aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n   \
    \ var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n\
    \    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao =\
    \ 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at\
    \ = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var\
    \ ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n   \
    \ var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n\
    \    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm =\
    \ 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br\
    \ = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var\
    \ bw = 0\n    var bx = 0\n    var by = 0\n    var bz = 0\n    var ca = 0\n   \
    \ var cb = 0\n    var cc = 0\n    var cd = 0\n    var ce = 0\n    var cf = 0\n\
    \    var cg = 0\n    var ch = 0\n    var ci = 0\n    var cj = 0\n    var ck =\
    \ 0\n    var cl = 0\n    var cm = 0\n    var cn = 0\n    var co = 0\n    var cp\
    \ = 0\n    var cq = 0\n    var cr = 0\n    var cs = 0\n    var ct = 0\n    var\
    \ cu = 0\n    var cv = 0\n    var cw = 0\n    var cx = 0\n    var cy = 0\n   \
    \ var cz = 0\n    var da = 0\n    var db = 0\n    var dc = 0\n    var dd = 0\n\
    \    var de = 0\n    var df = 0\n    var dg = 0\n    var dh = 0\n    var di =\
    \ 0\n    var dj = 0\n    var dk = 0\n    var dl = 0\n    var dm = 0\n    var dn\
    \ = 0\n    var do = 0\n    var dp = 0\n    var dq = 0\n    var dr = 0\n    var\
    \ ds = 0\n    var dt = 0\n    var du = 0\n    var dv = 0\n    var dw = 0\n   \
    \ var dx = 0\n    var dy = 0\n    var dz\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd1iv0lei.swift:53:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpd1iv0lei.swift:53:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpd1iv0lei.swift:127:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpd1iv0lei.swift:127:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpd1iv0lei.swift:138:9: error: type annotation\
    \ missing in pattern\n    var dz\n        ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var A = 0\n    var B = 0\n    var C = 0\n    var D = 0\n    var E = 0\n \
    \   var F = 0\n    var G = 0\n    var H = 0\n    var I = 0\n    var J = 0\n  \
    \  var K = 0\n    var L = 0\n    var M = 0\n    var N = 0\n    var O = 0\n   \
    \ var P = 0\n    var Q = 0\n    var R = 0\n    var S = 0\n    var T = 0\n    var\
    \ U = 0\n    var V = 0\n    var W = 0\n    var X = 0\n    var Y = 0\n    var Z\
    \ = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e =\
    \ 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var A = 0\n    var B = 0\n    var C = 0\n    var D = 0\n    var\
    \ E = 0\n    var F = 0\n    var G = 0\n    var H = 0\n    var I = 0\n    var J\
    \ = 0\n    var K = 0\n    var L = 0\n    var M = 0\n    var N = 0\n    var O =\
    \ 0\n    var P = 0\n    var Q = 0\n    var R = 0\n    var S = 0\n    var T = 0\n\
    \    var U = 0\n    var V = 0\n    var W = 0\n    var X = 0\n    var Y = 0\n \
    \   var Z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var A = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyn9dzcg1.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpyn9dzcg1.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:69:9:\
    \ error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:17:9:\
    \ note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:70:9:\
    \ error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:18:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:71:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:19:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:72:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:20:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:73:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:21:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:74:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:22:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:75:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:23:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:76:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:24:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:77:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:25:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:78:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:26:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:79:9:\
    \ error: invalid redeclaration"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string[string.startIndex.successor()] == substring {\n    \
    \    return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n    }\n    if string[string.endIndex.predecessor()] == substring\
    \ {\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n    }\n    return how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring) + how_many_times(string[string.endIndex.predecessor()..<string.startIndex],\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe8lza0ap.swift:16:33: error: value of type 'String.Index' has no\
    \ member 'successor'\n    if string[string.startIndex.successor()] == substring\
    \ {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpe8lza0ap.swift:17:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex.successor()..<string.endIndex], substring)\n\
    \                                 ^\n                                  string:\
    \                                                  substring: \n/tmp/tmpe8lza0ap.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpe8lza0ap.swift:17:60:\
    \ error: value of type 'String.Index' has no member 'successor'\n        return\
    \ 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpe8lza0ap.swift:19:31: error: value of type 'String.Index' has no member\
    \ 'predecessor'\n    if string[string.endIndex.predecessor()] == substring {\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpe8lza0ap.swift:20:34: error:\
    \ missing argument labels 'string:substring:' in call\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                  substring: \n\
    /tmp/tmpe8lza0ap.swift:20:41: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' "
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbj8zxg0x.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpbj8zxg0x.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpbj8zxg0x.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpbj8zxg0x.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpbj8zxg0x.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpbj8zxg0x.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string.characters[i]\
    \ != substring.characters[k] {\n            count += 1\n        }\n        i +=\
    \ 1\n        k += 1\n        if k > substring.characters.count {\n           \
    \ k = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpto2v2otj.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpto2v2otj.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpto2v2otj.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpto2v2otj.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpto2v2otj.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[i]\
    \ != substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpto2v2otj.swift:21:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpto2v2otj.swift:21:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpto2v2otj.swift:21:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n     "
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for c in string.unicodeScalars {\n        if c == substring {\n     \
    \       count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjj1za6b0.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    if\
    \ string.hasPrefix(substring) || string.hasSuffix(substring) {\n        return\
    \ how_many_times(string.dropFirst(substring.length), substring) + how_many_times(string.dropLast(substring.length),\
    \ substring)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuox4r_2z.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpuox4r_2z.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpuox4r_2z.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpuox4r_2z.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpuox4r_2z.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpuox4r_2z.swift:23:30: error: missing argument labels 'string:substring:'\
    \ in call\n        return how_many_times(string.dropFirst(substring.length), substring)\
    \ + how_many_times(string.dropLast(substring.length), substring)\n           \
    \                  ^\n                              string:                  \
    \           substring: \n/tmp/tmpuo"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        if string[start] == substring[0] {\n       \
    \     count += 1\n            start += 1\n            if start == end {\n    \
    \            return count\n            }\n        }\n        if string[end] ==\
    \ substring[0] {\n            count += 1\n            end -= 1\n            if\
    \ start == end {\n                return count\n            }\n        }\n   \
    \     if string[start] == substring[1] {\n            count += 1\n           \
    \ start += 1\n            if start == end {\n                return count\n  \
    \          }\n        }\n        if string[end] == substring[1] {\n          \
    \  count += 1\n            end -= 1\n            if start == end {\n         \
    \       return count\n            }\n        }\n        if string[start] == substring[2]\
    \ {\n            count += 1\n            start += 1\n            if start == end\
    \ {\n                return count\n            }\n        }\n        if string[end]\
    \ == substring[2] {\n            count += 1\n            end -= 1\n          \
    \  if start == end {\n                return count\n            }\n        }\n\
    \        if string[start] == substring[3] {\n            count += 1\n        \
    \    start += 1\n            if start == end {\n                return count\n\
    \            }\n        }\n        if string[end] == substring[3] {\n        \
    \    count += 1\n            end -= 1\n            if start == end {\n       \
    \         return count\n            }\n        }\n        if string[start] ==\
    \ substring[4] {\n            count += 1\n            start += 1\n           \
    \ if start == end {\n                return count\n            }\n        }\n\
    \        if string[end] == substring[4] {\n            count += 1\n          \
    \  end -= 1\n            if start == end {\n                return count\n   \
    \         }\n        }\n        if string[start] == substring[5] {\n         \
    \   count += 1\n            start += 1\n            if start == end {\n      \
    \          return count\n            }\n        }\n        if string[end] == substring[5]\
    \ {\n            count += 1\n            end -= 1\n            if start == end\
    \ {\n                return count\n            }\n        }\n        if string[start]\
    \ == substring[6] {\n            count += 1\n            start += 1\n        \
    \    if start == end {\n                return count\n            }\n        }\n\
    \        if string[end] == substring[6] {\n            count += 1\n          \
    \  end -= 1\n            if start == end {\n                return count\n   \
    \         }\n        }\n        if string[start] == substring[7] {\n         \
    \   count += 1\n            start += 1\n            if start == end {\n      \
    \          return count\n            }\n        }\n        if string[end] == substring[7]\
    \ {\n            count += 1\n            end -= 1\n            if start == end\
    \ {\n                return count\n            }\n        }\n        if string[start]\
    \ == substring[8] {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpu02ok16_.swift:152:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpu02ok16_.swift:19:23:\
    \ note: to match this opening '{'\n    while start < end {\n                 \
    \     ^\n/tmp/tmpu02ok16_.swift:152:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpu02ok16_.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpu02ok16_.swift:20:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[start] == substring[0] {\n           ^~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu02ok16_.swift:20:29:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[start] == substring[0] {\n  \
    \                          ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu02ok16_.swift:27:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[end] == substring[0] {\n           ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu02ok16_.swift:27:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[end] == substring[0] {\n    \
    \                      ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ substring.count)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp42khk_fs.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var last = 0\n    for i < string.count {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            last = i\n            i += 1\n      \
    \      continue\n        }\n        if string[i] == substring[1] {\n         \
    \   count += 1\n            last = i\n            i += 1\n            continue\n\
    \        }\n        if string[i] == substring[2] {\n            count += 1\n \
    \           last = i\n            i += 1\n            continue\n        }\n  \
    \      if string[i] == substring[3] {\n            count += 1\n            last\
    \ = i\n            i += 1\n            continue\n        }\n        if string[i]\
    \ == substring[4] {\n            count += 1\n            last = i\n          \
    \  i += 1\n            continue\n        }\n        if string[i] == substring[5]\
    \ {\n            count += 1\n            last = i\n            i += 1\n      \
    \      continue\n        }\n        if string[i] == substring[6] {\n         \
    \   count += 1\n            last = i\n            i += 1\n            continue\n\
    \        }\n        if string[i] == substring[7] {\n            count += 1\n \
    \           last = i\n            i += 1\n            continue\n        }\n  \
    \      if string[i] == substring[8] {\n            count += 1\n            last\
    \ = i\n            i += 1\n            continue\n        }\n        if string[i]\
    \ == substring[9] {\n            count += 1\n            last = i\n          \
    \  i += 1\n            continue\n        }\n        if string[i] == substring[10]\
    \ {\n            count += 1\n            last = i\n            i += 1\n      \
    \      continue\n        }\n        if string[i] == substring[11] {\n        \
    \    count += 1\n            last = i\n            i += 1\n            continue\n\
    \        }\n        if string[i] == substring[12] {\n            count += 1\n\
    \            last = i\n            i += 1\n            continue\n        }\n \
    \       if string[i] == substring[13] {\n            count += 1\n            last\
    \ = i\n            i += 1\n            continue\n        }\n        if string[i]\
    \ == substring[14] {\n            count += 1\n            last = i\n         \
    \   i += 1\n            continue\n        }\n        if string[i] == substring[15]\
    \ {\n            count += 1\n            last = i\n            i += 1\n      \
    \      continue\n        }\n        if string[i] == substring[16] {\n        \
    \    count += 1\n            last = i\n            i += 1\n            continue\n\
    \        }\n        if string[i] == substring[17] {\n            count += 1\n\
    \            last = i\n            i += 1\n            continue\n        }\n \
    \       if string[i] == substring[18] {\n            count += 1\n            last\
    \ = i\n            i += 1\n            continue\n        }\n        if string[i]\
    \ == substring[19] {\n            count += 1\n            last = i\n         \
    \   i += 1\n            continue\n        }\n        if string[i] == substring[20]\
    \ {\n            count += 1\n            last = i\n            i += 1\n      \
    \      continue\n        }\n        if string[i] == substring[21] {\n        \
    \    count += 1\n            last = i\n            i += 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp46jl3cnp.swift:21:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmp46jl3cnp.swift:21:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmp46jl3cnp.swift:170:67: error: expected\
    \ '}' at end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmp46jl3cnp.swift:21:26: note: to match this opening '{'\n  \
    \  for i < string.count {\n                         ^\n/tmp/tmp46jl3cnp.swift:170:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmp46jl3cnp.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmp46jl3cnp.swift:21:11:\
    \ error: '<' is not a prefix unary operator\n    for i < string.count {\n    \
    \      ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    while i < string.count\
    \ {\n        j = string.index(substring, i)\n        if j == nil {\n         \
    \   break\n        }\n        count = count + 1\n        i = j + 1\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdckprkkh.swift:20:20: error: no exact matches in call to instance\
    \ method 'index'\n        j = string.index(substring, i)\n                   ^\n\
    /tmp/tmpdckprkkh.swift:20:20: note: found candidate with type '(String.Index,\
    \ Int) -> String.Index'\n        j = string.index(substring, i)\n            \
    \       ^\n/tmp/tmpdckprkkh.swift:20:20: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        j = string.index(substring, i)\n            ~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdckprkkh.swift:21:14: warning: comparing non-optional value of type 'Int'\
    \ to 'nil' always returns false\n        if j == nil {\n           ~ ^  ~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex).offsetBy(len(substring))\n\
    \        if endIndex == startIndex {\n            count += 1\n        } else {\n\
    \            count += endIndex - startIndex\n        }\n        startIndex = endIndex\
    \ + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8wqr65zl.swift:17:65: error: cannot find 'len' in scope\n     \
    \   endIndex = string.index(substring, startIndex).offsetBy(len(substring))\n\
    \                                                                ^~~\n/tmp/tmp8wqr65zl.swift:17:27:\
    \ error: no exact matches in call to instance method 'index'\n        endIndex\
    \ = string.index(substring, startIndex).offsetBy(len(substring))\n           \
    \               ^\n/tmp/tmp8wqr65zl.swift:17:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex).offsetBy(len(substring))\n                          ^\n/tmp/tmp8wqr65zl.swift:17:56:\
    \ error: value of type 'String.Index' has no member 'offsetBy'\n        endIndex\
    \ = string.index(substring, startIndex).offsetBy(len(substring))\n           \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.rangeOfString(substring) == nil {\n        return 0\n\
    \    }\n    return string.rangeOfString(substring).location + string.rangeOfString(substring).length\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpevehv_97.swift:16:15: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if string.rangeOfString(substring) == nil {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpevehv_97.swift:19:19: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    return string.rangeOfString(substring).location\
    \ + string.rangeOfString(substring).length\n           ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpevehv_97.swift:19:62: error: value of type 'String' has no member 'rangeOfString'\n\
    \    return string.rangeOfString(substring).location + string.rangeOfString(substring).length\n\
    \                                                      ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).contains(substring) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm4mun4rb.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpm4mun4rb.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.count\n    var k = substring.count\n    while\
    \ i < j {\n        if string[i] == substring[k] {\n            count += 1\n  \
    \          i += k\n            k += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3yxvwlwo.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp3yxvwlwo.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3yxvwlwo.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += 1\n        \
    \    if k == substring.count {\n                k = 0\n            }\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_fazotgy.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp_fazotgy.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp_fazotgy.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp_fazotgy.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = string.characters.count\n    var m = substring.characters.count\n\
    \    while i < l {\n        j = string.characters.index(string.startIndex, offsetBy:\
    \ i)\n        k = substring.characters.index(substring.startIndex, offsetBy: j)\n\
    \        if k == nil {\n            break\n        }\n        if string.characters[k!]\
    \ != substring.characters[j!] {\n            break\n        }\n        i += 1\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9lb_l4cn.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var l = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp9lb_l4cn.swift:21:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var m =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9lb_l4cn.swift:23:31: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n        j = string.characters.index(string.startIndex,\
    \ offsetBy: i)\n            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9lb_l4cn.swift:24:34: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        k = substring.characters.index(substring.startIndex,\
    \ offsetBy: j)\n            ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9lb_l4cn.swift:25:14: warning: comparing non-optional value of type 'Int'\
    \ to 'nil' always returns false\n        if k == nil {\n           ~ ^  ~~~\n\
    /tmp/tmp9lb_l4cn.swift:28:31: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n        if string.characters[k!] != substring.characters[j!] {\n\
    \                             ~^\n                              \n/tmp/tmp9lb_l4cn.swift:28:59:\
    \ error: cannot force unwrap value of non-optional type 'Int'\n        if string.characters[k!]\
    \ != substring.characters[j!] {\n                                            \
    \             ~^\n                                                          \n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substrings(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppv1ghl56.swift:10:12: error: cannot find 'count_substrings' in\
    \ scope\n    return count_substrings(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpik07zbhd.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpik07zbhd.swift:19:31:\
    \ note: to match this opening '{'\n    while i < string.endIndex {\n         \
    \                     ^\n/tmp/tmpik07zbhd.swift:114:67: error: expected '}' at\
    \ end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmpik07zbhd.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmpik07zbhd.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpik07zbhd.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpik07zbhd.swift:19:13: error:\
    \ operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpik07zbhd.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpik07zbhd.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpik07zbhd.swift:22:28:\
    \ error: value of t"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count = count + 1\n        }\n        i = i +\
    \ 1\n        k = k - 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7ie99tup.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp7ie99tup.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp7ie99tup.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp7ie99tup.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7ie99tup.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7ie99tup.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    for\
    \ i < string.count {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += 1\n            for j < substring.count {\n          \
    \      if string[i] == substring[j] {\n                    count += 1\n      \
    \              i += 1\n                    j += 1\n                }\n       \
    \     }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_zfbmhpg.swift:19:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmp_zfbmhpg.swift:19:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmp_zfbmhpg.swift:23:19: error: expected\
    \ 'in' after for-each pattern\n            for j < substring.count {\n       \
    \           ^\n/tmp/tmp_zfbmhpg.swift:23:19: error: unary operator cannot be separated\
    \ from its operand\n            for j < substring.count {\n                  ^~\n\
    \                   \n/tmp/tmp_zfbmhpg.swift:14:16: error: use of local variable\
    \ 'count' before its declaration\n        return count(string)\n             \
    \  ^\n/tmp/tmp_zfbmhpg.swift:16:9: note: 'count' declared here\n    var count\
    \ = 0\n        ^\n/tmp/tmp_zfbmhpg.swift:19:11: error: '<' is not a prefix unary\
    \ operator\n    for i < string.count {\n          ^\n/tmp/tmp_zfbmhpg.swift:23:19:\
    \ error: '<' is not a prefix unary operator\n            for j < substring.count\
    \ {\n                  ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var A = 0\n    var B = 0\n    var C = 0\n    var D = 0\n    var E = 0\n \
    \   var F = 0\n    var G = 0\n    var H = 0\n    var I = 0\n    var J = 0\n  \
    \  var K = 0\n    var L = 0\n    var M = 0\n    var N = 0\n    var O = 0\n   \
    \ var P = 0\n    var Q = 0\n    var R = 0\n    var S = 0\n    var T = 0\n    var\
    \ U = 0\n    var V = 0\n    var W = 0\n    var X = 0\n    var Y = 0\n    var Z\
    \ = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e =\
    \ 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var A = 0\n    var B = 0\n    var C = 0\n    var D = 0\n    var\
    \ E = 0\n    var F = 0\n    var G = 0\n    var H = 0\n    var I = 0\n    var J\
    \ = 0\n    var K = 0\n    var L = 0\n    var M = 0\n    var N = 0\n    var O =\
    \ 0\n    var P = 0\n    var Q = 0\n    var R = 0\n    var S = 0\n    var T = 0\n\
    \    var U = 0\n    var V = 0\n    var W = 0\n    var X = 0\n    var Y = 0\n \
    \   var Z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var A = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyn9dzcg1.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpyn9dzcg1.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:69:9:\
    \ error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:17:9:\
    \ note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:70:9:\
    \ error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:18:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:71:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:19:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:72:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:20:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:73:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:21:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:74:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:22:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:75:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:23:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:76:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:24:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:77:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:25:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:78:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:26:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpyn9dzcg1.swift:79:9:\
    \ error: invalid redeclaration"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    for k in 0..<count(string) {\n        if string[k] == substring[0]\
    \ {\n            i = k\n            j = k\n        }\n        if string[k] ==\
    \ substring[1] {\n            i = k\n            j = k + 1\n        }\n      \
    \  if string[k] == substring[2] {\n            i = k\n            j = k + 2\n\
    \        }\n        if string[k] == substring[3] {\n            i = k\n      \
    \      j = k + 3\n        }\n        if string[k] == substring[4] {\n        \
    \    i = k\n            j = k + 4\n        }\n        if string[k] == substring[5]\
    \ {\n            i = k\n            j = k + 5\n        }\n        if string[k]\
    \ == substring[6] {\n            i = k\n            j = k + 6\n        }\n   \
    \     if string[k] == substring[7] {\n            i = k\n            j = k + 7\n\
    \        }\n        if string[k] == substring[8] {\n            i = k\n      \
    \      j = k + 8\n        }\n        if string[k] == substring[9] {\n        \
    \    i = k\n            j = k + 9\n        }\n        if string[k] == substring[10]\
    \ {\n            i = k\n            j = k + 10\n        }\n        if string[k]\
    \ == substring[11] {\n            i = k\n            j = k + 11\n        }\n \
    \       if string[k] == substring[12] {\n            i = k\n            j = k\
    \ + 12\n        }\n        if string[k] == substring[13] {\n            i = k\n\
    \            j = k + 13\n        }\n        if string[k] == substring[14] {\n\
    \            i = k\n            j = k + 14\n        }\n        if string[k] ==\
    \ substring[15] {\n            i = k\n            j = k + 15\n        }\n    \
    \    if string[k] == substring[16] {\n            i = k\n            j = k + 16\n\
    \        }\n        if string[k] == substring[17] {\n            i = k\n     \
    \       j = k + 17\n        }\n        if string[k] == substring[18] {\n     \
    \       i = k\n            j = k + 18\n        }\n        if string[k] == substring[19]\
    \ {\n            i = k\n            j = k + 19\n        }\n        if string[k]\
    \ == substring[20] {\n            i = k\n            j = k + 20\n        }\n \
    \       if string[k] == substring[21] {\n            i = k\n            j = k\
    \ + 21\n        }\n        if string[k] == substring[22] {\n            i = k\n\
    \            j = k + 22\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5344wfqm.swift:131:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp5344wfqm.swift:20:32:\
    \ note: to match this opening '{'\n    for k in 0..<count(string) {\n        \
    \                       ^\n/tmp/tmp5344wfqm.swift:131:67: error: expected '}'\
    \ at end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmp5344wfqm.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmp5344wfqm.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmp5344wfqm.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmp5344wfqm.swift:20:18: error:\
    \ cannot call value of non-function type 'Int'\n    for k in 0..<count(string)\
    \ {\n                 ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return string.count(substring)\
    \ + how_many_times(string, substring[..<string.count])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoyzyg22f.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpoyzyg22f.swift:13:19: error: cannot call value of non-function type 'Int'\n\
    \    return string.count(substring) + how_many_times(string, substring[..<string.count])\n\
    \                  ^\n/tmp/tmpoyzyg22f.swift:13:52: error: missing argument labels\
    \ 'string:substring:' in call\n    return string.count(substring) + how_many_times(string,\
    \ substring[..<string.count])\n                                              \
    \     ^\n                                                    string: substring:\
    \ \n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.startIndex.advancedBy(substring.endIndex.distanceTo(string.startIndex))\n\
    \    let count = string.distance(from: start, to: end) + 1\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvwa4yo_3.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvwa4yo_3.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpvwa4yo_3.swift:11:33: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.startIndex.advancedBy(substring.endIndex.distanceTo(string.startIndex))\n\
    \              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvwa4yo_3.swift:11:63: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.startIndex.advancedBy(substring.endIndex.distanceTo(string.startIndex))\n\
    \                                           ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = string.startIndex\n    while i < string.endIndex\
    \ && j < substring.endIndex {\n        if string[i] == substring[j] {\n      \
    \      count += 1\n            i += 1\n            j += 1\n        } else if string[i]\
    \ < substring[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp20_tdnv7.swift:17:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex &&\
    \ j < substring.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp20_tdnv7.swift:17:36:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex && j < substring.endIndex {\n                 \
    \                  ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp20_tdnv7.swift:18:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp20_tdnv7.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp20_tdnv7.swift:22:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] < substring[j] {\n                  ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp20_tdnv7.swift:22:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] < substring[j] {\n\
    \                              ^~~~~~~~~~~~\nSwift.String:3"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var startIndex = 0\n    var endIndex = string.count\n    var substringIndex\
    \ = string.startIndex\n    while substringIndex < endIndex {\n        if string[substringIndex]\
    \ == substring[0] {\n            substringIndex += 1\n            count += 1\n\
    \            if substringIndex == string.endIndex {\n                substringIndex\
    \ += 1\n                endIndex -= 1\n            }\n        } else {\n     \
    \       substringIndex += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl2qxoxe9.swift:17:26: error: referencing operator function '<'\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while substringIndex < endIndex {\n                         ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n\
    /tmp/tmpl2qxoxe9.swift:18:38: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[substringIndex]\
    \ == substring[0] {\n                                     ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpl2qxoxe9.swift:19:28:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            substringIndex += 1\n            ~~~~~~~~~~~~~~ ^  ~\n\
    /tmp/tmpl2qxoxe9.swift:22:32: error: binary operator '+=' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n                substringIndex +=\
    \ 1\n                ~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpl2qxoxe9.swift:26:28: error:\
    \ binary operator '+=' cannot be applied to operands of type 'String.Index' and\
    \ 'Int'\n            substringIndex += 1\n            ~~~~~~~~~~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j && k < string.count {\n        if\
    \ string[i] == substring[k] {\n            count += 1\n            i += 1\n  \
    \          k += 1\n        }\n        if string[i] == substring[k] {\n       \
    \     i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf6ohhsan.swift:155:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpf6ohhsan.swift:20:37:\
    \ note: to match this opening '{'\n    while i < j && k < string.count {\n   \
    \                                 ^\n/tmp/tmpf6ohhsan.swift:155:67: error: expected\
    \ '}' at end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmpf6ohhsan.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmpf6ohhsan.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpf6ohhsan.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpf6ohhsan.swift:21:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpf6ohhsan.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpf6ohhsan.swift:26:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpf6ohhsan.swift:26:25:\
    \ erro"
  stdout: ''
  timestamp: 1659824887
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += 1\n            k += 1\n        \
    \    if k == substring.count {\n                k = 0\n            }\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpaj0dao_o.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpaj0dao_o.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaj0dao_o.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string.characters[i]\
    \ != substring.characters[k] {\n            count += 1\n        }\n        i +=\
    \ 1\n        k += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb7_1v1ig.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpb7_1v1ig.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb7_1v1ig.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb7_1v1ig.swift:21:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb7_1v1ig.swift:21:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpb7_1v1ig.swift:21:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb7_1v1ig.swift:18:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j && k < string.count {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n        }\n        if k == substring.count {\n            j += 1\n   \
    \         k = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpptympmst.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpptympmst.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ = count + 1\n        }\n        i += 1\n        k += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl_k1785e.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpl_k1785e.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpl_k1785e.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpl_k1785e.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpl_k1785e.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[j] {\n            count\
    \ = count + 1\n        }\n        i = i + 1\n        j = j - 1\n    }\n    while\
    \ i < k {\n        if string[i] != substring[k] {\n            count = count +\
    \ 1\n        }\n        i = i + 1\n        k = k - 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps_oxo697.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmps_oxo697.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmps_oxo697.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps_oxo697.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmps_oxo697.swift:25:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps_oxo697.swift:25:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j && i < k {\n        if string.characters[i] == substring.characters[i]\
    \ {\n            i += 1\n            count += 1\n        } else {\n          \
    \  i = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpu2ld6_cs.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpu2ld6_cs.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu2ld6_cs.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[i] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu2ld6_cs.swift:18:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[i] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu2ld6_cs.swift:18:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[i] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu2ld6_cs.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[i] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu2ld6_cs.swift:15:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy5d55zja.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: error: no exact\
    \ matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpy5d55zja.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpy5d55zja.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpy5d55zja.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmpy5d55zja.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            i += 1\n      \
    \      count += how_many_times(string: String(string[i..<j]), substring: substring[1:])\n\
    \        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpn7t7f07x.swift:22:90: error: expected ',' separator\n         \
    \   count += how_many_times(string: String(string[i..<j]), substring: substring[1:])\n\
    \                                                                            \
    \             ^\n                                                            \
    \                             ,\n/tmp/tmpn7t7f07x.swift:22:90: error: expected\
    \ expression in list of expressions\n            count += how_many_times(string:\
    \ String(string[i..<j]), substring: substring[1:])\n                         \
    \                                                                ^\n/tmp/tmpn7t7f07x.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpn7t7f07x.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpn7t7f07x.swift:22:88:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            count += how_many_times(string: String(string[i..<j]), substring:\
    \ substring[1:])\n                                                           \
    \                            ^\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.distanceTo(substring.startIndex)\n    let end = string.endIndex.distanceTo(substring.endIndex)\n\
    \    return end - start\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4k9art0k.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'distanceTo'\n    let start = string.startIndex.distanceTo(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4k9art0k.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.distanceTo(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4k9art0k.swift:12:16: error:\
    \ cannot convert return expression of type 'Duration' to return type 'Int'\n \
    \   return end - start\n           ~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += count(substring)\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9zmq5i99.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp9zmq5i99.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp9zmq5i99.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp9zmq5i99.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9zmq5i99.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp9zmq5i99.swift:22:18: error: cannot call value\
    \ of non-function type 'Int'\n            i += count(substring)\n            \
    \     ^\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjtft51z2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjtft51z2.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
