language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n  \
    \  var currentPrimeFactorization = [Int]()\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorizationIndex2 = 0\n    var currentPrimeFactorizationIndex3\
    \ = 0\n    var currentPrimeFactorizationIndex4 = 0\n    var currentPrimeFactorizationIndex5\
    \ = 0\n    var currentPrimeFactorizationIndex6 = 0\n    var currentPrimeFactorizationIndex7\
    \ = 0\n    var currentPrimeFactorizationIndex8 = 0\n    var currentPrimeFactorizationIndex9\
    \ = 0\n    var currentPrimeFactorizationIndex10 = 0\n    var currentPrimeFactorizationIndex11\
    \ = 0\n    var currentPrimeFactorizationIndex12 = 0\n    var currentPrimeFactorizationIndex13\
    \ = 0\n    var currentPrimeFactorizationIndex14 = 0\n    var currentPrimeFactorizationIndex15\
    \ = 0\n    var currentPrimeFactorizationIndex16 = 0\n    var currentPrimeFactorizationIndex17\
    \ = 0\n    var currentPrimeFactorizationIndex18 = 0\n    var currentPrimeFactorizationIndex19\
    \ = 0\n    var currentPrimeFactorizationIndex20 = 0\n    var currentPrimeFactorizationIndex21\
    \ = 0\n    var currentPrimeFactorizationIndex22 = 0\n    var currentPrimeFactorizationIndex23\
    \ = 0\n    var currentPrimeFactorizationIndex24 = 0\n    var currentPrimeFactorizationIndex25\
    \ = 0\n    var currentPrimeFactorizationIndex26 = 0\n    var currentPrimeFactorizationIndex27\
    \ = 0\n    var currentPrimeFactorizationIndex28 = 0\n    var currentPrimeFactorizationIndex29\
    \ = 0\n    var currentPrimeFactorizationIndex30 = 0\n    var currentPrimeFactorizationIndex31\
    \ = 0\n    var currentPrimeFactorizationIndex32 = 0\n    var currentPrimeFactorizationIndex33\
    \ = 0\n    var currentPrimeFactorizationIndex34 = 0\n    var currentPrimeFactorizationIndex35\
    \ = 0\n    var currentPrimeFactorizationIndex36 = 0\n    var currentPrimeFactorizationIndex37\
    \ = 0\n    var currentPrimeFactorizationIndex38 = 0\n    var currentPrimeFactorizationIndex39\
    \ = 0\n    var currentPrimeFactorizationIndex40 = 0\n    var currentPrimeFactorizationIndex41\
    \ = 0\n    var currentPrimeFactorizationIndex42 = 0\n    var currentPrimeFactorizationIndex43\
    \ = 0\n    var currentPrimeFactorizationIndex44 = 0\n    var currentPrimeFactorizationIndex45\
    \ = 0\n    var currentPrimeFactorizationIndex46 = 0\n    var currentPrime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1qxr0h4h.swift:64:9: error: type annotation missing in pattern\n\
    \    var currentPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i < n {\n        if n % i == 0 {\n\
    \            factors.append(factor)\n            factor = 1\n        } else {\n\
    \            factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpdpxa5i11/tmpdpxa5i11.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b515742ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5157121b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5157121988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51571207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdpxa5i11                        0x000055fba91be4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b5157616460 __libc_start_main +
    245

    6    tmpdpxa5i11                        0x000055fba91be119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexCount = 0\n    var factorizationIndexCountMax = Int(IntMax)\n\
    \    var factorizationIndexCountMin = Int(IntMin)\n    var factorizationIndexCountMaxMin\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMax = Int(IntMin)\n    var\
    \ factorizationIndexCountMinMaxMax = Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMin\
    \ = Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMin = Int(IntMax)\n \
    \   var factorizationIndexCountMinMaxMaxMinMax = Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMax\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMax = Int(IntMin)\n\
    \    var factorizationIndexCountMinMaxMaxMinMaxMaxMax = Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMax\
    \ = Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMax = Int(IntMax)\n\
    \    var factorizationIndexCountMinMaxMaxMinMaxMaxMax = Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMax\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMax = Int(IntMin)\n\
    \    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMax = Int(IntMax)\n  \
    \  var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMax = Int(IntMin)\n    var\
    \ factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMax = Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMax\
    \ = Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMax =\
    \ Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMax)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMin)\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMaxMaxMaxMax =\
    \ Int(IntMax)\n    var factorizationIndexCountMin\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm6wrnjmo.swift:16:42: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationIndexCountMax = Int(IntMax)\n                            \
    \             ^~~~~~\n/tmp/tmpm6wrnjmo.swift:17:42: error: cannot find 'IntMin'\
    \ in scope\n    var factorizationIndexCountMin = Int(IntMin)\n               \
    \                          ^~~~~~\n/tmp/tmpm6wrnjmo.swift:18:45: error: cannot\
    \ find 'IntMax' in scope\n    var factorizationIndexCountMaxMin = Int(IntMax)\n\
    \                                            ^~~~~~\n/tmp/tmpm6wrnjmo.swift:19:45:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinMax\
    \ = Int(IntMin)\n                                            ^~~~~~\n/tmp/tmpm6wrnjmo.swift:20:48:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxMax\
    \ = Int(IntMax)\n                                               ^~~~~~\n/tmp/tmpm6wrnjmo.swift:21:51:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinMaxMaxMin\
    \ = Int(IntMin)\n                                                  ^~~~~~\n/tmp/tmpm6wrnjmo.swift:22:51:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxMaxMin\
    \ = Int(IntMax)\n                                                  ^~~~~~\n/tmp/tmpm6wrnjmo.swift:23:54:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinMaxMaxMinMax\
    \ = Int(IntMin)\n                                                     ^~~~~~\n\
    /tmp/tmpm6wrnjmo.swift:24:57: error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxMaxMinMaxMax\
    \ = Int(IntMax)\n                                                        ^~~~~~\n\
    /tmp/tmpm6wrnjmo.swift:25:57: error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinMaxMaxMinMaxMax\
    \ = Int(IntMin)\n                                                        ^~~~~~\n\
    /tmp/tmpm6wrnjmo.swift:26:60: error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxMaxMinMaxMaxMax\
    \ = Int(IntMax)\n                                                           ^~~~~~\n\
    /tmp/tmpm6wrnjmo.swift:27:60: error: cannot find 'IntMin' in sco"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var factor = 2\n    var prime = true\n    var\
    \ factorizationCount = 0\n    while i < n {\n        while j < n {\n         \
    \   if n % i == 0 {\n                factorizationCount += 1\n               \
    \ factorization.append(factor)\n                factor *= i\n                factorization.append(factor)\n\
    \                factor *= j\n                factorizationCount += 1\n      \
    \          factorization.append(factor)\n                factor *= i\n       \
    \         factorizationCount += 1\n                factorizationCount += 1\n \
    \               factorizationCount += 1\n                factorizationCount +=\
    \ 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factorizationCount += 1\n                factorizationCount\
    \ += 1\n                factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvsfyfog4.swift:122:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmpvsfyfog4.swift:19:21: note: to match this opening '{'\n        while j\
    \ < n {\n                    ^\n/tmp/tmpvsfyfog4.swift:122:38: error: expected\
    \ '}' at end of brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n     \
    \                                ^\n/tmp/tmpvsfyfog4.swift:18:17: note: to match\
    \ this opening '{'\n    while i < n {\n                ^\n/tmp/tmpvsfyfog4.swift:122:38:\
    \ error: expected '}' at end of brace statement\nassert(factorize(n: 18) == [2,\
    \ 3, 3])\n                                     ^\n/tmp/tmpvsfyfog4.swift:11:33:\
    \ note: to match this opening '{'\nfunc factorize(n: Int) -> [Int] {\n       \
    \                         ^\n/tmp/tmpvsfyfog4.swift:99:17: warning: variable is\
    \ unused\n                factor\n                ^~~~~~\n/tmp/tmpvsfyfog4.swift:103:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpvsfyfog4.swift:13:9:\
    \ warning: variable 'i' was never mutated; consider changing to 'let' constant\n\
    \    var i = 2\n    ~~~ ^\n    let\n/tmp/tmpvsfyfog4.swift:14:9: warning: variable\
    \ 'j' was never mutated; consider changing to 'let' constant\n    var j = 1\n\
    \    ~~~ ^\n    let\n/tmp/tmpvsfyfog4.swift:16:9: warning: initialization of variable\
    \ 'prime' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var prime = true\n    ~~~~^~~~~\n    _\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [1]\n    var isPrime = true\n    var isFactor = false\n\
    \    var isPrimeFactor = false\n    var isPrimeFactor2 = false\n    var isPrimeFactor3\
    \ = false\n    var isPrimeFactor4 = false\n    var isPrimeFactor5 = false\n  \
    \  var isPrimeFactor6 = false\n    var isPrimeFactor7 = false\n    var isPrimeFactor8\
    \ = false\n    var isPrimeFactor9 = false\n    var isPrimeFactor10 = false\n \
    \   var isPrimeFactor11 = false\n    var isPrimeFactor12 = false\n    var isPrimeFactor13\
    \ = false\n    var isPrimeFactor14 = false\n    var isPrimeFactor15 = false\n\
    \    var isPrimeFactor16 = false\n    var isPrimeFactor17 = false\n    var isPrimeFactor18\
    \ = false\n    var isPrimeFactor19 = false\n    var isPrimeFactor20 = false\n\
    \    var isPrimeFactor21 = false\n    var isPrimeFactor22 = false\n    var isPrimeFactor23\
    \ = false\n    var isPrimeFactor24 = false\n    var isPrimeFactor25 = false\n\
    \    var isPrimeFactor26 = false\n    var isPrimeFactor27 = false\n    var isPrimeFactor28\
    \ = false\n    var isPrimeFactor29 = false\n    var isPrimeFactor30 = false\n\
    \    var isPrimeFactor31 = false\n    var isPrimeFactor32 = false\n    var isPrimeFactor33\
    \ = false\n    var isPrimeFactor34 = false\n    var isPrimeFactor35 = false\n\
    \    var isPrimeFactor36 = false\n    var isPrimeFactor37 = false\n    var isPrimeFactor38\
    \ = false\n    var isPrimeFactor39 = false\n    var isPrimeFactor40 = false\n\
    \    var isPrimeFactor41 = false\n    var isPrimeFactor42 = false\n    var isPrimeFactor43\
    \ = false\n    var isPrimeFactor44 = false\n    var isPrimeFactor45 = false\n\
    \    var isPrimeFactor46 = false\n    var isPrimeFactor47 = false\n    var isPrimeFactor48\
    \ = false\n    var isPrimeFactor49 = false\n    var isPrimeFactor50 = false\n\
    \    var isPrimeFactor51 = false\n    var isPrimeFactor52 = false\n    var isPrimeFactor53\
    \ = false\n    var isPrimeFactor54 = false\n    var isPrimeFactor55 = false\n\
    \    var isPrimeFactor56 = false\n    var isPrimeFactor57 = false\n    var isPrimeFactor58\
    \ = false\n    var isPrimeFactor59 = false\n    var isPrimeFactor60 = false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6ddma8vu.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:13:9:\
    \ warning: initialization of variable 'primeFactors' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactors = [1]\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:14:9: warning: initialization\
    \ of variable 'isPrime' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:15:9:\
    \ warning: initialization of variable 'isFactor' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isFactor = false\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp6ddma8vu.swift:16:9: warning: initialization of variable 'isPrimeFactor'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactor = false\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:17:9:\
    \ warning: initialization of variable 'isPrimeFactor2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactor2 = false\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:18:9: warning: initialization\
    \ of variable 'isPrimeFactor3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeFactor3 = false\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6ddma8vu.swift:19:9: warning: initialization of variable 'isPrimeFactor4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactor4 = false\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:20:9:\
    \ warning: initialization of variable 'isPrimeFactor5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactor5 = false\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6ddma8vu.swift:21:9: warning: initialization\
    \ of variable 'isPrimeFactor6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeFactor6 = fal"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationValue = 1\n    var\
    \ factorizationValueIndex = 0\n    var factorizationValueIndexMax = factorization.count\
    \ - 1\n    for _ in 0..<factorizationCount {\n        if factorizationIndex ==\
    \ factorizationValueIndexMax {\n            factors.append(factorizationValue)\n\
    \            factorizationIndex = 0\n            factorizationValueIndex++\n \
    \           factorizationValue = 1\n        } else {\n            factorizationValue\
    \ *= factorization[factorizationIndex]\n            factorizationIndex++\n   \
    \     }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm38_xqhu.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm38_xqhu.swift:23:36: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            factorizationValueIndex++\n\
    \                                   ^~\n/tmp/tmpm38_xqhu.swift:27:31: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            factorizationIndex++\n\
    \                              ^~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var primeFactorization = [Int]()\n    var\
    \ primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeSet = [Bool]()\n\
    \    var isPrimeSetIndex = 0\n    var isPrimeSetIndexMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax2 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax3\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax4 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax5 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax6\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax8 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax9\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax10 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax11 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax12\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax13 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax14 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax15\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax16 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax17 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax18\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax20 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax21\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax22 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax23 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax24\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax25 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax26 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax27\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax28 = Int(sqrt(Double(n)))\n\
    \    var isPrimeSetIndexMax29 = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax30\
    \ = Int(sqrt(Double(n)))\n    var isPrimeSetIndexMax31 = Int(sqrt(Double(n)))\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpka4h009b.swift:19:34: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeSetIndexMax = Int(sqrt(Double(n)))\n                                \
    \ ^~~~\n/tmp/tmpka4h009b.swift:20:35: error: cannot find 'sqrt' in scope\n   \
    \ var isPrimeSetIndexMax2 = Int(sqrt(Double(n)))\n                           \
    \       ^~~~\n/tmp/tmpka4h009b.swift:21:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax3 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:22:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax4 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:23:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax5 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:24:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax6 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:25:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax7 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:26:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax8 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:27:35: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax9 = Int(sqrt(Double(n)))\n                        \
    \          ^~~~\n/tmp/tmpka4h009b.swift:28:36: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeSetIndexMax10 = Int(sqrt(Double(n)))\n                       \
    \            ^~~~\n/tmp/tmpka4h009b.swift:29:36: error: cannot find 'sqrt' in\
    \ scope\n    var isPrimeSetIndexMax11 = Int(sqrt(Double(n)))\n               \
    \                    ^~~~\n/tmp/tmpka4h009b.swift:30:36: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeSetIndexMax12 = Int(sqrt(Double(n)))\n            \
    \                       ^~~~\n/tmp/tmpka4h009b.swift:31:36: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeSetIndexMax13 = Int(sqrt(Double(n)))\n     \
    \                              ^~~~\n/tmp/tmpka4h009b.swift:32:3"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var currentFactor = 1\n    var currentFactorIndex\
    \ = 0\n    var currentFactorValue = 1\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeValue = 1\n    var isPrimeFactorization = false\n    var\
    \ isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationValue = 1\n    var\
    \ isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeIndex =\
    \ 0\n    var isPrimeFactorizationPrimeValue = 1\n    var isPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationValue\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeValue = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationValue =\
    \ 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex = 0\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeValue = 1\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationValue\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeValue\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationValue\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0dc9jrm2.swift:36:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex = 0\n \
    \       ^\n/tmp/tmp0dc9jrm2.swift:33:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0dc9jrm2.swift:42:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0dc9jrm2.swift:39:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0dc9jrm2.swift:47:9: error: type annotation missing\
    \ in pattern\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var primeFactorization\
    \ = factorizationOfPrimes(n)\n    var factorizationIndex = 0\n    var primeFactorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var primeFactorizationCount = 1\n \
    \   var factorizationPrimeCount = 1\n    var primeFactorizationPrimeCount = 1\n\
    \    var factorizationPrimeIndex = 0\n    var primeFactorizationPrimeIndex = 0\n\
    \    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n    var primeFactorizationPrimeIndex\
    \ = 0\n    var primeFactorizationPrimeCount = 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpar1n79ox.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpar1n79ox.swift:14:30: error: cannot find\
    \ 'factorizationOfPrimes' in scope\n    var primeFactorization = factorizationOfPrimes(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpar1n79ox.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimeCount'\n    var primeFactorizationPrimeCount\
    \ = 1\n        ^\n/tmp/tmpar1n79ox.swift:20:9: note: 'primeFactorizationPrimeCount'\
    \ previously declared here\n    var primeFactorizationPrimeCount = 1\n       \
    \ ^\n/tmp/tmpar1n79ox.swift:24:9: error: invalid redeclaration of 'primeFactorizationPrimeIndex'\n\
    \    var primeFactorizationPrimeIndex = 0\n        ^\n/tmp/tmpar1n79ox.swift:22:9:\
    \ note: 'primeFactorizationPrimeIndex' previously declared here\n    var primeFactorizationPrimeIndex\
    \ = 0\n        ^\n/tmp/tmpar1n79ox.swift:25:9: error: invalid redeclaration of\
    \ 'primeFactorizationPrimeCount'\n    var primeFactorizationPrimeCount = 1\n \
    \       ^\n/tmp/tmpar1n79ox.swift:20:9: note: 'primeFactorizationPrimeCount' previously\
    \ declared here\n    var primeFactorizationPrimeCount = 1\n        ^\n/tmp/tmpar1n79ox.swift:26:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimeIndex'\n    var primeFactorizationPrimeIndex\
    \ = 0\n        ^\n/tmp/tmpar1n79ox.swift:22:9: note: 'primeFactorizationPrimeIndex'\
    \ previously declared here\n    var primeFactorizationPrimeIndex = 0\n       \
    \ ^\n/tmp/tmpar1n79ox.swift:27:9: error: invalid redeclaration of 'primeFactorizationPrimeCount'\n\
    \    var primeFactorizationPrimeCount = 1\n        ^\n/tmp/tmpar1n79ox.swift:20:9:\
    \ note: 'primeFactorizationPrimeCount' previously declared here\n    var primeFactorizationPrimeCount\
    \ = 1\n        ^\n/tmp/tmpar1n79ox.swift:28:9: error: invalid redeclaration of\
    \ 'primeFactorizationPrimeIndex'\n    var primeFactorizationPrimeIndex = 0\n \
    \       ^\n/tmp/tmpar1n79ox.swift:22:9: note: 'primeFactorizationPrimeIndex' previously\
    \ declared here\n    var primeFactorizatio"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69\
    \ = 0\n    var factorizationIndex70 = 0\n    var factorizationIndex71 = 0\n  \
    \  var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4uzniqhh.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for _ in 0..<factorization.count {\n        if factorizationCount <=\
    \ factorization.count {\n            factors.append(factorization[factorizationCount])\n\
    \            factorizationCount += 1\n        } else {\n            break\n  \
    \      }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxs7_3ygy.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n   \
    \ var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n\
    \    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int =\
    \ 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int\
    \ = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e:\
    \ Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var\
    \ i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n   \
    \ var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n\
    \    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int =\
    \ 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int\
    \ = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c:\
    \ Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var\
    \ g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n   \
    \ var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n\
    \    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\
    \ 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int\
    \ = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a:\
    \ Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var\
    \ e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n   \
    \ var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n\
    \    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int =\
    \ 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int\
    \ = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y:\
    \ Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var\
    \ c: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfpsllqf2.swift:39:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:40:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:24:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationSum\
    \ = 0\n    var factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq7zk_tmn.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactorization = [Int]()\n    var primeFactorizationIndex\
    \ = 0\n    var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeCount = 0\n    var isPrimeFactorization = true\n    var\
    \ isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount = 0\n    var\
    \ isPrimePrime = true\n    var isPrimePrimeIndex = 0\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimeFactorization = true\n    var isPrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationCount = 0\n    var isPrimePrimePrime =\
    \ true\n    var isPrimePrimePrimeIndex = 0\n    var isPrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeIndex = 0\n    var isPrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeIndex = 0\n    var isPrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeIndex = 0\n    var isPrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeIndex = 0\n    var isPrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9flxndm0.swift:36:9: error: invalid redeclaration of 'isPrimePrimePrimeIndex'\n\
    \    var isPrimePrimePrimeIndex = 0\n        ^\n/tmp/tmp9flxndm0.swift:30:9: note:\
    \ 'isPrimePrimePrimeIndex' previously declared here\n    var isPrimePrimePrimeIndex\
    \ = 0\n        ^\n/tmp/tmp9flxndm0.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimeCount'\n    var isPrimePrimePrimeCount = 0\n        ^\n/tmp/tmp9flxndm0.swift:31:9:\
    \ note: 'isPrimePrimePrimeCount' previously declared here\n    var isPrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmp9flxndm0.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimeFactorization'\n    var isPrimePrimePrimeFactorization = true\n\
    \        ^\n/tmp/tmp9flxndm0.swift:32:9: note: 'isPrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimeFactorization = true\n  \
    \      ^\n/tmp/tmp9flxndm0.swift:39:9: error: invalid redeclaration of 'isPrimePrimePrimeFactorizationIndex'\n\
    \    var isPrimePrimePrimeFactorizationIndex = 0\n        ^\n/tmp/tmp9flxndm0.swift:33:9:\
    \ note: 'isPrimePrimePrimeFactorizationIndex' previously declared here\n    var\
    \ isPrimePrimePrimeFactorizationIndex = 0\n        ^\n/tmp/tmp9flxndm0.swift:40:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimeFactorizationCount'\n    var\
    \ isPrimePrimePrimeFactorizationCount = 0\n        ^\n/tmp/tmp9flxndm0.swift:34:9:\
    \ note: 'isPrimePrimePrimeFactorizationCount' previously declared here\n    var\
    \ isPrimePrimePrimeFactorizationCount = 0\n        ^\n/tmp/tmp9flxndm0.swift:41:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrime'\n    var isPrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp9flxndm0.swift:35:9: note: 'isPrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrime = true\n        ^\n\
    /tmp/tmp9flxndm0.swift:42:9: error: invalid redeclaration of 'isPrimePrimePrimeIndex'\n\
    \    var isPrimePrimePrimeIndex = 0\n        ^\n/tmp/tmp9flxndm0.swift:30:9: note:\
    \ 'isPrimePrimePrimeIndex' previously declared here\n    var isPrimePrimePrimeIndex\
    \ = 0\n        ^\n/tmp/tmp9flxndm0.swift:43:9: error: invalid redeclaration of\
    \ 'isPrimePrim"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationCount = 0\n    var factorizationSum\
    \ = 0\n    var factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc2srw2uq.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorizationSum\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n\
    \    var isPrimeFactorization: Bool = false\n    var isPrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_mtkf6sd.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \      ^\n/tmp/tmp_mtkf6sd.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n        ^\n/tmp/tmp_mtkf6sd.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:29:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:29:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp_mtkf6sd.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePr"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var factor = 1\n    while i < n {\n       \
    \ if n % i == 0 {\n            factors.append(factor)\n            factor = 1\n\
    \            while i * j < n {\n                j += 1\n            }\n      \
    \      i += 1\n        } else {\n            factor += 1\n        }\n    }\n \
    \   factors.append(factor)\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpea50yy26/tmpea50yy26.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b284e73dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b284e434b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b284e434988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b284e4337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpea50yy26                        0x00005617818144c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b284e929460 __libc_start_main +
    245

    6    tmpea50yy26                        0x0000561781814119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationIndex = [Int]()\n    var primeFactorizationIndexCount\
    \ = [Int]()\n    var primeFactorizationIndexCountMax = Int()\n    var primeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValue = Int()\n    var primeFactorizationIndexCountMaxValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueIndex = Int()\n    var primeFactorizationIndexCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n\
    \    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex =\
    \ Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n  \
    \  var primeFactorizationIndexCountMaxValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp28c5d1x4.swift:28:9: error: invalid redeclaration of 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\n\
    \    var primeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n  \
    \      ^\n/tmp/tmp28c5d1x4.swift:26:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:29:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueValue'\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:27:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:30:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:26:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:31:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueValue'\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:27:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp28c5d1x4.swift:34:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueValueIndex'\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n    \
    \    ^\n/tmp/tmp28c5d1x4.swift:32:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n        ^\n/tm"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationSize =\
    \ factorization.count\n    var factorizationIndex = factorizationSize - 1\n  \
    \  var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[factorizationLastIndex]\n    var factorizationLastIndex = factorizationSize\
    \ - 1\n    var factorizationLast = factorization[factorizationLastIndex]\n   \
    \ var factorizationLastIndex = factorizationSize - 1\n    var factorizationLast\
    \ = factorization[\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7nrqhr5m.swift:58:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp7nrqhr5m.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp08qhr2im.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmp08qhr2im.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmp08qhr2im.swift:40:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationProduct = 1\n    var factorizationProductSum = 0\n    var factorizationProductProduct\
    \ = 1\n    var factorizationProductProductSum = 0\n    var factorizationProductProductProduct\
    \ = 1\n    var factorizationProductProductProductSum = 0\n    var factorizationProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductSum = 0\n    var factorizationProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductSum = 0\n    var\
    \ factorizationProductProductProductProductProductProduct = 1\n    var factorizationProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProduct\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfbngglbp.swift:36:9: error: invalid redeclaration of 'factorizationProductProductProductProductProductProductProductProductProductProductSum'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpfbngglbp.swift:34:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductSum'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpfbngglbp.swift:39:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProduct'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpfbngglbp.swift:37:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductProductProduct'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpfbngglbp.swift:42:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpfbngglbp.swift:40:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpfbngglbp.swift:43:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpfbngglbp.swift:41:9: note: 'factorizationProductProductProductProductProductProductProductProd"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [[Int]] = []\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = factorizationIndex\n    var factorizationIndexMax2 =\
    \ factorizationIndex\n    var factorizationIndexMax3 = factorizationIndex\n  \
    \  var factorizationIndexMax4 = factorizationIndex\n    var factorizationIndexMax5\
    \ = factorizationIndex\n    var factorizationIndexMax6 = factorizationIndex\n\
    \    var factorizationIndexMax7 = factorizationIndex\n    var factorizationIndexMax8\
    \ = factorizationIndex\n    var factorizationIndexMax9 = factorizationIndex\n\
    \    var factorizationIndexMax10 = factorizationIndex\n    var factorizationIndexMax11\
    \ = factorizationIndex\n    var factorizationIndexMax12 = factorizationIndex\n\
    \    var factorizationIndexMax13 = factorizationIndex\n    var factorizationIndexMax14\
    \ = factorizationIndex\n    var factorizationIndexMax15 = factorizationIndex\n\
    \    var factorizationIndexMax16 = factorizationIndex\n    var factorizationIndexMax17\
    \ = factorizationIndex\n    var factorizationIndexMax18 = factorizationIndex\n\
    \    var factorizationIndexMax19 = factorizationIndex\n    var factorizationIndexMax20\
    \ = factorizationIndex\n    var factorizationIndexMax21 = factorizationIndex\n\
    \    var factorizationIndexMax22 = factorizationIndex\n    var factorizationIndexMax23\
    \ = factorizationIndex\n    var factorizationIndexMax24 = factorizationIndex\n\
    \    var factorizationIndexMax25 = factorizationIndex\n    var factorizationIndexMax26\
    \ = factorizationIndex\n    var factorizationIndexMax27 = factorizationIndex\n\
    \    var factorizationIndexMax28 = factorizationIndex\n    var factorizationIndexMax29\
    \ = factorizationIndex\n    var factorizationIndexMax30 = factorizationIndex\n\
    \    var factorizationIndexMax31 = factorizationIndex\n    var factorizationIndexMax32\
    \ = factorizationIndex\n    var factorizationIndexMax33 = factorizationIndex\n\
    \    var factorizationIndexMax34 = factorizationIndex\n    var factorizationIndexMax35\
    \ = factorizationIndex\n    var factorizationIndexMax36 = factorizationIndex\n\
    \    var factorizationIndexMax37 = factorizationIndex\n    var factorizationIndexMax38\
    \ = factorizationIndex\n    var factorizationIndexMax39 = factorizationIndex\n\
    \    var factorizationIndexMax40 = factorizationIndex\n    var factorizationIndexMax41\
    \ = factorizationIndex\n    var factorizationIndexMax42 = factorizationIndex\n\
    \    var factorizationIndexMax43 = factorizationIndex\n    var factorizationIndexMax44\
    \ = factorizationIndex\n    var factorizationIndexMax45 = factorizationIndex\n\
    \    var factorizationIndexMax46 = factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpflt41n__.swift:60:35: error: cannot find 'factor' in scope\n  \
    \  var factorizationIndexMax46 = factor\n                                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 2\n    var isPrimeCountMax2: Int = 2\n    var isPrimeCountMin2: Int =\
    \ 2\n    var isPrimeCountMax3: Int = 2\n    var isPrimeCountMin3: Int = 2\n  \
    \  var isPrimeCountMax4: Int = 2\n    var isPrimeCountMin4: Int = 2\n    var isPrimeCountMax5:\
    \ Int = 2\n    var isPrimeCountMin5: Int = 2\n    var isPrimeCountMax6: Int =\
    \ 2\n    var isPrimeCountMin6: Int = 2\n    var isPrimeCountMax7: Int = 2\n  \
    \  var isPrimeCountMin7: Int = 2\n    var isPrimeCountMax8: Int = 2\n    var isPrimeCountMin8:\
    \ Int = 2\n    var isPrimeCountMax9: Int = 2\n    var isPrimeCountMin9: Int =\
    \ 2\n    var isPrimeCountMax10: Int = 2\n    var isPrimeCountMin10: Int = 2\n\
    \    var isPrimeCountMax11: Int = 2\n    var isPrimeCountMin11: Int = 2\n    var\
    \ isPrimeCountMax12: Int = 2\n    var isPrimeCountMin12: Int = 2\n    var isPrimeCountMax13:\
    \ Int = 2\n    var isPrimeCountMin13: Int = 2\n    var isPrimeCountMax14: Int\
    \ = 2\n    var isPrimeCountMin14: Int = 2\n    var isPrimeCountMax15: Int = 2\n\
    \    var isPrimeCountMin15: Int = 2\n    var isPrimeCountMax16: Int = 2\n    var\
    \ isPrimeCountMin16: Int = 2\n    var isPrimeCountMax17: Int = 2\n    var isPrimeCountMin17:\
    \ Int = 2\n    var isPrimeCountMax18: Int = 2\n    var isPrimeCountMin18: Int\
    \ = 2\n    var isPrimeCountMax19: Int = 2\n    var isPrimeCountMin19: Int = 2\n\
    \    var isPrimeCountMax20: Int = 2\n    var isPrimeCountMin20: Int = 2\n    var\
    \ isPrimeCountMax21: Int = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppe06rca_.swift:56:33: error: expected initial value after '='\n\
    \    var isPrimeCountMax21: Int = \n                                ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberSum = 0\n    var factorizationNumberSumCount\
    \ = 0\n    var factorizationNumberSumIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuqbow55w.swift:22:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmpuqbow55w.swift:24:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmpuqbow55w.swift:26:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmpuqbow55w.swift:28:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmpuqbow55w.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared h"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        factors.append(factor)\n   \
    \     factorizationCount *= factor\n    }\n    \n    var factorizationCount2 =\
    \ 1\n    for factor in factorization {\n        factors.append(factor)\n     \
    \   factorizationCount2 *= factor\n    }\n    \n    if factorizationCount != factorizationCount2\
    \ {\n        print(\"factorizationCount != factorizationCount2\")\n    }\n   \
    \ \n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaa4iyje1.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var remainder = n\n\n    while remainder > 1 {\n\
    \        if remainder % factor == 0 {\n            factorization[factor-1] +=\
    \ 1\n            remainder /= factor\n        } else {\n            factor +=\
    \ 1\n        }\n    }\n\n    return factorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0660a24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b066071b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b066071b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b066071b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b066071abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b066051a7ec <unavailable> + 186348

    6    tmp4r3b_fes                        0x000055e2960f7d48 <unavailable> + 7496

    7    tmp4r3b_fes                        0x000055e2960f739b <unavailable> + 5019

    8    libc.so.6                          0x00002b0660c10460 __libc_start_main +
    245

    9    tmp4r3b_fes                        0x000055e2960f70b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var\
    \ isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n  \
    \  var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n\
    \    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 =\
    \ 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var isPrimeIndex31 = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprghzeqim.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmprghzeqim.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmprghzeqim.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmprghzeqim.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmprghzeqim.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmprghzeqim.swift:16:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmprghzeqim.swift:17:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmprghzeqim.swift:18:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmprghzeqim.swift:19:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmprghzeqim.swift:20:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmprghzeqim.swift:21:9: warning: initialization\
    \ of variable 'isPrimeCount3' was never used; consider replacing "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationIndex = 0\n \
    \   var factorizationIndex = 0\n    var primeFactorizationArray: [Int] = []\n\
    \    var factorizationArray: [Int] = []\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2x96qq8b.swift:24:9: error: invalid redeclaration of 'primeFactorizationArrayIndex'\n\
    \    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp2x96qq8b.swift:20:9:\
    \ note: 'primeFactorizationArrayIndex' previously declared here\n    var primeFactorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp2x96qq8b.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationArrayIndex'\n    var factorizationArrayIndex = 0\n        ^\n\
    /tmp/tmp2x96qq8b.swift:21:9: note: 'factorizationArrayIndex' previously declared\
    \ here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp2x96qq8b.swift:26:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp2x96qq8b.swift:22:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp2x96qq8b.swift:27:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArrayCount = 0\n        ^\n/tmp/tmp2x96qq8b.swift:23:9:\
    \ note: 'factorizationArrayCount' previously declared here\n    var factorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp2x96qq8b.swift:28:9: error: invalid redeclaration of\
    \ 'primeFactorizationArrayIndex'\n    var primeFactorizationArrayIndex = 0\n \
    \       ^\n/tmp/tmp2x96qq8b.swift:20:9: note: 'primeFactorizationArrayIndex' previously\
    \ declared here\n    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp2x96qq8b.swift:29:9:\
    \ error: invalid redeclaration of 'factorizationArrayIndex'\n    var factorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp2x96qq8b.swift:21:9: note: 'factorizationArrayIndex'\
    \ previously declared here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp2x96qq8b.swift:30:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp2x96qq8b.swift:22:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp2x96qq8b.swift:31:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArray"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumCountMax\
    \ = 0\n    var isPrimeSumCountMaxCount = 0\n    var isPrimeSumCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCount = 0\n    var isPrimeSumCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCount = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCount = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax = 0\n    var\
    \ isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCount = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax = 0\n\
    \    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount = 0\n\
    \    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount = 0\n\
    \    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax =\
    \ 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx1_sugdr.swift:27:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax'\n\
    \    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax = 0\n        ^\n/tmp/tmpx1_sugdr.swift:26:9:\
    \ note: 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax' previously declared\
    \ here\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMax = 0\n     \
    \   ^\n/tmp/tmpx1_sugdr.swift:30:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\n\
    \    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax = 0\n    \
    \    ^\n/tmp/tmpx1_sugdr.swift:29:9: note: 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n        ^\n/tmp/tmpx1_sugdr.swift:32:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount'\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount\
    \ = 0\n        ^\n/tmp/tmpx1_sugdr.swift:31:9: note: 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCount\
    \ = 0\n        ^\n/tmp/tmpx1_sugdr.swift:34:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\n    var\
    \ isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax = 0\n   \
    \     ^\n/tmp/tmpx1_sugdr.swift:33:9: note: 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax\
    \ = 0\n        ^\n/tmp/tmpx1_sugdr.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\n    var\
    \ isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax = 0\n   \
    \     ^\n/tmp/tmpx1_sugdr.swift:33:9: note: 'isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCountMaxCountMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxCountMaxCountMaxCountMaxCo"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i < n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmjxqcjd9.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime: Bool = false\n    var isPrimeCount = 0\n    var isPrimePrime:\
    \ Bool = false\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var is\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcit7vu3y.swift:43:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpcit7vu3y.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpcit7vu3y.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpcit7vu3y.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:34:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpcit7vu3y.swift:37:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n     \
    \   ^\n/tmp/tmpcit7vu3y.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePri"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n   \
    \ var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n\
    \    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int =\
    \ 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int\
    \ = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e:\
    \ Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var\
    \ i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n   \
    \ var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n\
    \    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int =\
    \ 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int\
    \ = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c:\
    \ Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var\
    \ g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n   \
    \ var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n\
    \    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\
    \ 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int\
    \ = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a:\
    \ Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var\
    \ e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n   \
    \ var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n\
    \    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int =\
    \ 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int\
    \ = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y:\
    \ Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var\
    \ c: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfpsllqf2.swift:39:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:40:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:24:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var k = 0\n    while i * j <= n {\n       \
    \ if n % i == 0 {\n            factors.append(i)\n            n /= i\n       \
    \     j += 1\n        }\n        if n % j == 0 {\n            factors.append(j)\n\
    \            n /= j\n            k += 1\n        }\n        i += 1\n        j\
    \ += 1\n    }\n    if n != 1 {\n        factors.append(n)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcsoyl06f.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpcsoyl06f.swift:24:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var isPrime: Bool = false\n    var isPrime2:\
    \ Bool = false\n    var isPrime3: Bool = false\n    var isPrime4: Bool = false\n\
    \    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n    var isPrime7:\
    \ Bool = false\n    var isPrime8: Bool = false\n    var isPrime9: Bool = false\n\
    \    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n    var isPrime12:\
    \ Bool = false\n    var isPrime13: Bool = false\n    var isPrime14: Bool = false\n\
    \    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n    var isPrime17:\
    \ Bool = false\n    var isPrime18: Bool = false\n    var isPrime19: Bool = false\n\
    \    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n    var isPrime22:\
    \ Bool = false\n    var isPrime23: Bool = false\n    var isPrime24: Bool = false\n\
    \    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n    var isPrime27:\
    \ Bool = false\n    var isPrime28: Bool = false\n    var isPrime29: Bool = false\n\
    \    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n    var isPrime32:\
    \ Bool = false\n    var isPrime33: Bool = false\n    var isPrime34: Bool = false\n\
    \    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n    var isPrime37:\
    \ Bool = false\n    var isPrime38: Bool = false\n    var isPrime39: Bool = false\n\
    \    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n    var isPrime42:\
    \ Bool = false\n    var isPrime43: Bool = false\n    var isPrime44: Bool = false\n\
    \    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n    var isPrime47:\
    \ Bool = false\n    var isPrime48: Bool = false\n    var isPrime49: Bool = false\n\
    \    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n    var isPrime52:\
    \ Bool = false\n    var isPrime53: Bool = false\n    var isPrime54: Bool = false\n\
    \    var isPrime55: Bool = false\n    var isPrime56: Bool = false\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpozwn1qka.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpozwn1qka.swift:14:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:15:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:16:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:17:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:18:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:19:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:20:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:21:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:22:9:\
    \ warning: variable 'isPrime9' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime9: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpozwn1qka.swift:23:9:\
    \ warning: variable 'isPrime10' was never used; consider replacing with '_' or\
    \ removing it\n    va"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4ftvjtj7.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp4ftvjtj7.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp4ftvjtj7.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp4ftvjtj7.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp4ftvjtj7.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp4ftvjtj7.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp4ftvjtj7.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isP"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex\
    \ = 0\n    var isPrimeCount = 0\n    var isPrimeCountIndex = 0\n    var isPrimeCountMax\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMin = 0\n    var\
    \ isPrimeCountMinIndex = 0\n    var isPrimeCountSum = 0\n    var isPrimeCountSumIndex\
    \ = 0\n    var isPrimeCountProduct = 0\n    var isPrimeCountProductIndex = 0\n\
    \    var isPrimeCountProductMax = 0\n    var isPrimeCountProductMaxIndex = 0\n\
    \    var isPrimeCountProductMin = 0\n    var isPrimeCountProductMinIndex = 0\n\
    \    var isPrimeCountProductSum = 0\n    var isPrimeCountProductSumIndex = 0\n\
    \    var isPrimeCountProductProduct = 0\n    var isPrimeCountProductProductIndex\
    \ = 0\n    var isPrimeCountProductProductMax = 0\n    var isPrimeCountProductProductMaxIndex\
    \ = 0\n    var isPrimeCountProductProductMin = 0\n    var isPrimeCountProductProductMinIndex\
    \ = 0\n    var isPrimeCountProductProductSum = 0\n    var isPrimeCountProductProductSumIndex\
    \ = 0\n    var isPrimeCountProductProductProduct = 0\n    var isPrimeCountProductProductProductIndex\
    \ = 0\n    var isPrimeCountProductProductProductMax = 0\n    var isPrimeCountProductProductProductMaxIndex\
    \ = 0\n    var isPrimeCountProductProductProductMin = 0\n    var isPrimeCountProductProductProductMinIndex\
    \ = 0\n    var isPrimeCountProductProductProductSum = 0\n    var isPrimeCountProductProductProductSumIndex\
    \ = 0\n    var isPrimeCountProductProductProductProduct = 0\n    var isPrimeCountProductProductProductProductIndex\
    \ = 0\n    var isPrimeCountProductProductProductProductMax = 0\n    var isPrimeCountProductProductProductProductMaxIndex\
    \ = 0\n    var isPrimeCountProductProductProductProductMin = 0\n    var isPrimeCountProductProductProductProductMinIndex\
    \ = 0\n    var isPrimeCountProductProductProductProductSum = 0\n    var isPrimeCountProductProductProductProductSumIndex\
    \ = 0\n    var isPrimeCountProductProductProductProductProduct = 0\n    var isPrimeCountProductProductProductProductProductIndex\
    \ = 0\n    var isPrimeCountProductProductProductProductProductMax = 0\n    var\
    \ isPrimeCountProductProductProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductProductProductMin\
    \ = 0\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprgls2pq0.swift:61:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount:\
    \ Int = 0\n    var factorizationCount: Int = 0\n    var factorizationSum: Int\
    \ = 0\n    var factorizationSumCount: Int = 0\n    var factorizationSumCount2:\
    \ Int = 0\n    var factorizationSumCount3: Int = 0\n    var factorizationSumCount4:\
    \ Int = 0\n    var factorizationSumCount5: Int = 0\n    var factorizationSumCount6:\
    \ Int = 0\n    var factorizationSumCount7: Int = 0\n    var factorizationSumCount8:\
    \ Int = 0\n    var factorizationSumCount9: Int = 0\n    var factorizationSumCount10:\
    \ Int = 0\n    var factorizationSumCount11: Int = 0\n    var factorizationSumCount12:\
    \ Int = 0\n    var factorizationSumCount13: Int = 0\n    var factorizationSumCount14:\
    \ Int = 0\n    var factorizationSumCount15: Int = 0\n    var factorizationSumCount16:\
    \ Int = 0\n    var factorizationSumCount17: Int = 0\n    var factorizationSumCount18:\
    \ Int = 0\n    var factorizationSumCount19: Int = 0\n    var factorizationSumCount20:\
    \ Int = 0\n    var factorizationSumCount21: Int = 0\n    var factorizationSumCount22:\
    \ Int = 0\n    var factorizationSumCount23: Int = 0\n    var factorizationSumCount24:\
    \ Int = 0\n    var factorizationSumCount25: Int = 0\n    var factorizationSumCount26:\
    \ Int = 0\n    var factorizationSumCount27: Int = 0\n    var factorizationSumCount28:\
    \ Int = 0\n    var factorizationSumCount29: Int = 0\n    var factorizationSumCount30:\
    \ Int = 0\n    var factorizationSumCount31: Int = 0\n    var factorizationSumCount32:\
    \ Int = 0\n    var factorizationSumCount33: Int = 0\n    var factorizationSumCount34:\
    \ Int = 0\n    var factorizationSumCount35: Int = 0\n    var factorizationSumCount36:\
    \ Int = 0\n    var factorizationSumCount37: Int = 0\n    var factorizationSumCount38:\
    \ Int = 0\n    var factorizationSumCount39: Int = 0\n    var factorizationSumCount40:\
    \ Int = 0\n    var factorizationSumCount41: Int = 0\n    var factorizationSumCount42:\
    \ Int = 0\n    var factorizationSumCount43: Int = 0\n    var factorizationSumCount44:\
    \ Int = 0\n    var factorizationSumCount45: Int = 0\n    var factorizationSumCount46:\
    \ Int = 0\n    var factorizationSumCount47: Int = 0\n    var factorizationSumCount48:\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2x5j6qdx.swift:64:33: error: expected type\n    var factorizationSumCount48:\
    \ \n                                ^\n                                 <#type#>\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n != 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpow4ovtn0.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationMax\
    \ = 0\n    var factorizationMin = Int()\n    var factorizationMaxIndex = Int()\n\
    \    var factorizationMinIndex = Int()\n    var factorizationMaxValue = Int()\n\
    \    var factorizationMinValue = Int()\n    var factorizationMaxValueIndex = Int()\n\
    \    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValueIndex = Int()\n    var factorizationMaxValueIndex\
    \ = Int()\n    var factorizationMinValue\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5mn7b2jc.swift:23:9: error: invalid redeclaration of 'factorizationMaxValueIndex'\n\
    \    var factorizationMaxValueIndex = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:21:9:\
    \ note: 'factorizationMaxValueIndex' previously declared here\n    var factorizationMaxValueIndex\
    \ = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:24:9: error: invalid redeclaration\
    \ of 'factorizationMinValueIndex'\n    var factorizationMinValueIndex = Int()\n\
    \        ^\n/tmp/tmp5mn7b2jc.swift:22:9: note: 'factorizationMinValueIndex' previously\
    \ declared here\n    var factorizationMinValueIndex = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationMaxValueIndex'\n    var factorizationMaxValueIndex\
    \ = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:21:9: note: 'factorizationMaxValueIndex'\
    \ previously declared here\n    var factorizationMaxValueIndex = Int()\n     \
    \   ^\n/tmp/tmp5mn7b2jc.swift:26:9: error: invalid redeclaration of 'factorizationMinValueIndex'\n\
    \    var factorizationMinValueIndex = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:22:9:\
    \ note: 'factorizationMinValueIndex' previously declared here\n    var factorizationMinValueIndex\
    \ = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:27:9: error: invalid redeclaration\
    \ of 'factorizationMaxValueIndex'\n    var factorizationMaxValueIndex = Int()\n\
    \        ^\n/tmp/tmp5mn7b2jc.swift:21:9: note: 'factorizationMaxValueIndex' previously\
    \ declared here\n    var factorizationMaxValueIndex = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:28:9:\
    \ error: invalid redeclaration of 'factorizationMinValueIndex'\n    var factorizationMinValueIndex\
    \ = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:22:9: note: 'factorizationMinValueIndex'\
    \ previously declared here\n    var factorizationMinValueIndex = Int()\n     \
    \   ^\n/tmp/tmp5mn7b2jc.swift:29:9: error: invalid redeclaration of 'factorizationMaxValueIndex'\n\
    \    var factorizationMaxValueIndex = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:21:9:\
    \ note: 'factorizationMaxValueIndex' previously declared here\n    var factorizationMaxValueIndex\
    \ = Int()\n        ^\n/tmp/tmp5mn7b2jc.swift:30:9: error: invalid redeclara"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = 0\n    var factorizationMin = Int()\n    var factorizationSum\
    \ = 0\n    var factorizationSumCount = 0\n    var factorizationSumIndex = 0\n\
    \    var factorizationSumMax = 0\n    var factorizationSumMin = Int()\n    var\
    \ factorizationSumSum = 0\n    var factorizationSumSumCount = 0\n    var factorizationSumSumIndex\
    \ = 0\n    var factorizationSumSumMax = 0\n    var factorizationSumSumMin = Int()\n\
    \    var factorizationSumSumSum = 0\n    var factorizationSumSumSumCount = 0\n\
    \    var factorizationSumSumSumIndex = 0\n    var factorizationSumSumSumMax =\
    \ 0\n    var factorizationSumSumSumMin = Int()\n    var factorizationSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumCount = 0\n    var factorizationSumSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumSumMax = 0\n    var factorizationSumSumSumSumMin\
    \ = Int()\n    var factorizationSumSumSumSumSum = 0\n    var factorizationSumSumSumSumCount\
    \ = 0\n    var factorizationSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMin = Int()\n    var factorizationSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumCount = 0\n    var factorizationSumSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumSumMax = 0\n    var factorizationSumSumSumSumMin\
    \ = Int()\n    var factorizationSumSumSumSumSumSum = 0\n    var factorizationSumSumSumSumSumCount\
    \ = 0\n    var factorizationSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMin = Int()\n    var factorizationSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumCount = 0\n    var factorizationSumSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumSumMax = 0\n    var factorizationSumSumSumSumMin\
    \ = Int()\n    var factorizationSumSumSumSumSum = 0\n    var factorizationSumSumSumSumSumCount\
    \ = 0\n    var factorizationSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMin = Int()\n    var factorizationSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumCount = 0\n    var factorizationSumSumSumSumSumIndex\
    \ = 0\n    var factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt4yhrdmi.swift:38:9: error: invalid redeclaration of 'factorizationSumSumSumSumCount'\n\
    \    var factorizationSumSumSumSumCount = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:33:9:\
    \ note: 'factorizationSumSumSumSumCount' previously declared here\n    var factorizationSumSumSumSumCount\
    \ = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:39:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumSumIndex'\n    var factorizationSumSumSumSumIndex = 0\n\
    \        ^\n/tmp/tmpt4yhrdmi.swift:34:9: note: 'factorizationSumSumSumSumIndex'\
    \ previously declared here\n    var factorizationSumSumSumSumIndex = 0\n     \
    \   ^\n/tmp/tmpt4yhrdmi.swift:40:9: error: invalid redeclaration of 'factorizationSumSumSumSumMax'\n\
    \    var factorizationSumSumSumSumMax = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:35:9:\
    \ note: 'factorizationSumSumSumSumMax' previously declared here\n    var factorizationSumSumSumSumMax\
    \ = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:41:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumSumMin'\n    var factorizationSumSumSumSumMin = Int()\n\
    \        ^\n/tmp/tmpt4yhrdmi.swift:36:9: note: 'factorizationSumSumSumSumMin'\
    \ previously declared here\n    var factorizationSumSumSumSumMin = Int()\n   \
    \     ^\n/tmp/tmpt4yhrdmi.swift:42:9: error: invalid redeclaration of 'factorizationSumSumSumSumSum'\n\
    \    var factorizationSumSumSumSumSum = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:37:9:\
    \ note: 'factorizationSumSumSumSumSum' previously declared here\n    var factorizationSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:43:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumSumCount'\n    var factorizationSumSumSumSumCount = 0\n\
    \        ^\n/tmp/tmpt4yhrdmi.swift:33:9: note: 'factorizationSumSumSumSumCount'\
    \ previously declared here\n    var factorizationSumSumSumSumCount = 0\n     \
    \   ^\n/tmp/tmpt4yhrdmi.swift:44:9: error: invalid redeclaration of 'factorizationSumSumSumSumIndex'\n\
    \    var factorizationSumSumSumSumIndex = 0\n        ^\n/tmp/tmpt4yhrdmi.swift:34:9:\
    \ note: 'factorizationSumSumSumSumIndex' previously declared here\n    var factorizationSumSumSumSumIndex\
    \ = 0\n        ^\n/tmp/tmpt4yhr"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp22g9hy0z.swift:18:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmp22g9hy0z.swift:16:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:19:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmp22g9hy0z.swift:17:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:20:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmp22g9hy0z.swift:16:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:21:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmp22g9hy0z.swift:17:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:22:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmp22g9hy0z.swift:16:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:23:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmp22g9hy0z.swift:17:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:24:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmp22g9hy0z.swift:16:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:25:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmp22g9hy0z.swift:17:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmp22g9hy0z.swift:26:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    va"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationValue = 1\n    var\
    \ factorizationValueIndex = 0\n    var factorizationValueIndexMax = factorization.count\n\
    \    var factorizationValueMax = factorization[factorizationValueIndex]\n    var\
    \ factorizationValueMin = factorization[factorizationValueIndex - 1]\n    var\
    \ factorizationValueMinIndex = factorization.index(of: factorizationValueMin)\n\
    \    var factorizationValueMaxIndex = factorization.index(of: factorizationValueMax)\n\
    \    var factorizationValueMinValue = factorization[factorizationValueMinIndex]\n\
    \    var factorizationValueMaxValue = factorization[factorizationValueMaxIndex]\n\
    \    var factorizationValueMinValueIndex = factorization.index(of: factorizationValueMinValue)\n\
    \    var factorizationValueMaxValueIndex = factorization.index(of: factorizationValueMaxValue)\n\
    \    var factorizationValueMinValueIndexMax = factorization.index(of: factorizationValueMinValueIndex)\n\
    \    var factorizationValueMaxValueIndexMax = factorization.index(of: factorizationValueMaxValueIndex)\n\
    \    var factorizationValueMinValueIndexMin = factorization.index(of: factorizationValueMinValueIndexMax)\n\
    \    var factorizationValueMaxValueIndexMin = factorization.index(of: factorizationValueMaxValueIndexMax)\n\
    \    var factorizationValueMinValueIndexMinMax = factorization.index(of: factorizationValueMinValueIndexMin)\n\
    \    var factorizationValueMaxValueIndexMinMax = factorization.index(of: factorizationValueMaxValueIndexMin)\n\
    \    var factorizationValueMinValueIndexMinMax = factorization.index(of: factorizationValueMinValueIndexMinMax)\n\
    \    var factorizationValueMaxValueIndexMinMax = factorization.index(of: factorizationValueMaxValueIndexMinMax)\n\
    \    var factorizationValueMinValueIndexMinMax = factorization.index(of: factorizationValueMinValueIndexMinMax)\n\
    \    var factorizationValueMaxValueIndexMinMax = factorization.index(of: factorizationValueMaxValueIndexMinMax)\n\
    \    var factorizationValueMinValueIndexMinMax = factorization.index(of: factorizationValueMinValueIndexMinMax)\n\
    \    var factorizationValueMaxValueIndexMinMax = factorization.index(of: factorizationValueMaxValueIndexMinMax)\n\
    \    var factorizationValueMinValueIndexMinMax = factorization.index(of: factorizationValueMinValueIndexMinMax)\n\
    \    var factorizationValueMaxValueIndexMinMax = factorization.index(of: factorizationValueMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplpa07end.swift:41:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmplpa07end.swift:40:68: note: to match this opening '('\n    var factorizationValueMaxValueIndexMinMax\
    \ = factorization.index(of: factorizationValueMax\n                          \
    \                                         ^\n/tmp/tmplpa07end.swift:13:25: error:\
    \ cannot find 'factorizationOfNumber' in scope\n    var factorization = factorizationOfNumber(n)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = true\n    var\
    \ isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime = true\n  \
    \  var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv6_j1n_q.swift:32:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpv6_j1n_q.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpv6_j1n_q.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpv6_j1n_q.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpv6_j1n_q.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpv6_j1n_q.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpv6_j1n_q.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpv6_j1n_q.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactoriz"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var primeFactorization\
    \ = factorizationOfNumber(n)\n    var primeFactorizationIndex = -1\n    var factorizationIndex\
    \ = -1\n    var factorizationIndex2 = -1\n    var factorizationIndex3 = -1\n \
    \   var factorizationIndex4 = -1\n    var factorizationIndex5 = -1\n    var factorizationIndex6\
    \ = -1\n    var factorizationIndex7 = -1\n    var factorizationIndex8 = -1\n \
    \   var factorizationIndex9 = -1\n    var factorizationIndex10 = -1\n    var factorizationIndex11\
    \ = -1\n    var factorizationIndex12 = -1\n    var factorizationIndex13 = -1\n\
    \    var factorizationIndex14 = -1\n    var factorizationIndex15 = -1\n    var\
    \ factorizationIndex16 = -1\n    var factorizationIndex17 = -1\n    var factorizationIndex18\
    \ = -1\n    var factorizationIndex19 = -1\n    var factorizationIndex20 = -1\n\
    \    var factorizationIndex21 = -1\n    var factorizationIndex22 = -1\n    var\
    \ factorizationIndex23 = -1\n    var factorizationIndex24 = -1\n    var factorizationIndex25\
    \ = -1\n    var factorizationIndex26 = -1\n    var factorizationIndex27 = -1\n\
    \    var factorizationIndex28 = -1\n    var factorizationIndex29 = -1\n    var\
    \ factorizationIndex30 = -1\n    var factorizationIndex31 = -1\n    var factorizationIndex32\
    \ = -1\n    var factorizationIndex33 = -1\n    var factorizationIndex34 = -1\n\
    \    var factorizationIndex35 = -1\n    var factorizationIndex36 = -1\n    var\
    \ factorizationIndex37 = -1\n    var factorizationIndex38 = -1\n    var factorizationIndex39\
    \ = -1\n    var factorizationIndex40 = -1\n    var factorizationIndex41 = -1\n\
    \    var factorizationIndex42 = -1\n    var factorizationIndex43 = -1\n    var\
    \ factorizationIndex44 = -1\n    var factorizationIndex45 = -1\n    var factorizationIndex46\
    \ = -1\n    var factorizationIndex47 = -1\n    var factorizationIndex48 = -1\n\
    \    var factorizationIndex49 = -1\n    var factorizationIndex50 = -1\n    var\
    \ factorizationIndex51 = -1\n    var factorizationIndex52 = -1\n    var factorizationIndex53\
    \ = -1\n    var factorizationIndex54 = -1\n    var factorizationIndex55 = -1\n\
    \    var factorizationIndex56 = -1\n    var factorizationIndex57 = -1\n    var\
    \ factorizationIndex58 = -1\n    var factorizationIndex59 = -1\n    var factorizationIndex60\
    \ = -1\n    var factorizationIndex61 = -1\n    var factorizationIndex62 = -1\n\
    \    var factorizationIndex63 = -1\n    var factorizationIndex64 = -1\n    var\
    \ factorizationIndex65 = -1\n    var factorizationIndex66 = -1\n    var factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv2b4wc3l.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv2b4wc3l.swift:14:30: error: cannot find\
    \ 'factorizationOfNumber' in scope\n    var primeFactorization = factorizationOfNumber(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv2b4wc3l.swift:82:9:\
    \ error: type annotation missing in pattern\n    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp337ks_2p.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumOfFactors = 0\n    var factorizationSumOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactors = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplb08zgl6.swift:23:9: error: invalid redeclaration of 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:22:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:27:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFac"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > factors.count\
    \ {\n            factors.append(factor)\n        } else {\n            for _ in\
    \ 0..<factors[factors.count-1] {\n                factors.append(factor)\n   \
    \         }\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppf5incq9.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var factorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var factorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var factorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var factorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var factorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var factorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var factorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var factorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var factorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var factorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var factorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var factorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var factorizationNumberIndex27 = 0\n    var factorizationNumberIndex28\
    \ = 0\n    var factorizationNumberIndex29 = 0\n    var factorizationNumberIndex30\
    \ = 0\n    var factorizationNumberIndex31 = 0\n    var factorizationNumberIndex32\
    \ = 0\n    var factorizationNumberIndex33 = 0\n    var factorizationNumberIndex34\
    \ = 0\n    var factorizationNumberIndex35 = 0\n    var factorizationNumberIndex36\
    \ = 0\n    var factorizationNumberIndex37 = 0\n    var factorizationNumberIndex38\
    \ = 0\n    var factorizationNumberIndex39 = 0\n    var factorizationNumberIndex40\
    \ = 0\n    var factorizationNumberIndex41 = 0\n    var factorizationNumberIndex42\
    \ = 0\n    var factorizationNumberIndex43 = 0\n    var factorizationNumberIndex44\
    \ = 0\n    var factorizationNumberIndex45 = 0\n    var factorizationNumberIndex46\
    \ = 0\n    var factorizationNumberIndex47 = 0\n    var factorizationNumberIndex48\
    \ = 0\n    var factorizationNumberIndex49 = 0\n    var factorizationNumberIndex50\
    \ = 0\n    var factorizationNumberIndex51 = 0\n    var factorizationNumberIndex52\
    \ = 0\n    var factorizationNumberIndex53 = 0\n    var factorizationNumberIndex54\
    \ = 0\n    var factorizationNumberIndex55 = 0\n    var factorizationNumberIndex56\
    \ = 0\n    var factorizationNumberIndex57 = 0\n    var factorizationNumberIndex58\
    \ = 0\n    var factorizationNumberIndex59 = 0\n    var factorizationNumberIndex60\
    \ = 0\n    var factorizationNumberIndex61 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcpfe9y4m.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpcpfe9y4m.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcpfe9y4m.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:15:9:\
    \ warning: initialization of variable 'factorizationNumber' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumber\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:16:9: warning:\
    \ initialization of variable 'factorizationNumberIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:17:9: warning:\
    \ initialization of variable 'factorizationNumberIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:18:9:\
    \ warning: initialization of variable 'factorizationNumberIndex3' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:19:9:\
    \ warning: initialization of variable 'factorizationNumberIndex4' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:20:9:\
    \ warning: initialization of variable 'factorizationNumberIndex5' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex5\
    \ = 0\n    ~~~~^~~"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = 0\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = false\n   \
    \ var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount = 1\n \
    \   var isPrimeFactorizationIsPrime = true\n    var isPrimeFactorizationIsPrimeIndex\
    \ = 0\n    var isPrimeFactorizationIsPrimeCount = 1\n    var isPrimeFactorizationIsPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIndex = 0\n    var\
    \ isPrimeFactorizationIsPrimeFactorizationCount = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrime\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeIndex = 0\n\
    \    var isPrimeFactorizationIsPrimeFactorizationIsPrimeCount = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrime\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeIndex\
    \ = 0\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeCount\
    \ = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrime\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeIndex\
    \ = 0\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeCount\
    \ = 1\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptq4i95zg.swift:42:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIsPrimeFactorizationIndex\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorizationCount = 0\n    var currentFactorizationIndex: Int\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndexCountLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimit: Int = 0\n    var currentFactorizationIndexLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var\
    \ currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n  \
    \  var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n  \
    \  var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit:\
    \ Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n  \
    \  var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n    var currentFactorizationIndexLimitLimitLimitLimit:\
    \ Int = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx2h2p68e.swift:53:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpx2h2p68e.swift:23:9: error: invalid redeclaration of 'currentFactorizationIndexLimitLimitLimitLimit'\n\
    \    var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:22:9:\
    \ note: 'currentFactorizationIndexLimitLimitLimitLimit' previously declared here\n\
    \    var currentFactorizationIndexLimitLimitLimitLimit: Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:25:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexLimitLimitLimitLimitLimit'\n\
    \    var currentFactorizationIndexLimitLimitLimitLimitLimit: Int = 0\n       \
    \ ^\n/tmp/tmpx2h2p68e.swift:24:9: note: 'currentFactorizationIndexLimitLimitLimitLimitLimit'\
    \ previously declared here\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:26:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndexLimitLimitLimitLimitLimit'\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:24:9: note: 'currentFactorizationIndexLimitLimitLimitLimitLimit'\
    \ previously declared here\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:27:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndexLimitLimitLimitLimitLimit'\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:24:9: note: 'currentFactorizationIndexLimitLimitLimitLimitLimit'\
    \ previously declared here\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:28:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndexLimitLimitLimitLimitLimit'\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:24:9: note: 'currentFactorizationIndexLimitLimitLimitLimitLimit'\
    \ previously declared here\n    var currentFactorizationIndexLimitLimitLimitLimitLimit:\
    \ Int = 0\n        ^\n/tmp/tmpx2h2p68e.swift:29:9: error: invalid redeclaration\
    \ of 'currentFactorization"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var i = 2\n    var factor = 1\n    while i < n {\n        if n % i == 0 {\n\
    \            factor *= i\n            factors.append(factor)\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n\
    \        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpn5r94di7.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationMax = Int(sqrt(Double(n)))\n\
    \    var factorizationMin = factorizationMax\n    var factorizationSum = 0\n \
    \   var factorizationSumMax = 0\n    var factorizationSumMin = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9wy494it.swift:14:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp9wy494it.swift:21:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationSumMinIndex'\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:20:9: note: 'factorizationSumMinIndex' previously declared\
    \ here\n    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9: note: 'factorizationSumMaxIndex'\
    \ previously declared here\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:24:9: error: invalid redeclaration of 'factorizationSumMinIndex'\n\
    \    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:20:9:\
    \ note: 'factorizationSumMinIndex' previously declared here\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:19:9: note: 'factorizationSumMaxIndex' previously declared\
    \ here\n    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationSumMinIndex'\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:20:9: note: 'factorizationSumMinIndex'\
    \ previously declared here\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:27:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it"
  stdout: ''
  timestamp: 1659824876
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = Int(n)\n    while p > 1 {\n        while p % i ==\
    \ 0 {\n            factors.append(i)\n            p /= i\n        }\n        i\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var factorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex =\
    \ 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex2 = 0\n    var isPrimeFactorizationIndex3 =\
    \ 0\n    var isPrimeFactorizationIndex4 = 0\n    var isPrimeFactorizationIndex5\
    \ = 0\n    var isPrimeFactorizationIndex6 = 0\n    var isPrimeFactorizationIndex7\
    \ = 0\n    var isPrimeFactorizationIndex8 = 0\n    var isPrimeFactorizationIndex9\
    \ = 0\n    var isPrimeFactorizationIndex10 = 0\n    var isPrimeFactorizationIndex11\
    \ = 0\n    var isPrimeFactorizationIndex12 = 0\n    var isPrimeFactorizationIndex13\
    \ = 0\n    var isPrimeFactorizationIndex14 = 0\n    var isPrimeFactorizationIndex15\
    \ = 0\n    var isPrimeFactorizationIndex16 = 0\n    var isPrimeFactorizationIndex17\
    \ = 0\n    var isPrimeFactorizationIndex18 = 0\n    var isPrimeFactorizationIndex19\
    \ = 0\n    var isPrimeFactorizationIndex20 = 0\n    var isPrimeFactorizationIndex21\
    \ = 0\n    var isPrimeFactorizationIndex22 = 0\n    var isPrimeFactorizationIndex23\
    \ = 0\n    var isPrimeFactorizationIndex24 = 0\n    var isPrimeFactorizationIndex25\
    \ = 0\n    var isPrimeFactorizationIndex26 = 0\n    var isPrimeFactorizationIndex27\
    \ = 0\n    var isPrimeFactorizationIndex28 = 0\n    var isPrimeFactorizationIndex29\
    \ = 0\n    var isPrimeFactorizationIndex30 = 0\n    var isPrimeFactorizationIndex31\
    \ = 0\n    var isPrimeFactorizationIndex32 = 0\n    var isPrimeFactorizationIndex33\
    \ = 0\n    var isPrimeFactorizationIndex34 = 0\n    var isPrimeFactorizationIndex35\
    \ = 0\n    var isPrimeFactorizationIndex36 = 0\n    var isPrimeFactorizationIndex37\
    \ = 0\n    var isPrimeFactorizationIndex38 = 0\n    var isPrimeFactorizationIndex39\
    \ = 0\n    var isPrimeFactorizationIndex40 = 0\n    var isPrimeFactorizationIndex41\
    \ = 0\n    var isPrimeFactorizationIndex42 = 0\n    var isPrimeFactorizationIndex43\
    \ = 0\n    var isPrimeFactorizationIndex44 = 0\n    var isPrimeFactorizationIndex45\
    \ = 0\n    var isPrimeFactorizationIndex46 = 0\n    var is\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3z1ocymn.swift:65:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp3z1ocymn.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp3z1ocymn.swift:13:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3z1ocymn.swift:14:9: warning:\
    \ initialization of variable 'primeFactorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3z1ocymn.swift:15:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3z1ocymn.swift:16:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmp3z1ocymn.swift:17:9: warning:\
    \ initialization of variable 'isPrimeIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3z1ocymn.swift:18:9: warning: initialization of variable 'isPrimeFactorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmp3z1ocymn.swift:19:9: warning: initialization of variable 'isPrimeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization = true\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3z1ocymn.swift:20:9:\
    \ warning: initialization of variable 'isPrimeFactorizationIndex2' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var isPrimeFactorizationI"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var i = 2\n    var j = 0\n    var k = 0\n    var\
    \ temp = 0\n    var count = 0\n    var factorization = [Int]()\n    var isPrime\
    \ = [Bool]()\n    var isPrimeSet = [Bool]()\n    var isPrimeSet2 = []\n    var\
    \ isPrimeSet3 = []\n    var isPrimeSet4 = []\n    var isPrimeSet5 = []\n    var\
    \ isPrimeSet6 = []\n    var isPrimeSet7 = []\n    var isPrimeSet8 = []\n    var\
    \ isPrimeSet9 = []\n    var isPrimeSet10 = []\n    var isPrimeSet11 = []\n   \
    \ var isPrimeSet12 = []\n    var isPrimeSet13 = []\n    var isPrimeSet14 = []\n\
    \    var isPrimeSet15 = []\n    var isPrimeSet16 = []\n    var isPrimeSet17 =\
    \ []\n    var isPrimeSet18 = []\n    var isPrimeSet19 = []\n    var isPrimeSet20\
    \ = []\n    var isPrimeSet21 = []\n    var isPrimeSet22 = []\n    var isPrimeSet23\
    \ = []\n    var isPrimeSet24 = []\n    var isPrimeSet25 = []\n    var isPrimeSet26\
    \ = []\n    var isPrimeSet27 = []\n    var isPrimeSet28 = []\n    var isPrimeSet29\
    \ = []\n    var isPrimeSet30 = []\n    var isPrimeSet31 = []\n    var isPrimeSet32\
    \ = []\n    var isPrimeSet33 = []\n    var isPrimeSet34 = []\n    var isPrimeSet35\
    \ = []\n    var isPrimeSet36 = []\n    var isPrimeSet37 = []\n    var isPrimeSet38\
    \ = []\n    var isPrimeSet39 = []\n    var isPrimeSet40 = []\n    var isPrimeSet41\
    \ = []\n    var isPrimeSet42 = []\n    var isPrimeSet43 = []\n    var isPrimeSet44\
    \ = []\n    var isPrimeSet45 = []\n    var isPrimeSet46 = []\n    var isPrimeSet47\
    \ = []\n    var isPrimeSet48 = []\n    var isPrimeSet49 = []\n    var isPrimeSet50\
    \ = []\n    var isPrimeSet51 = []\n    var isPrimeSet52 = []\n    var isPrimeSet53\
    \ = []\n    var isPrimeSet54 = []\n    var isPrimeSet55 = []\n    var isPrimeSet56\
    \ = []\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpg0l3msyw.swift:77:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpg0l3msyw.swift:22:23: error: empty collection literal requires\
    \ an explicit type\n    var isPrimeSet2 = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:23:23:\
    \ error: empty collection literal requires an explicit type\n    var isPrimeSet3\
    \ = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:24:23: error: empty collection\
    \ literal requires an explicit type\n    var isPrimeSet4 = []\n              \
    \        ^~\n/tmp/tmpg0l3msyw.swift:25:23: error: empty collection literal requires\
    \ an explicit type\n    var isPrimeSet5 = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:26:23:\
    \ error: empty collection literal requires an explicit type\n    var isPrimeSet6\
    \ = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:27:23: error: empty collection\
    \ literal requires an explicit type\n    var isPrimeSet7 = []\n              \
    \        ^~\n/tmp/tmpg0l3msyw.swift:28:23: error: empty collection literal requires\
    \ an explicit type\n    var isPrimeSet8 = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:29:23:\
    \ error: empty collection literal requires an explicit type\n    var isPrimeSet9\
    \ = []\n                      ^~\n/tmp/tmpg0l3msyw.swift:30:24: error: empty collection\
    \ literal requires an explicit type\n    var isPrimeSet10 = []\n             \
    \          ^~\n/tmp/tmpg0l3msyw.swift:31:24: error: empty collection literal requires\
    \ an explicit type\n    var isPrimeSet11 = []\n                       ^~\n/tmp/tmpg0l3msyw.swift:32:24:\
    \ error: empty collection literal requires an explicit type\n    var isPrimeSet12\
    \ = []\n                       ^~\n/tmp/tmpg0l3msyw.swift:33:24: error: empty\
    \ collection literal requires an explicit type\n    var isPrimeSet13 = []\n  \
    \                     ^~\n/tmp/tmpg0l3msyw.swift:34:24: error: empty collection\
    \ literal requires an explicit type\n    var isPrimeSet14 = []\n             \
    \          ^~\n/tmp/tmpg0l3msyw.swift:35:24: error: empty collection literal requires\
    \ an explicit type\n    var isPrimeSet15 = []\n                       ^~\n/tmp/tmpg0l3msyw.swift:36:24: "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var factorizationCountMax = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax2 = factorizationCountMax\n    var factorizationCountMax3\
    \ = factorizationCountMax\n    var factorizationCountMax4 = factorizationCountMax\n\
    \    var factorizationCountMax5 = factorizationCountMax\n    var factorizationCountMax6\
    \ = factorizationCountMax\n    var factorizationCountMax7 = factorizationCountMax\n\
    \    var factorizationCountMax8 = factorizationCountMax\n    var factorizationCountMax9\
    \ = factorizationCountMax\n    var factorizationCountMax10 = factorizationCountMax\n\
    \    var factorizationCountMax11 = factorizationCountMax\n    var factorizationCountMax12\
    \ = factorizationCountMax\n    var factorizationCountMax13 = factorizationCountMax\n\
    \    var factorizationCountMax14 = factorizationCountMax\n    var factorizationCountMax15\
    \ = factorizationCountMax\n    var factorizationCountMax16 = factorizationCountMax\n\
    \    var factorizationCountMax17 = factorizationCountMax\n    var factorizationCountMax18\
    \ = factorizationCountMax\n    var factorizationCountMax19 = factorizationCountMax\n\
    \    var factorizationCountMax20 = factorizationCountMax\n    var factorizationCountMax21\
    \ = factorizationCountMax\n    var factorizationCountMax22 = factorizationCountMax\n\
    \    var factorizationCountMax23 = factorizationCountMax\n    var factorizationCountMax24\
    \ = factorizationCountMax\n    var factorizationCountMax25 = factorizationCountMax\n\
    \    var factorizationCountMax26 = factorizationCountMax\n    var factorizationCountMax27\
    \ = factorizationCountMax\n    var factorizationCountMax28 = factorizationCountMax\n\
    \    var factorizationCountMax29 = factorizationCountMax\n    var factorizationCountMax30\
    \ = factorizationCountMax\n    var factorizationCountMax31 = factorizationCountMax\n\
    \    var factorizationCountMax32 = factorizationCountMax\n    var factorizationCountMax33\
    \ = factorizationCountMax\n    var factorizationCountMax34 = factorizationCountMax\n\
    \    var factorizationCountMax35 = factorizationCountMax\n    var factorizationCountMax36\
    \ = factorizationCountMax\n    var factorizationCountMax37 = factorizationCountMax\n\
    \    var factorizationCountMax38 = factorizationCountMax\n    var factorizationCountMax39\
    \ = factorizationCountMax\n    var factorizationCountMax40 = factorizationCountMax\n\
    \    var factorizationCountMax41 = factorizationCountMax\n    var factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpa0anvmc8.swift:16:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationCountMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmpa0anvmc8.swift:57:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var currentFactorization = [Int]()\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorizationValue = 1\n \
    \   var currentFactorizationValueIndex = 0\n    var currentFactorizationValueIndexMax\
    \ = 0\n    var currentFactorizationValueIndexMaxIndex = 0\n    var currentFactorizationValueIndexMin\
    \ = 0\n    var currentFactorizationValueIndexMinIndex = 0\n    var currentFactorizationValueIndexMaxValue\
    \ = 0\n    var currentFactorizationValueIndexMinValue = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationValueIndexMinValueIndex = 0\n    var currentFactorizationValueIndexMaxValueIndex\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplwyiqhc4.swift:61:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmplwyiqhc4.swift:26:9: error: invalid redeclaration of 'currentFactorizationValueIndexMaxValueIndex'\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:24:9:\
    \ note: 'currentFactorizationValueIndexMaxValueIndex' previously declared here\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:27:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueIndexMinValueIndex'\n\
    \    var currentFactorizationValueIndexMinValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:25:9:\
    \ note: 'currentFactorizationValueIndexMinValueIndex' previously declared here\n\
    \    var currentFactorizationValueIndexMinValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:28:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueIndexMaxValueIndex'\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:24:9:\
    \ note: 'currentFactorizationValueIndexMaxValueIndex' previously declared here\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:29:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueIndexMinValueIndex'\n\
    \    var currentFactorizationValueIndexMinValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:25:9:\
    \ note: 'currentFactorizationValueIndexMinValueIndex' previously declared here\n\
    \    var currentFactorizationValueIndexMinValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:30:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueIndexMaxValueIndex'\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:24:9:\
    \ note: 'currentFactorizationValueIndexMaxValueIndex' previously declared here\n\
    \    var currentFactorizationValueIndexMaxValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:31:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueIndexMinValueIndex'\n\
    \    var currentFactorizationValueIndexMinValueIndex = 0\n        ^\n/tmp/tmplwyiqhc4.swift:25:9:\
    \ note: 'currentFactorizationValueIndexMinValueIndex"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i < n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmjxqcjd9.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime: Bool = false\n    var isPrimeCount = 0\n    var isPrimePrime:\
    \ Bool = false\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var is\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcit7vu3y.swift:43:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpcit7vu3y.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpcit7vu3y.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpcit7vu3y.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpcit7vu3y.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpcit7vu3y.swift:34:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpcit7vu3y.swift:37:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n     \
    \   ^\n/tmp/tmpcit7vu3y.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePri"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumCountMax = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMaxIndex2 = 0\n    var factorizationSumCountMaxIndex3\
    \ = 0\n    var factorizationSumCountMaxIndex4 = 0\n    var factorizationSumCountMaxIndex5\
    \ = 0\n    var factorizationSumCountMaxIndex6 = 0\n    var factorizationSumCountMaxIndex7\
    \ = 0\n    var factorizationSumCountMaxIndex8 = 0\n    var factorizationSumCountMaxIndex9\
    \ = 0\n    var factorizationSumCountMaxIndex10 = 0\n    var factorizationSumCountMaxIndex11\
    \ = 0\n    var factorizationSumCountMaxIndex12 = 0\n    var factorizationSumCountMaxIndex13\
    \ = 0\n    var factorizationSumCountMaxIndex14 = 0\n    var factorizationSumCountMaxIndex15\
    \ = 0\n    var factorizationSumCountMaxIndex16 = 0\n    var factorizationSumCountMaxIndex17\
    \ = 0\n    var factorizationSumCountMaxIndex18 = 0\n    var factorizationSumCountMaxIndex19\
    \ = 0\n    var factorizationSumCountMaxIndex20 = 0\n    var factorizationSumCountMaxIndex21\
    \ = 0\n    var factorizationSumCountMaxIndex22 = 0\n    var factorizationSumCountMaxIndex23\
    \ = 0\n    var factorizationSumCountMaxIndex24 = 0\n    var factorizationSumCountMaxIndex25\
    \ = 0\n    var factorizationSumCountMaxIndex26 = 0\n    var factorizationSumCountMaxIndex27\
    \ = 0\n    var factorizationSumCountMaxIndex28 = 0\n    var factorizationSumCountMaxIndex29\
    \ = 0\n    var factorizationSumCountMaxIndex30 = 0\n    var factorizationSumCountMaxIndex31\
    \ = 0\n    var factorizationSumCountMaxIndex32 = 0\n    var factorizationSumCountMaxIndex33\
    \ = 0\n    var factorizationSumCountMaxIndex34 = 0\n    var factorizationSumCountMaxIndex35\
    \ = 0\n    var factorizationSumCountMaxIndex36 = 0\n    var factorizationSumCountMaxIndex37\
    \ = 0\n    var factorizationSumCountMaxIndex38 = 0\n    var factorizationSumCountMaxIndex39\
    \ = 0\n    var factorizationSumCountMaxIndex40 = 0\n    var factorizationSumCountMaxIndex41\
    \ = 0\n    var factorizationSumCountMaxIndex42 = 0\n    var factorizationSumCountMaxIndex43\
    \ = 0\n    var factorizationSumCountMaxIndex44 = 0\n    var factorizationSumCountMaxIndex45\
    \ = 0\n    var factorizationSumCountMaxIndex46 = 0\n    var factorizationSumCountMaxIndex47\
    \ = 0\n    var factorizationSumCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0tu76oxc.swift:64:9: error: type annotation missing in pattern\n\
    \    var factorizationSumCount\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumOfFactors = 0\n    var factorizationSumOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactors = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplb08zgl6.swift:23:9: error: invalid redeclaration of 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:22:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:27:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFac"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationSumOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorization = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsgrnp7vk.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsgrnp7vk.swift:24:9: error: invalid redeclaration\
    \ of 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\n\
    \    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n        ^\n/tmp/tmpsgrnp7vk.swift:23:9: note: 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\
    \ previously declared here\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n        ^\n/tmp/tmpsgrnp7vk.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\n\
    \    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n        ^\n/tmp/tmpsgrnp7vk.swift:23:9: note: 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\
    \ previously declared here\n    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n        ^\n/tmp/tmpsgrnp7vk.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\n\
    \    var factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization\
    \ = 0\n        ^\n/tmp/tmpsgrnp7vk.swift:26:9: note: 'factorizationSumOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorizationOfFactorization'\
    \ previously declared here"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > 1 {\n\
    \            factors.append(factor)\n        }\n        factorizationCount *=\
    \ factor\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzszootmz.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = 0\n    var factorizationIndexMaxCount = 0\n    var factorizationIndexMaxCountIndex\
    \ = 0\n    var factorizationIndexMaxCountIndexMax = 0\n    var factorizationIndexMaxCountIndexMaxCount\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndexMaxCountIndexMaxCountMax\
    \ = 0\n    var factorizationIndexMaxCountIndexMaxCountMax = 0\n    var factorizationIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp80kuaz8_.swift:21:9: error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxCountIndexMaxCountMax'\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/tmp/tmp80kuaz8_.swift:20:9:\
    \ note: 'factorizationIndexMaxCountIndexMaxCountMax' previously declared here\n\
    \    var factorizationIndexMaxCountIndexMaxCountMax = 0\n        ^\n/t"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp337ks_2p.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factor != 1 {\n         \
    \   factors.append(factor)\n            factorizationCount *= factor\n       \
    \ }\n    }\n    if factorizationCount != 1 {\n        factors.append(factorizationCount)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnbb9c_ho.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp016e3yoi.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMin = Int()\n    var isPrimeFactorsCountMinIndex =\
    \ Int()\n    var isPrimeFactorsCountSum = Int()\n    var isPrimeFactorsCountSumIndex\
    \ = Int()\n    var isPrimeFactorsCountSumMax = Int()\n    var isPrimeFactorsCountSumMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountSumMin = Int()\n    var isPrimeFactorsCountSumMinIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSum = Int()\n    var isPrimeFactorsCountSumSumIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumMax = Int()\n    var isPrimeFactorsCountSumSumMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumMin = Int()\n    var isPrimeFactorsCountSumSumMinIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSum = Int()\n    var isPrimeFactorsCountSumSumSumIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumMax = Int()\n    var isPrimeFactorsCountSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumMin = Int()\n    var isPrimeFactorsCountSumSumSumMinIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumSum = Int()\n    var isPrimeFactorsCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumSumMax = Int()\n    var isPrimeFactorsCountSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumSumMin = Int()\n    var isPrimeFactorsCountSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumSumSum = Int()\n    var isPrimeFactorsCountSumSumSumSumSumIndex\
    \ = Int()\n    var isPrimeFactorsCountSumSumSumSumSumMax = Int()\n    var isPrimeFactorsCountSumSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi3i9g7u0.swift:50:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > factors.count\
    \ {\n            factors.append(factor)\n        } else {\n            factors[factors.count\
    \ - 1] = factor\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8r5k64ho.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factor: Int = 0\n    var isPrime: Bool = false\n    var isPrime2: Bool\
    \ = false\n    var isPrime3: Bool = false\n    var isPrime4: Bool = false\n  \
    \  var isPrime5: Bool = false\n    var isPrime6: Bool = false\n    var isPrime7:\
    \ Bool = false\n    var isPrime8: Bool = false\n    var isPrime9: Bool = false\n\
    \    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n    var isPrime12:\
    \ Bool = false\n    var isPrime13: Bool = false\n    var isPrime14: Bool = false\n\
    \    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n    var isPrime17:\
    \ Bool = false\n    var isPrime18: Bool = false\n    var isPrime19: Bool = false\n\
    \    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n    var isPrime22:\
    \ Bool = false\n    var isPrime23: Bool = false\n    var isPrime24: Bool = false\n\
    \    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n    var isPrime27:\
    \ Bool = false\n    var isPrime28: Bool = false\n    var isPrime29: Bool = false\n\
    \    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n    var isPrime32:\
    \ Bool = false\n    var isPrime33: Bool = false\n    var isPrime34: Bool = false\n\
    \    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n    var isPrime37:\
    \ Bool = false\n    var isPrime38: Bool = false\n    var isPrime39: Bool = false\n\
    \    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n    var isPrime42:\
    \ Bool = false\n    var isPrime43: Bool = false\n    var isPrime44: Bool = false\n\
    \    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n    var isPrime47:\
    \ Bool = false\n    var isPrime48: Bool = false\n    var isPrime49: Bool = false\n\
    \    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n    var isPrime52:\
    \ Bool = false\n    var isPrime53: Bool = false\n    var isPrime54: Bool = false\n\
    \    var isPrime55: Bool = false\n    var isPrime56: Bool = false\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5e4ycr3o.swift:70:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp5e4ycr3o.swift:12:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:13:9: warning: variable 'factor'\
    \ was never used; consider replacing with '_' or removing it\n    var factor:\
    \ Int = 0\n        ^~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:14:9: warning: variable\
    \ 'isPrime' was never used; consider replacing with '_' or removing it\n    var\
    \ isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:15:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:16:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:17:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:18:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:19:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:20:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:21:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:22:9:\
    \ warning: variable 'isPrime9' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime9: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp5e4ycr3o.swift:23:9:\
    \ warning: variable 'isPrime10' was never us"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var\
    \ isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n  \
    \  var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n\
    \    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 =\
    \ 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var isPrimeIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu99ppaft.swift:76:9: error: type annotation missing in pattern\n\
    \    var isPrimeIndex\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 0\n    while i < n {\n        if n % i == 0 {\n  \
    \          factors.append(i)\n            n /= i\n        } else {\n         \
    \   i += 1\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptssu86s6.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax2\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax5\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax7 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax8\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax9 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax10 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax11\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax12 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax13 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax14\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax15 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax16 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax17\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax18 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax19 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax20\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax21 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax22 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax23\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax24 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax25 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax26\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax27 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax28 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax29\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax30 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax31 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax32\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax33 = Int(ceil(sqrt(\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc44os_a4.swift:49:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpc44os_a4.swift:16:31: error: cannot find 'ceil' in scope\n    var\
    \ isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                             \
    \ ^~~~\n/tmp/tmpc44os_a4.swift:16:36: error: cannot find 'sqrt' in scope\n   \
    \ var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                         \
    \          ^~~~\n/tmp/tmpc44os_a4.swift:17:32: error: cannot find 'ceil' in scope\n\
    \    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n                     \
    \          ^~~~\n/tmp/tmpc44os_a4.swift:17:37: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n                     \
    \               ^~~~\n/tmp/tmpc44os_a4.swift:18:32: error: cannot find 'ceil'\
    \ in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n          \
    \                     ^~~~\n/tmp/tmpc44os_a4.swift:18:37: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n          \
    \                          ^~~~\n/tmp/tmpc44os_a4.swift:19:32: error: cannot find\
    \ 'ceil' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n   \
    \                            ^~~~\n/tmp/tmpc44os_a4.swift:19:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpc44os_a4.swift:20:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpc44os_a4.swift:20:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpc44os_a4.swift:21:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpc44os_a4.swift:21:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpc44os_a4.swift:22:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrim"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphno3gaer.swift:19:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmphno3gaer.swift:18:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmphno3gaer.swift:20:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \        ^\n/tmp/tmphno3gaer.swift:18:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmphno3gaer.swift:21:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmphno3gaer.swift:18:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmphno3gaer.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \        ^\n/tmp/tmphno3gaer.swift:18:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmphno3gaer.swift:23:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmphno3gaer.swift:18:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmphno3gaer.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \        ^\n/tmp/tmphno3gaer.swift:18:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmphno3gaer.swift:25:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmphno3gaer.swift:18:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmphno3gaer.swift:26"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n \
    \   var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp38axmhch.swift:37:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n     \
    \   ^\n/tmp/tmp38axmhch.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmp38axmhch.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmp38axmhch.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmp38axmhch.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n       \
    \ ^\n/tmp/tmp38axmhch.swift:39:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmp38axmhch.swift:41:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2_5mleaj.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex3 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex5 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex7 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex8 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex9 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex10 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex11 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex12 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex13 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex14 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex15 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex16 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex17 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex18 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex19 = Int(arc4random_uniform(UInt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2lw6bi40.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp2lw6bi40.swift:37:63: note: to match this opening '('\n    var isPrimeFactorsCountMaxIndex19\
    \ = Int(arc4random_uniform(UInt\n                                            \
    \                  ^\n/tmp/tmp2lw6bi40.swift:18:38: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:19:43:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \              ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:20:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:21:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex3\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:22:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:23:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex5\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:24:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:25:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex7\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var isPrime = true\n    var isDivisible\
    \ = false\n    var isFactor = false\n    var isPrimeFactor = false\n    var isPrimeDivisible\
    \ = false\n    var isPrimeDivisibleFactor = false\n    var isPrimeDivisibleFactor2\
    \ = false\n    var isPrimeDivisibleFactor3 = false\n    var isPrimeDivisibleFactor4\
    \ = false\n    var isPrimeDivisibleFactor5 = false\n    var isPrimeDivisibleFactor6\
    \ = false\n    var isPrimeDivisibleFactor7 = false\n    var isPrimeDivisibleFactor8\
    \ = false\n    var isPrimeDivisibleFactor9 = false\n    var isPrimeDivisibleFactor10\
    \ = false\n    var isPrimeDivisibleFactor11 = false\n    var isPrimeDivisibleFactor12\
    \ = false\n    var isPrimeDivisibleFactor13 = false\n    var isPrimeDivisibleFactor14\
    \ = false\n    var isPrimeDivisibleFactor15 = false\n    var isPrimeDivisibleFactor16\
    \ = false\n    var isPrimeDivisibleFactor17 = false\n    var isPrimeDivisibleFactor18\
    \ = false\n    var isPrimeDivisibleFactor19 = false\n    var isPrimeDivisibleFactor20\
    \ = false\n    var isPrimeDivisibleFactor21 = false\n    var isPrimeDivisibleFactor22\
    \ = false\n    var isPrimeDivisibleFactor23 = false\n    var isPrimeDivisibleFactor24\
    \ = false\n    var isPrimeDivisibleFactor25 = false\n    var isPrimeDivisibleFactor26\
    \ = false\n    var isPrimeDivisibleFactor27 = false\n    var isPrimeDivisibleFactor28\
    \ = false\n    var isPrimeDivisibleFactor29 = false\n    var isPrimeDivisibleFactor30\
    \ = false\n    var isPrimeDivisibleFactor31 = false\n    var isPrimeDivisibleFactor32\
    \ = false\n    var isPrimeDivisibleFactor33 = false\n    var isPrimeDivisibleFactor34\
    \ = false\n    var isPrimeDivisibleFactor35 = false\n    var isPrimeDivisibleFactor36\
    \ = false\n    var isPrimeDivisibleFactor37 = false\n    var isPrimeDivisibleFactor38\
    \ = false\n    var isPrimeDivisibleFactor39 = false\n    var isPrimeDivisibleFactor40\
    \ = false\n    var isPrimeDivisibleFactor41 = false\n    var isPrimeDivisibleFactor42\
    \ = false\n    var isPrimeDivisibleFactor43 = false\n    var isPrimeDivisibleFactor44\
    \ = false\n    var isPrimeDivisibleFactor45 = false\n    var isPrimeDivisibleFactor46\
    \ = false\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5n0cs_hh.swift:65:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp5n0cs_hh.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp5n0cs_hh.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5n0cs_hh.swift:14:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmp5n0cs_hh.swift:15:9: warning:\
    \ initialization of variable 'isDivisible' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isDivisible = false\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp5n0cs_hh.swift:16:9: warning: initialization of variable 'isFactor'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isFactor = false\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp5n0cs_hh.swift:17:9:\
    \ warning: initialization of variable 'isPrimeFactor' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactor = false\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp5n0cs_hh.swift:18:9: warning: initialization\
    \ of variable 'isPrimeDivisible' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeDivisible = false\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5n0cs_hh.swift:19:9: warning: initialization of variable 'isPrimeDivisibleFactor'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeDivisibleFactor = false\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp5n0cs_hh.swift:20:9: warning: initialization of variable 'isPrimeDivisibleFactor2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeDivisibleFactor2 = false\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmp5n0cs_hh.swift:21:9: warning: initialization "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount =\
    \ 0\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumSum\
    \ = 0\n    var isPrimeSumSumCount = 0\n    var isPrimeSumSumSum = 0\n    var isPrimeSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSum = 0\n    var isPrimeSumSumSumSumCount = 0\n\
    \    var isPrimeSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumCount = 0\n\
    \    var isPrimeSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumCount =\
    \ 0\n    var isPrimeSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var isPrimeSumSumSumSumSumSumSum = 0\n    var isPrimeSumSumSumSumSumSumCount\
    \ = 0\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpamksvu1u.swift:56:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpamksvu1u.swift:27:9: error: invalid redeclaration of 'isPrimeSumSumSumSumSumCount'\n\
    \    var isPrimeSumSumSumSumSumCount = 0\n        ^\n/tmp/tmpamksvu1u.swift:25:9:\
    \ note: 'isPrimeSumSumSumSumSumCount' previously declared here\n    var isPrimeSumSumSumSumSumCount\
    \ = 0\n        ^\n/tmp/tmpamksvu1u.swift:28:9: error: invalid redeclaration of\
    \ 'isPrimeSumSumSumSumSumSum'\n    var isPrimeSumSumSumSumSumSum = 0\n       \
    \ ^\n/tmp/tmpamksvu1u.swift:26:9: note: 'isPrimeSumSumSumSumSumSum' previously\
    \ declared here\n    var isPrimeSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpamksvu1u.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeSumSumSumSumSumCount'\n    var isPrimeSumSumSumSumSumCount\
    \ = 0\n        ^\n/tmp/tmpamksvu1u.swift:25:9: note: 'isPrimeSumSumSumSumSumCount'\
    \ previously declared here\n    var isPrimeSumSumSumSumSumCount = 0\n        ^\n\
    /tmp/tmpamksvu1u.swift:30:9: error: invalid redeclaration of 'isPrimeSumSumSumSumSumSum'\n\
    \    var isPrimeSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpamksvu1u.swift:26:9:\
    \ note: 'isPrimeSumSumSumSumSumSum' previously declared here\n    var isPrimeSumSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmpamksvu1u.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeSumSumSumSumSumSumCount'\n    var isPrimeSumSumSumSumSumSumCount = 0\n\
    \        ^\n/tmp/tmpamksvu1u.swift:31:9: note: 'isPrimeSumSumSumSumSumSumCount'\
    \ previously declared here\n    var isPrimeSumSumSumSumSumSumCount = 0\n     \
    \   ^\n/tmp/tmpamksvu1u.swift:34:9: error: invalid redeclaration of 'isPrimeSumSumSumSumSumSumSum'\n\
    \    var isPrimeSumSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpamksvu1u.swift:32:9:\
    \ note: 'isPrimeSumSumSumSumSumSumSum' previously declared here\n    var isPrimeSumSumSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmpamksvu1u.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeSumSumSumSumSumSumCount'\n    var isPrimeSumSumSumSumSumSumCount = 0\n\
    \        ^\n/tmp/tmpamksvu1u.swift:31:9: note: 'isPrimeSumSumSumSumSumSumCount'\
    \ previously declared here\n    var isPrimeSumSumSumSumSumSumCount = 0\n     "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n    var factorizationMaxIndex = 0\n\
    \    var factorizationMin = Int(sqrt(Double(n)))\n    var factorizationMinIndex\
    \ = 0\n    var factorizationSum = 0\n    var factorizationSumIndex = 0\n    var\
    \ factorizationSumMax = 0\n    var factorizationSumMaxIndex = 0\n    var factorizationSumMin\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumSum = 0\n\
    \    var factorizationSumSumIndex = 0\n    var factorizationSumSumMax = 0\n  \
    \  var factorizationSumSumMaxIndex = 0\n    var factorizationSumSumMin = 0\n \
    \   var factorizationSumSumMinIndex = 0\n    var factorizationSumSumSum = 0\n\
    \    var factorizationSumSumSumIndex = 0\n    var factorizationSumSumSumMax =\
    \ 0\n    var factorizationSumSumSumMaxIndex = 0\n    var factorizationSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumMinIndex = 0\n    var factorizationSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMaxIndex = 0\n    var factorizationSumSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumSumMaxIndex = 0\n    var factorizationSumSumSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumSumMaxIndex = 0\n    var factorizationSumSumSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumSumSumMaxIndex = 0\n    var factorizationSumSumSumSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumSumSumMax\
    \ = 0\n    var factorizationSumSum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwxyqxvi7.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmpwxyqxvi7.swift:17:32: error: cannot find 'sqrt' in scope\n    var factorizationMin\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpwxyqxvi7.swift:50:9:\
    \ error: invalid redeclaration of 'factorizationSumSumSumSumSumIndex'\n    var\
    \ factorizationSumSumSumSumSumIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:44:9:\
    \ note: 'factorizationSumSumSumSumSumIndex' previously declared here\n    var\
    \ factorizationSumSumSumSumSumIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:51:9:\
    \ error: invalid redeclaration of 'factorizationSumSumSumSumSumMax'\n    var factorizationSumSumSumSumSumMax\
    \ = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:45:9: note: 'factorizationSumSumSumSumSumMax'\
    \ previously declared here\n    var factorizationSumSumSumSumSumMax = 0\n    \
    \    ^\n/tmp/tmpwxyqxvi7.swift:52:9: error: invalid redeclaration of 'factorizationSumSumSumSumSumMaxIndex'\n\
    \    var factorizationSumSumSumSumSumMaxIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:46:9:\
    \ note: 'factorizationSumSumSumSumSumMaxIndex' previously declared here\n    var\
    \ factorizationSumSumSumSumSumMaxIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:53:9:\
    \ error: invalid redeclaration of 'factorizationSumSumSumSumSumMin'\n    var factorizationSumSumSumSumSumMin\
    \ = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:47:9: note: 'factorizationSumSumSumSumSumMin'\
    \ previously declared here\n    var factorizationSumSumSumSumSumMin = 0\n    \
    \    ^\n/tmp/tmpwxyqxvi7.swift:54:9: error: invalid redeclaration of 'factorizationSumSumSumSumSumMinIndex'\n\
    \    var factorizationSumSumSumSumSumMinIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:48:9:\
    \ note: 'factorizationSumSumSumSumSumMinIndex' previously declared here\n    var\
    \ factorizationSumSumSumSumSumMinIndex = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:55:9:\
    \ error: invalid redeclaration of 'factorizationSumSumSumSumSumSum'\n    var factorizationSumSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmpwxyqxvi7.swift:49:9: note: 'factorizationSumSumSumSumSumSum'"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationIndexCount\
    \ = 0\n    var primeFactorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax2 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax3 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax4\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax6 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax7 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax8\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax9 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax10 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax11 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax12\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax13 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax14 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax15 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax16\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax17 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax18 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax19 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax20\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax21 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax22 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax23 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax24\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax25 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax26 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax27 = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax28\
    \ = Int(ceil(sqrt(Double(n))))\n    var primeFactorizationIndexCountMax29 = Int(ceil(sqrt(Double(n))))\n\
    \    var primeFactorizationIndexCountMax30 = Int(ceil(sqrt(Double(n))))\n    var\
    \ primeFactorizationIndexCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1ueuuvn9.swift:17:47: error: cannot find 'ceil' in scope\n    var\
    \ primeFactorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n             \
    \                                 ^~~~\n/tmp/tmp1ueuuvn9.swift:17:52: error: cannot\
    \ find 'sqrt' in scope\n    var primeFactorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                                   ^~~~\n/tmp/tmp1ueuuvn9.swift:18:48:\
    \ error: cannot find 'ceil' in scope\n    var primeFactorizationIndexCountMax2\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \  ^~~~\n/tmp/tmp1ueuuvn9.swift:18:53: error: cannot find 'sqrt' in scope\n  \
    \  var primeFactorizationIndexCountMax2 = Int(ceil(sqrt(Double(n))))\n       \
    \                                             ^~~~\n/tmp/tmp1ueuuvn9.swift:19:48:\
    \ error: cannot find 'ceil' in scope\n    var primeFactorizationIndexCountMax3\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \  ^~~~\n/tmp/tmp1ueuuvn9.swift:19:53: error: cannot find 'sqrt' in scope\n  \
    \  var primeFactorizationIndexCountMax3 = Int(ceil(sqrt(Double(n))))\n       \
    \                                             ^~~~\n/tmp/tmp1ueuuvn9.swift:20:48:\
    \ error: cannot find 'ceil' in scope\n    var primeFactorizationIndexCountMax4\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \  ^~~~\n/tmp/tmp1ueuuvn9.swift:20:53: error: cannot find 'sqrt' in scope\n  \
    \  var primeFactorizationIndexCountMax4 = Int(ceil(sqrt(Double(n))))\n       \
    \                                             ^~~~\n/tmp/tmp1ueuuvn9.swift:21:48:\
    \ error: cannot find 'ceil' in scope\n    var primeFactorizationIndexCountMax5\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \  ^~~~\n/tmp/tmp1ueuuvn9.swift:21:53: error: cannot find 'sqrt' in scope\n  \
    \  var primeFactorizationIndexCountMax5 = Int(ceil(sqrt(Double(n))))\n       \
    \                                             ^~~~\n/tmp/tmp1ueuuvn9.swift:22:48:\
    \ error: cannot find 'ceil' in scope\n    var primeFactorizationIndexCountMax6\
    \ = Int(ceil(sqrt(Double(n))))\n                      "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n    var factorizationIndexMax2\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax3 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax4 = Int(sqrt(Double(n)))\n    var factorizationIndexMax5\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax6 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax7 = Int(sqrt(Double(n)))\n    var factorizationIndexMax8\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax9 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax10 = Int(sqrt(Double(n)))\n    var factorizationIndexMax11\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax12 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax13 = Int(sqrt(Double(n)))\n    var factorizationIndexMax14\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax15 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax16 = Int(sqrt(Double(n)))\n    var factorizationIndexMax17\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax18 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax19 = Int(sqrt(Double(n)))\n    var factorizationIndexMax20\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax21 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax22 = Int(sqrt(Double(n)))\n    var factorizationIndexMax23\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax24 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax25 = Int(sqrt(Double(n)))\n    var factorizationIndexMax26\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax27 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax28 = Int(sqrt(Double(n)))\n    var factorizationIndexMax29\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax30 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax31 = Int(sqrt(Double(n)))\n    var factorizationIndexMax32\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax33 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax34 = Int(sqrt(Double(n)))\n    var factorizationIndexMax35\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax36 = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax37 = Int(sqrt(Double(n)))\n    var factorizationIndexMax38\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMax39 = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpug8_zyra.swift:53:34: error: expected initial value after '='\n\
    \    var factorizationIndexMax39 = \n                                 ^\n/tmp/tmpug8_zyra.swift:15:37:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexMax = Int(sqrt(Double(n)))\n\
    \                                    ^~~~\n/tmp/tmpug8_zyra.swift:16:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax2 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:17:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax3 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:18:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax4 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:19:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax5 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:20:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax6 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:21:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax7 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:22:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax8 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:23:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax9 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpug8_zyra.swift:24:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax10 = Int(sqrt(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmpug8_zyra.swift:25:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax11 = Int(sqrt(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmpug8_zyra.swift:26:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexMax12 = Int(sqrt(Double(n)))\n\
    \               "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var factorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var factorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var factorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var factorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var factorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var factorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var factorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var factorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var factorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var factorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var factorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var factorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var factorizationNumberIndex27 = 0\n    var factorizationNumberIndex28\
    \ = 0\n    var factorizationNumberIndex29 = 0\n    var factorizationNumberIndex30\
    \ = 0\n    var factorizationNumberIndex31 = 0\n    var factorizationNumberIndex32\
    \ = 0\n    var factorizationNumberIndex33 = 0\n    var factorizationNumberIndex34\
    \ = 0\n    var factorizationNumberIndex35 = 0\n    var factorizationNumberIndex36\
    \ = 0\n    var factorizationNumberIndex37 = 0\n    var factorizationNumberIndex38\
    \ = 0\n    var factorizationNumberIndex39 = 0\n    var factorizationNumberIndex40\
    \ = 0\n    var factorizationNumberIndex41 = 0\n    var factorizationNumberIndex42\
    \ = 0\n    var factorizationNumberIndex43 = 0\n    var factorizationNumberIndex44\
    \ = 0\n    var factorizationNumberIndex45 = 0\n    var factorizationNumberIndex46\
    \ = 0\n    var factorizationNumberIndex47 = 0\n    var factorizationNumberIndex48\
    \ = 0\n    var factorizationNumberIndex49 = 0\n    var factorizationNumberIndex50\
    \ = 0\n    var factorizationNumberIndex51 = 0\n    var factorizationNumberIndex52\
    \ = 0\n    var factorizationNumberIndex53 = 0\n    var factorizationNumberIndex54\
    \ = 0\n    var factorizationNumberIndex55 = 0\n    var factorizationNumberIndex56\
    \ = 0\n    var factorizationNumberIndex57 = 0\n    var factorizationNumberIndex58\
    \ = 0\n    var factorizationNumberIndex59 = 0\n    var factorizationNumberIndex60\
    \ = 0\n    var factorizationNumberIndex61 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcpfe9y4m.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpcpfe9y4m.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcpfe9y4m.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:15:9:\
    \ warning: initialization of variable 'factorizationNumber' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumber\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:16:9: warning:\
    \ initialization of variable 'factorizationNumberIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:17:9: warning:\
    \ initialization of variable 'factorizationNumberIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:18:9:\
    \ warning: initialization of variable 'factorizationNumberIndex3' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:19:9:\
    \ warning: initialization of variable 'factorizationNumberIndex4' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:20:9:\
    \ warning: initialization of variable 'factorizationNumberIndex5' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex5\
    \ = 0\n    ~~~~^~~"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var i = 2\n    while i <= n {\n        while n\
    \ % i == 0 {\n            factorization.append(i)\n            n /= i\n      \
    \  }\n        i += 1\n    }\n    if n > 1 {\n        factorization.append(n)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp87h4k5z3.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        if factors.contains(factor) {\n            continue\n        }\n\
    \        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp6nk4mvc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4\
    \ = 0\n    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6\
    \ = 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var isPri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyfjqc1ry.swift:77:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0\
    \ {\n            factors.append(factor)\n            factor = 1\n        } else\
    \ {\n            factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp8upf0mr0/tmp8upf0mr0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b1e12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b1b09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b1b09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b1b087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8upf0mr0                        0x000055d822c5d4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b89b1ffe460 __libc_start_main +
    245

    6    tmp8upf0mr0                        0x000055d822c5d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationNumber = 0\n    var\
    \ factorizationNumberCount = 0\n    var factorizationNumberIndex = 0\n    var\
    \ factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex = 0\n\
    \    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptl9ek6gc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptl9ek6gc.swift:20:9: error: invalid redeclaration\
    \ of 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex =\
    \ 0\n        ^\n/tmp/tmptl9ek6gc.swift:19:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmptl9ek6gc.swift:21:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmptl9ek6gc.swift:19:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmptl9ek6gc.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \        ^\n/tmp/tmptl9ek6gc.swift:19:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmptl9ek6gc.swift:23:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmptl9ek6gc.swift:19:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmptl9ek6gc.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \        ^\n/tmp/tmptl9ek6gc.swift:19:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmptl9ek6gc.swift:25:9: error: invalid redeclaration of 'factorizationNumberCountIndex'\n\
    \    var factorizationNumberCountIndex = 0\n        ^\n/tmp/tmptl9ek6gc.swift:19:9:\
    \ note: 'factorizationNumberCountIndex' previously declared here\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmptl9ek6gc.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex = 0\n\
    \  "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex3 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex5 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex7 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex8 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex9 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex10 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex11 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex12 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex13 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex14 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex15 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex16 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex17 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex18 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex19 = Int(arc4random_uniform(UInt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2lw6bi40.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp2lw6bi40.swift:37:63: note: to match this opening '('\n    var isPrimeFactorsCountMaxIndex19\
    \ = Int(arc4random_uniform(UInt\n                                            \
    \                  ^\n/tmp/tmp2lw6bi40.swift:18:38: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:19:43:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \              ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:20:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:21:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex3\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:22:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:23:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex5\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:24:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:25:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex7\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var product = n * n\n    var primes = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = true\n    var isPrimeFactorizationIndex = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeIndex = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrimeIndex = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeIndex = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeIndex = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeIndex = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeIndex = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeIndex = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeIndex =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp89rdha1s.swift:45:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp89rdha1s.swift:28:9: error: invalid redeclaration of 'isPrimePrimePrimePrimeIndex'\n\
    \    var isPrimePrimePrimePrimeIndex = 0\n        ^\n/tmp/tmp89rdha1s.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimeIndex' previously declared here\n    var isPrimePrimePrimePrimeIndex\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = factorization(n: n)\n    for prime in primes {\n        factors.append(prime)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkiaonf3c.swift:13:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n: n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > factors.count\
    \ {\n            factors.append(factor)\n        } else {\n            factors[factors.count-1]\
    \ *= factor\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2_mehvwp.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69\
    \ = 0\n    var factorizationIndex70 = 0\n    var factorizationIndex71 = 0\n  \
    \  var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4uzniqhh.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ factorizationCount: Int = 0\n    var isPrime: Bool = false\n    var isPrime2:\
    \ Bool = false\n    var isPrime3: Bool = false\n    var isPrime4: Bool = false\n\
    \    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n    var isPrime7:\
    \ Bool = false\n    var isPrime8: Bool = false\n    var isPrime9: Bool = false\n\
    \    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n    var isPrime12:\
    \ Bool = false\n    var isPrime13: Bool = false\n    var isPrime14: Bool = false\n\
    \    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n    var isPrime17:\
    \ Bool = false\n    var isPrime18: Bool = false\n    var isPrime19: Bool = false\n\
    \    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n    var isPrime22:\
    \ Bool = false\n    var isPrime23: Bool = false\n    var isPrime24: Bool = false\n\
    \    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n    var isPrime27:\
    \ Bool = false\n    var isPrime28: Bool = false\n    var isPrime29: Bool = false\n\
    \    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n    var isPrime32:\
    \ Bool = false\n    var isPrime33: Bool = false\n    var isPrime34: Bool = false\n\
    \    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n    var isPrime37:\
    \ Bool = false\n    var isPrime38: Bool = false\n    var isPrime39: Bool = false\n\
    \    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n    var isPrime42:\
    \ Bool = false\n    var isPrime43: Bool = false\n    var isPrime44: Bool = false\n\
    \    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n    var isPrime47:\
    \ Bool = false\n    var isPrime48: Bool = false\n    var isPrime49: Bool = false\n\
    \    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n    var isPrime52:\
    \ Bool = false\n    var isPrime53: Bool = false\n    var isPrime54: Bool = false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphihtan0x.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmphihtan0x.swift:14:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int = 0\n        ^\n        _\n/tmp/tmphihtan0x.swift:15:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmphihtan0x.swift:16:9: warning:\
    \ variable 'factorizationCount' was never used; consider replacing with '_' or\
    \ removing it\n    var factorizationCount: Int = 0\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmphihtan0x.swift:17:9: warning: variable 'isPrime' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime: Bool = false\n\
    \        ^~~~~~~\n        _\n/tmp/tmphihtan0x.swift:18:9: warning: variable 'isPrime2'\
    \ was never used; consider replacing with '_' or removing it\n    var isPrime2:\
    \ Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:19:9: warning:\
    \ variable 'isPrime3' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:20:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:21:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:22:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmphihtan0x.swift:23:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n   "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp016e3yoi.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorCount = 0\n    while factor <= n {\n\
    \        if n % factor == 0 {\n            factorization[factorCount] = factor\n\
    \            factorCount += 1\n        }\n        factor += 1\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b10610f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1060de7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1060de7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1060de713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1060de6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1060be67ec <unavailable> + 186348

    6    tmpq94_4y0m                        0x0000555b7ada3d36 <unavailable> + 7478

    7    tmpq94_4y0m                        0x0000555b7ada339b <unavailable> + 5019

    8    libc.so.6                          0x00002b10612dc460 __libc_start_main +
    245

    9    tmpq94_4y0m                        0x0000555b7ada30b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [1]\n    var factorization =\
    \ [1]\n    var isPrime = true\n    var isFactorization = true\n    var isPrimeFactorization\
    \ = true\n    var isPrimePrime = true\n    var isPrimePrimeFactorization = true\n\
    \    var isPrimePrimePrime = true\n    var isPrimePrimePrimeFactorization = true\n\
    \    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = true\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm_2ruzg8.swift:42:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = factorize(n: n)\n    var primeFactorsCount = primeFactors.count\n\
    \    var factorsCount = 1\n    var factorsCountMax = primeFactorsCount\n    var\
    \ factorsCountMin = primeFactorsCount\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factorsCountMinInt = Int(factorsCountMin)\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n    var factorsCountMinFloat\
    \ = Float(factorsCountMin)\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factorsCountMinInt = Int(factorsCountMin)\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n    var factorsCountMinFloat\
    \ = Float(factorsCountMin)\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factorsCountMinInt = Int(factorsCountMin)\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n    var factorsCountMinFloat\
    \ = Float(factorsCountMin)\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factorsCountMinInt = Int(factorsCountMin)\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n    var factorsCountMinFloat\
    \ = Float(factorsCountMin)\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factorsCountMinInt = Int(factorsCountMin)\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n    var factorsCountMinFloat\
    \ = Float(factorsCountMin)\n    var factorsCountMaxInt = Int(factorsCountMax)\n\
    \    var factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfwwy9vit.swift:24:9: error: invalid redeclaration of 'factorsCountMaxInt'\n\
    \    var factorsCountMaxInt = Int(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:18:9:\
    \ note: 'factorsCountMaxInt' previously declared here\n    var factorsCountMaxInt\
    \ = Int(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:25:9: error: invalid\
    \ redeclaration of 'factorsCountMinInt'\n    var factorsCountMinInt = Int(factorsCountMin)\n\
    \        ^\n/tmp/tmpfwwy9vit.swift:19:9: note: 'factorsCountMinInt' previously\
    \ declared here\n    var factorsCountMinInt = Int(factorsCountMin)\n        ^\n\
    /tmp/tmpfwwy9vit.swift:26:9: error: invalid redeclaration of 'factorsCountMaxDouble'\n\
    \    var factorsCountMaxDouble = Double(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:20:9:\
    \ note: 'factorsCountMaxDouble' previously declared here\n    var factorsCountMaxDouble\
    \ = Double(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:27:9: error: invalid\
    \ redeclaration of 'factorsCountMinDouble'\n    var factorsCountMinDouble = Double(factorsCountMin)\n\
    \        ^\n/tmp/tmpfwwy9vit.swift:21:9: note: 'factorsCountMinDouble' previously\
    \ declared here\n    var factorsCountMinDouble = Double(factorsCountMin)\n   \
    \     ^\n/tmp/tmpfwwy9vit.swift:28:9: error: invalid redeclaration of 'factorsCountMaxFloat'\n\
    \    var factorsCountMaxFloat = Float(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:22:9:\
    \ note: 'factorsCountMaxFloat' previously declared here\n    var factorsCountMaxFloat\
    \ = Float(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:29:9: error: invalid\
    \ redeclaration of 'factorsCountMinFloat'\n    var factorsCountMinFloat = Float(factorsCountMin)\n\
    \        ^\n/tmp/tmpfwwy9vit.swift:23:9: note: 'factorsCountMinFloat' previously\
    \ declared here\n    var factorsCountMinFloat = Float(factorsCountMin)\n     \
    \   ^\n/tmp/tmpfwwy9vit.swift:30:9: error: invalid redeclaration of 'factorsCountMaxInt'\n\
    \    var factorsCountMaxInt = Int(factorsCountMax)\n        ^\n/tmp/tmpfwwy9vit.swift:18:9:\
    \ note: 'factorsCountMaxInt' previously declared here\n    var factorsCountMaxInt\
    \ = Int(factorsCountMax)\n        ^\n/tmp/tm"
  stdout: ''
  timestamp: 1659824876
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0\
    \ {\n            factors.append(factor)\n            factor = 1\n        } else\
    \ {\n            factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp8upf0mr0/tmp8upf0mr0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b1e12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b1b09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b1b09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b1b087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8upf0mr0                        0x000055d822c5d4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b89b1ffe460 __libc_start_main +
    245

    6    tmp8upf0mr0                        0x000055d822c5d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationIndexMax = factorizationCount - 1\n    var factorizationIndexMin\
    \ = 0\n    var factorizationIndexMaxMin = factorizationIndexMax - 1\n    var factorizationIndexMinMax\
    \ = factorizationIndexMin + 1\n    var factorizationIndexMaxMinMin = factorizationIndexMaxMin\
    \ + 1\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMin\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2j5ff0gl.swift:21:39: error: use of local variable 'factorizationIndexMinMaxMin'\
    \ before its declaration\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\
    \ + 1\n                                      ^\n/tmp/tmp2j5ff0gl.swift:21:9: note:\
    \ 'factorizationIndexMinMaxMin' declared here\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin + 1\n        ^\n/tmp/tmp2j5ff0gl.swift:22:42:\
    \ error: use of local variable 'factorizationIndexMinMaxMinMin' before its declaration\n\
    \    var factorizationIndexMinMaxMinMin = factorizationIndexMinMaxMinMin + 1\n\
    \                                         ^\n/tmp/tmp2j5ff0gl.swift:22:9: note:\
    \ 'factorizationIndexMinMaxMinMin' declared here\n    var factorizationIndexMinMaxMinMin\
    \ = factorizationIndexMinMaxMinMin + 1\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [[Int]] = [[]]\n    var factorizationIndex = 0\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization: [[Int]] = [[]]\n\
    \    var currentFactorizationIndex = 0\n    var currentFactorization: [[Int]]\
    \ = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int]] = [[]]\n    var currentFactorizationIndex = 0\n    var currentFactorization:\
    \ [[Int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_xda2xn1.swift:66:36: error: expected ']' in array type\n    var\
    \ currentFactorization: [[Int\n                                   ^\n/tmp/tmp_xda2xn1.swift:66:32:\
    \ note: to match this opening '['\n    var currentFactorization: [[Int\n     \
    \                          ^\n/tmp/tmp_xda2xn1.swift:66:36: error: expected ']'\
    \ in array type\n    var currentFactorization: [[Int\n                       \
    \            ^\n/tmp/tmp_xda2xn1.swift:66:31: note: to match this opening '['\n\
    \    var currentFactorization: [[Int\n                              ^\n/tmp/tmp_xda2xn1.swift:17:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndex'\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp_xda2xn1.swift:15:9: note: 'currentFactorizationIndex'\
    \ previously declared here\n    var currentFactorizationIndex = 0\n        ^\n\
    /tmp/tmp_xda2xn1.swift:18:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: [[Int]] = [[]]\n        ^\n/tmp/tmp_xda2xn1.swift:16:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ [[Int]] = [[]]\n        ^\n/tmp/tmp_xda2xn1.swift:19:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmp_xda2xn1.swift:15:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp_xda2xn1.swift:20:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ [[Int]] = [[]]\n        ^\n/tmp/tmp_xda2xn1.swift:16:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: [[Int]] = [[]]\n   \
    \     ^\n/tmp/tmp_xda2xn1.swift:21:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp_xda2xn1.swift:15:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp_xda2xn1.swift:22:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization: [[Int]] = [[]]\n     \
    \   ^\n/"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n   \
    \ var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n    var isPrimeFactorsCountMaxIndex = Int(Int\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpub_6volc.swift:51:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpub_6volc.swift:50:42: note: to match this opening '('\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int\n                                         ^\n/tmp/tmpub_6volc.swift:20:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:19:9: note: 'isPrimeFactorsCountMaxIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n\
    \        ^\n/tmp/tmpub_6volc.swift:21:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n\
    \        ^\n/tmp/tmpub_6volc.swift:19:9: note: 'isPrimeFactorsCountMaxIndex' previously\
    \ declared here\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n      \
    \  ^\n/tmp/tmpub_6volc.swift:23:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n\
    \        ^\n/tmp/tmpub_6volc.swift:19:9: note: 'isPrimeFactorsCountMaxIndex' previously\
    \ declared here\n    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n      \
    \  ^\n/tmp/tmpub_6volc.swift:25:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int(Int64.max)\n        ^\n/tmp/tmpub_6volc.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(Int6"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumOfFactors = 0\n    var factorizationSumOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactors = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplb08zgl6.swift:23:9: error: invalid redeclaration of 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:22:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:24:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmplb08zgl6.swift:27:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFac"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationIndex = 0\n \
    \   var factorizationIndex = 0\n    var factorizationIndex2 = 0\n    var factorizationIndex3\
    \ = 0\n    var factorizationIndex4 = 0\n    var factorizationIndex5 = 0\n    var\
    \ factorizationIndex6 = 0\n    var factorizationIndex7 = 0\n    var factorizationIndex8\
    \ = 0\n    var factorizationIndex9 = 0\n    var factorizationIndex10 = 0\n   \
    \ var factorizationIndex11 = 0\n    var factorizationIndex12 = 0\n    var factorizationIndex13\
    \ = 0\n    var factorizationIndex14 = 0\n    var factorizationIndex15 = 0\n  \
    \  var factorizationIndex16 = 0\n    var factorizationIndex17 = 0\n    var factorizationIndex18\
    \ = 0\n    var factorizationIndex19 = 0\n    var factorizationIndex20 = 0\n  \
    \  var factorizationIndex21 = 0\n    var factorizationIndex22 = 0\n    var factorizationIndex23\
    \ = 0\n    var factorizationIndex24 = 0\n    var factorizationIndex25 = 0\n  \
    \  var factorizationIndex26 = 0\n    var factorizationIndex27 = 0\n    var factorizationIndex28\
    \ = 0\n    var factorizationIndex29 = 0\n    var factorizationIndex30 = 0\n  \
    \  var factorizationIndex31 = 0\n    var factorizationIndex32 = 0\n    var factorizationIndex33\
    \ = 0\n    var factorizationIndex34 = 0\n    var factorizationIndex35 = 0\n  \
    \  var factorizationIndex36 = 0\n    var factorizationIndex37 = 0\n    var factorizationIndex38\
    \ = 0\n    var factorizationIndex39 = 0\n    var factorizationIndex40 = 0\n  \
    \  var factorizationIndex41 = 0\n    var factorizationIndex42 = 0\n    var factorizationIndex43\
    \ = 0\n    var factorizationIndex44 = 0\n    var factorizationIndex45 = 0\n  \
    \  var factorizationIndex46 = 0\n    var factorizationIndex47 = 0\n    var factorizationIndex48\
    \ = 0\n    var factorizationIndex49 = 0\n    var factorizationIndex50 = 0\n  \
    \  var factorizationIndex51 = 0\n    var factorizationIndex52 = 0\n    var factorizationIndex53\
    \ = 0\n    var factorizationIndex54 = 0\n    var factorizationIndex55 = 0\n  \
    \  var factorizationIndex56 = 0\n    var factorizationIndex57 = 0\n    var factorizationIndex58\
    \ = 0\n    var factorizationIndex59 = 0\n    var factorizationIndex60 = 0\n  \
    \  var factorizationIndex61 = 0\n    var factorizationIndex62 = 0\n    var factorizationIndex63\
    \ = 0\n    var factorizationIndex64 = 0\n    var factorizationIndex65 = 0\n  \
    \  var factorizationIndex66 = 0\n    var factorizationIndex67 = 0\n    var factorizationIndex68\
    \ = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4c8bqxn6.swift:85:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        if factors.contains(factor) {\n            continue\n        }\n\
    \        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp6nk4mvc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2_5mleaj.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var isPrime: Bool = false\n    var\
    \ isPrimeCount = 0\n    var isPrimeFactorization: Bool = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime: Bool = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization: Bool = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime: Bool = false\n   \
    \ var isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp51mp3dt5.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactorizationPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber: Int = 0\n    var factorizationNumberCount = 0\n    var\
    \ factorizationNumberIndex = 0\n    var factorizationNumberCountMax = 0\n    var\
    \ factorizationNumberIndexMax = 0\n    var factorizationNumberCountMin = 0\n \
    \   var factorizationNumberIndexMin = 0\n    var factorizationNumberCountMaxMin\
    \ = 0\n    var factorizationNumberIndexMaxMin = 0\n    var factorizationNumberCountMinMax\
    \ = 0\n    var factorizationNumberIndexMinMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMaxMinMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMaxMinMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMaxMinMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorizationNumberCountMinMaxMax\
    \ = 0\n    var factorizationNumberIndexMinMaxMax = 0\n    var factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_44wzknd.swift:30:9: error: invalid redeclaration of 'factorizationNumberCountMaxMinMax'\n\
    \    var factorizationNumberCountMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:26:9:\
    \ note: 'factorizationNumberCountMaxMinMax' previously declared here\n    var\
    \ factorizationNumberCountMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:31:9:\
    \ error: invalid redeclaration of 'factorizationNumberIndexMaxMinMax'\n    var\
    \ factorizationNumberIndexMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:27:9:\
    \ note: 'factorizationNumberIndexMaxMinMax' previously declared here\n    var\
    \ factorizationNumberIndexMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:32:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountMinMaxMax'\n    var\
    \ factorizationNumberCountMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:28:9:\
    \ note: 'factorizationNumberCountMinMaxMax' previously declared here\n    var\
    \ factorizationNumberCountMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:33:9:\
    \ error: invalid redeclaration of 'factorizationNumberIndexMinMaxMax'\n    var\
    \ factorizationNumberIndexMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:29:9:\
    \ note: 'factorizationNumberIndexMinMaxMax' previously declared here\n    var\
    \ factorizationNumberIndexMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:34:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountMaxMinMax'\n    var\
    \ factorizationNumberCountMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:26:9:\
    \ note: 'factorizationNumberCountMaxMinMax' previously declared here\n    var\
    \ factorizationNumberCountMaxMinMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:35:9:\
    \ error: invalid redeclaration of 'factorizationNumberIndexMinMaxMax'\n    var\
    \ factorizationNumberIndexMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:29:9:\
    \ note: 'factorizationNumberIndexMinMaxMax' previously declared here\n    var\
    \ factorizationNumberIndexMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:36:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountMinMaxMax'\n    var\
    \ factorizationNumberCountMinMaxMax = 0\n        ^\n/tmp/tmp_44wzknd.swift:28:9:\
    \ note: 'factorizationNumberCountMinMa"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeCountIndex\
    \ = 0\n    var isPrimeCountMax = 0\n    var isPrimeCountMaxIndex = 0\n    var\
    \ isPrimeCountMin = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountSum\
    \ = 0\n    var isPrimeCountSumIndex = 0\n    var isPrimeCountProduct = 0\n   \
    \ var isPrimeCountProductIndex = 0\n    var isPrimeCountProductMax = 0\n    var\
    \ isPrimeCountProductMaxIndex = 0\n    var isPrimeCountProductMin = 0\n    var\
    \ isPrimeCountProductMinIndex = 0\n    var isPrimeCountProductSum = 0\n    var\
    \ isPrimeCountProductSumIndex = 0\n    var isPrimeCountProductProduct = 0\n  \
    \  var isPrimeCountProductProductIndex = 0\n    var isPrimeCountProductProductMax\
    \ = 0\n    var isPrimeCountProductProductMaxIndex = 0\n    var isPrimeCountProductProductMin\
    \ = 0\n    var isPrimeCountProductProductMinIndex = 0\n    var isPrimeCountProductProductSum\
    \ = 0\n    var isPrimeCountProductProductSumIndex = 0\n    var isPrimeCountProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductIndex = 0\n    var isPrimeCountProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n    var isPrimeCountProductProductProductMinIndex = 0\n    var isPrimeCountProductProductProductSum\
    \ = 0\n    var isPrimeCountProductProductProductSumIndex = 0\n    var isPrimeCountProductProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductIndex = 0\n    var isPrimeCountProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n    var isPrimeCountProductProductProductMinIndex = 0\n    var isPrimeCountProductProductProductSum\
    \ = 0\n    var isPrimeCountProductProductProductSumIndex = 0\n    var isPrimeCountProductProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductIndex = 0\n    var isPrimeCountProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n    var isPrimeCountProductProduct\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps62omaz6.swift:52:9: error: invalid redeclaration of 'isPrimeCountProductProductProductIndex'\n\
    \    var isPrimeCountProductProductProductIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:44:9:\
    \ note: 'isPrimeCountProductProductProductIndex' previously declared here\n  \
    \  var isPrimeCountProductProductProductIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:53:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductMax'\n   \
    \ var isPrimeCountProductProductProductMax = 0\n        ^\n/tmp/tmps62omaz6.swift:45:9:\
    \ note: 'isPrimeCountProductProductProductMax' previously declared here\n    var\
    \ isPrimeCountProductProductProductMax = 0\n        ^\n/tmp/tmps62omaz6.swift:54:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductMaxIndex'\n\
    \    var isPrimeCountProductProductProductMaxIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:46:9:\
    \ note: 'isPrimeCountProductProductProductMaxIndex' previously declared here\n\
    \    var isPrimeCountProductProductProductMaxIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:55:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductMin'\n   \
    \ var isPrimeCountProductProductProductMin = 0\n        ^\n/tmp/tmps62omaz6.swift:47:9:\
    \ note: 'isPrimeCountProductProductProductMin' previously declared here\n    var\
    \ isPrimeCountProductProductProductMin = 0\n        ^\n/tmp/tmps62omaz6.swift:56:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductMinIndex'\n\
    \    var isPrimeCountProductProductProductMinIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:48:9:\
    \ note: 'isPrimeCountProductProductProductMinIndex' previously declared here\n\
    \    var isPrimeCountProductProductProductMinIndex = 0\n        ^\n/tmp/tmps62omaz6.swift:57:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductSum'\n   \
    \ var isPrimeCountProductProductProductSum = 0\n        ^\n/tmp/tmps62omaz6.swift:49:9:\
    \ note: 'isPrimeCountProductProductProductSum' previously declared here\n    var\
    \ isPrimeCountProductProductProductSum = 0\n        ^\n/tmp/tmps62omaz6.swift:58:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductSum"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var factor = 1\n    while i <= n {\n      \
    \  while n % i == 0 {\n            factors.append(factor)\n            n /= i\n\
    \            factor = 1\n        }\n        i += 1\n        j += 1\n        factor\
    \ *= j\n    }\n    factors.append(factor)\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7eyoheov.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var factorization\
    \ = [Int]()\n    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorization2 = [Bool]()\n\
    \    var isPrimeFactorization3 = [Bool]()\n    var isPrimeFactorization4 = [Bool]()\n\
    \    var isPrimeFactorization5 = [Bool]()\n    var isPrimeFactorization6 = [Bool]()\n\
    \    var isPrimeFactorization7 = [Bool]()\n    var isPrimeFactorization8 = [Bool]()\n\
    \    var isPrimeFactorization9 = [Bool]()\n    var isPrimeFactorization10 = [Bool]()\n\
    \    var isPrimeFactorization11 = [Bool]()\n    var isPrimeFactorization12 = [Bool]()\n\
    \    var isPrimeFactorization13 = [Bool]()\n    var isPrimeFactorization14 = [Bool]()\n\
    \    var isPrimeFactorization15 = [Bool]()\n    var isPrimeFactorization16 = [Bool]()\n\
    \    var isPrimeFactorization17 = [Bool]()\n    var isPrimeFactorization18 = [Bool]()\n\
    \    var isPrimeFactorization19 = [Bool]()\n    var isPrimeFactorization20 = [Bool]()\n\
    \    var isPrimeFactorization21 = [Bool]()\n    var isPrimeFactorization22 = [Bool]()\n\
    \    var isPrimeFactorization23 = [Bool]()\n    var isPrimeFactorization24 = [Bool]()\n\
    \    var isPrimeFactorization25 = [Bool]()\n    var isPrimeFactorization26 = [Bool]()\n\
    \    var isPrimeFactorization27 = [Bool]()\n    var isPrimeFactorization28 = [Bool]()\n\
    \    var isPrimeFactorization29 = [Bool]()\n    var isPrimeFactorization30 = [Bool]()\n\
    \    var isPrimeFactorization31 = [Bool]()\n    var isPrimeFactorization32 = [Bool]()\n\
    \    var isPrimeFactorization33 = [Bool]()\n    var isPrimeFactorization34 = [Bool]()\n\
    \    var isPrimeFactorization35 = [Bool]()\n    var isPrimeFactorization36 = [Bool]()\n\
    \    var isPrimeFactorization37 = [Bool]()\n    var isPrimeFactorization38 = [Bool]()\n\
    \    var isPrimeFactorization39 = [\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: '/tmp/tmphm9mguo7.swift:57:1: error: expected expression in container literal

    }

    ^

    '
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int\
    \ = 0\n    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q:\
    \ Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var\
    \ u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n   \
    \ var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n\
    \    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int =\
    \ 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int\
    \ = 0\n    var k: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var p:\
    \ Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var\
    \ t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n   \
    \ var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n\
    \    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int =\
    \ 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int\
    \ = 0\n    var j: Int = 0\n    var k: Int = 0\n    var m: Int = 0\n    var n:\
    \ Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var\
    \ s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n   \
    \ var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n\
    \    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int =\
    \ 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int\
    \ = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var m:\
    \ Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var\
    \ r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n   \
    \ var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n\
    \    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int =\
    \ 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int\
    \ = 0\n    var h: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9152iyuz.swift:38:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:39:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:40:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:41:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:17:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:42:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:18:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:43:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:19:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:44:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:20:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:45:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:21:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:46:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:22:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:47:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:23:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:48:9:\
    \ error: invalid redeclaration of 'u'\n    var u: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:24:9:\
    \ note: 'u' previously declared here\n    var u: Int = 0\n "
  stdout: ''
  timestamp: 1659824877
- exit_code: -1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorizationCount = 0\n    while factorizationCount\
    \ < n {\n        if n % factor == 0 {\n            factorizationCount += 1\n \
    \           factorization.append(factor)\n        }\n        factor += 1\n   \
    \ }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824882
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber: Int = 0\n    var factorizationNumberIndex = 0\n    var\
    \ factorizationNumberIndex2 = 0\n    var factorizationNumberIndex3 = 0\n    var\
    \ factorizationNumberIndex4 = 0\n    var factorizationNumberIndex5 = 0\n    var\
    \ factorizationNumberIndex6 = 0\n    var factorizationNumberIndex7 = 0\n    var\
    \ factorizationNumberIndex8 = 0\n    var factorizationNumberIndex9 = 0\n    var\
    \ factorizationNumberIndex10 = 0\n    var factorizationNumberIndex11 = 0\n   \
    \ var factorizationNumberIndex12 = 0\n    var factorizationNumberIndex13 = 0\n\
    \    var factorizationNumberIndex14 = 0\n    var factorizationNumberIndex15 =\
    \ 0\n    var factorizationNumberIndex16 = 0\n    var factorizationNumberIndex17\
    \ = 0\n    var factorizationNumberIndex18 = 0\n    var factorizationNumberIndex19\
    \ = 0\n    var factorizationNumberIndex20 = 0\n    var factorizationNumberIndex21\
    \ = 0\n    var factorizationNumberIndex22 = 0\n    var factorizationNumberIndex23\
    \ = 0\n    var factorizationNumberIndex24 = 0\n    var factorizationNumberIndex25\
    \ = 0\n    var factorizationNumberIndex26 = 0\n    var factorizationNumberIndex27\
    \ = 0\n    var factorizationNumberIndex28 = 0\n    var factorizationNumberIndex29\
    \ = 0\n    var factorizationNumberIndex30 = 0\n    var factorizationNumberIndex31\
    \ = 0\n    var factorizationNumberIndex32 = 0\n    var factorizationNumberIndex33\
    \ = 0\n    var factorizationNumberIndex34 = 0\n    var factorizationNumberIndex35\
    \ = 0\n    var factorizationNumberIndex36 = 0\n    var factorizationNumberIndex37\
    \ = 0\n    var factorizationNumberIndex38 = 0\n    var factorizationNumberIndex39\
    \ = 0\n    var factorizationNumberIndex40 = 0\n    var factorizationNumberIndex41\
    \ = 0\n    var factorizationNumberIndex42 = 0\n    var factorizationNumberIndex43\
    \ = 0\n    var factorizationNumberIndex44 = 0\n    var factorizationNumberIndex45\
    \ = 0\n    var factorizationNumberIndex46 = 0\n    var factorizationNumberIndex47\
    \ = 0\n    var factorizationNumberIndex48 = 0\n    var factorizationNumberIndex49\
    \ = 0\n    var factorizationNumberIndex50 = 0\n    var factorizationNumberIndex51\
    \ = 0\n    var factorizationNumberIndex52 = 0\n    var factorizationNumberIndex53\
    \ = 0\n    var factorizationNumberIndex54 = 0\n    var factorizationNumberIndex55\
    \ = 0\n    var factorizationNumberIndex56 = 0\n    var factorizationNumberIndex57\
    \ = 0\n    var factorizationNumberIndex58 = 0\n    var factorizationNumberIndex59\
    \ = 0\n    var factorizationNumberIndex60 = 0\n    var factorizationNumberIndex61\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1jm6sxly.swift:76:9: error: type annotation missing in pattern\n\
    \    var factorizationNumberIndex61\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexCount = 0\n    var factorizationIndexCountMax = Int(IntMax)\n\
    \    var factorizationIndexCountMin = Int(IntMin)\n    var factorizationIndexCountMinMax\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxInt = Int(IntMax)\n    var\
    \ factorizationIndexCountMinMaxIntInt = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntInt = Int(IntMax)\n\
    \    var factorizationIndexCountMinMaxIntIntIntIntInt = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntInt =\
    \ Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntInt =\
    \ Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqf99f8bk.swift:16:42: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationIndexCountMax = Int(IntMax)\n                            \
    \             ^~~~~~\n/tmp/tmpqf99f8bk.swift:17:42: error: cannot find 'IntMin'\
    \ in scope\n    var factorizationIndexCountMin = Int(IntMin)\n               \
    \                          ^~~~~~\n/tmp/tmpqf99f8bk.swift:18:45: error: cannot\
    \ find 'IntMax' in scope\n    var factorizationIndexCountMinMax = Int(IntMax)\n\
    \                                            ^~~~~~\n/tmp/tmpqf99f8bk.swift:19:48:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxInt\
    \ = Int(IntMax)\n                                               ^~~~~~\n/tmp/tmpqf99f8bk.swift:20:51:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntInt\
    \ = Int(IntMax)\n                                                  ^~~~~~\n/tmp/tmpqf99f8bk.swift:21:54:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntIntInt\
    \ = Int(IntMax)\n                                                     ^~~~~~\n\
    /tmp/tmpqf99f8bk.swift:22:57: error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntIntIntInt\
    \ = Int(IntMax)\n                                                        ^~~~~~\n\
    /tmp/tmpqf99f8bk.swift:23:60: error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntIntIntIntInt\
    \ = Int(IntMax)\n                                                           ^~~~~~\n\
    /tmp/tmpqf99f8bk.swift:24:63: error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntIntIntIntIntInt\
    \ = Int(IntMax)\n                                                            \
    \  ^~~~~~\n/tmp/tmpqf99f8bk.swift:25:66: error: cannot find 'IntMax' in scope\n\
    \    var factorizationIndexCountMinMaxIntIntIntIntIntIntInt = Int(IntMax)\n  \
    \                                                               ^~~~~~\n/tmp/tmpqf99f8bk.swift:26:69:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMinMaxIntIntIntIntIntIntIntInt\
    \ = Int(IntMax)\n                                                 "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountMax\
    \ = 0\n    var factorizationNumberCountMaxIndex = 0\n    var factorizationNumberCountMin\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumber\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplpvcey22.swift:23:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmplpvcey22.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmplpvcey22.swift:25:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmplpvcey22.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmplpvcey22.swift:27:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmplpvcey22.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmplpvcey22.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmplpvcey22.swift:29:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmplpvcey22.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared h"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount =\
    \ 0\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n    var isPrimeCountMin =\
    \ 1\n    var isPrimeCountMaxMin = Int(sqrt(Double(n)))\n    var isPrimeCountMinMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMax = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n \
    \   var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpld3q54id.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeCountMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpld3q54id.swift:18:34: error: cannot find 'sqrt' in scope\n    var isPrimeCountMaxMin\
    \ = Int(sqrt(Double(n)))\n                                 ^~~~\n/tmp/tmpld3q54id.swift:19:34:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMax = Int(sqrt(Double(n)))\n\
    \                                 ^~~~\n/tmp/tmpld3q54id.swift:20:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMinMaxMin = Int(sqrt(Double(n)))\n\
    \                                    ^~~~\n/tmp/tmpld3q54id.swift:21:40: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \                                       ^~~~\n/tmp/tmpld3q54id.swift:22:43: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \                                          ^~~~\n/tmp/tmpld3q54id.swift:23:46:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMax =\
    \ Int(sqrt(Double(n)))\n                                             ^~~~\n/tmp/tmpld3q54id.swift:24:49:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n                                                ^~~~\n\
    /tmp/tmpld3q54id.swift:25:52: error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax\
    \ = Int(sqrt(Double(n)))\n                                                   ^~~~\n\
    /tmp/tmpld3q54id.swift:26:55: error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n                                                   \
    \   ^~~~\n/tmp/tmpld3q54id.swift:27:58: error: cannot find 'sqrt' in scope\n \
    \   var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n  \
    \                                                       ^~~~\n/tmp/tmpld3q54id.swift:28:61:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n             "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp337ks_2p.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2_5mleaj.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = 0\n \
    \   var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount =\
    \ 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz0dpzzos.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpz0dpzzos.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpz0dpzzos.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz0dpzzos.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpz0dpzzos.swift:35:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz0dpzzos.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpz0dpzzos.swift:36:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpz0dpzzos.swift:34:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n     \
    \   ^\n/tmp/tmpz0dpzzos.swift:39:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpz0dpzzos.swift:37:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpz0dpzzos.swift:40:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpz0dpzzos.swift:38:9: note: 'i"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationValueIndex\
    \ = 0\n    var currentFactorizationValueIndex2 = 0\n    var currentFactorizationValueIndex3\
    \ = 0\n    var currentFactorizationValueIndex4 = 0\n    var currentFactorizationValueIndex5\
    \ = 0\n    var currentFactorizationValueIndex6 = 0\n    var currentFactorizationValueIndex7\
    \ = 0\n    var currentFactorizationValueIndex8 = 0\n    var currentFactorizationValueIndex9\
    \ = 0\n    var currentFactorizationValueIndex10 = 0\n    var currentFactorizationValueIndex11\
    \ = 0\n    var currentFactorizationValueIndex12 = 0\n    var currentFactorizationValueIndex13\
    \ = 0\n    var currentFactorizationValueIndex14 = 0\n    var currentFactorizationValueIndex15\
    \ = 0\n    var currentFactorizationValueIndex16 = 0\n    var currentFactorizationValueIndex17\
    \ = 0\n    var currentFactorizationValueIndex18 = 0\n    var currentFactorizationValueIndex19\
    \ = 0\n    var currentFactorizationValueIndex20 = 0\n    var currentFactorizationValueIndex21\
    \ = 0\n    var currentFactorizationValueIndex22 = 0\n    var currentFactorizationValueIndex23\
    \ = 0\n    var currentFactorizationValueIndex24 = 0\n    var currentFactorizationValueIndex25\
    \ = 0\n    var currentFactorizationValueIndex26 = 0\n    var currentFactorizationValueIndex27\
    \ = 0\n    var currentFactorizationValueIndex28 = 0\n    var currentFactorizationValueIndex29\
    \ = 0\n    var currentFactorizationValueIndex30 = 0\n    var currentFactorizationValueIndex31\
    \ = 0\n    var currentFactorizationValueIndex32 = 0\n    var currentFactorizationValueIndex33\
    \ = 0\n    var currentFactorizationValueIndex34 = 0\n    var currentFactorizationValueIndex35\
    \ = 0\n    var currentFactorizationValueIndex36 = 0\n    var currentFactorizationValueIndex37\
    \ = 0\n    var currentFactorizationValueIndex38 = 0\n    var currentFactorizationValueIndex39\
    \ = 0\n    var currentFactorizationValueIndex40 = 0\n    var currentFactorizationValueIndex41\
    \ = 0\n    var currentFactorizationValueIndex42 = 0\n    var currentFactorizationValueIndex43\
    \ = 0\n    var currentFactorizationValueIndex44 = 0\n    var currentFactorizationValueIndex45\
    \ = 0\n    var currentFactorizationValueIndex46 = 0\n    var currentFactorizationValueIndex47\
    \ = 0\n    var currentFactorizationValueIndex48 = 0\n    var currentFactorizationValueIndex49\
    \ = 0\n    var currentFactorizationValueIndex50 = 0\n    var currentFactorizationValueIndex51\
    \ = 0\n    var currentFactorizationValueIndex52 = 0\n    var currentFactorizationValueIndex53\
    \ = 0\n    var current\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbbapg7id.swift:70:9: error: type annotation missing in pattern\n\
    \    var current\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationProduct = 1\n    var factorizationSumProduct = 1\n    var factorizationProductSum\
    \ = 0\n    var factorizationProductSumProduct = 1\n    var factorizationProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProduct = 1\n    var factorizationProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProduct = 1\n    var\
    \ factorizationProductSumProductSumProductSumProductSum = 0\n    var factorizationProductSumProductSumProductSumProductSumProduct\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProduct\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n    var factorizationProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt3kfw4ub.swift:26:9: error: invalid redeclaration of 'factorizationProductSumProductSumProductSumProductSumProductSum'\n\
    \    var factorizationProductSumProductSumProductSumProductSumProductSum = 1\n\
    \        ^\n/tmp/tmpt3kfw4ub.swift:25:9: note: 'factorizationProductSumProductSumProductSumProductSumProductSum'\
    \ previously declared here\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationProductSumProductSumProductSumProductSumProductSum'\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:25:9: note: 'factorizationProductSumProductSumProductSumProductSumProductSum'\
    \ previously declared here\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationProductSumProductSumProductSumProductSumProductSum'\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n        ^\n/tmp/tmpt3kfw4ub.swift:25:9: note: 'factorizationProductSumProductSumProductSumProductSumProductSum'\
    \ previously declared here\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:29:9: error: invalid redeclaration of\
    \ 'factorizationProductSumProductSumProductSumProductSumProductSum'\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:25:9: note: 'factorizationProductSumProductSumProductSumProductSumProductSum'\
    \ previously declared here\n    var factorizationProductSumProductSumProductSumProductSumProductSum\
    \ = 0\n        ^\n/tmp/tmpt3kfw4ub.swift:32:9: error: invalid redeclaration of\
    \ 'factorizationProductSumProductSumProductSumProductSumProductSumProductSum'\n\
    \    var factorizationProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1\n        ^\n/tmp/tmpt3kfw4ub.swift:31:9: note: 'factorizationProductSumProductSumProductSumProductSumProductSumProductSum'\
    \ prev"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int\
    \ = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var p:\
    \ Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var\
    \ t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n   \
    \ var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n\
    \    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int =\
    \ 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int\
    \ = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m:\
    \ Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var\
    \ r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n   \
    \ var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n\
    \    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int =\
    \ 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int\
    \ = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k:\
    \ Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var\
    \ p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n   \
    \ var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n\
    \    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int =\
    \ 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int\
    \ = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i:\
    \ Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var\
    \ m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n   \
    \ var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n\
    \    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int =\
    \ 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuhvyjy5f.swift:109:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpuhvyjy5f.swift:39:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:40:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmpuhvyjy5f.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmpuhvy"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = factorization(n: n)\n    for prime in primes {\n        factors.append(prime)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkiaonf3c.swift:13:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n: n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationFactor\
    \ = 1\n    var factorizationPrime = 1\n    var factorizationPrimeIndex = 0\n \
    \   var factorizationPrimeCount = 1\n    var factorizationPrimeFactor = 1\n  \
    \  var factorizationPrimePrime = 1\n    var factorizationPrimePrimeIndex = 0\n\
    \    var factorizationPrimePrimeCount = 1\n    var factorizationPrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrime = 1\n    var factorizationPrimePrimePrimeIndex\
    \ = 0\n    var factorizationPrimePrimePrimeCount = 1\n    var factorizationPrimePrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrimePrime = 1\n    var factorizationPrimePrimePrimePrimeIndex\
    \ = 0\n    var factorizationPrimePrimePrimePrimeCount = 1\n    var factorizationPrimePrimePrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrimePrimePrime = 1\n    var factorizationPrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var factorizationPrimePrimePrimePrimePrimeCount = 1\n    var factorizationPrimePrimePrimePrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrimePrimePrimePrime = 1\n    var factorizationPrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var factorizationPrimePrimePrimePrimePrimePrimeCount = 1\n    var factorizationPrimePrimePrimePrimePrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrimePrimePrimePrimePrime = 1\n    var factorizationPrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeCount = 1\n   \
    \ var factorizationPrimePrimePrimePrimePrimePrimePrimeFactor = 1\n    var factorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = 1\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeIndex = 0\n   \
    \ var factorizationPrimePrimePrimePrimePrimePrimePrimeCount = 1\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = 1\n    var factorizationPrimePrimePrimePrimePrimePrimePrimePrime = 1\n   \
    \ var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcbbwzan.swift:41:9: error: invalid redeclaration of 'factorizationPrimePrimePrimePrimePrimePrimeIndex'\n\
    \    var factorizationPrimePrimePrimePrimePrimePrimeIndex = 0\n        ^\n/tmp/tmptcbbwzan.swift:37:9:\
    \ note: 'factorizationPrimePrimePrimePrimePrimePrimeIndex' previously declared\
    \ here\n    var factorizationPrimePrimePrimePrimePrimePrimeIndex = 0\n       \
    \ ^\n/tmp/tmptcbbwzan.swift:44:9: error: invalid redeclaration of 'factorizationPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var factorizationPrimePrimePrimePrimePrimePrimePrime = 1\n        ^\n/tmp/tmptcbbwzan.swift:40:9:\
    \ note: 'factorizationPrimePrimePrimePrimePrimePrimePrime' previously declared\
    \ here\n    var factorizationPrimePrimePrimePrimePrimePrimePrime = 1\n       \
    \ ^\n/tmp/tmptcbbwzan.swift:46:9: error: invalid redeclaration of 'factorizationPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var factorizationPrimePrimePrimePrimePrimePrimePrimeCount = 1\n        ^\n\
    /tmp/tmptcbbwzan.swift:42:9: note: 'factorizationPrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 1\n        ^\n/tmp/tmptcbbwzan.swift:47:9: error: invalid redeclaration of\
    \ 'factorizationPrimePrimePrimePrimePrimePrimePrimeFactor'\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = 1\n        ^\n/tmp/tmptcbbwzan.swift:43:9: note: 'factorizationPrimePrimePrimePrimePrimePrimePrimeFactor'\
    \ previously declared here\n    var factorizationPrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = 1\n        ^\n/tmp/tmptcbbwzan.swift:49:9: error: type annotation missing\
    \ in pattern\n    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var factorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var factorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var factorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var factorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var factorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var factorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var factorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var factorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var factorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var factorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var factorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var factorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var factorizationNumberIndex27 = 0\n    var factorizationNumberIndex28\
    \ = 0\n    var factorizationNumberIndex29 = 0\n    var factorizationNumberIndex30\
    \ = 0\n    var factorizationNumberIndex31 = 0\n    var factorizationNumberIndex32\
    \ = 0\n    var factorizationNumberIndex33 = 0\n    var factorizationNumberIndex34\
    \ = 0\n    var factorizationNumberIndex35 = 0\n    var factorizationNumberIndex36\
    \ = 0\n    var factorizationNumberIndex37 = 0\n    var factorizationNumberIndex38\
    \ = 0\n    var factorizationNumberIndex39 = 0\n    var factorizationNumberIndex40\
    \ = 0\n    var factorizationNumberIndex41 = 0\n    var factorizationNumberIndex42\
    \ = 0\n    var factorizationNumberIndex43 = 0\n    var factorizationNumberIndex44\
    \ = 0\n    var factorizationNumberIndex45 = 0\n    var factorizationNumberIndex46\
    \ = 0\n    var factorizationNumberIndex47 = 0\n    var factorizationNumberIndex48\
    \ = 0\n    var factorizationNumberIndex49 = 0\n    var factorizationNumberIndex50\
    \ = 0\n    var factorizationNumberIndex51 = 0\n    var factorizationNumberIndex52\
    \ = 0\n    var factorizationNumberIndex53 = 0\n    var factorizationNumberIndex54\
    \ = 0\n    var factorizationNumberIndex55 = 0\n    var factorizationNumberIndex56\
    \ = 0\n    var factorizationNumberIndex57 = 0\n    var factorizationNumberIndex58\
    \ = 0\n    var factorizationNumberIndex59 = 0\n    var factorizationNumberIndex60\
    \ = 0\n    var factorizationNumberIndex61 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcpfe9y4m.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpcpfe9y4m.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcpfe9y4m.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:15:9:\
    \ warning: initialization of variable 'factorizationNumber' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumber\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:16:9: warning:\
    \ initialization of variable 'factorizationNumberIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:17:9: warning:\
    \ initialization of variable 'factorizationNumberIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:18:9:\
    \ warning: initialization of variable 'factorizationNumberIndex3' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:19:9:\
    \ warning: initialization of variable 'factorizationNumberIndex4' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcpfe9y4m.swift:20:9:\
    \ warning: initialization of variable 'factorizationNumberIndex5' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex5\
    \ = 0\n    ~~~~^~~"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationIndex\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n\
    \    var currentPrimeFactorization = [Int]()\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n    var currentPrimeFactorizationIndexMax = IntMax\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpb4_jnav7.swift:19:45: error: cannot find 'IntMax' in scope\n  \
    \  var currentPrimeFactorizationIndexMax = IntMax\n                          \
    \                  ^~~~~~\n/tmp/tmpb4_jnav7.swift:20:45: error: cannot find 'IntMin'\
    \ in scope\n    var currentPrimeFactorizationIndexMin = IntMin\n             \
    \                               ^~~~~~\n/tmp/tmpb4_jnav7.swift:21:45: error: cannot\
    \ find 'IntMax' in scope\n    var currentPrimeFactorizationIndexMax = IntMax\n\
    \                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:22:45:\
    \ error: cannot find 'IntMin' in scope\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:23:45:\
    \ error: cannot find 'IntMax' in scope\n    var currentPrimeFactorizationIndexMax\
    \ = IntMax\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:24:45:\
    \ error: cannot find 'IntMin' in scope\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:25:45:\
    \ error: cannot find 'IntMax' in scope\n    var currentPrimeFactorizationIndexMax\
    \ = IntMax\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:26:45:\
    \ error: cannot find 'IntMin' in scope\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:27:45:\
    \ error: cannot find 'IntMax' in scope\n    var currentPrimeFactorizationIndexMax\
    \ = IntMax\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:28:45:\
    \ error: cannot find 'IntMin' in scope\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:29:45:\
    \ error: cannot find 'IntMax' in scope\n    var currentPrimeFactorizationIndexMax\
    \ = IntMax\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swift:30:45:\
    \ error: cannot find 'IntMin' in scope\n    var currentPrimeFactorizationIndexMin\
    \ = IntMin\n                                            ^~~~~~\n/tmp/tmpb4_jnav7.swi"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var isPrime: Bool = false\n    var\
    \ isPrimeCount = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwt4z5viw.swift:40:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n        ^\n/tmp/tmpwt4z5viw.swift:39:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpwt4z5viw.swift:41:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = [1]\n    var i: Int = 0\n    var j: Int = 0\n\
    \    var factor: Int = 0\n    var factorizationCount: Int = 0\n    var isPrime:\
    \ Bool = false\n    var isPrimeCount: Int = 0\n    var isPrimeFactorization: Bool\
    \ = false\n    var isPrimeFactorizationCount: Int = 0\n    var isPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeCount: Int = 0\n    var isPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorCount: Int = 0\n    var\
    \ isPrimeFactorizationPrimeFactorPrime: Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactor: Bool = false\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorCount: Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactor: Bool\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n    var isPrimeFactorizationPrimeFactor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqah7yiif.swift:39:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount'\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount:\
    \ Int = 0\n        ^\n/tmp/tmpqah7yiif.swift:37:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount:\
    \ Int = 0\n        ^\n/tmp/tmpqah7yiif.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime'\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n        ^\n/tmp/tmpqah7yiif.swift:38:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime:\
    \ Bool = false\n        ^\n/tmp/tmpqah7yiif.swift:43:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount'\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n        ^\n/tmp/tmpqah7yiif.swift:41:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrimeCount:\
    \ Int = 0\n        ^\n/tmp/tmpqah7yiif.swift:44:9: error: type annotation missing\
    \ in pattern\n    var isPrimeFactorizationPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var factorizationCountMax = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax2 = Int(sqrt(Double(n)))\n    var factorizationCountMax3\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax4 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax5 = Int(sqrt(Double(n)))\n    var factorizationCountMax6\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax7 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax8 = Int(sqrt(Double(n)))\n    var factorizationCountMax9\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax10 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax11 = Int(sqrt(Double(n)))\n    var factorizationCountMax12\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax13 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax14 = Int(sqrt(Double(n)))\n    var factorizationCountMax15\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax16 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax17 = Int(sqrt(Double(n)))\n    var factorizationCountMax18\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax19 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax20 = Int(sqrt(Double(n)))\n    var factorizationCountMax21\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax22 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax23 = Int(sqrt(Double(n)))\n    var factorizationCountMax24\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax25 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax26 = Int(sqrt(Double(n)))\n    var factorizationCountMax27\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax28 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax29 = Int(sqrt(Double(n)))\n    var factorizationCountMax30\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax31 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax32 = Int(sqrt(Double(n)))\n    var factorizationCountMax33\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax34 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax35 = Int(sqrt(Double(n)))\n    var factorizationCountMax36\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountMax37 = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMax38 = Int(sqrt(Double(n)))\n    var factor\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqgqixsv1.swift:16:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationCountMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmpqgqixsv1.swift:17:38: error: cannot find 'sqrt' in scope\n\
    \    var factorizationCountMax2 = Int(sqrt(Double(n)))\n                     \
    \                ^~~~\n/tmp/tmpqgqixsv1.swift:18:38: error: cannot find 'sqrt'\
    \ in scope\n    var factorizationCountMax3 = Int(sqrt(Double(n)))\n          \
    \                           ^~~~\n/tmp/tmpqgqixsv1.swift:19:38: error: cannot\
    \ find 'sqrt' in scope\n    var factorizationCountMax4 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:20:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax5 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:21:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax6 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:22:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax7 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:23:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax8 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:24:38: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax9 = Int(sqrt(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmpqgqixsv1.swift:25:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax10 = Int(sqrt(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmpqgqixsv1.swift:26:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax11 = Int(sqrt(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmpqgqixsv1.swift:27:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax12 = Int(sqrt(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmpqgqixsv1.swift:28:39: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountMax13 = Int(sqrt(Doub"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy0jokyx7.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz396cms2.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = n\n    while p > 1 {\n        while p % i == 0 {\n\
    \            factors.append(i)\n            p /= i\n        }\n        i += 1\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber: Int = 0\n    var factorizationNumberIndex = 0\n    var\
    \ factorizationNumberIndex2 = 0\n    var factorizationNumberIndex3 = 0\n    var\
    \ factorizationNumberIndex4 = 0\n    var factorizationNumberIndex5 = 0\n    var\
    \ factorizationNumberIndex6 = 0\n    var factorizationNumberIndex7 = 0\n    var\
    \ factorizationNumberIndex8 = 0\n    var factorizationNumberIndex9 = 0\n    var\
    \ factorizationNumberIndex10 = 0\n    var factorizationNumberIndex11 = 0\n   \
    \ var factorizationNumberIndex12 = 0\n    var factorizationNumberIndex13 = 0\n\
    \    var factorizationNumberIndex14 = 0\n    var factorizationNumberIndex15 =\
    \ 0\n    var factorizationNumberIndex16 = 0\n    var factorizationNumberIndex17\
    \ = 0\n    var factorizationNumberIndex18 = 0\n    var factorizationNumberIndex19\
    \ = 0\n    var factorizationNumberIndex20 = 0\n    var factorizationNumberIndex21\
    \ = 0\n    var factorizationNumberIndex22 = 0\n    var factorizationNumberIndex23\
    \ = 0\n    var factorizationNumberIndex24 = 0\n    var factorizationNumberIndex25\
    \ = 0\n    var factorizationNumberIndex26 = 0\n    var factorizationNumberIndex27\
    \ = 0\n    var factorizationNumberIndex28 = 0\n    var factorizationNumberIndex29\
    \ = 0\n    var factorizationNumberIndex30 = 0\n    var factorizationNumberIndex31\
    \ = 0\n    var factorizationNumberIndex32 = 0\n    var factorizationNumberIndex33\
    \ = 0\n    var factorizationNumberIndex34 = 0\n    var factorizationNumberIndex35\
    \ = 0\n    var factorizationNumberIndex36 = 0\n    var factorizationNumberIndex37\
    \ = 0\n    var factorizationNumberIndex38 = 0\n    var factorizationNumberIndex39\
    \ = 0\n    var factorizationNumberIndex40 = 0\n    var factorizationNumberIndex41\
    \ = 0\n    var factorizationNumberIndex42 = 0\n    var factorizationNumberIndex43\
    \ = 0\n    var factorizationNumberIndex44 = 0\n    var factorizationNumberIndex45\
    \ = 0\n    var factorizationNumberIndex46 = 0\n    var factorizationNumberIndex47\
    \ = 0\n    var factorizationNumberIndex48 = 0\n    var factorizationNumberIndex49\
    \ = 0\n    var factorizationNumberIndex50 = 0\n    var factorizationNumberIndex51\
    \ = 0\n    var factorizationNumberIndex52 = 0\n    var factorizationNumberIndex53\
    \ = 0\n    var factorizationNumberIndex54 = 0\n    var factorizationNumberIndex55\
    \ = 0\n    var factorizationNumberIndex56 = 0\n    var factorizationNumberIndex57\
    \ = 0\n    var factorizationNumberIndex58 = 0\n    var factorizationNumberIndex59\
    \ = 0\n    var factorizationNumberIndex60 = 0\n    var factorizationNumberIndex61\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1jm6sxly.swift:76:9: error: type annotation missing in pattern\n\
    \    var factorizationNumberIndex61\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [1]\n    var factorization = [Int]()\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = true\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy560zh6d.swift:33:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpy560zh6d.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpy560zh6d.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpy560zh6d.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpy560zh6d.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpy560zh6d.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpy560zh6d.swift:42:9: error: type annotation missing\
    \ in pattern\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var primeFactorsCount = 0\n    var isPrime\
    \ = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu1i3qpne.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var prime: Int = 0\n    var isPrime: Bool\
    \ = false\n    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n  \
    \  var isPrime4: Bool = false\n    var isPrime5: Bool = false\n    var isPrime6:\
    \ Bool = false\n    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n\
    \    var isPrime9: Bool = false\n    var isPrime10: Bool = false\n    var isPrime11:\
    \ Bool = false\n    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n\
    \    var isPrime14: Bool = false\n    var isPrime15: Bool = false\n    var isPrime16:\
    \ Bool = false\n    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n\
    \    var isPrime19: Bool = false\n    var isPrime20: Bool = false\n    var isPrime21:\
    \ Bool = false\n    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n\
    \    var isPrime24: Bool = false\n    var isPrime25: Bool = false\n    var isPrime26:\
    \ Bool = false\n    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n\
    \    var isPrime29: Bool = false\n    var isPrime30: Bool = false\n    var isPrime31:\
    \ Bool = false\n    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n\
    \    var isPrime34: Bool = false\n    var isPrime35: Bool = false\n    var isPrime36:\
    \ Bool = false\n    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n\
    \    var isPrime39: Bool = false\n    var isPrime40: Bool = false\n    var isPrime41:\
    \ Bool = false\n    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n\
    \    var isPrime44: Bool = false\n    var isPrime45: Bool = false\n    var isPrime46:\
    \ Bool = false\n    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n\
    \    var isPrime49: Bool = false\n    var isPrime50: Bool = false\n    var isPrime51:\
    \ Bool = false\n    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n\
    \    var isPrime54: Bool = false\n    var isPrime55: Bool = false\n    var isPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnmvd80zi.swift:70:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumCount = 0\n    var factorizationSumCountMax = 0\n    var factorizationSumCountMin\
    \ = 0\n    var factorizationSumCountMaxMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var factorizationSumCountMaxMinMin\
    \ = 0\n    var factorizationSumCountMaxMinMin = 0\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsxpq622y.swift:65:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpsxpq622y.swift:20:9: error: invalid redeclaration of 'factorizationSumCountMaxMinMin'\n\
    \    var factorizationSumCountMaxMinMin = 0\n        ^\n/tmp/tmpsxpq622y.swift:19:9:\
    \ note: 'factorizationSumCountMaxMinMin' previously declared here\n    var factorizationSumCountMaxMinMin\
    \ = 0\n        ^\n/tmp/tmpsxpq622y.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMaxMinMin'\n    var factorizationSumCountMaxMinMin = 0\n\
    \        ^\n/tmp/tmpsxpq622y.swift:19:9: note: 'factorizationSumCountMaxMinMin'\
    \ previously declared here\n    var factorizationSumCountMaxMinMin = 0\n     \
    \   ^\n/tmp/tmpsxpq622y.swift:22:9: error: invalid redeclaration of 'factorizationSumCountMaxMinMin'\n\
    \    var factorizationSumCountMaxMinMin = 0\n        ^\n/tmp/tmpsxpq622y.swift:19:9:\
    \ note: 'factorizationSumCountMaxMinMin' previously declared here\n    var factorizationSumCountMaxMinMin\
    \ = 0\n        ^\n/tmp/tmpsxpq622y.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMaxMinMin'\n    var factorizationSumCountMaxMinMin = 0\n\
    \        ^\n/tmp/tmpsxpq622y.swift:19:9: note: 'factorizationSumCountMaxMinMin'\
    \ previously declared here\n    var factorizationSumCountMaxMinMin = 0\n     \
    \   ^\n/tmp/tmpsxpq622y.swift:24:9: error: invalid redeclaration of 'factorizationSumCountMaxMinMin'\n\
    \    var factorizationSumCountMaxMinMin = 0\n        ^\n/tmp/tmpsxpq622y.swift:19:9:\
    \ note: 'factorizationSumCountMaxMinMin' previously declared here\n    var factorizationSumCountMaxMinMin\
    \ = 0\n        ^\n/tmp/tmpsxpq622y.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMaxMinMin'\n    var factorizationSumCountMaxMinMin = 0\n\
    \        ^\n/tmp/tmpsxpq622y.swift:19:9: note: 'factorizationSumCountMaxMinMin'\
    \ previously declared here\n    var factorizationSumCountMaxMinMin = 0\n     \
    \   ^\n/tmp/tmpsxpq622y.swift:26:9: error: invalid redeclaration of 'factorizationSumCountMaxMinMin'\n\
    \    var factorizationSumCountMaxMinMin = 0\n        ^\n/tmp/tmpsxpq622y.swift:19:9:\
    \ note: 'factorizationSumCountMaxMinMin' prev"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = 0\n    var factorizationMin = 0\n    var factorizationSum\
    \ = 0\n    var factorizationSumMax = 0\n    var factorizationSumMin = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMinIndex = 0\n    var\
    \ factorizationSumMaxIndex = 0\n    var factorizationSumMin\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcanwm_4a.swift:22:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmpcanwm_4a.swift:20:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmpcanwm_4a.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationSumMinIndex'\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmpcanwm_4a.swift:21:9: note: 'factorizationSumMinIndex' previously declared\
    \ here\n    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmpcanwm_4a.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmpcanwm_4a.swift:20:9: note: 'factorizationSumMaxIndex'\
    \ previously declared here\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmpcanwm_4a.swift:25:9: error: invalid redeclaration of 'factorizationSumMinIndex'\n\
    \    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmpcanwm_4a.swift:21:9:\
    \ note: 'factorizationSumMinIndex' previously declared here\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmpcanwm_4a.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmpcanwm_4a.swift:20:9: note: 'factorizationSumMaxIndex' previously declared\
    \ here\n    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmpcanwm_4a.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationSumMinIndex'\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmpcanwm_4a.swift:21:9: note: 'factorizationSumMinIndex'\
    \ previously declared here\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmpcanwm_4a.swift:28:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmpcanwm_4a.swift:20:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmpcanwm_4a.swift:29:9: error: invalid redeclaration of\
    \ 'factorizationSumMinIndex'\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmpcanwm_4a.swift:21:9: n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex3 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex5 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex7 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex8 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex9 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex10 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex11 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex12 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex13 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex14 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex15 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex16 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex17 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex18 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex19 = Int(arc4random_uniform(UInt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2lw6bi40.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp2lw6bi40.swift:37:63: note: to match this opening '('\n    var isPrimeFactorsCountMaxIndex19\
    \ = Int(arc4random_uniform(UInt\n                                            \
    \                  ^\n/tmp/tmp2lw6bi40.swift:18:38: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:19:43:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \              ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:20:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex2 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:21:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex3\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:22:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex4 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:23:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex5\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:24:44: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex6 = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2lw6bi40.swift:25:44:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndex7\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \               ^~~~~~~~~~~~~~~~~~\n/tmp"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorCount = 0\n    var isPrime = true\n\
    \    var isPrimeCount = 0\n    var isPrimeFactorization = [Int]()\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationIndexCount\
    \ = 0\n    var isPrimeFactorizationIndexCountMax = IntMax\n    var isPrimeFactorizationIndexCountMin\
    \ = IntMin\n    var isPrimeFactorizationIndexMax = IntMax\n    var isPrimeFactorizationIndexMin\
    \ = IntMin\n    var isPrimeFactorizationIndexMax2 = IntMax\n    var isPrimeFactorizationIndexMin2\
    \ = IntMin\n    var isPrimeFactorizationIndexMax3 = IntMax\n    var isPrimeFactorizationIndexMin3\
    \ = IntMin\n    var isPrimeFactorizationIndexMax4 = IntMax\n    var isPrimeFactorizationIndexMin4\
    \ = IntMin\n    var isPrimeFactorizationIndexMax5 = IntMax\n    var isPrimeFactorizationIndexMin5\
    \ = IntMin\n    var isPrimeFactorizationIndexMax6 = IntMax\n    var isPrimeFactorizationIndexMin6\
    \ = IntMin\n    var isPrimeFactorizationIndexMax7 = IntMax\n    var isPrimeFactorizationIndexMin7\
    \ = IntMin\n    var isPrimeFactorizationIndexMax8 = IntMax\n    var isPrimeFactorizationIndexMin8\
    \ = IntMin\n    var isPrimeFactorizationIndexMax9 = IntMax\n    var isPrimeFactorizationIndexMin9\
    \ = IntMin\n    var isPrimeFactorizationIndexMax10 = IntMax\n    var isPrimeFactorizationIndexMin10\
    \ = IntMin\n    var isPrimeFactorizationIndexMax11 = IntMax\n    var isPrimeFactorizationIndexMin11\
    \ = IntMin\n    var isPrimeFactorizationIndexMax12 = IntMax\n    var isPrimeFactorizationIndexMin12\
    \ = IntMin\n    var isPrimeFactorizationIndexMax13 = IntMax\n    var isPrimeFactorizationIndexMin13\
    \ = IntMin\n    var isPrimeFactorizationIndexMax14 = IntMax\n    var isPrimeFactorizationIndexMin14\
    \ = IntMin\n    var isPrimeFactorizationIndexMax15 = IntMax\n    var isPrimeFactorizationIndexMin15\
    \ = IntMin\n    var isPrimeFactorizationIndexMax16 = IntMax\n    var isPrimeFactorizationIndexMin16\
    \ = IntMin\n    var isPrimeFactorizationIndexMax17 = IntMax\n    var isPrimeFactorizationIndexMin17\
    \ = IntMin\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpr17pucj0.swift:21:45: error: cannot find 'IntMax' in scope\n  \
    \  var isPrimeFactorizationIndexCountMax = IntMax\n                          \
    \                  ^~~~~~\n/tmp/tmpr17pucj0.swift:22:45: error: cannot find 'IntMin'\
    \ in scope\n    var isPrimeFactorizationIndexCountMin = IntMin\n             \
    \                               ^~~~~~\n/tmp/tmpr17pucj0.swift:23:40: error: cannot\
    \ find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax = IntMax\n    \
    \                                   ^~~~~~\n/tmp/tmpr17pucj0.swift:24:40: error:\
    \ cannot find 'IntMin' in scope\n    var isPrimeFactorizationIndexMin = IntMin\n\
    \                                       ^~~~~~\n/tmp/tmpr17pucj0.swift:25:41:\
    \ error: cannot find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax2\
    \ = IntMax\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:26:41:\
    \ error: cannot find 'IntMin' in scope\n    var isPrimeFactorizationIndexMin2\
    \ = IntMin\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:27:41:\
    \ error: cannot find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax3\
    \ = IntMax\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:28:41:\
    \ error: cannot find 'IntMin' in scope\n    var isPrimeFactorizationIndexMin3\
    \ = IntMin\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:29:41:\
    \ error: cannot find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax4\
    \ = IntMax\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:30:41:\
    \ error: cannot find 'IntMin' in scope\n    var isPrimeFactorizationIndexMin4\
    \ = IntMin\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:31:41:\
    \ error: cannot find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax5\
    \ = IntMax\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:32:41:\
    \ error: cannot find 'IntMin' in scope\n    var isPrimeFactorizationIndexMin5\
    \ = IntMin\n                                        ^~~~~~\n/tmp/tmpr17pucj0.swift:33:41:\
    \ error: cannot find 'IntMax' in scope\n    var isPrimeFactorizationIndexMax6"
  stdout: ''
  timestamp: 1659824877
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var product = n * n\n    var i = 2\n    while product % i == 0 {\n      \
    \  factors.append(i)\n        product /= i\n        i += 1\n    }\n    if product\
    \ > 1 {\n        factors.append(product)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmppvha_idn/tmppvha_idn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae814f13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae814c0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae814c0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae814c097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvha_idn                        0x00005572fda594c2 <unavailable> + 5314

    5    libc.so.6                          0x00002ae8150ff460 __libc_start_main +
    245

    6    tmppvha_idn                        0x00005572fda59119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorizationCount = 0\n    while factor <=\
    \ n {\n        while n % factor == 0 {\n            factorizationCount += 1\n\
    \            n /= factor\n        }\n        factorization.append(factor)\n  \
    \      factor++\n    }\n    if n != 1 {\n        factorizationCount += 1\n   \
    \ }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwfhsxv5s.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmpwfhsxv5s.swift:21:15: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n    var factorizationIndexMaxMinus1\
    \ = factorizationIndexMax - 1\n    var factorizationIndexMin = factorizationIndexMax\
    \ + 1\n    var factorizationIndexMinPlus1 = factorizationIndexMin + 1\n    var\
    \ factorizationIndexMinPlus2 = factorizationIndexMin + 2\n    var factorizationIndexMinPlus3\
    \ = factorizationIndexMin + 3\n    var factorizationIndexMinPlus4 = factorizationIndexMin\
    \ + 4\n    var factorizationIndexMinPlus5 = factorizationIndexMin + 5\n    var\
    \ factorizationIndexMinPlus6 = factorizationIndexMin + 6\n    var factorizationIndexMinPlus7\
    \ = factorizationIndexMin + 7\n    var factorizationIndexMinPlus8 = factorizationIndexMin\
    \ + 8\n    var factorizationIndexMinPlus9 = factorizationIndexMin + 9\n    var\
    \ factorizationIndexMinPlus10 = factorizationIndexMin + 10\n    var factorizationIndexMinPlus11\
    \ = factorizationIndexMin + 11\n    var factorizationIndexMinPlus12 = factorizationIndexMin\
    \ + 12\n    var factorizationIndexMinPlus13 = factorizationIndexMin + 13\n   \
    \ var factorizationIndexMinPlus14 = factorizationIndexMin + 14\n    var factorizationIndexMinPlus15\
    \ = factorizationIndexMin + 15\n    var factorizationIndexMinPlus16 = factorizationIndexMin\
    \ + 16\n    var factorizationIndexMinPlus17 = factorizationIndexMin + 17\n   \
    \ var factorizationIndexMinPlus18 = factorizationIndexMin + 18\n    var factorizationIndexMinPlus19\
    \ = factorizationIndexMin + 19\n    var factorizationIndexMinPlus20 = factorizationIndexMin\
    \ + 20\n    var factorizationIndexMinPlus21 = factorizationIndexMin + 21\n   \
    \ var factorizationIndexMinPlus22 = factorizationIndexMin + 22\n    var factorizationIndexMinPlus23\
    \ = factorizationIndexMin + 23\n    var factorizationIndexMinPlus24 = factorizationIndexMin\
    \ + 24\n    var factorizationIndexMinPlus25 = factorizationIndexMin + 25\n   \
    \ var factorizationIndexMinPlus26 = factorizationIndexMin + 26\n    var factorizationIndexMinPlus27\
    \ = factorizationIndexMin + 27\n    var factorizationIndexMinPlus28 = factorizationIndexMin\
    \ + 28\n    var factorizationIndexMinPlus29 = factorizationIndexMin + 29\n   \
    \ var factorizationIndexMinPlus30 = factorizationIndexMin + 30\n    var factorizationIndexMinPlus31\
    \ = factorizationIndexMin + 31\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5g8gober.swift:49:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp5g8gober.swift:15:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount =\
    \ 0\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n    var isPrimeCountMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax13 = Int(sqrt(Double(n)))\n    var isPrimeCountMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax15 = Int(sqrt(Double(n)))\n    var isPrimeCountMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax18 = Int(sqrt(Double(n)))\n    var isPrimeCountMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax20 = Int(sqrt(Double(n)))\n    var isPrimeCountMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax23 = Int(sqrt(Double(n)))\n    var isPrimeCountMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax25 = Int(sqrt(Double(n)))\n    var isPrimeCountMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax28 = Int(sqrt(Double(n)))\n    var isPrimeCountMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax30 = Int(sqrt(Double(n)))\n    var isPrimeCountMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax33 = Int(sqrt(Double(n)))\n    var isPrimeCountMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax35 = Int(sqrt(Double(n)))\n    var isPrime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc9as042_.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeCountMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpc9as042_.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpc9as042_.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmpc9as042_.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpc9as042_.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpc9as042_.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpc9as042_.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpc9as042_.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpc9as042_.swift:29:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax14 = Int(sqrt(Dou"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = -1\n    var isPrimeCount = 0\n    var\
    \ isPrimeIndexCount = 0\n    var isPrimeIndex = 0\n    var isPrimeIndex2 = 0\n\
    \    var isPrimeIndexCount2 = 0\n    var isPrimeIndex2Count = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeIndexCount3 = 0\n    var isPrimeIndex3Count = 0\n    var\
    \ isPrimeIndex4 = 0\n    var isPrimeIndexCount4 = 0\n    var isPrimeIndex4Count\
    \ = 0\n    var isPrimeIndex5 = 0\n    var isPrimeIndexCount5 = 0\n    var isPrimeIndex5Count\
    \ = 0\n    var isPrimeIndex6 = 0\n    var isPrimeIndexCount6 = 0\n    var isPrimeIndex6Count\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndexCount7 = 0\n    var isPrimeIndex7Count\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeIndexCount8 = 0\n    var isPrimeIndex8Count\
    \ = 0\n    var isPrimeIndex9 = 0\n    var isPrimeIndexCount9 = 0\n    var isPrimeIndex9Count\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndexCount10 = 0\n    var isPrimeIndex10Count\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeIndexCount11 = 0\n    var isPrimeIndex11Count\
    \ = 0\n    var isPrimeIndex12 = 0\n    var isPrimeIndexCount12 = 0\n    var isPrimeIndex12Count\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndexCount13 = 0\n    var isPrimeIndex13Count\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeIndexCount14 = 0\n    var isPrimeIndex14Count\
    \ = 0\n    var isPrimeIndex15 = 0\n    var isPrimeIndexCount15 = 0\n    var isPrimeIndex15Count\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndexCount16 = 0\n    var isPrimeIndex16Count\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeIndexCount17 = 0\n    var isPrimeIndex17Count\
    \ = 0\n    var isPrimeIndex18 = 0\n    var isPrimeIndexCount18 = 0\n    var isPrimeIndex18Count\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp0dn_3pm.swift:19:9: error: invalid redeclaration of 'isPrimeIndex'\n\
    \    var isPrimeIndex = 0\n        ^\n/tmp/tmpp0dn_3pm.swift:16:9: note: 'isPrimeIndex'\
    \ previously declared here\n    var isPrimeIndex = -1\n        ^\n/tmp/tmpp0dn_3pm.swift:72:9:\
    \ error: type annotation missing in pattern\n    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [[Int]] = [[]]\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = factorizationIndex\n    var factorizationIndexMax2 =\
    \ factorizationIndex\n    var factorizationIndexMax3 = factorizationIndex\n  \
    \  var factorizationIndexMax4 = factorizationIndex\n    var factorizationIndexMax5\
    \ = factorizationIndex\n    var factorizationIndexMax6 = factorizationIndex\n\
    \    var factorizationIndexMax7 = factorizationIndex\n    var factorizationIndexMax8\
    \ = factorizationIndex\n    var factorizationIndexMax9 = factorizationIndex\n\
    \    var factorizationIndexMax10 = factorizationIndex\n    var factorizationIndexMax11\
    \ = factorizationIndex\n    var factorizationIndexMax12 = factorizationIndex\n\
    \    var factorizationIndexMax13 = factorizationIndex\n    var factorizationIndexMax14\
    \ = factorizationIndex\n    var factorizationIndexMax15 = factorizationIndex\n\
    \    var factorizationIndexMax16 = factorizationIndex\n    var factorizationIndexMax17\
    \ = factorizationIndex\n    var factorizationIndexMax18 = factorizationIndex\n\
    \    var factorizationIndexMax19 = factorizationIndex\n    var factorizationIndexMax20\
    \ = factorizationIndex\n    var factorizationIndexMax21 = factorizationIndex\n\
    \    var factorizationIndexMax22 = factorizationIndex\n    var factorizationIndexMax23\
    \ = factorizationIndex\n    var factorizationIndexMax24 = factorizationIndex\n\
    \    var factorizationIndexMax25 = factorizationIndex\n    var factorizationIndexMax26\
    \ = factorizationIndex\n    var factorizationIndexMax27 = factorizationIndex\n\
    \    var factorizationIndexMax28 = factorizationIndex\n    var factorizationIndexMax29\
    \ = factorizationIndex\n    var factorizationIndexMax30 = factorizationIndex\n\
    \    var factorizationIndexMax31 = factorizationIndex\n    var factorizationIndexMax32\
    \ = factorizationIndex\n    var factorizationIndexMax33 = factorizationIndex\n\
    \    var factorizationIndexMax34 = factorizationIndex\n    var factorizationIndexMax35\
    \ = factorizationIndex\n    var factorizationIndexMax36 = factorizationIndex\n\
    \    var factorizationIndexMax37 = factorizationIndex\n    var factorizationIndexMax38\
    \ = factorizationIndex\n    var factorizationIndexMax39 = factorizationIndex\n\
    \    var factorizationIndexMax40 = factorizationIndex\n    var factorizationIndexMax41\
    \ = factorizationIndex\n    var factorizationIndexMax42 = factorizationIndex\n\
    \    var factorizationIndexMax43 = factorizationIndex\n    var factorizationIndexMax44\
    \ = factorizationIndex\n    var factorizationIndexMax45 = factorizationIndex\n\
    \    var factorizationIndexMax4\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk7mrdwnb.swift:60:9: error: type annotation missing in pattern\n\
    \    var factorizationIndexMax4\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = 0\n    var factorizationSum = 0\n    var factorizationSumOfSquares\
    \ = 0\n    var factorizationSumOfCubes = 0\n    var factorizationSumOfCubesSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRoot = 0\n    var factorizationSumOfCubesSquareRootSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubes = 0\n    var factorizationSumOfCubesSquareRootCubesSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRoot = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubes = 0\n   \
    \ var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquares = 0\n    var\
    \ factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRoot = 0\n    var\
    \ factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootSquares = 0\n\
    \    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubes\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRoot\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubes\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRoot\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubes\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquares\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRoot\
    \ = 0\n    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootSquare\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9g1gt8mf.swift:39:9: error: type annotation missing in pattern\n\
    \    var factorizationSumOfCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootCubesSquareRootSquare\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0\
    \ {\n            factors.append(factor)\n            factor = 1\n        } else\
    \ {\n            factor *= i\n        }\n        i += 1\n    }\n    if factor\
    \ > 1 {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpkcslibnn/tmpkcslibnn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc0a5c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc0a2bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc0a2bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc0a2bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkcslibnn                        0x000055fe068b84c2 <unavailable> + 5314

    5    libc.so.6                          0x00002adc0a7b1460 __libc_start_main +
    245

    6    tmpkcslibnn                        0x000055fe068b8119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var\
    \ isPrimeFactorization = false\n    var isPrimeFactorizationIndex = 0\n    var\
    \ isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime = false\n \
    \   var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgd07yx19.swift:40:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:41:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:38:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:42:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpgd07yx19.swift:39:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpgd07yx19.swift:43:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpgd07yx19.swift:44:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPr"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        while n % i ==\
    \ 0 {\n            factors.append(factor)\n            n /= i\n            factor\
    \ = 1\n        }\n        i += 1\n        factor++\n    }\n    if n > 1 {\n  \
    \      factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpg5287q3j.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpg5287q3j.swift:22:15:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        factor++\n\
    \              ^~\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = Int(n)\n    while p > 1 {\n        while p % i ==\
    \ 0 {\n            factors.append(i)\n            p /= i\n        }\n        i\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n\
    \    var isPrimeFactorization: Bool = false\n    var isPrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyu0y4y6j.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \      ^\n/tmp/tmpyu0y4y6j.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpyu0y4y6j.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n        ^\n/tmp/tmpyu0y4y6j.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpyu0y4y6j.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpyu0y4y6j.swift:30:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpyu0y4y6j.swift:34:9: error: type annotation\
    \ missing in pattern\n    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n    var isPrimeCountMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax13 = Int(sqrt(Double(n)))\n    var isPrimeCountMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax15 = Int(sqrt(Double(n)))\n    var isPrimeCountMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax18 = Int(sqrt(Double(n)))\n    var isPrimeCountMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax20 = Int(sqrt(Double(n)))\n    var isPrimeCountMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax23 = Int(sqrt(Double(n)))\n    var isPrimeCountMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax25 = Int(sqrt(Double(n)))\n    var isPrimeCountMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax28 = Int(sqrt(Double(n)))\n    var isPrimeCountMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax30 = Int(sqrt(Double(n)))\n    var isPrimeCountMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax33 = Int(sqrt(Double(n)))\n    var isPrimeCountMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax35 = Int(sqrt(Double(n)))\n    var isPri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvpv0xlnp.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeCountMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpvpv0xlnp.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpvpv0xlnp.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmpvpv0xlnp.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpvpv0xlnp.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpvpv0xlnp.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpvpv0xlnp.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpvpv0xlnp.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpvpv0xlnp.swift:29:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax14 = Int(sqrt(Dou"
  stdout: ''
  timestamp: 1659824877
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationCount = 0\n    var factorizationSum\
    \ = 0\n\n    for _ in 0..<n {\n        factorizationCount += 1\n        factorizationSum\
    \ += factorizationCount\n        if factorizationSum == n {\n            factorizationSum\
    \ += factorizationCount\n            factorizationCount -= 1\n        }\n    \
    \    factorization.append(factorizationCount)\n    }\n\n    for _ in 0..<n {\n\
    \        factorizationCount -= 1\n        factorizationSum += factorizationCount\n\
    \        if factorizationSum == n {\n            factorizationSum += factorizationCount\n\
    \            factorizationCount += 1\n        }\n        factorization.append(factorizationCount)\n\
    \    }\n\n    for _ in 0..<n {\n        factorizationCount += 1\n        factorizationSum\
    \ += factorizationCount\n        if factorizationSum == n {\n            factorizationSum\
    \ += factorizationCount\n            factorizationCount -= 1\n        }\n    \
    \    factorization.append(factorizationCount)\n    }\n\n    for _ in 0..<n {\n\
    \        factorizationCount -= 1\n        factorizationSum += factorizationCount\n\
    \        if factorizationSum == n {\n            factorizationSum += factorizationCount\n\
    \            factorizationCount += 1\n        }\n        factorization.append(factorizationCount)\n\
    \    }\n\n    for _ in 0..<n {\n        factorizationCount += 1\n        factorizationSum\
    \ += factorizationCount\n        if factorizationSum == n {\n            factorizationSum\
    \ += factorizationCount\n            factorizationCount -= 1\n        }\n    \
    \    factorization.append(factorizationCount)\n    }\n\n    for _ in 0..<n {\n\
    \        factorizationCount -= 1\n        factorizationSum += factorizationCount\n\
    \        if factorizationSum == n {\n            factorizationSum += factorizationCount\n\
    \            factorizationCount += 1\n        }\n        factorization.append(factorizationCount)\n\
    \    }\n\n    for _ in 0..<n {\n        factorizationCount += 1\n        factorizationSum\
    \ += factorizationCount\n        if factorizationSum == n {\n            factorizationSum\
    \ += factorizationCount\n            factorizationCount -= 1\n        }\n    \
    \    factorization.append(factorizationCount)\n    }\n\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpuf3d_16q/tmpuf3d_16q.swift:103: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac34237ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac342071b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac342071988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3420707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuf3d_16q                        0x0000559a175f7552 <unavailable> + 5458

    5    libc.so.6                          0x00002ac342566460 __libc_start_main +
    245

    6    tmpuf3d_16q                        0x0000559a175f71a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int\
    \ = 0\n    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q:\
    \ Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var\
    \ u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n   \
    \ var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n\
    \    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int =\
    \ 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int\
    \ = 0\n    var k: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var p:\
    \ Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var\
    \ t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n   \
    \ var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n\
    \    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int =\
    \ 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int\
    \ = 0\n    var j: Int = 0\n    var k: Int = 0\n    var m: Int = 0\n    var n:\
    \ Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var\
    \ s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n   \
    \ var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n\
    \    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int =\
    \ 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int\
    \ = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var m:\
    \ Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var\
    \ r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n   \
    \ var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n\
    \    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int =\
    \ 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int\
    \ = 0\n    var h: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9152iyuz.swift:38:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:39:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:40:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:41:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:17:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:42:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:18:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:43:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:19:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:44:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:20:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:45:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:21:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:46:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:22:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:47:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:23:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:48:9:\
    \ error: invalid redeclaration of 'u'\n    var u: Int = 0\n        ^\n/tmp/tmp9152iyuz.swift:24:9:\
    \ note: 'u' previously declared here\n    var u: Int = 0\n "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var factorizationCount = 0\n\
    \    var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorization = true\n    var isPrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpas0f8_7p.swift:39:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationMax = Int(sqrt(Double(n)))\n\
    \    var factorizationMin = factorizationMax\n    var factorizationSum = 0\n \
    \   var factorizationSumMax = 0\n    var factorizationSumMin = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorizationSumMinIndex = 0\n    var factorizationSumMaxIndex\
    \ = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9wy494it.swift:14:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp9wy494it.swift:21:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationSumMinIndex'\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:20:9: note: 'factorizationSumMinIndex' previously declared\
    \ here\n    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9: note: 'factorizationSumMaxIndex'\
    \ previously declared here\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:24:9: error: invalid redeclaration of 'factorizationSumMinIndex'\n\
    \    var factorizationSumMinIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:20:9:\
    \ note: 'factorizationSumMinIndex' previously declared here\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumMaxIndex'\n    var factorizationSumMaxIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:19:9: note: 'factorizationSumMaxIndex' previously declared\
    \ here\n    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationSumMinIndex'\n    var factorizationSumMinIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it.swift:20:9: note: 'factorizationSumMinIndex'\
    \ previously declared here\n    var factorizationSumMinIndex = 0\n        ^\n\
    /tmp/tmp9wy494it.swift:27:9: error: invalid redeclaration of 'factorizationSumMaxIndex'\n\
    \    var factorizationSumMaxIndex = 0\n        ^\n/tmp/tmp9wy494it.swift:19:9:\
    \ note: 'factorizationSumMaxIndex' previously declared here\n    var factorizationSumMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9wy494it"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var primeFactorsCount = 0\n    var isPrime\
    \ = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_8202iaa.swift:40:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = 0\n \
    \   var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj36vgqlw.swift:40:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n    var isPrimeCountMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax13 = Int(sqrt(Double(n)))\n    var isPrimeCountMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax15 = Int(sqrt(Double(n)))\n    var isPrimeCountMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax18 = Int(sqrt(Double(n)))\n    var isPrimeCountMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax20 = Int(sqrt(Double(n)))\n    var isPrimeCountMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax23 = Int(sqrt(Double(n)))\n    var isPrimeCountMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax25 = Int(sqrt(Double(n)))\n    var isPrimeCountMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax28 = Int(sqrt(Double(n)))\n    var isPrimeCountMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax30 = Int(sqrt(Double(n)))\n    var isPrimeCountMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax33 = Int(sqrt(Double(n)))\n    var isPrimeCountMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax35 = Int(sqrt(Double(n)))\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp909t0dop.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp909t0dop.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeCountMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmp909t0dop.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmp909t0dop.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmp909t0dop.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp909t0dop.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp909t0dop.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp909t0dop.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp909t0dop.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp909t0dop.swift:29:33: erro"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpek1fo2vf.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsvktjd9j.swift:131:11: error: expected type\n    var a: \n    \
    \      ^\n           <#type#>\n/tmp/tmpsvktjd9j.swift:39:9: error: invalid redeclaration\
    \ of 'i'\n    var i: Int\n        ^\n/tmp/tmpsvktjd9j.swift:14:9: note: 'i' previously\
    \ declared here\n    var i: Int\n        ^\n/tmp/tmpsvktjd9j.swift:40:9: error:\
    \ invalid redeclaration of 'j'\n    var j: Int\n        ^\n/tmp/tmpsvktjd9j.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int\n        ^\n/tmp/tmpsvktjd9j.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int\n        ^\n/tmp/tmpsvktjd9j.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int\n        ^\n/tmp/tmpsvktjd9j.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int\n        ^\n/tmp/tmpsvktjd9j.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int\n        ^\n/tmp/tmpsvktjd9j.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int\n        ^\n/tmp/tmpsvktjd9j.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int\n        ^\n/tmp/tmpsvktjd9j.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int\n        ^\n/tmp/tmpsvktjd9j.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int\n        ^\n/tmp/tmpsvktjd9j.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int\n        ^\n/tmp/tmpsvktjd9j.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int\n        ^\n/tmp/tmpsvktjd9j.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int\n        ^\n/tmp/tmpsvktjd9j.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int\n        ^\n/tmp/tmpsvktjd9j.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int\n        ^\n/tmp/tmpsvktjd9j.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int\n        ^\n/tmp/tmpsvktjd9j.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int\n        ^\n/tmp/tmpsvktjd9j.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int\n        ^\n/tmp/tmpsvktjd9j.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int\n        ^\n/tmp/tmpsvktjd9j.swift:24:9:\
    \ note: 't' previously declared here\n    var "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy0jokyx7.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex\
    \ = 0\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax15 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax18 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax20 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax23 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax25 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax28 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax30 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax33 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax35 = Int(sqrt(Double(n)))\n    var isPri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1el_8n4p.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeIndexMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmp1el_8n4p.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmp1el_8n4p.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmp1el_8n4p.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmp1el_8n4p.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp1el_8n4p.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp1el_8n4p.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp1el_8n4p.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmp1el_8n4p.swift:29:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax14 = Int(sqrt(Dou"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var factorizationCount = 0\n\
    \    var primeFactorizationCount = 0\n    var factorizationPrimeCount = 0\n  \
    \  var primeFactorizationPrimeCount = 0\n    var factorizationPrime: Int\n   \
    \ var primeFactorizationPrime: Int\n    var factorizationPrimeCountPrime: Int\n\
    \    var primeFactorizationPrimeCountPrime: Int\n    var factorizationPrimePrime:\
    \ Int\n    var primeFactorizationPrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: Int\n    var factorizationPrimePrimePrime:\
    \ Int\n    var factorizationPrimePrimePrime: \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp265pkw6q.swift:57:38: error: expected type\n    var factorizationPrimePrimePrime:\
    \ \n                                     ^\n                                 \
    \     <#type#>\n/tmp/tmp265pkw6q.swift:25:9: error: invalid redeclaration of 'factorizationPrimePrimePrime'\n\
    \    var factorizationPrimePrimePrime: Int\n        ^\n/tmp/tmp265pkw6q.swift:24:9:\
    \ note: 'factorizationPrimePrimePrime' previously declared here\n    var factorizationPrimePrimePrime:\
    \ Int\n        ^\n/tmp/tmp265pkw6q.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationPrimePrimePrime'\n    var factorizationPrimePrimePrime: Int\n\
    \        ^\n/tmp/tmp265pkw6q.swift:24:9: note: 'factorizationPrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimePrimePrime: Int\n      \
    \  ^\n/tmp/tmp265pkw6q.swift:27:9: error: invalid redeclaration of 'factorizationPrimePrimePrime'\n\
    \    var factorizationPrimePrimePrime: Int\n        ^\n/tmp/tmp265pkw6q.swift:24:9:\
    \ note: 'factorizationPrimePrimePrime' previously declared here\n    var factorizationPrimePrimePrime:\
    \ Int\n        ^\n/tmp/tmp265pkw6q.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationPrimePrimePrime'\n    var factorizationPrimePrimePrime: Int\n\
    \        ^\n/tmp/tmp265pkw6q.swift:24:9: note: 'factorizationPrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimePrimePrime: Int\n      \
    \  ^\n/tmp/tmp265pkw6q.swift:29:9: error: invalid redeclaration of 'factorizationPrimePrimePrime'\n\
    \    var factorizationPrimePrimePrime: Int\n        ^\n/tmp/tmp265pkw6q.swift:24:9:\
    \ note: 'factorizationPrimePrimePrime' previously declared here\n    var factorizationPrimePrimePrime:\
    \ Int\n        ^\n/tmp/tmp265pkw6q.swift:30:9: error: invalid redeclaration of\
    \ 'factorizationPrimePrimePrime'\n    var factorizationPrimePrimePrime: Int\n\
    \        ^\n/tmp/tmp265pkw6q.swift:24:9: note: 'factorizationPrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimePrimePrime: Int\n      \
    \  ^\n/tmp/tmp265pkw6q.swift:31:9: error: invalid redeclaration of 'factorizationPrimePrimePrime'\n\
    \    var factorizationPrimePrimePrime: Int\n        ^\n/tmp/t"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationArray: [Int] = []\n    var factorizationArrayCount = 0\n    var\
    \ factorizationArrayIndex = 0\n    var factorizationArrayCountMax = Int(pow(Double(n),\
    \ Double(2)))\n    var factorizationArrayCountMin = Int(pow(Double(n), Double(2)))\n\
    \    var factorizationArrayCountMaxMin = Int(pow(Double(n), Double(2)))\n    var\
    \ factorizationArrayCountMinMin = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMin =\
    \ Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factorizationArrayCountMaxMinMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n    var factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdg6p19an.swift:18:42: error: cannot find 'pow' in scope\n    var\
    \ factorizationArrayCountMax = Int(pow(Double(n), Double(2)))\n              \
    \                           ^~~\n/tmp/tmpdg6p19an.swift:19:42: error: cannot find\
    \ 'pow' in scope\n    var factorizationArrayCountMin = Int(pow(Double(n), Double(2)))\n\
    \                                         ^~~\n/tmp/tmpdg6p19an.swift:20:45: error:\
    \ cannot find 'pow' in scope\n    var factorizationArrayCountMaxMin = Int(pow(Double(n),\
    \ Double(2)))\n                                            ^~~\n/tmp/tmpdg6p19an.swift:21:45:\
    \ error: cannot find 'pow' in scope\n    var factorizationArrayCountMinMin = Int(pow(Double(n),\
    \ Double(2)))\n                                            ^~~\n/tmp/tmpdg6p19an.swift:22:48:\
    \ error: cannot find 'pow' in scope\n    var factorizationArrayCountMaxMinMin\
    \ = Int(pow(Double(n), Double(2)))\n                                         \
    \      ^~~\n/tmp/tmpdg6p19an.swift:23:48: error: cannot find 'pow' in scope\n\
    \    var factorizationArrayCountMaxMinMin = Int(pow(Double(n), Double(2)))\n \
    \                                              ^~~\n/tmp/tmpdg6p19an.swift:24:51:\
    \ error: cannot find 'pow' in scope\n    var factorizationArrayCountMaxMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n                                         \
    \         ^~~\n/tmp/tmpdg6p19an.swift:25:51: error: cannot find 'pow' in scope\n\
    \    var factorizationArrayCountMaxMinMinMin = Int(pow(Double(n), Double(2)))\n\
    \                                                  ^~~\n/tmp/tmpdg6p19an.swift:26:51:\
    \ error: cannot find 'pow' in scope\n    var factorizationArrayCountMaxMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n                                         \
    \         ^~~\n/tmp/tmpdg6p19an.swift:27:54: error: cannot find 'pow' in scope\n\
    \    var factorizationArrayCountMaxMinMinMinMin = Int(pow(Double(n), Double(2)))\n\
    \                                                     ^~~\n/tmp/tmpdg6p19an.swift:28:54:\
    \ error: cannot find 'pow' in scope\n    var factorizationArrayCountMaxMinMinMinMin\
    \ = Int(pow(Double(n), Double(2)))\n                    "
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n   \
    \ var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n\
    \    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int =\
    \ 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int\
    \ = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e:\
    \ Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var\
    \ i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n   \
    \ var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n\
    \    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int =\
    \ 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int\
    \ = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c:\
    \ Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var\
    \ g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n   \
    \ var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n\
    \    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\
    \ 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int\
    \ = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a:\
    \ Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var\
    \ e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n   \
    \ var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n\
    \    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int =\
    \ 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int\
    \ = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y:\
    \ Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var\
    \ c: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfpsllqf2.swift:39:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:40:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmpfpsllqf2.swift:24:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n "
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimePrimeFactors = [Bool]()\n \
    \   var isPrimePrimePrimeFactors = [Bool]()\n    var isPrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimeFactors = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeFactors = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactors = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n    var isPrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdukweomb.swift:27:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors = [Bool]()\n\
    \        ^\n/tmp/tmpdukweomb.swift:26:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n        ^\n/tmp/tmpdukweomb.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n        ^\n/tmp/tmpdukweomb.swift:28:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n        ^\n/tmp/tmpdukweomb.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n        ^\n/tmp/tmpdukweomb.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactors\
    \ = [Bool]()\n        ^\n/tmp/tmpdukweomb.swift:34:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax2\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax5\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax7 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax8\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax9 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax10 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax11\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax12 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax13 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax14\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax15 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax16 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax17\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax18 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax19 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax20\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax21 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax22 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax23\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax24 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax25 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax26\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax27 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax28 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax29\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax30 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax31 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax32\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax33 = Int(ceil(sqrt(Double(n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpl0jine9n.swift:49:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpl0jine9n.swift:48:49: note: to match this opening '('\n    var isPrimeCountMax33\
    \ = Int(ceil(sqrt(Double(n\n                                                ^\n\
    /tmp/tmpl0jine9n.swift:16:31: error: cannot find 'ceil' in scope\n    var isPrimeCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n                              ^~~~\n/tmp/tmpl0jine9n.swift:16:36:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                   ^~~~\n/tmp/tmpl0jine9n.swift:17:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpl0jine9n.swift:17:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpl0jine9n.swift:18:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpl0jine9n.swift:18:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpl0jine9n.swift:19:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpl0jine9n.swift:19:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpl0jine9n.swift:20:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpl0jine9n.swift:20:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpl0jine9n.swift:21:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpl0jine9n.swift:21:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMa"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp016e3yoi.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n    var factorizationMin = factorizationMax\n\
    \    var factorizationMaxIndex = 0\n    var factorizationMinIndex = 0\n    var\
    \ factorizationMaxCount = 0\n    var factorizationMinCount = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCountIndex = 0\n    var factorizationMaxCountIndex\
    \ = 0\n    var factorizationMinCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3_w0jw94.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp3_w0jw94.swift:23:9: error: invalid redeclaration of 'factorizationMaxCountIndex'\n\
    \    var factorizationMaxCountIndex = 0\n        ^\n/tmp/tmp3_w0jw94.swift:21:9:\
    \ note: 'factorizationMaxCountIndex' previously declared here\n    var factorizationMaxCountIndex\
    \ = 0\n        ^\n/tmp/tmp3_w0jw94.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationMinCountIndex'\n    var factorizationMinCountIndex = 0\n     \
    \   ^\n/tmp/tmp3_w0jw94.swift:22:9: note: 'factorizationMinCountIndex' previously\
    \ declared here\n    var factorizationMinCountIndex = 0\n        ^\n/tmp/tmp3_w0jw94.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationMaxCountIndex'\n    var factorizationMaxCountIndex\
    \ = 0\n        ^\n/tmp/tmp3_w0jw94.swift:21:9: note: 'factorizationMaxCountIndex'\
    \ previously declared here\n    var factorizationMaxCountIndex = 0\n        ^\n\
    /tmp/tmp3_w0jw94.swift:26:9: error: invalid redeclaration of 'factorizationMinCountIndex'\n\
    \    var factorizationMinCountIndex = 0\n        ^\n/tmp/tmp3_w0jw94.swift:22:9:\
    \ note: 'factorizationMinCountIndex' previously declared here\n    var factorizationMinCountIndex\
    \ = 0\n        ^\n/tmp/tmp3_w0jw94.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationMaxCountIndex'\n    var factorizationMaxCountIndex = 0\n     \
    \   ^\n/tmp/tmp3_w0jw94.swift:21:9: note: 'factorizationMaxCountIndex' previously\
    \ declared here\n    var factorizationMaxCountIndex = 0\n        ^\n/tmp/tmp3_w0jw94.swift:28:9:\
    \ error: invalid redeclaration of 'factorizationMinCountIndex'\n    var factorizationMinCountIndex\
    \ = 0\n        ^\n/tmp/tmp3_w0jw94.swift:22:9: note: 'factorizationMinCountIndex'\
    \ previously declared here\n    var factorizationMinCountIndex = 0\n        ^\n\
    /tmp/tmp3_w0jw94.swift:29:9: error: invalid redeclaration of 'factorizationMaxCountIndex'\n\
    \    var factorizationMaxCountIndex = 0\n        ^\n/tmp/tmp3_w0jw94.swift:21:9:\
    \ note: 'factorizationMaxCountIndex' previously declared here\n    var f"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy0jokyx7.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe6s74jk0.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var primeFactors: [Int] = []\n    var isPrime: [Bool] = []\n    var isPrimeIndex:\
    \ Int = 0\n    var isPrimeCount: Int = 0\n    var isPrimeCountMax: Int = 0\n \
    \   var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMin: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var\
    \ is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7xnvqbnq.swift:60:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp7xnvqbnq.swift:21:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:18:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp7xnvqbnq.swift:20:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:18:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp7xnvqbnq.swift:24:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:20:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp7xnvqbnq.swift:18:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:20:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp7xnvqbnq.swift:27:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:18:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7xnvqbnq.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factor == 1 {\n         \
    \   factors.append(factor)\n        } else {\n            factors.append(factor)\n\
    \            factors.append(factorizationCount)\n            factorizationCount\
    \ *= factor\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxujh4g1h.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationCount = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int = 0\n    var currentFactorization: Int\
    \ = 0\n    var currentFactorization: Int\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8xdwcm5c.swift:17:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:16:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:18:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmp8xdwcm5c.swift:16:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:19:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:16:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmp8xdwcm5c.swift:20:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:16:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:21:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmp8xdwcm5c.swift:16:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:22:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:16:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmp8xdwcm5c.swift:23:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:16:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmp8xdwcm5c.swift:24:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmp8xdwcm5c.swift:16:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = 0\n    var primeFactorizationCount = 0\n    var\
    \ factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var primeFactorization = 1\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationCount = 0\n \
    \   var factorization = 1\n    var prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprfi8xnqp.swift:16:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmprfi8xnqp.swift:14:9:\
    \ note: 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmprfi8xnqp.swift:17:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = 1\n        ^\n/tmp/tmprfi8xnqp.swift:12:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmprfi8xnqp.swift:18:9: error: invalid redeclaration of 'primeFactorization'\n\
    \    var primeFactorization = 1\n        ^\n/tmp/tmprfi8xnqp.swift:13:9: note:\
    \ 'primeFactorization' previously declared here\n    var primeFactorization =\
    \ [Int]()\n        ^\n/tmp/tmprfi8xnqp.swift:19:9: error: invalid redeclaration\
    \ of 'primeFactorizationCount'\n    var primeFactorizationCount = 0\n        ^\n\
    /tmp/tmprfi8xnqp.swift:14:9: note: 'primeFactorizationCount' previously declared\
    \ here\n    var primeFactorizationCount = [Int]()\n        ^\n/tmp/tmprfi8xnqp.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationCount'\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmprfi8xnqp.swift:15:9: note: 'factorizationCount' previously\
    \ declared here\n    var factorizationCount = 0\n        ^\n/tmp/tmprfi8xnqp.swift:21:9:\
    \ error: invalid redeclaration of 'primeFactorizationCount'\n    var primeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmprfi8xnqp.swift:14:9: note: 'primeFactorizationCount'\
    \ previously declared here\n    var primeFactorizationCount = [Int]()\n      \
    \  ^\n/tmp/tmprfi8xnqp.swift:22:9: error: invalid redeclaration of 'factorization'\n\
    \    var factorization = 1\n        ^\n/tmp/tmprfi8xnqp.swift:12:9: note: 'factorization'\
    \ previously declared here\n    var factorization = [Int]()\n        ^\n/tmp/tmprfi8xnqp.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorization'\n    var primeFactorization\
    \ = 1\n        ^\n/tmp/tmprfi8xnqp.swift:13:9: note: 'primeFactorization' previously\
    \ declared here\n    var primeFactorization = [Int]()\n        ^\n/tmp/tmprfi8xnqp.swift:24:"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountSum: Int = 0\n    var isPrimeCountSumMax: Int =\
    \ 0\n    var isPrimeCountSumMin: Int = 0\n    var isPrimeCountSumMaxMin: Int =\
    \ 0\n    var isPrimeCountSumMaxMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMin:\
    \ Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMinMinMin: Int = 0\n    var isPrimeCountSumMaxMinMinMinMinMin\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0rend1qx.swift:24:9: error: invalid redeclaration of 'isPrimeCountSumMaxMinMinMin'\n\
    \    var isPrimeCountSumMaxMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:23:9:\
    \ note: 'isPrimeCountSumMaxMinMinMin' previously declared here\n    var isPrimeCountSumMaxMinMinMin:\
    \ Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumMaxMinMinMinMin'\n    var isPrimeCountSumMaxMinMinMinMin:\
    \ Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:25:9: note: 'isPrimeCountSumMaxMinMinMinMin'\
    \ previously declared here\n    var isPrimeCountSumMaxMinMinMinMin: Int = 0\n\
    \        ^\n/tmp/tmp0rend1qx.swift:27:9: error: invalid redeclaration of 'isPrimeCountSumMaxMinMinMinMin'\n\
    \    var isPrimeCountSumMaxMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:25:9:\
    \ note: 'isPrimeCountSumMaxMinMinMinMin' previously declared here\n    var isPrimeCountSumMaxMinMinMinMin:\
    \ Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumMaxMinMinMinMin'\n    var isPrimeCountSumMaxMinMinMinMin:\
    \ Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:25:9: note: 'isPrimeCountSumMaxMinMinMinMin'\
    \ previously declared here\n    var isPrimeCountSumMaxMinMinMinMin: Int = 0\n\
    \        ^\n/tmp/tmp0rend1qx.swift:30:9: error: invalid redeclaration of 'isPrimeCountSumMaxMinMinMinMinMin'\n\
    \    var isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:29:9:\
    \ note: 'isPrimeCountSumMaxMinMinMinMinMin' previously declared here\n    var\
    \ isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumMaxMinMinMinMinMin'\n    var\
    \ isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:29:9:\
    \ note: 'isPrimeCountSumMaxMinMinMinMinMin' previously declared here\n    var\
    \ isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumMaxMinMinMinMinMin'\n    var\
    \ isPrimeCountSumMaxMinMinMinMinMin: Int = 0\n        ^\n/tmp/tmp0rend1qx.swift:29:9:\
    \ note: 'isPrimeCountSumMaxMinMin"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i < n {\n        if n % i == 0 {\n\
    \            factor *= i\n            factorization.append(factor)\n         \
    \   n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n >\
    \ 1 {\n        factorization.append(n)\n    }\n    return factorization\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6qbe_7a3.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorizationCount = 0\n    while n > 1 {\n\
    \        while n % factor == 0 {\n            factorizationCount += 1\n      \
    \      n /= factor\n        }\n        factorization = [factorizationCount] +\
    \ factorization\n        factor++\n    }\n    return factorization\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu7dsmn4x.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmpu7dsmn4x.swift:21:15: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp337ks_2p.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp337ks_2p.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp337ks_2p.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1659824876
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy0jokyx7.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpy0jokyx7.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpy0jokyx7.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ count: Int = 0\n    var isPrime: Bool = false\n    var isPrime2: Bool = false\n\
    \    var isPrime3: Bool = false\n    var isPrime4: Bool = false\n    var isPrime5:\
    \ Bool = false\n    var isPrime6: Bool = false\n    var isPrime7: Bool = false\n\
    \    var isPrime8: Bool = false\n    var isPrime9: Bool = false\n    var isPrime10:\
    \ Bool = false\n    var isPrime11: Bool = false\n    var isPrime12: Bool = false\n\
    \    var isPrime13: Bool = false\n    var isPrime14: Bool = false\n    var isPrime15:\
    \ Bool = false\n    var isPrime16: Bool = false\n    var isPrime17: Bool = false\n\
    \    var isPrime18: Bool = false\n    var isPrime19: Bool = false\n    var isPrime20:\
    \ Bool = false\n    var isPrime21: Bool = false\n    var isPrime22: Bool = false\n\
    \    var isPrime23: Bool = false\n    var isPrime24: Bool = false\n    var isPrime25:\
    \ Bool = false\n    var isPrime26: Bool = false\n    var isPrime27: Bool = false\n\
    \    var isPrime28: Bool = false\n    var isPrime29: Bool = false\n    var isPrime30:\
    \ Bool = false\n    var isPrime31: Bool = false\n    var isPrime32: Bool = false\n\
    \    var isPrime33: Bool = false\n    var isPrime34: Bool = false\n    var isPrime35:\
    \ Bool = false\n    var isPrime36: Bool = false\n    var isPrime37: Bool = false\n\
    \    var isPrime38: Bool = false\n    var isPrime39: Bool = false\n    var isPrime40:\
    \ Bool = false\n    var isPrime41: Bool = false\n    var isPrime42: Bool = false\n\
    \    var isPrime43: Bool = false\n    var isPrime44: Bool = false\n    var isPrime45:\
    \ Bool = false\n    var isPrime46: Bool = false\n    var isPrime47: Bool = false\n\
    \    var isPrime48: Bool = false\n    var isPrime49: Bool = false\n    var isPrime50:\
    \ Bool = false\n    var isPrime51: Bool = false\n    var isPrime52: Bool = false\n\
    \    var isPrime53: Bool = false\n    var isPrime54: Bool = false\n    var is\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbbi3b1wl.swift:71:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpbbi3b1wl.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:14:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int = 0\n        ^\n        _\n/tmp/tmpbbi3b1wl.swift:15:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmpbbi3b1wl.swift:16:9: warning:\
    \ variable 'count' was never used; consider replacing with '_' or removing it\n\
    \    var count: Int = 0\n        ^~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:17:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:18:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:19:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:20:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:21:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:22:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpbbi3b1wl.swift:23:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it"
  stdout: ''
  timestamp: 1659824877
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    while factor <= n {\n        while n % factor\
    \ == 0 {\n            factorization.append(factor)\n            n /= factor\n\
    \        }\n        factor++\n    }\n    if n > 1 {\n        factorization.append(n)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3az80og_.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmp3az80og_.swift:19:15: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1659824877
