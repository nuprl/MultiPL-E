language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p >\
    \ p {\n        return modp(n, p - p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpolqoik5c.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpolqoik5c.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpolqoik5c.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpolqoik5c.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpolqoik5c.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - p)\n            \
    \       ^\n                    n: p: \n/tmp/tmpolqoik5c.swift:183:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires a\
    \ positive number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires a positive\
    \ number\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n -\
    \ p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p - p)\n\t}\n\treturn modp((n -\
    \ p) * (n - p) / 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7sur_mzg.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires a positive number\")\n                ^~~~~\n\
    /tmp/tmp7sur_mzg.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires a positive number\")\n                ^~~~~\n/tmp/tmp7sur_mzg.swift:30:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp7sur_mzg.swift:33:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - p)\n                           ^\n       \
    \                     n: p: \n/tmp/tmp7sur_mzg.swift:35:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp((n - p) * (n - p) / 2, p)\n     \
    \              ^\n                    n:                     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tswitch {\n\t\
    case n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\treturn n\n\tcase n > p:\n\t\treturn\
    \ modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjw6_i7rk.swift:24:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpjw6_i7rk.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpjw6_i7rk.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpjw6_i7rk.swift:22:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ p\n                ^\n/tmp/tmpjw6_i7rk.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0\
    \ {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too large\")\n\t}\n\t\
    var res int\n\tfor i := 0; i < p; i++ {\n\t\tres = (res * n) % p\n\t}\n\treturn\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp18oiv2ix.swift:32:10: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var res int\n\
    \                ^\n/tmp/tmp18oiv2ix.swift:32:10: note: join the identifiers together\n\
    \        var res int\n            ~~~~^~~\n            resint\n/tmp/tmp18oiv2ix.swift:32:10:\
    \ note: join the identifiers together with camel-case\n        var res int\n \
    \           ~~~~^~~\n            resInt\n/tmp/tmp18oiv2ix.swift:33:9: error: expected\
    \ type\n        for i := 0; i < p; i++ {\n               ^\n                <#type#>\n\
    /tmp/tmp18oiv2ix.swift:33:9: error: expected 'in' after for-each pattern\n   \
    \     for i := 0; i < p; i++ {\n               ^\n/tmp/tmp18oiv2ix.swift:33:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < p; i++ {\n               ^\n/tmp/tmp18oiv2ix.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmp18oiv2ix.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmp18oiv2ix.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: modulus is\
    \ too large\")\n                ^~~~~\n/tmp/tmp18oiv2ix.swift:32:6: error: type\
    \ annotation missing in pattern\n        var res int\n            ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == 2 {\n\t\treturn p + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n\
    \ == 4 {\n\t\treturn p + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n\
    \ == 6 {\n\t\treturn p + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n\
    \ == 8 {\n\t\treturn p + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n\
    \ == 10 {\n\t\treturn p + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif\
    \ n == 12 {\n\t\treturn p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\t\
    if n == 14 {\n\t\treturn p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\
    \tif n == 16 {\n\t\treturn p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t\
    }\n\tif n == 18 {\n\t\treturn p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\
    \t}\n\tif n == 20 {\n\t\treturn p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\
    \t}\n\tif n == 22 {\n\t\treturn p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == 24 {\n\t\treturn p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == 26 {\n\t\treturn p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\
    \t}\n\tif n == 28 {\n\t\treturn p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\
    \t}\n\tif n == 30 {\n\t\treturn p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\
    \t}\n\tif n == 32 {\n\t\treturn p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\
    \t}\n\tif n == 34 {\n\t\treturn p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\
    \t}\n\tif n == 36 {\n\t\treturn p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\
    \t}\n\tif n == 38 {\n\t\treturn p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfyvnoipa.swift:164:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpfyvnoipa.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpfyvnoipa.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpfyvnoipa.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmpfyvnoipa.swift:19:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"p < 1\")\n           \
    \     ^~~~~\n/tmp/tmpfyvnoipa.swift:22:3: error: cannot find 'panic' in scope\n\
    \                panic(\"p > p\")\n                ^~~~~\n/tmp/tmpfyvnoipa.swift:146:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (-p)) + (n & p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpfmss4jq9/tmpfmss4jq9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dc57efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dc54e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dc54e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dc54e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfmss4jq9                        0x000055925cd0c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b9dc59db460 __libc_start_main +
    245

    6    tmpfmss4jq9                        0x000055925cd0be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n   \
    \     return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkluih7q7.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpkluih7q7.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpkluih7q7.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpkluih7q7.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpkluih7q7.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpkluih7q7.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpkluih7q7.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n,\
    \ p - p)\n\t}\n\treturn modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp96aaun1j.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp96aaun1j.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmp96aaun1j.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmp96aaun1j.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmp96aaun1j.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn n\n\t\
    case n == p:\n\t\treturn 1\n\tcase n == 0 || n == p:\n\t\treturn 0\n\tcase n >=\
    \ p:\n\t\treturn modp(n - p, p)\n\tdefault:\n\t\treturn modp((p - 1) * (n - p),\
    \ p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jkz56vs.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp4jkz56vs.swift:22:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp4jkz56vs.swift:24:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((p\
    \ - 1) * (n - p), p)\n                           ^\n                         \
    \   n:                 p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return n\n    }\n\
    \    if n == p {\n        return n\n    }\n    if n < p {\n        return modp(n\
    \ - p, p)\n    }\n    return modp((n - p) + p, p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp76_t1jz6.swift:21:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp76_t1jz6.swift:23:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - p) + p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn n - p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp85avim0r.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n & (p - 1), p)\n    }\n    if\
    \ p > n {\n        return modp(n & (p - 1), p)\n    }\n    return n & (p - 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4z3oav45.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp4z3oav45.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmp4z3oav45.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n & (p - 1), p)\n      \
    \             ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\
    \t\treturn 0\n\tcase n == p:\n\t\treturn n\n\tcase n == 0 || p == 0:\n\t\treturn\
    \ 1\n\tcase p == n:\n\t\treturn 0\n\tcase p == 1 or n == 1 or p == n:\n\t\treturn\
    \ n\n\tcase p == 2 or n == 2 or p == n:\n\t\treturn n\n\tcase p == 3 or n == 3\
    \ or p == n:\n\t\treturn n\n\tcase p == 4 or n == 4 or p == n:\n\t\treturn n\n\
    \tcase p == 5 or n == 5 or p == n:\n\t\treturn n\n\tcase p == 6 or n == 6 or p\
    \ == n:\n\t\treturn n\n\tcase p == 7 or n == 7 or p == n:\n\t\treturn n\n\tcase\
    \ p == 8 or n == 8 or p == n:\n\t\treturn n\n\tcase p == 9 or n == 9 or p == n:\n\
    \t\treturn n\n\tcase p == 10 or n == 10 or p == n:\n\t\treturn n\n\tcase p ==\
    \ 11 or n == 11 or p == n:\n\t\treturn n\n\tcase p == 12 or n == 12 or p == n:\n\
    \t\treturn n\n\tcase p == 13 or n == 13 or p == n:\n\t\treturn n\n\tcase p ==\
    \ 14 or n == 14 or p == n:\n\t\treturn n\n\tcase p == 15 or n == 15 or p == n:\n\
    \t\treturn n\n\tcase p == 16 or n == 16 or p == n:\n\t\treturn n\n\tcase p ==\
    \ 17 or n == 17 or p == n:\n\t\treturn n\n\tcase p == 18 or n == 18 or p == n:\n\
    \t\treturn n\n\tcase p == 19 or n == 19 or p == n:\n\t\treturn n\n\tcase p ==\
    \ 20 or n == 20 or p == n:\n\t\treturn n\n\tcase p == 21 or n == 21 || p == n:\n\
    \t\treturn n\n\tcase p == 22 or n == 22 || p == n:\n\t\treturn n\n\tcase p ==\
    \ 23 or n == 23 || p == n:\n\t\treturn n\n\tcase p == 24 or n == 24 || p == n:\n\
    \t\treturn n\n\tcase p == 25 or n == 25 || p == n:\n\t\treturn n\n\tcase p ==\
    \ 26 or n == 26 || p == n:\n\t\treturn n\n\tcase p == 27 or n == 27 || p == n:\n\
    \t\treturn n\n\tcase p == 28 or n == 28 || p == n:\n\t\treturn n\n\tcase p ==\
    \ 29 or n == 29 || p == n:\n\t\treturn n\n\tcase p == 30 or n == 30 || p == n:\n\
    \t\treturn n\n\tcase \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmdyuz4ci.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpmdyuz4ci.swift:23:14: error: expected\
    \ ':' after 'case'\n        case p == 1 or n == 1 or p == n:\n               \
    \     ^\n/tmp/tmpmdyuz4ci.swift:23:16: error: consecutive statements on a line\
    \ must be separated by ';'\n        case p == 1 or n == 1 or p == n:\n       \
    \               ^\n                      ;\n/tmp/tmpmdyuz4ci.swift:23:23: error:\
    \ consecutive statements on a line must be separated by ';'\n        case p ==\
    \ 1 or n == 1 or p == n:\n                             ^\n                   \
    \          ;\n/tmp/tmpmdyuz4ci.swift:23:26: error: consecutive statements on a\
    \ line must be separated by ';'\n        case p == 1 or n == 1 or p == n:\n  \
    \                              ^\n                                ;\n/tmp/tmpmdyuz4ci.swift:23:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        case\
    \ p == 1 or n == 1 or p == n:\n                                       ^\n    \
    \                                   ;\n/tmp/tmpmdyuz4ci.swift:23:33: error: expected\
    \ expression\n        case p == 1 or n == 1 or p == n:\n                     \
    \                  ^\n/tmp/tmpmdyuz4ci.swift:25:14: error: expected ':' after\
    \ 'case'\n        case p == 2 or n == 2 or p == n:\n                    ^\n/tmp/tmpmdyuz4ci.swift:25:16:\
    \ error: consecutive statements on a line must be separated by ';'\n        case\
    \ p == 2 or n == 2 or p == n:\n                      ^\n                     \
    \ ;\n/tmp/tmpmdyuz4ci.swift:25:23: error: consecutive statements on a line must\
    \ be separated by ';'\n        case p == 2 or n == 2 or p == n:\n            \
    \                 ^\n                             ;\n/tmp/tmpmdyuz4ci.swift:25:26:\
    \ error: consecutive statements on a line must be separated by ';'\n        case\
    \ p == 2 or n == 2 or p == n:\n                                ^\n           \
    \                     ;\n/tmp/tmpmdyuz4ci.swift:25:33: error: consecutive statements\
    \ on a line must be separated by ';'\n        case p == 2 or n == 2 or p == n:\n\
    \                   "
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\t\
    r := 1\n\tfor i := n - 1; i >= 0; i-- {\n\t\tr *= p\n\t\tr += n\n\t}\n\treturn\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7v2qvjon.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmp7v2qvjon.swift:32:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmp7v2qvjon.swift:33:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmp7v2qvjon.swift:33:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmp7v2qvjon.swift:33:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmp7v2qvjon.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires n\
    \ >= 0\")\n                ^~~~~\n/tmp/tmp7v2qvjon.swift:18:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires p >= 1\")\n        \
    \        ^~~~~\n/tmp/tmp7v2qvjon.swift:30:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires p <= p\")\n                ^~~~~\n/tmp/tmp7v2qvjon.swift:32:2:\
    \ error: cannot find 'r' in scope\n        r := 1\n        ^\n/tmp/tmp7v2qvjon.swift:37:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(n, -p)\n\tdefault:\n\t\treturn modp(n / p, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpx9ndpn4_.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpx9ndpn4_.swift:19:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpx9ndpn4_.swift:21:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ -p)\n                           ^\n                            n: p: \n/tmp/tmpx9ndpn4_.swift:23:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p - 2)\n    }\n    if p % 2 == 1 {\n        return modp(n,\
    \ p - 1)\n    }\n    if p % 2 == 0 {\n        return modp(n, p - 2)\n    }\n \
    \   return modp(n, p - 3)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpb6xk1mil.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p - 1)\n                   ^\n                \
    \    n: p: \n/tmp/tmpb6xk1mil.swift:27:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 2)\n                   ^\n             \
    \       n: p: \n/tmp/tmpb6xk1mil.swift:30:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 1)\n                   ^\n             \
    \       n: p: \n/tmp/tmpb6xk1mil.swift:33:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 2)\n                   ^\n             \
    \       n: p: \n/tmp/tmpb6xk1mil.swift:35:16: error: missing argument labels 'n:p:'\
    \ in call\n    return modp(n, p - 3)\n               ^\n                n: p:\
    \ \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p - p)\n\t}\n\treturn modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpabjglyy5.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpabjglyy5.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n/tmp/tmpabjglyy5.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpabjglyy5.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmpabjglyy5.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n == 0\
    \ {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpws5cp6xc.swift:183:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpws5cp6xc.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmpws5cp6xc.swift:16:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive modulus\")\n\
    \t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p)\
    \ * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp64v5if7g.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp64v5if7g.swift:29:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp64v5if7g.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ number\")\n                ^~~~~\n/tmp/tmp64v5if7g.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive modulus\"\
    )\n                ^~~~~\n/tmp/tmp64v5if7g.swift:29:2: error: cannot find 'q'\
    \ in scope\n        q := n / p\n        ^\n/tmp/tmp64v5if7g.swift:31:14: error:\
    \ cannot find 'q' in scope\n        return modp(q, p) * p + r\n              \
    \      ^\n/tmp/tmp64v5if7g.swift:31:26: error: cannot find 'r' in scope\n    \
    \    return modp(q, p) * p + r\n                                ^\n/tmp/tmp64v5if7g.swift:31:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv2a35pq4.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpv2a35pq4.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return n\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n > p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - 1) * (n - p), p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpva6yxvfm.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpva6yxvfm.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((p - 1) * (n - p), p)\n               ^\n  \
    \              n:                 p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn n - p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp85avim0r.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4qi35vad.swift:180:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp4qi35vad.swift:15:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp4qi35vad.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n <= p:\n\t\treturn n\n\tcase n >= p && n <= p*p:\n\t\treturn n\n\
    \tdefault:\n\t\treturn modp((n-p)/p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0odxxo5z.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp0odxxo5z.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp0odxxo5z.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((n-p)/p,\
    \ p)\n                           ^\n                            n:       p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5_pdp9ec.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp5_pdp9ec.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp5_pdp9ec.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmp5_pdp9ec.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp5_pdp9ec.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmp5_pdp9ec.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmp5_pdp9ec.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpczpm5p3j.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpczpm5p3j.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpczpm5p3j.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpczpm5p3j.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpczpm5p3j.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpczpm5p3j.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpczpm5p3j.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n > p:\n\t\treturn modp(n - p, p)\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvgbqynlr.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvgbqynlr.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyvwzfoo0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyvwzfoo0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p ==\
    \ 0 {\n\t\treturn 0\n\t}\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn n % p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmphtvt9r9l/tmphtvt9r9l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09cedd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09ceac7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09ceac7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09ceac67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphtvt9r9l                        0x000055b0e29fd2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b09cefbc460 __libc_start_main +
    245

    6    tmphtvt9r9l                        0x000055b0e29fcef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 2 {\n        return p + 1\n    }\n    if n == 3 {\n        return\
    \ p + 2\n    }\n    if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n\
    \        return p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n \
    \   if n == 7 {\n        return p + 6\n    }\n    if n == 8 {\n        return\
    \ p + 7\n    }\n    if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n\
    \        return p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n\
    \    if n == 12 {\n        return p + 11\n    }\n    if n == 13 {\n        return\
    \ p + 12\n    }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15\
    \ {\n        return p + 14\n    }\n    if n == 16 {\n        return p + 15\n \
    \   }\n    if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n    \
    \    return p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n  \
    \  if n == 20 {\n        return p + 19\n    }\n    if n == 21 {\n        return\
    \ p + 20\n    }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23\
    \ {\n        return p + 22\n    }\n    if n == 24 {\n        return p + 23\n \
    \   }\n    if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n    \
    \    return p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n  \
    \  if n == 28 {\n        return p + 27\n    }\n    if n == 29 {\n        return\
    \ p + 28\n    }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31\
    \ {\n        return p + 30\n    }\n    if n == 32 {\n        return p + 31\n \
    \   }\n    if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n    \
    \    return p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n  \
    \  if n == 36 {\n        return p + 35\n    }\n    if n == 37 {\n        return\
    \ p + 36\n    }\n    if n == 38 {\n        return p + 37\n    }\n    if n == 39\
    \ {\n        return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_g9ep_tr.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_g9ep_tr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_g9ep_tr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp_g9ep_tr.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp_g9ep_tr.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    p = p - 1\n\t}\n\tif p > p {\n\t\tp = p - 1\n\t}\n\tlet q = p / p\n\tlet r = p\
    \ % p\n\tlet s = q * q\n\tlet t = s * q\n\tlet u = t * q\n\tlet v = t * r\n\t\
    let w = u * r\n\tlet x = v * r\n\tlet y = w * r\n\tlet z = x * r\n\tlet a = y\
    \ * r\n\tlet b = z * r\n\tlet c = a * r\n\tlet d = b * r\n\tlet e = c * r\n\t\
    let f = d * r\n\tlet g = e * r\n\tlet h = f * r\n\treturn h\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1cd9ruez.swift:24:3: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n                p = p - 1\n                ^\n/tmp/tmp1cd9ruez.swift:27:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ p - 1\n                ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tswitch {\n\t\
    case n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\treturn n\n\tcase n >= p:\n\t\t\
    return p\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn modp(n - p,\
    \ p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqf8e7e3i.swift:24:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpqf8e7e3i.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpqf8e7e3i.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpqf8e7e3i.swift:22:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ p\n                ^\n/tmp/tmpqf8e7e3i.swift:32:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n\
    /tmp/tmpqf8e7e3i.swift:36:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - p, p)\n                   ^\n                    n: \
    \    p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptlzzr4fo.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmptlzzr4fo.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmptlzzr4fo.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmptlzzr4fo.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp928tafs6/tmp928tafs6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52817d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52814c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52814c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52814c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp928tafs6                        0x000055ea5cda02cd <unavailable> + 4813

    5    libc.so.6                          0x00002b52819be460 __libc_start_main +
    245

    6    tmp928tafs6                        0x000055ea5cd9fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 0 {\n\t\treturn\
    \ 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p - 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p - 1 {\n\t\treturn p\n\t}\n\tif n == p - 2 {\n\t\treturn p + 1\n\t}\n\t\
    if n == p - 2 {\n\t\treturn p + 1\n\t}\n\tif n == p - 3 {\n\t\treturn p + 2\n\t\
    }\n\tif n == p - 3 {\n\t\treturn p + 2\n\t}\n\tif n == p - 4 {\n\t\treturn p +\
    \ 3\n\t}\n\tif n == p - 4 {\n\t\treturn p + 3\n\t}\n\tif n == p - 5 {\n\t\treturn\
    \ p + 4\n\t}\n\tif n == p - 5 {\n\t\treturn p + 4\n\t}\n\tif n == p - 6 {\n\t\t\
    return p + 5\n\t}\n\tif n == p - 6 {\n\t\treturn p + 5\n\t}\n\tif n == p - 7 {\n\
    \t\treturn p + 6\n\t}\n\tif n == p - 7 {\n\t\treturn p + 6\n\t}\n\tif n == p -\
    \ 8 {\n\t\treturn p + 7\n\t}\n\tif n == p - 8 {\n\t\treturn p + 7\n\t}\n\tif n\
    \ == p - 9 {\n\t\treturn p + 8\n\t}\n\tif n == p - 9 {\n\t\treturn p + 8\n\t}\n\
    \tif n == p - 10 {\n\t\treturn p + 9\n\t}\n\tif n == p - 10 {\n\t\treturn p +\
    \ 9\n\t}\n\tif n == p - 11 {\n\t\treturn p + 10\n\t}\n\tif n == p - 11 {\n\t\t\
    return p + 10\n\t}\n\tif n == p - 12 {\n\t\treturn p + 11\n\t}\n\tif n == p -\
    \ 12 {\n\t\treturn p + 11\n\t}\n\tif n == p - 13 {\n\t\treturn p + 12\n\t}\n\t\
    if n == p - 13 {\n\t\treturn p + 12\n\t}\n\tif n == p - 14 {\n\t\treturn p + 13\n\
    \t}\n\tif n == p - 14 {\n\t\treturn p + 13\n\t}\n\tif n == p - 15 {\n\t\treturn\
    \ p + 14\n\t}\n\tif n == p - 15 {\n\t\treturn p + 14\n\t}\n\tif n == p - 16 {\n\
    \t\treturn p + 15\n\t}\n\tif n == p - 16 {\n\t\treturn p + 15\n\t}\n\tif n ==\
    \ p - 17 {\n\t\treturn p + 16\n\t}\n\tif n == p - 17 {\n\t\treturn p + 16\n\t\
    }\n\tif n == p - 18 {\n\t\treturn p + 17\n\t}\n\tif n == p - 18\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpb0fw8dpg.swift:140:16: error: expected '{' after 'if' condition\n\
    \        if n == p - 18\n                      ^\n/tmp/tmpb0fw8dpg.swift:15:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ -n\n                ^\n/tmp/tmpb0fw8dpg.swift:18:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n + 1, p)\n\
    \    }\n    return modp(n - 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv95af4rd.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpv95af4rd.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpv95af4rd.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n + 1, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpv95af4rd.swift:26:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(n - 2, p)\n               ^\n\
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\tpanic(\"modp: negative modulus\")\n\tcase p ==\
    \ 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p % 2 == 0:\n\t\treturn\
    \ modp(n / 2, p)\n\tdefault:\n\t\treturn modp(n / 2, p) + modp((n / 2) * (n %\
    \ 2), p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp01lj22_a.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp01lj22_a.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmp01lj22_a.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmp01lj22_a.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmp01lj22_a.swift:26:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n / 2, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp01lj22_a.swift:28:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / 2, p) + modp((n / 2) * (n % 2), p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmp01lj22_a.swift:28:31: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n / 2, p) + modp((n\
    \ / 2) * (n % 2), p)\n                                            ^\n        \
    \                                     n:                 p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(abs(n), -p)\n    }\n    if p\
    \ > p {\n        return modp(n, p)\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp30jyuzzu.swift:180:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp30jyuzzu.swift:21:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(abs(n), p)\n                   ^\n                    n:\
    \      p: \n/tmp/tmp30jyuzzu.swift:24:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(abs(n), -p)\n                   ^\n           \
    \         n:      p: \n/tmp/tmp30jyuzzu.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 2 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - 1, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p - 1)\n\t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p)\
    \ * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpe3omfa20.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpe3omfa20.swift:35:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpe3omfa20.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ n\")\n                ^~~~~\n/tmp/tmpe3omfa20.swift:18:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive p\")\n    \
    \            ^~~~~\n/tmp/tmpe3omfa20.swift:30:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n - 1, p)\n                    \
    \       ^\n                            n:     p: \n/tmp/tmpe3omfa20.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - 1)\n                           ^\n                            n: p: \n/tmp/tmpe3omfa20.swift:35:2:\
    \ error: cannot find 'q' in scope\n        q := n / p\n        ^\n/tmp/tmpe3omfa20.swift:37:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) * p + r\n       \
    \             ^\n/tmp/tmpe3omfa20.swift:37:26: error: cannot find 'r' in scope\n\
    \        return modp(q, p) * p + r\n                                ^\n/tmp/tmpe3omfa20.swift:37:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp(p / n, p)\n    }\n    return n - (n % p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6ou28vb0.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp6ou28vb0.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp6ou28vb0.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(p / n, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\"\
    )\n\t}\n\tq := p\n\tfor n > 0 {\n\t\tq /= 2\n\t\tn--\n\t}\n\treturn q\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9w2u_jaf.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmp9w2u_jaf.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmp9w2u_jaf.swift:33:8:\
    \ error: expected 'in' after for-each pattern\n        for n > 0 {\n         \
    \     ^\n/tmp/tmp9w2u_jaf.swift:33:8: error: unary operator cannot be separated\
    \ from its operand\n        for n > 0 {\n              ^~\n               \n/tmp/tmp9w2u_jaf.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp9w2u_jaf.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 1\")\n \
    \               ^~~~~\n/tmp/tmp9w2u_jaf.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmp9w2u_jaf.swift:32:2: error: cannot find 'q' in scope\n     \
    \   q := p\n        ^\n/tmp/tmp9w2u_jaf.swift:33:8: error: '>' is not a prefix\
    \ unary operator\n        for n > 0 {\n              ^\n/tmp/tmp9w2u_jaf.swift:37:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp20b_mec.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpp20b_mec.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpp20b_mec.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpp20b_mec.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpp20b_mec.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive modulus\")\n\
    \t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tmod := p\n\tn %= p\n\tif n == 0 {\n\t\treturn\
    \ mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n == p {\n\t\treturn\
    \ mod\n\t}\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn mod - 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\
    \tn %= p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\treturn mod -\
    \ 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %= p\n\tif n ==\
    \ 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\treturn mod\n\
    \t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t\
    }\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\
    \treturn mod - 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %=\
    \ p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t\
    }\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\
    \treturn mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n == p {\n\t\t\
    return mod\n\t}\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\t\
    if n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod\
    \ += p\n\tn %= p\n\tif n == 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\treturn\
    \ mod - 1\n\t}\n\tif n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %= p\n\tif\
    \ n == 0 {\n\t\treturn mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif\
    \ n == p {\n\t\treturn mod\n\t}\n\tmod += p\n\tn %= p\n\tif n == 0 {\n\t\treturn\
    \ mod\n\t}\n\tif n == 1 {\n\t\treturn mod - 1\n\t}\n\tif n == \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hjiw8jg.swift:29:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        mod := p\n           ^\n           ;\n/tmp/tmp6hjiw8jg.swift:29:6:\
    \ error: expected expression\n        mod := p\n            ^\n/tmp/tmp6hjiw8jg.swift:159:1:\
    \ error: expected expression after operator\n}\n^\n/tmp/tmp6hjiw8jg.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ number\")\n                ^~~~~\n/tmp/tmp6hjiw8jg.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive modulus\"\
    )\n                ^~~~~\n/tmp/tmp6hjiw8jg.swift:29:2: error: cannot find 'mod'\
    \ in scope\n        mod := p\n        ^~~\n/tmp/tmp6hjiw8jg.swift:32:10: error:\
    \ cannot find 'mod' in scope\n                return mod\n                   \
    \    ^~~\n/tmp/tmp6hjiw8jg.swift:35:10: error: cannot find 'mod' in scope\n  \
    \              return mod - 1\n                       ^~~\n/tmp/tmp6hjiw8jg.swift:38:10:\
    \ error: cannot find 'mod' in scope\n                return mod\n            \
    \           ^~~\n/tmp/tmp6hjiw8jg.swift:40:2: error: cannot find 'mod' in scope\n\
    \        mod += p\n        ^~~\n/tmp/tmp6hjiw8jg.swift:41:4: error: left side\
    \ of mutating operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n\
    \        ~ ^\n/tmp/tmp6hjiw8jg.swift:43:10: error: cannot find 'mod' in scope\n\
    \                return mod\n                       ^~~\n/tmp/tmp6hjiw8jg.swift:46:10:\
    \ error: cannot find 'mod' in scope\n                return mod - 1\n        \
    \               ^~~\n/tmp/tmp6hjiw8jg.swift:49:10: error: cannot find 'mod' in\
    \ scope\n                return mod\n                       ^~~\n/tmp/tmp6hjiw8jg.swift:51:2:\
    \ error: cannot find 'mod' in scope\n        mod += p\n        ^~~\n/tmp/tmp6hjiw8jg.swift:52:4:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n %= p\n        ~ ^\n/tmp/tmp6hjiw8jg.swift:54:10: error: cannot find\
    \ 'mod' in scope\n                return mod\n                       ^~~\n/tmp/tmp6hjiw8jg.swift:57:10:\
    \ error: cannot find 'mod' in scope\n                return "
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p < p {\n\t\tpanic(\"modp called with p < p\"\
    )\n\t}\n\tx := n\n\ty := p\n\tfor {\n\t\tx -= y\n\t\tif x == 0 {\n\t\t\treturn\
    \ y\n\t\t}\n\t\ty *= 2\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0b10y0av.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp0b10y0av.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp0b10y0av.swift:34:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp0b10y0av.swift:34:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp0b10y0av.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp0b10y0av.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp called with p < 1\")\n                ^~~~~\n/tmp/tmp0b10y0av.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < p\")\n                ^~~~~\n/tmp/tmp0b10y0av.swift:32:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 1\n\t\
    }\n\tswitch {\n\tcase p < 0:\n\t\treturn modp(n - 1, -p)\n\tcase n < 0:\n\t\t\
    return modp(-n, p)\n\tdefault:\n\t\treturn modp(n & (p - 1), p)\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnvah680c.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpnvah680c.swift:19:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, -p)\n   \
    \                        ^\n                            n:     p: \n/tmp/tmpnvah680c.swift:21:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmpnvah680c.swift:23:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ & (p - 1), p)\n                           ^\n                            n:\
    \           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n < p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((n - p) + p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp33rwvbyr.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp33rwvbyr.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((n - p) + p, p)\n\
    \                   ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - n) % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeettots2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpeettots2.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((p - n) % p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n % p) + p) % p\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp76lz891x.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp76lz891x.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\tdefault:\n\
    \t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpawiomkg2.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpawiomkg2.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpawiomkg2.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2juaqvzx.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmp2juaqvzx.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp2juaqvzx.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmp2juaqvzx.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p ==\
    \ 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n <= p {\n\t\treturn modp(n - 1, p) + p\n\t}\n\treturn modp(p,\
    \ n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpefbp_u9y.swift:27:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - 1, p) + p\n                          \
    \ ^\n                            n:     p: \n/tmp/tmpefbp_u9y.swift:29:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(p, n)\n        \
    \           ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - n) % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj_ifytf1.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpj_ifytf1.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((p - n) % p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n   \
    \     return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return p\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj8_2b_2k.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpj8_2b_2k.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpj8_2b_2k.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpj8_2b_2k.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpj8_2b_2k.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpj8_2b_2k.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpj8_2b_2k.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(n, -p)\n\t}\n\tswitch {\n\tcase p < n:\n\t\treturn modp(n - p, p)\n\
    \tcase p > n:\n\t\treturn modp(n, p - n)\n\t}\n\treturn (p % n) + 1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgvkzbfl4.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpgvkzbfl4.swift:23:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpgvkzbfl4.swift:19:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(abs(n),\
    \ p)\n                           ^\n                            n:      p: \n\
    /tmp/tmpgvkzbfl4.swift:21:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, -p)\n                           ^\n          \
    \                  n: p: \n/tmp/tmpgvkzbfl4.swift:25:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpgvkzbfl4.swift:27:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - n)\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < n {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp(n, p - n)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_4n7kdjr.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp_4n7kdjr.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - n)\n    \
    \               ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n == 0\
    \ {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpws5cp6xc.swift:183:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpws5cp6xc.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmpws5cp6xc.swift:16:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\tif r == 0 {\n\t\treturn\
    \ q\n\t}\n\treturn q + modp(q, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpy4py5fpu.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpy4py5fpu.swift:29:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpy4py5fpu.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpy4py5fpu.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 1\")\n \
    \               ^~~~~\n/tmp/tmpy4py5fpu.swift:29:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmpy4py5fpu.swift:31:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpy4py5fpu.swift:32:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmpy4py5fpu.swift:34:9: error: cannot find 'q' in scope\n    \
    \    return q + modp(q, p)\n               ^\n/tmp/tmpy4py5fpu.swift:34:18: error:\
    \ cannot find 'q' in scope\n        return q + modp(q, p)\n                  \
    \      ^\n/tmp/tmpy4py5fpu.swift:34:17: error: missing argument labels 'n:p:'\
    \ in call\n        return q + modp(q, p)\n                       ^\n         \
    \               n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif p > p {\n\t\tpanic(\"modp p must be positive\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp88x1nt_k.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp88x1nt_k.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp88x1nt_k.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmp88x1nt_k.swift:18:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmp88x1nt_k.swift:21:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp p must be positive\"\
    )\n                ^~~~~\n/tmp/tmp88x1nt_k.swift:180:3: error: non-void function\
    \ should return a value\n                return \n                ^\n/tmp/tmp88x1nt_k.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(n, abs(p))\n\tcase p == 0:\n\t\treturn 0\n\
    \tdefault:\n\t\treturn n & (p - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpci24y4a2.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpci24y4a2.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpci24y4a2.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ abs(p))\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n >= p {\n\t\treturn modp(n - p, p)\n\t}\n\t\
    return modp((p - 1) * (n - p) + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphlkhdb1c.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmphlkhdb1c.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 1\")\n                ^~~~~\n/tmp/tmphlkhdb1c.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmphlkhdb1c.swift:32:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((p - 1) *\
    \ (n - p) + p, p)\n                   ^\n                    n:              \
    \       p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tswitch {\n\tcase p < n:\n\t\treturn modp(n - p, p)\n\tcase p > n:\n\t\treturn\
    \ modp(n, p - n)\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7awkweob.swift:29:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp7awkweob.swift:15:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative number\")\n  \
    \              ^~~~~\n/tmp/tmp7awkweob.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p < 1\")\n                ^~~~~\n/tmp/tmp7awkweob.swift:31:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp7awkweob.swift:33:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - n)\n                           ^\n       \
    \                     n: p: \n/tmp/tmp7awkweob.swift:35:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n >= p {\n        return n -\
    \ p\n    }\n    return p + (n - p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp_s68kxn2/tmp_s68kxn2.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0ca957c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0ca64eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0ca64e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0ca64d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_s68kxn2                        0x000055a5b6f2e23d <unavailable> + 4669

    5    libc.so.6                          0x00002ac0cab43460 __libc_start_main +
    245

    6    tmp_s68kxn2                        0x000055a5b6f2de69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\t\
    default:\n\t\treturn n & (p - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpguq1nr2m.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpguq1nr2m.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpguq1nr2m.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\
    \treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p\
    \ > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\
    \t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p,\
    \ p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn\
    \ modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\
    \t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif\
    \ p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\
    \t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n,\
    \ p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn\
    \ modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\t}\n\tif\
    \ p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p, p)\n\
    \t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn modp(n-p,\
    \ p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\t\treturn\
    \ modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif p < p {\n\
    \t\treturn modp(n-p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p-p)\n\t}\n\tif\
    \ p < p {\n\t\treturn modp(n-p, p)\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_ffqzwam.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmp_ffqzwam.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n/tmp/tmp_ffqzwam.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n-p, p)\n               \
    \            ^\n                            n:   p: \n/tmp/tmp_ffqzwam.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p-p)\n                           ^\n                            n: p: \n/tmp/tmp_ffqzwam.swift:36:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n-p,\
    \ p)\n                           ^\n                            n:   p: \n/tmp/tmp_ffqzwam.swift:39:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p-p)\n                           ^\n                            n: p: \n/tmp/tmp_ffqzwam.swift:42:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n-p,\
    \ p)\n                           ^\n                            n:   p: \n/tmp/tmp_ffqzwam.swift:45:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p-p)\n                           ^\n                            n: p: \n/tmp/tmp_ffqzwam.swift:48:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n-p,\
    \ p)\n                           ^\n                            n:   p: \n/tmp/tmp_ffqzwam.swift:51:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p-p)\n                           ^\n                            n: p: \n/tmp/tmp_ffqzwam.swift:54:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n-p,\
    \ p)\n                           ^\n                            n:   p: \n/tmp/tmp_ffqzwam.swift:57:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p-p)\n                           ^\n                            n: p: \n/tmp"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n += p\n    }\n  \
    \  if n < p {\n        return n\n    }\n    if n == p {\n        return 1\n  \
    \  }\n    if n > p {\n        return modp(n - p, p)\n    }\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpiefd2tfr.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n/tmp/tmpiefd2tfr.swift:24:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\
    \t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpz2whvrln.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpz2whvrln.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpz2whvrln.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpz2whvrln.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 1\")\n              \
    \  ^~~~~\n/tmp/tmpz2whvrln.swift:182:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7rfods6i.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmp7rfods6i.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp7rfods6i.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmp7rfods6i.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if p % 2 == 1 {\n        return modp(n / 2,\
    \ p)\n    }\n    if p % 2 == 0 {\n        return modp((n - 1) / 2, p)\n    }\n\
    \    if p < p {\n        return modp((n - 1) / 2, p)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    return modp((n - 1) / 2, p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbegrsgnh.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpbegrsgnh.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpbegrsgnh.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpbegrsgnh.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp((n - 1) / 2, p)\n               \
    \    ^\n                    n:           p: \n/tmp/tmpbegrsgnh.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((n - 1) / 2, p)\n\
    \                   ^\n                    n:           p: \n/tmp/tmpbegrsgnh.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbegrsgnh.swift:41:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp((n - 1) / 2,\
    \ p)\n               ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return p\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n > p {\n        return modp(n - p, p)\n    }\n    if n < p {\n\
    \        return modp(n, p - n)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg_rrewz7.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpg_rrewz7.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - n)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p < p {\n\t\treturn modp(n, p - 1)\n\t}\n\tq := p / n\n\tr := p % n\n\treturn\
    \ modp(q, p) + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjkhymgk6.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmpjkhymgk6.swift:32:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmpjkhymgk6.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpjkhymgk6.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmpjkhymgk6.swift:30:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(n, p - 1)\n                           ^\n\
    \                            n: p: \n/tmp/tmpjkhymgk6.swift:32:2: error: cannot\
    \ find 'q' in scope\n        q := p / n\n        ^\n/tmp/tmpjkhymgk6.swift:34:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) + r\n           \
    \         ^\n/tmp/tmpjkhymgk6.swift:34:22: error: cannot find 'r' in scope\n \
    \       return modp(q, p) + r\n                            ^\n/tmp/tmpjkhymgk6.swift:34:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) + r\n\
    \                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 2 {\n        return p\n    }\n    if n == 3 {\n        return\
    \ p\n    }\n    if n == 4 {\n        return p\n    }\n    if n == 5 {\n      \
    \  return p\n    }\n    if n == 6 {\n        return p\n    }\n    if n == 7 {\n\
    \        return p\n    }\n    if n == 8 {\n        return p\n    }\n    if n ==\
    \ 9 {\n        return p\n    }\n    if n == 10 {\n        return p\n    }\n  \
    \  if n == 11 {\n        return p\n    }\n    if n == 12 {\n        return p\n\
    \    }\n    if n == 13 {\n        return p\n    }\n    if n == 14 {\n        return\
    \ p\n    }\n    if n == 15 {\n        return p\n    }\n    if n == 16 {\n    \
    \    return p\n    }\n    if n == 17 {\n        return p\n    }\n    if n == 18\
    \ {\n        return p\n    }\n    if n == 19 {\n        return p\n    }\n    if\
    \ n == 20 {\n        return p\n    }\n    if n == 21 {\n        return p\n   \
    \ }\n    if n == 22 {\n        return p\n    }\n    if n == 23 {\n        return\
    \ p\n    }\n    if n == 24 {\n        return p\n    }\n    if n == 25 {\n    \
    \    return p\n    }\n    if n == 26 {\n        return p\n    }\n    if n == 27\
    \ {\n        return p\n    }\n    if n == 28 {\n        return p\n    }\n    if\
    \ n == 29 {\n        return p\n    }\n    if n == 30 {\n        return p\n   \
    \ }\n    if n == 31 {\n        return p\n    }\n    if n == 32 {\n        return\
    \ p\n    }\n    if n == 33 {\n        return p\n    }\n    if n == 34 {\n    \
    \    return p\n    }\n    if n == 35 {\n        return p\n    }\n    if n == 36\
    \ {\n        return p\n    }\n    if n == 37 {\n        return p\n    }\n    if\
    \ n == 38 {\n        return p\n    }\n    if n == 39 {\n        return p\n   \
    \ }\n    if n == 40 {\n        return p\n    }\n    if n == 41 {\n        return\
    \ p\n    }\n    if n == 42 {\n        return p\n    }\n    if n == 43 {\n    \
    \    return p\n    }\n    if n == 44 {\n        return p\n    }\n    if n == 45\
    \ {\n        return p\n    }\n    if n == 46 {\n        return p\n    }\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvdoyge38.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpvdoyge38.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n < p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((p - 1) * (n - p), p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpny1gz77q.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmpny1gz77q.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - 1) * (n - p),\
    \ p)\n                   ^\n                    n:                 p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp(n / p, p)\n    }\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpl4cynvgc.swift:179:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpl4cynvgc.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpl4cynvgc.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpl4cynvgc.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n > p:\n\t\treturn modp(n - p, p)\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvgbqynlr.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvgbqynlr.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 2 {\n        return n\n    }\n    if p > p {\n        return\
    \ modp(n - p, p)\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return modp(n\
    \ - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if\
    \ n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return\
    \ modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n\
    \    if n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n    \
    \    return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p,\
    \ p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if n ==\
    \ p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n\
    \ - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if\
    \ n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return\
    \ modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n\
    \    if n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n    \
    \    return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p,\
    \ p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if n ==\
    \ p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n\
    \ - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if\
    \ n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return\
    \ modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n\
    \    if n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n    \
    \    return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n - p,\
    \ p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if n ==\
    \ p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return modp(n\
    \ - p, p)\n    }\n    if n == p {\n        return modp(n - p, p)\n    }\n    if\
    \ n == p {\n        return modp(n - p, p)\n    }\n    if n == p {\n        return\
    \ modp(n - p, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2f2g3yvk.swift:158:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp2f2g3yvk.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp2f2g3yvk.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmp2f2g3yvk.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp2f2g3yvk.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:39:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:60:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp2f2g3yvk.swift:63:20:\
    \ error: missing"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\t\
    case p == 1:\n\t\treturn n\n\tdefault:\n\t\tlet r = n % p\n\t\tif r == 0 {\n\t\
    \t\treturn modp(r, n)\n\t\t}\n\t\treturn modp(r, p) + p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphoskcb9a.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmphoskcb9a.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmphoskcb9a.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmphoskcb9a.swift:26:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(r, n)\n                                   ^\n                         \
    \           n: p: \n/tmp/tmphoskcb9a.swift:28:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(r, p) + p\n                    \
    \       ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p - p)\n\t}\n\treturn modp(n + p - 1, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv_liwpnm.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires n >= 0\")\n                ^~~~~\n/tmp/tmpv_liwpnm.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ >= 1\")\n                ^~~~~\n/tmp/tmpv_liwpnm.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpv_liwpnm.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmpv_liwpnm.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n + p - 1,\
    \ p)\n                   ^\n                    n:         p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if p ==\
    \ 2 {\n        return modp(n / 2, p)\n    }\n    if p == 3 {\n        return modp(n\
    \ / 3, p)\n    }\n    if p == 4 {\n        return modp(n / 4, p)\n    }\n    if\
    \ p == 5 {\n        return modp(n / 5, p)\n    }\n    if p == 6 {\n        return\
    \ modp(n / 6, p)\n    }\n    if p == 7 {\n        return modp(n / 7, p)\n    }\n\
    \    if p == 8 {\n        return modp(n / 8, p)\n    }\n    if p == 9 {\n    \
    \    return modp(n / 9, p)\n    }\n    if p == 10 {\n        return modp(n / 10,\
    \ p)\n    }\n    if p == 11 {\n        return modp(n / 11, p)\n    }\n    if p\
    \ == 12 {\n        return modp(n / 12, p)\n    }\n    if p == 13 {\n        return\
    \ modp(n / 13, p)\n    }\n    if p == 14 {\n        return modp(n / 14, p)\n \
    \   }\n    if p == 15 {\n        return modp(n / 15, p)\n    }\n    if p == 16\
    \ {\n        return modp(n / 16, p)\n    }\n    if p == 17 {\n        return modp(n\
    \ / 17, p)\n    }\n    if p == 18 {\n        return modp(n / 18, p)\n    }\n \
    \   if p == 19 {\n        return modp(n / 19, p)\n    }\n    if p == 20 {\n  \
    \      return modp(n / 20, p)\n    }\n    if p == 21 {\n        return modp(n\
    \ / 21, p)\n    }\n    if p == 22 {\n        return modp(n / 22, p)\n    }\n \
    \   if p == 23 {\n        return modp(n / 23, p)\n    }\n    if p == 24 {\n  \
    \      return modp(n / 24, p)\n    }\n    if p == 25 {\n        return modp(n\
    \ / 25, p)\n    }\n    if p == 26 {\n        return modp(n / 26, p)\n    }\n \
    \   if p == 27 {\n        return modp(n / 27, p)\n    }\n    if p == 28 {\n  \
    \      return modp(n / 28, p)\n    }\n    if p == 29 {\n        return modp(n\
    \ / 29, p)\n    }\n    if p == 30 {\n        return modp(n / 30, p)\n    }\n \
    \   if p == 31 {\n        return modp(n / 31, p)\n    }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplrs6k3jk.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmplrs6k3jk.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmplrs6k3jk.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmplrs6k3jk.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 3, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmplrs6k3jk.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n / 4, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / 5, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmplrs6k3jk.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmplrs6k3jk.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 11, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmplrs6k3jk.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 12, p)\n\
    \                   ^\n                    n:    "
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(n, abs(p))\n\tcase p == 0:\n\t\treturn 0\n\
    \tcase p % 2 == 1:\n\t\treturn modp(n*n, p)\n\tdefault:\n\t\treturn modp(n*(n-1),\
    \ p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyq7roh1o.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyq7roh1o.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpyq7roh1o.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ abs(p))\n                           ^\n                            n: p: \n\
    /tmp/tmpyq7roh1o.swift:22:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n*n, p)\n                           ^\n         \
    \                   n:   p: \n/tmp/tmpyq7roh1o.swift:24:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n*(n-1), p)\n           \
    \                ^\n                            n:       p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n % p) + p) % p\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp76lz891x.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp76lz891x.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\tdefault:\n\
    \t\treturn modp(n / p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpilu8wdg8.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpilu8wdg8.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpilu8wdg8.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive modulus\")\n\
    \t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\treturn q * p + r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpip2vyyfi.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpip2vyyfi.swift:29:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpip2vyyfi.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ number\")\n                ^~~~~\n/tmp/tmpip2vyyfi.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive modulus\"\
    )\n                ^~~~~\n/tmp/tmpip2vyyfi.swift:29:2: error: cannot find 'q'\
    \ in scope\n        q := n / p\n        ^\n/tmp/tmpip2vyyfi.swift:31:9: error:\
    \ cannot find 'q' in scope\n        return q * p + r\n               ^\n/tmp/tmpip2vyyfi.swift:31:17:\
    \ error: cannot find 'r' in scope\n        return q * p + r\n                \
    \       ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn n\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp05_hnve3.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmp05_hnve3.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp05_hnve3.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmp05_hnve3.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n += p\n    }\n  \
    \  if n < p {\n        return n\n    }\n    if n == p {\n        return 1\n  \
    \  }\n    if n > p {\n        return modp(n - p, p)\n    }\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpiefd2tfr.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n/tmp/tmpiefd2tfr.swift:24:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n <= p {\n        return modp(n\
    \ - p, p)\n    }\n    return modp(p, n)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8xq5uw33.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp8xq5uw33.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmp8xq5uw33.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp8xq5uw33.swift:32:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(p, n)\n               ^\n  \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif p > 1\
    \ {\n\t\tp = p - 1\n\t}\n\tx := n\n\tfor x != 0 {\n\t\tx = x % p\n\t}\n\treturn\
    \ x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv30tuxji.swift:27:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpv30tuxji.swift:27:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpv30tuxji.swift:28:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmpv30tuxji.swift:28:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmpv30tuxji.swift:15:3: error: cannot assign to value: 'n' is a 'let' constant\n\
    \                n = -n\n                ^\n/tmp/tmpv30tuxji.swift:16:3: error:\
    \ cannot assign to value: 'p' is a 'let' constant\n                p = -p\n  \
    \              ^\n/tmp/tmpv30tuxji.swift:25:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = p - 1\n                ^\n/tmp/tmpv30tuxji.swift:27:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmpv30tuxji.swift:28:8:\
    \ error: '!=' is not a prefix unary operator\n        for x != 0 {\n         \
    \     ^\n/tmp/tmpv30tuxji.swift:31:9: error: cannot find 'x' in scope\n      \
    \  return x\n               ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\treturn 0\n\tcase p == 0:\n\t\treturn n\n\tcase\
    \ p < n:\n\t\treturn p % n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfwai_3gr.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpfwai_3gr.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpfwai_3gr.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if p < p {\n        return modp(n - p, p)\n\
    \    }\n    if p > p {\n        return modp(n, p)\n    }\n    if p % 2 == 0 {\n\
    \        return modp(n / 2, p)\n    }\n    return modp(n / 2, p) + modp(n % 2,\
    \ p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcbum2yym.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpcbum2yym.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpcbum2yym.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpcbum2yym.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpcbum2yym.swift:36:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpcbum2yym.swift:38:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(n / 2, p) + modp(n % 2, p)\n\
    \               ^\n                n:     p: \n/tmp/tmpcbum2yym.swift:38:33: error:\
    \ missing argument labels 'n:p:' in call\n    return modp(n / 2, p) + modp(n %\
    \ 2, p)\n                                ^\n                                 n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 2 {\n        return n\n    }\n    if p > p {\n        return\
    \ modp(n - p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyiit2pg1.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmpyiit2pg1.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n - p, p)\n                   ^\n             \
    \       n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < 2 {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu0w_1nvd.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpu0w_1nvd.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpu0w_1nvd.swift:172:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 || p == 0 {\n        return 0\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n <= p {\n        return modp(n - p, p)\n    }\n    if p <\
    \ n {\n        return modp(n, p - n)\n    }\n    return modp(p - n, p)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu8jgr37r.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpu8jgr37r.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmpu8jgr37r.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpu8jgr37r.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - n)\n            \
    \       ^\n                    n: p: \n/tmp/tmpu8jgr37r.swift:38:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(p - n, p)\n               ^\n\
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if p > n {\n        return modp(n,\
    \ p - 1)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p+1 {\n        return n\n    }\n \
    \   if n == p-1 {\n        return n\n    }\n    if n == p+2 {\n        return\
    \ n\n    }\n    if n == p+3 {\n        return n\n    }\n    if n == p+4 {\n  \
    \      return n\n    }\n    if n == p+5 {\n        return n\n    }\n    if n ==\
    \ p+6 {\n        return n\n    }\n    if n == p+7 {\n        return n\n    }\n\
    \    if n == p+8 {\n        return n\n    }\n    if n == p+9 {\n        return\
    \ n\n    }\n    if n == p+10 {\n        return n\n    }\n    if n == p+11 {\n\
    \        return n\n    }\n    if n == p+12 {\n        return n\n    }\n    if\
    \ n == p+13 {\n        return n\n    }\n    if n == p+14 {\n        return n\n\
    \    }\n    if n == p+15 {\n        return n\n    }\n    if n == p+16 {\n    \
    \    return n\n    }\n    if n == p+17 {\n        return n\n    }\n    if n ==\
    \ p+18 {\n        return n\n    }\n    if n == p+19 {\n        return n\n    }\n\
    \    if n == p+20 {\n        return n\n    }\n    if n == p+21 {\n        return\
    \ n\n    }\n    if n == p+22 {\n        return n\n    }\n    if n == p+23 {\n\
    \        return n\n    }\n    if n == p+24 {\n        return n\n    }\n    if\
    \ n == p+25 {\n        return n\n    }\n    if n == p+26 {\n        return n\n\
    \    }\n    if n == p+27 {\n        return n\n    }\n    if n == p+28 {\n    \
    \    return n\n    }\n    if n == p+29 {\n        return n\n    }\n    if n ==\
    \ p+30 {\n        return n\n    }\n    if n == p+31 {\n        return n\n    }\n\
    \    if n == p+32 {\n        return n\n    }\n    if n == p+33 {\n        return\
    \ n\n    }\n    if n == p+34 {\n        return n\n    }\n    if n == p+35 {\n\
    \        return n\n    }\n    if n == p+36 {\n        return n\n    }\n    if\
    \ n == p+37 {\n        return n\n    }\n    if n == p+38 {\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0l_73wtm.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp0l_73wtm.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp0l_73wtm.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp0l_73wtm.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmp0l_73wtm.swift:148:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\treturn 0\n\tcase p == 0:\n\t\treturn n\n\tcase\
    \ p == 1:\n\t\treturn 1\n\tcase p == 2:\n\t\treturn 2\n\tcase p < n:\n\t\treturn\
    \ p - 1\n\t}\n\tswitch {\n\tcase n % p == 0:\n\t\treturn n\n\tcase n % p == p:\n\
    \t\treturn n\n\tcase n % p == p - 1:\n\t\treturn n % p + 1\n\tcase n % p == p\
    \ - 2:\n\t\treturn n % p + 2\n\tcase n % p == p - 3:\n\t\treturn n % p + 3\n\t\
    case n % p == p - 4:\n\t\treturn n % p + 4\n\tcase n % p == p - 5:\n\t\treturn\
    \ n % p + 5\n\tcase n % p == p - 6:\n\t\treturn n % p + 6\n\tcase n % p == p -\
    \ 7:\n\t\treturn n % p + 7\n\tcase n % p == p - 8:\n\t\treturn n % p + 8\n\tcase\
    \ n % p == p - 9:\n\t\treturn n % p + 9\n\tcase n % p == p - 10:\n\t\treturn n\
    \ % p + 10\n\tcase n % p == p - 11:\n\t\treturn n % p + 11\n\tcase n % p == p\
    \ - 12:\n\t\treturn n % p + 12\n\tcase n % p == p - 13:\n\t\treturn n % p + 13\n\
    \tcase n % p == p - 14:\n\t\treturn n % p + 14\n\tcase n % p == p - 15:\n\t\t\
    return n % p + 15\n\tcase n % p == p - 16:\n\t\treturn n % p + 16\n\tcase n %\
    \ p == p - 17:\n\t\treturn n % p + 17\n\tcase n % p == p - 18:\n\t\treturn n %\
    \ p + 18\n\tcase n % p == p - 19:\n\t\treturn n % p + 19\n\tcase n % p == p -\
    \ 20:\n\t\treturn n % p + 20\n\tcase n % p == p - 21:\n\t\treturn n % p + 21\n\
    \tcase n % p == p - 22:\n\t\treturn n % p + 22\n\tcase n % p == p - 23:\n\t\t\
    return n % p + 23\n\tcase n % p == p - 24:\n\t\treturn n % p + 24\n\tcase n %\
    \ p == p - 25:\n\t\treturn n % p + 25\n\tcase n % p == p - 26:\n\t\treturn n %\
    \ p + 26\n\tcase n % p == p - 27:\n\t\treturn n % p + 27\n\tcase n % p == p -\
    \ 28:\n\t\treturn n % p + 28\n\tcase n % p == p - 29:\n\t\treturn n % p + 29\n\
    \tcase n % p == p - 30:\n\t\treturn n % p + 30\n\tcase \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq_px5dlw.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpq_px5dlw.swift:30:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpq_px5dlw.swift:95:6:\
    \ error: expected pattern\n        case \n            ^\n/tmp/tmpq_px5dlw.swift:95:6:\
    \ error: expected ':' after 'case'\n        case \n            ^\n/tmp/tmpq_px5dlw.swift:117:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpq_px5dlw.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpq_px5dlw.swift:15:3: error: cannot assign to value: 'n'\
    \ is a 'let' constant\n                n = -n\n                ^\n/tmp/tmpq_px5dlw.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpq_px5dlw.swift:99:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p > p {\n\t\treturn modp(n - p, p)\n\t}\n\treturn modp((n - p) / p, p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1r5yajhz.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp1r5yajhz.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmp1r5yajhz.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmp1r5yajhz.swift:32:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - p) /\
    \ p, p)\n                   ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n   \
    \     return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p - 1 {\n      \
    \  return n - 1\n    }\n    if n == p - 2 {\n        return n - 2\n    }\n   \
    \ if n == p - 3 {\n        return n - 3\n    }\n    if n == p - 4 {\n        return\
    \ n - 4\n    }\n    if n == p - 5 {\n        return n - 5\n    }\n    if n ==\
    \ p - 6 {\n        return n - 6\n    }\n    if n == p - 7 {\n        return n\
    \ - 7\n    }\n    if n == p - 8 {\n        return n - 8\n    }\n    if n == p\
    \ - 9 {\n        return n - 9\n    }\n    if n == p - 10 {\n        return n -\
    \ 10\n    }\n    if n == p - 11 {\n        return n - 11\n    }\n    if n == p\
    \ - 12 {\n        return n - 12\n    }\n    if n == p - 13 {\n        return n\
    \ - 13\n    }\n    if n == p - 14 {\n        return n - 14\n    }\n    if n ==\
    \ p - 15 {\n        return n - 15\n    }\n    if n == p - 16 {\n        return\
    \ n - 16\n    }\n    if n == p - 17 {\n        return n - 17\n    }\n    if n\
    \ == p - 18 {\n        return n - 18\n    }\n    if n == p - 19 {\n        return\
    \ n - 19\n    }\n    if n == p - 20 {\n        return n - 20\n    }\n    if n\
    \ == p - 21 {\n        return n - 21\n    }\n    if n == p - 22 {\n        return\
    \ n - 22\n    }\n    if n == p - 23 {\n        return n - 23\n    }\n    if n\
    \ == p - 24 {\n        return n - 24\n    }\n    if n == p - 25 {\n        return\
    \ n - 25\n    }\n    if n == p - 26 {\n        return n - 26\n    }\n    if n\
    \ == p - 27 {\n        return n - 27\n    }\n    if n == p - 28 {\n        return\
    \ n - 28\n    }\n    if n == p - 29 {\n        return n - 29\n    }\n    if n\
    \ == p - 30 {\n        return n - 30\n    }\n    if n == p - 31 {\n        return\
    \ n - 31\n    }\n    if n == p - 32 {\n        return n - 32\n    }\n    if n\
    \ == p - 33 {\n        return n - 33\n    }\n    if n == p - 34 {\n        return\
    \ n - 34\n    }\n    if n == p - 35 {\n        return n - 35\n    }\n    if n\
    \ == p - 36 {\n        return n - 36\n    }\n    if n == p - 37 {\n        return\
    \ n - 37\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptv3pgihj.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmptv3pgihj.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmptv3pgihj.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmptv3pgihj.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmptv3pgihj.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmptv3pgihj.swift:148:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n & (p - 1), p)\n    }\n    if p < p {\n        return modp(n >>\
    \ 1, p)\n    }\n    return modp(n >> 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzhisjkuu.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpzhisjkuu.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmpzhisjkuu.swift:24:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n >> 1, p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpzhisjkuu.swift:26:16: error:\
    \ missing argument labels 'n:p:' in call\n    return modp(n >> 2, p)\n       \
    \        ^\n                n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3ghfgaed.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3ghfgaed.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3ghfgaed.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp3ghfgaed.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n < p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((p - n) % p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8isfptio.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp8isfptio.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - n) % p, p)\n\
    \                   ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 0 {\n\t\treturn 0\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\tif r == 0 {\n\t\treturn\
    \ q\n\t}\n\treturn q + modp(q, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7huu29w3.swift:27:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp7huu29w3.swift:27:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp7huu29w3.swift:15:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ -n\n                ^\n/tmp/tmp7huu29w3.swift:16:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = -p\n                ^\n\
    /tmp/tmp7huu29w3.swift:27:2: error: cannot find 'q' in scope\n        q := n /\
    \ p\n        ^\n/tmp/tmp7huu29w3.swift:29:5: error: cannot find 'r' in scope\n\
    \        if r == 0 {\n           ^\n/tmp/tmp7huu29w3.swift:30:10: error: cannot\
    \ find 'q' in scope\n                return q\n                       ^\n/tmp/tmp7huu29w3.swift:32:9:\
    \ error: cannot find 'q' in scope\n        return q + modp(q, p)\n           \
    \    ^\n/tmp/tmp7huu29w3.swift:32:18: error: cannot find 'q' in scope\n      \
    \  return q + modp(q, p)\n                        ^\n/tmp/tmp7huu29w3.swift:32:17:\
    \ error: missing argument labels 'n:p:' in call\n        return q + modp(q, p)\n\
    \                       ^\n                        n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tlet mut n1 =\
    \ n\n\tlet mut n2 = n\n\tlet mut n3 = n\n\tlet mut n4 = n\n\tlet mut n5 = n\n\t\
    let mut n6 = n\n\tlet mut n7 = n\n\tlet mut n8 = n\n\tlet mut n9 = n\n\tlet mut\
    \ n10 = n\n\tlet mut n11 = n\n\tlet mut n12 = n\n\tlet mut n13 = n\n\tlet mut\
    \ n14 = n\n\tlet mut n15 = n\n\tlet mut n16 = n\n\tlet mut n17 = n\n\tlet mut\
    \ n18 = n\n\tlet mut n19 = n\n\tlet mut n20 = n\n\tlet mut n21 = n\n\tlet mut\
    \ n22 = n\n\tlet mut n23 = n\n\tlet mut n24 = n\n\tlet mut n25 = n\n\tlet mut\
    \ n26 = n\n\tlet mut n27 = n\n\tlet mut n28 = n\n\tlet mut n29 = n\n\tlet mut\
    \ n30 = n\n\tlet mut n31 = n\n\tlet mut n32 = n\n\tlet mut n33 = n\n\tlet mut\
    \ n34 = n\n\tlet mut n35 = n\n\tlet mut n36 = n\n\tlet mut n37 = n\n\tlet mut\
    \ n38 = n\n\tlet mut n39 = n\n\tlet mut n40 = n\n\tlet mut n41 = n\n\tlet mut\
    \ n42 = n\n\tlet mut n43 = n\n\tlet mut n44 = n\n\tlet mut n45 = n\n\tlet mut\
    \ n46 = n\n\tlet mut n47 = n\n\tlet mut n48 = n\n\tlet mut n49 = n\n\tlet mut\
    \ n50 = n\n\tlet mut n51 = n\n\tlet mut n52 = n\n\tlet mut n53 = n\n\tlet mut\
    \ n54 = n\n\tlet mut n55 = n\n\tlet mut n56 = n\n\tlet mut n57 = n\n\tlet mut\
    \ n58 = n\n\tlet mut \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppr15e7k5.swift:24:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut n1 =\
    \ n\n                ^\n/tmp/tmppr15e7k5.swift:24:10: note: join the identifiers\
    \ together\n        let mut n1 = n\n            ~~~~^~\n            mutn1\n/tmp/tmppr15e7k5.swift:24:10:\
    \ note: join the identifiers together with camel-case\n        let mut n1 = n\n\
    \            ~~~~^~\n            mutN1\n/tmp/tmppr15e7k5.swift:25:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut n2 = n\n                ^\n/tmp/tmppr15e7k5.swift:25:10:\
    \ note: join the identifiers together\n        let mut n2 = n\n            ~~~~^~\n\
    \            mutn2\n/tmp/tmppr15e7k5.swift:25:10: note: join the identifiers together\
    \ with camel-case\n        let mut n2 = n\n            ~~~~^~\n            mutN2\n\
    /tmp/tmppr15e7k5.swift:26:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut n3 = n\n\
    \                ^\n/tmp/tmppr15e7k5.swift:26:10: note: join the identifiers together\n\
    \        let mut n3 = n\n            ~~~~^~\n            mutn3\n/tmp/tmppr15e7k5.swift:26:10:\
    \ note: join the identifiers together with camel-case\n        let mut n3 = n\n\
    \            ~~~~^~\n            mutN3\n/tmp/tmppr15e7k5.swift:27:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut n4 = n\n                ^\n/tmp/tmppr15e7k5.swift:27:10:\
    \ note: join the identifiers together\n        let mut n4 = n\n            ~~~~^~\n\
    \            mutn4\n/tmp/tmppr15e7k5.swift:27:10: note: join the identifiers together\
    \ with camel-case\n        let mut n4 = n\n            ~~~~^~\n            mutN4\n\
    /tmp/tmppr15e7k5.swift:28:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut n5 = n\n\
    \                ^\n/tmp/tmppr15e7k5.swift:28:10: note: join the identifiers together\n\
    \        let mut n5 = n\n            ~~~~^~\n            m"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzeza2wvd.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpzeza2wvd.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpzeza2wvd.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tlet r = p % n\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpminkqkg6.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpminkqkg6.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnxfubh09.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpnxfubh09.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpnxfubh09.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpnxfubh09.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnxfubh09.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpnxfubh09.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2juaqvzx.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmp2juaqvzx.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp2juaqvzx.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmp2juaqvzx.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ argument\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive argument\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if n == p {\n\t\treturn n\n\t}\n\tswitch {\n\tcase p < n:\n\t\treturn modp(n -\
    \ p, p)\n\tcase p > n:\n\t\treturn modp(n, p - n)\n\t}\n\tswitch {\n\tcase p <\
    \ 2:\n\t\treturn modp(n - 1, p)\n\tcase p < 5:\n\t\treturn modp(n - 2, p)\n\t\
    case p < 10:\n\t\treturn modp(n - 3, p)\n\tcase p < 20:\n\t\treturn modp(n - 4,\
    \ p)\n\tcase p < 50:\n\t\treturn modp(n - 5, p)\n\tcase p < 100:\n\t\treturn modp(n\
    \ - 6, p)\n\tcase p < 200:\n\t\treturn modp(n - 7, p)\n\tcase p < 500:\n\t\treturn\
    \ modp(n - 8, p)\n\tcase p < 1000:\n\t\treturn modp(n - 9, p)\n\tcase p < 2000:\n\
    \t\treturn modp(n - 10, p)\n\tcase p < 5000:\n\t\treturn modp(n - 11, p)\n\tcase\
    \ p < 10000:\n\t\treturn modp(n - 12, p)\n\tcase p < 20000:\n\t\treturn modp(n\
    \ - 13, p)\n\tcase p < 50000:\n\t\treturn modp(n - 14, p)\n\tcase p < 100000:\n\
    \t\treturn modp(n - 15, p)\n\tcase p < 200000:\n\t\treturn modp(n - 16, p)\n\t\
    case p < 500000:\n\t\treturn modp(n - 17, p)\n\tcase p < 1000000:\n\t\treturn\
    \ modp(n - 18, p)\n\tcase p < 2000000:\n\t\treturn modp(n - 19, p)\n\tcase p <\
    \ 5000000:\n\t\treturn modp(n - 20, p)\n\tcase p < 10000000:\n\t\treturn modp(n\
    \ - 21, p)\n\tcase p < 20000000:\n\t\treturn modp(n - 22, p)\n\tcase p < 50000000:\n\
    \t\treturn modp(n - 23, p)\n\tcase p < 100000000:\n\t\treturn modp(n - 24, p)\n\
    \tcase p < 200000000:\n\t\treturn modp(n - 25, p)\n\tcase p < 500000000:\n\t\t\
    return modp(n - 26, p)\n\tcase p < 1000000000:\n\t\treturn modp(n - 27, p)\n\t\
    case p < 2000000000:\n\t\treturn modp(n - 28, p)\n\tcase p < 5000000000:\n\t\t\
    return modp(n - 29, p)\n\tcase p \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsmi4yazm.swift:29:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsmi4yazm.swift:35:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpsmi4yazm.swift:94:8:\
    \ error: expected ':' after 'case'\n        case p \n              ^\n/tmp/tmpsmi4yazm.swift:116:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpsmi4yazm.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpsmi4yazm.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires positive argument\")\n                ^~~~~\n\
    /tmp/tmpsmi4yazm.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive argument\")\n                ^~~~~\n/tmp/tmpsmi4yazm.swift:31:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpsmi4yazm.swift:33:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - n)\n                           ^\n       \
    \                     n: p: \n/tmp/tmpsmi4yazm.swift:37:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - 1, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpsmi4yazm.swift:39:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 2, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpsmi4yazm.swift:41:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 3, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpsmi4yazm.swift:43:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 4, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpsmi4yazm.swift:45:14:\
    \ error: missing argument labels 'n:p:' in call\n      "
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p % p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwh847upv.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpwh847upv.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpwh847upv.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p < 2:\n\
    \t\treturn 1\n\tdefault:\n\t\tlet r = n % p\n\t\tif r == 0 {\n\t\t\treturn p\n\
    \t\t} else {\n\t\t\treturn r\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4hv0nqq3.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp4hv0nqq3.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return pow2(n)\n    }\n    if p < p {\n \
    \       return pow2(n) % p\n    }\n    if p < p {\n        return n % p\n    }\n\
    \    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdul4l0ew.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpdul4l0ew.swift:18:16: error: cannot find 'pow2' in\
    \ scope\n        return pow2(n)\n               ^~~~\n/tmp/tmpdul4l0ew.swift:21:16:\
    \ error: cannot find 'pow2' in scope\n        return pow2(n) % p\n           \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if p < p {\n        return modp(n, p)\n  \
    \  }\n    if p > p {\n        return modp(n, p)\n    }\n    if p < p {\n     \
    \   return modp(n, p)\n    }\n    if p > p {\n        return modp(n, p)\n    }\n\
    \    if p < p {\n        return modp(n, p)\n    }\n    if p > p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n    if\
    \ p > p {\n        return modp(n, p)\n    }\n    if p < p {\n        return modp(n,\
    \ p)\n    }\n    if p > p {\n        return modp(n, p)\n    }\n    if p < p {\n\
    \        return modp(n, p)\n    }\n    if p > p {\n        return modp(n, p)\n\
    \    }\n    if p < p {\n        return modp(n, p)\n    }\n    if p > p {\n   \
    \     return modp(n, p)\n    }\n    if p < p {\n        return modp(n, p)\n  \
    \  }\n    if p > p {\n        return modp(n, p)\n    }\n    if p < p {\n     \
    \   return modp(n, p)\n    }\n    if p > p {\n        return modp(n, p)\n    }\n\
    \    if p < p {\n        return modp(n, p)\n    }\n    if p > p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n    if\
    \ p > p {\n        return modp(n, p)\n    }\n    if p < p {\n        return modp(n,\
    \ p)\n    }\n    if p > p {\n        return modp(n, p)\n    }\n    if p < p {\n\
    \        return modp(n, p)\n    }\n    if p > p {\n        return modp(n, p)\n\
    \    }\n    if p < p {\n        return modp(n, p)\n    }\n    if p > p {\n   \
    \     return modp(n, p)\n    }\n    if p < p {\n        return modp(n, p)\n  \
    \  }\n    if p > p {\n        return modp(n, p)\n    }\n    if p < p {\n     \
    \   return modp(n, p)\n    }\n    if p > p {\n        return modp(n, p)\n    }\n\
    \    if p < p {\n        return modp(n, p)\n    }\n    if p > p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n    if\
    \ p > p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcyv6a8z9.swift:156:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpcyv6a8z9.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpcyv6a8z9.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpcyv6a8z9.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:39:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:42:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:45:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:48:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:51:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:54:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpcyv6a8z9.swift:57:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n              "
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplxmf5f56.swift:189:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmplxmf5f56.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmplxmf5f56.swift:171:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n        return\
    \ modp(n, p)\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n\
    \        return p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n \
    \   if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n        return\
    \ p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n\
    \        return p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n \
    \   if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n        return\
    \ p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n    if n == 12\
    \ {\n        return p + 11\n    }\n    if n == 13 {\n        return p + 12\n \
    \   }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15 {\n    \
    \    return p + 14\n    }\n    if n == 16 {\n        return p + 15\n    }\n  \
    \  if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n        return\
    \ p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n    if n == 20\
    \ {\n        return p + 19\n    }\n    if n == 21 {\n        return p + 20\n \
    \   }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23 {\n    \
    \    return p + 22\n    }\n    if n == 24 {\n        return p + 23\n    }\n  \
    \  if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n        return\
    \ p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n    if n == 28\
    \ {\n        return p + 27\n    }\n    if n == 29 {\n        return p + 28\n \
    \   }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31 {\n    \
    \    return p + 30\n    }\n    if n == 32 {\n        return p + 31\n    }\n  \
    \  if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n        return\
    \ p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n    if n == 36\
    \ {\n        return p + 35\n    }\n    if n == 37 {\n        return p + 36\n \
    \   }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp89fpol91.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp89fpol91.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp89fpol91.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmp89fpol91.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp89fpol91.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n\
    \ - n, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgj4ucna8.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpgj4ucna8.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - n, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p+1 {\n\t\treturn n\n\t}\n\tif n == p-1 {\n\t\treturn n\n\t}\n\tif n\
    \ == p+2 {\n\t\treturn n\n\t}\n\tif n == p+3 {\n\t\treturn n\n\t}\n\tif n == p+4\
    \ {\n\t\treturn n\n\t}\n\tif n == p+5 {\n\t\treturn n\n\t}\n\tif n == p+6 {\n\t\
    \treturn n\n\t}\n\tif n == p+7 {\n\t\treturn n\n\t}\n\tif n == p+8 {\n\t\treturn\
    \ n\n\t}\n\tif n == p+9 {\n\t\treturn n\n\t}\n\tif n == p+10 {\n\t\treturn n\n\
    \t}\n\tif n == p+11 {\n\t\treturn n\n\t}\n\tif n == p+12 {\n\t\treturn n\n\t}\n\
    \tif n == p+13 {\n\t\treturn n\n\t}\n\tif n == p+14 {\n\t\treturn n\n\t}\n\tif\
    \ n == p+15 {\n\t\treturn n\n\t}\n\tif n == p+16 {\n\t\treturn n\n\t}\n\tif n\
    \ == p+17 {\n\t\treturn n\n\t}\n\tif n == p+18 {\n\t\treturn n\n\t}\n\tif n ==\
    \ p+19 {\n\t\treturn n\n\t}\n\tif n == p+20 {\n\t\treturn n\n\t}\n\tif n == p+21\
    \ {\n\t\treturn n\n\t}\n\tif n == p+22 {\n\t\treturn n\n\t}\n\tif n == p+23 {\n\
    \t\treturn n\n\t}\n\tif n == p+24 {\n\t\treturn n\n\t}\n\tif n == p+25 {\n\t\t\
    return n\n\t}\n\tif n == p+26 {\n\t\treturn n\n\t}\n\tif n == p+27 {\n\t\treturn\
    \ n\n\t}\n\tif n == p+28 {\n\t\treturn n\n\t}\n\tif n == p+29 {\n\t\treturn n\n\
    \t}\n\tif n == p+30 {\n\t\treturn n\n\t}\n\tif n == p+31 {\n\t\treturn n\n\t}\n\
    \tif n == p+32 {\n\t\treturn n\n\t}\n\tif n == p+33 {\n\t\treturn n\n\t}\n\tif\
    \ n == p+34 {\n\t\treturn n\n\t}\n\tif n == p+35 {\n\t\treturn n\n\t}\n\tif n\
    \ == p+36 {\n\t\treturn n\n\t}\n\tif n == p+37 {\n\t\treturn n\n\t}\n\tif n ==\
    \ p+\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1k2agl8g.swift:146:12: error: expected '{' after 'if' condition\n\
    \        if n == p+\n                  ^\n/tmp/tmp1k2agl8g.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmp1k2agl8g.swift:18:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n/tmp/tmp1k2agl8g.swift:146:11:\
    \ error: '+' is not a postfix unary operator\n        if n == p+\n           \
    \      ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(abs(n), -p)\n    }\n    if n\
    \ == 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n\
    \    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == 2 {\n        return p\n    }\n    if n == 3 {\n        return\
    \ p\n    }\n    if n == 4 {\n        return p\n    }\n    if n == 5 {\n      \
    \  return p\n    }\n    if n == 6 {\n        return p\n    }\n    if n == 7 {\n\
    \        return p\n    }\n    if n == 8 {\n        return p\n    }\n    if n ==\
    \ 9 {\n        return p\n    }\n    if n == 10 {\n        return p\n    }\n  \
    \  if n == 11 {\n        return p\n    }\n    if n == 12 {\n        return p\n\
    \    }\n    if n == 13 {\n        return p\n    }\n    if n == 14 {\n        return\
    \ p\n    }\n    if n == 15 {\n        return p\n    }\n    if n == 16 {\n    \
    \    return p\n    }\n    if n == 17 {\n        return p\n    }\n    if n == 18\
    \ {\n        return p\n    }\n    if n == 19 {\n        return p\n    }\n    if\
    \ n == 20 {\n        return p\n    }\n    if n == 21 {\n        return p\n   \
    \ }\n    if n == 22 {\n        return p\n    }\n    if n == 23 {\n        return\
    \ p\n    }\n    if n == 24 {\n        return p\n    }\n    if n == 25 {\n    \
    \    return p\n    }\n    if n == 26 {\n        return p\n    }\n    if n == 27\
    \ {\n        return p\n    }\n    if n == 28 {\n        return p\n    }\n    if\
    \ n == 29 {\n        return p\n    }\n    if n == 30 {\n        return p\n   \
    \ }\n    if n == 31 {\n        return p\n    }\n    if n == 32 {\n        return\
    \ p\n    }\n    if n == 33 {\n        return p\n    }\n    if n == 34 {\n    \
    \    return p\n    }\n    if n == 35 {\n        return p\n    }\n    if n == 36\
    \ {\n        return p\n    }\n    if n == 37 {\n        return p\n    }\n    if\
    \ n == 38 {\n        return p\n    }\n    if n == 39 {\n        return p\n   \
    \ }\n    if n == 40 {\n        return p\n    }\n    if n == 41 {\n        return\
    \ p\n    }\n    if n == 42 {\n        return p\n    }\n    if n == 43 {\n    \
    \    return p\n    }\n    if n == 44 {\n        return p\n    }\n    if n == 45\
    \ {\n        return p\n    }\n    if n == 46 {\n        return p\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp12e8lbxd.swift:188:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp12e8lbxd.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp12e8lbxd.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp12e8lbxd.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), -p)\n          \
    \         ^\n                    n:      p: \n/tmp/tmp12e8lbxd.swift:170:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 0 {\n\t\tp = -p\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn0jkcg3d.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpn0jkcg3d.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpn0jkcg3d.swift:19:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = -p\n                ^\n\
    /tmp/tmpn0jkcg3d.swift:21:4: error: left side of mutating operator isn't mutable:\
    \ 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase\
    \ n <= p:\n\t\treturn n\n\tcase p < n:\n\t\treturn p - 1\n\t}\n\treturn 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj7s_q19w.swift:21:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj7s_q19w.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpj7s_q19w.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n%p)+p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpdf_kyfww/tmpdf_kyfww.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3f2b7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3f2873b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3f2873988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3f28727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdf_kyfww                        0x0000559aabba42cd <unavailable> + 4813

    5    libc.so.6                          0x00002af3f2d68460 __libc_start_main +
    245

    6    tmpdf_kyfww                        0x0000559aabba3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 2, p)\n\
    \    }\n    if p < p {\n        return modp(n - 3, p)\n    }\n    if p < p {\n\
    \        return modp(n - 4, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 5, p)\n    }\n    if p < p {\n        return modp(n - 6, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 7, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 8, p)\n    }\n    if p < p {\n        return modp(n - 9, p)\n    }\n\
    \    if p < p {\n        return modp(n - 10, p)\n    }\n    if p < p {\n     \
    \   return modp(n - 11, p)\n    }\n    if p < p {\n        return modp(n - 12,\
    \ p)\n    }\n    if p < p {\n        return modp(n - 13, p)\n    }\n    if p <\
    \ p {\n        return modp(n - 14, p)\n    }\n    if p < p {\n        return modp(n\
    \ - 15, p)\n    }\n    if p < p {\n        return modp(n - 16, p)\n    }\n   \
    \ if p < p {\n        return modp(n - 17, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 18, p)\n    }\n    if p < p {\n        return modp(n - 19, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 20, p)\n    }\n    if p < p {\n \
    \       return modp(n - 21, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 22, p)\n    }\n    if p < p {\n        return modp(n - 23, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 24, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 25, p)\n    }\n    if p < p {\n        return modp(n - 26, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 27, p)\n    }\n    if p < p {\n \
    \       return modp(n - 28, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 29, p)\n    }\n    if p < p {\n        return modp(n - 30, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 31, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 32, p)\n    }\n    if p < p {\n        return modp(n - 33, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 34, p)\n    }\n    if p < p {\n \
    \       return modp(n - 35, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxb62c1dr.swift:146:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxb62c1dr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxb62c1dr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxb62c1dr.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:24:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 2, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmpxb62c1dr.swift:51:20:\
    \ erro"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return n\n    }\n\
    \    if p == 0 {\n        return 1\n    }\n    if n < p {\n        return modp(n,\
    \ p - 1)\n    }\n    if n == p {\n        return n\n    }\n    if n == p+1 {\n\
    \        return n\n    }\n    if n == p-1 {\n        return modp(n + 1, p)\n \
    \   }\n    return modp(n - 1, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3r1kx3hp.swift:21:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p - 1)\n                   ^\n                \
    \    n: p: \n/tmp/tmp3r1kx3hp.swift:30:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n + 1, p)\n                   ^\n             \
    \       n:     p: \n/tmp/tmp3r1kx3hp.swift:32:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - 1, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n >= p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((p - 1) * (n - p), p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpumu3p7g8.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmpumu3p7g8.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - 1) * (n - p),\
    \ p)\n                   ^\n                    n:                 p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y %\
    \ 2 == 0 {\n\t\t\tx /= 2\n\t\t\ty /= 2\n\t\t\tz /= 2\n\t\t} else {\n\t\t\tbreak\n\
    \t\t}\n\t}\n\tx %= p\n\ty %= p\n\tz %= p\n\tif x == 0 {\n\t\treturn z\n\t}\n\t\
    if y == 0 {\n\t\treturn x\n\t}\n\tif x == p {\n\t\treturn y\n\t}\n\tif y == p\
    \ {\n\t\treturn z\n\t}\n\tif x == z {\n\t\treturn y\n\t}\n\tif y == z {\n\t\t\
    return x\n\t}\n\tif x == y {\n\t\treturn z\n\t}\n\tif y == x {\n\t\treturn y\n\
    \t}\n\tif x == z {\n\t\treturn x\n\t}\n\tif y == z {\n\t\treturn y\n\t}\n\tif\
    \ x == y {\n\t\treturn z\n\t}\n\tif y == x {\n\t\treturn y\n\t}\n\tif x == z {\n\
    \t\treturn x\n\t}\n\tif y == z {\n\t\treturn y\n\t}\n\tif x == y {\n\t\treturn\
    \ z\n\t}\n\tif y == x {\n\t\treturn y\n\t}\n\tif x == z {\n\t\treturn x\n\t}\n\
    \tif y == z {\n\t\treturn y\n\t}\n\tif x == y {\n\t\treturn z\n\t}\n\tif y ==\
    \ x {\n\t\treturn y\n\t}\n\tif x == z {\n\t\treturn x\n\t}\n\tif y == z {\n\t\t\
    return y\n\t}\n\tif x == y {\n\t\treturn z\n\t}\n\tif y == x {\n\t\treturn y\n\
    \t}\n\tif x == z {\n\t\treturn x\n\t}\n\tif y == z {\n\t\treturn y\n\t}\n\tif\
    \ x == y {\n\t\treturn z\n\t}\n\tif y == x {\n\t\treturn y\n\t}\n\tif x == z {\n\
    \t\treturn x\n\t}\n\tif y == z {\n\t\treturn y\n\t}\n\tif x == y {\n\t\treturn\
    \ z\n\t}\n\tif y == x {\n\t\treturn y\n\t}\n\tif x == z {\n\t\treturn x\n\t}\n\
    \tif y == z {\n\t\treturn y\n\t}\n\tif x == y {\n\t\treturn z\n\t}\n\tif y ==\
    \ x {\n\t\treturn y\n\t}\n\tif x == z {\n\t\treturn x\n\t}\n\tif y == z {\n\t\t\
    return y\n\t}\n\tif \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0ov03shw.swift:33:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp0ov03shw.swift:33:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp0ov03shw.swift:36:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp0ov03shw.swift:36:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp0ov03shw.swift:162:4: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmp0ov03shw.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmp0ov03shw.swift:16:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n/tmp/tmp0ov03shw.swift:19:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p < 1\")\n    \
    \            ^~~~~\n/tmp/tmp0ov03shw.swift:22:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"p > p\")\n                ^~~~~\n/tmp/tmp0ov03shw.swift:33:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmp0ov03shw.swift:45:2:\
    \ error: cannot find 'x' in scope\n        x %= p\n        ^\n/tmp/tmp0ov03shw.swift:46:2:\
    \ error: cannot find 'y' in scope\n        y %= p\n        ^\n/tmp/tmp0ov03shw.swift:47:2:\
    \ error: cannot find 'z' in scope\n        z %= p\n        ^\n/tmp/tmp0ov03shw.swift:48:5:\
    \ error: cannot find 'x' in scope\n        if x == 0 {\n           ^\n/tmp/tmp0ov03shw.swift:49:10:\
    \ error: cannot find 'z' in scope\n                return z\n                \
    \       ^\n/tmp/tmp0ov03shw.swift:51:5: error: cannot find 'y' in scope\n    \
    \    if y == 0 {\n           ^\n/tmp/tmp0ov03shw.swift:52:10: error: cannot find\
    \ 'x' in scope\n                return x\n                       ^\n/tmp/tmp0ov03shw.swift:54:5:\
    \ error: cannot find 'x' in scope\n        if x == p {\n           ^\n/tmp/tmp0ov03shw.swift:55:10:\
    \ error: cannot find 'y' in scope\n                return y\n                \
    \       ^\n/tmp/tmp0ov03shw.swift:57:5: error: cannot find 'y' in scope\n    \
    \    if y == p {\n "
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n - p, p)\n    }\n    if p % 2 == 0 {\n        return modp(n\
    \ / 2, p)\n    }\n    return modp((n - 1) / 2, p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpensvnqxw.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpensvnqxw.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpensvnqxw.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpensvnqxw.swift:32:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp((n - 1) / 2, p)\n          \
    \     ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n <= p {\n\t\t\
    return 0\n\t}\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn 1\n\t}\n\treturn r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpb8c3d_ua/tmpb8c3d_ua.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2597911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2597608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2597608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25976077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8c3d_ua                        0x000055e1e3d0824d <unavailable> + 4685

    5    libc.so.6                          0x00002b2597afd460 __libc_start_main +
    245

    6    tmpb8c3d_ua                        0x000055e1e3d07ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < 2 {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpftne5ust.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpftne5ust.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpftne5ust.swift:172:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tq := p / n\n\tr := p % n\n\t\
    return modp(q, p) * n + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq48in6c2.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmpq48in6c2.swift:32:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmpq48in6c2.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpq48in6c2.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmpq48in6c2.swift:30:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpq48in6c2.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p / n\n        ^\n/tmp/tmpq48in6c2.swift:34:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) * n + r\n       \
    \             ^\n/tmp/tmpq48in6c2.swift:34:26: error: cannot find 'r' in scope\n\
    \        return modp(q, p) * n + r\n                                ^\n/tmp/tmpq48in6c2.swift:34:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * n\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return n\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n >= p {\n        return n - p\n    }\n    return n - p + p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmps4xzoq_b/tmps4xzoq_b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc080abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc07da2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc07da2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc07da17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps4xzoq_b                        0x0000561aa56dc23d <unavailable> + 4669

    5    libc.so.6                          0x00002adc08297460 __libc_start_main +
    245

    6    tmps4xzoq_b                        0x0000561aa56dbe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (-p)) + (n & p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpfmss4jq9/tmpfmss4jq9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dc57efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dc54e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dc54e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dc54e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfmss4jq9                        0x000055925cd0c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b9dc59db460 __libc_start_main +
    245

    6    tmpfmss4jq9                        0x000055925cd0be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n << p) & -((n << p) & + n))\
    \ >> p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpy8z95ycz.swift:14:37: error: unary operator cannot be separated\
    \ from its operand\n    return ((n << p) & -((n << p) & + n)) >> p\n         \
    \                           ^~\n                                     \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    if p % 2 == 0 {\n        return modp(n\
    \ / 2, p)\n    }\n    return modp(n / 2, p) + modp(n / 2, p - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_9pkyey1.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp_9pkyey1.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp_9pkyey1.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp_9pkyey1.swift:32:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(n / 2, p) + modp(n / 2, p - 1)\n    \
    \           ^\n                n:     p: \n/tmp/tmp_9pkyey1.swift:32:33: error:\
    \ missing argument labels 'n:p:' in call\n    return modp(n / 2, p) + modp(n /\
    \ 2, p - 1)\n                                ^\n                             \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    if p % 2 == 0 {\n        return modp(n\
    \ / 2, p)\n    }\n    return modp(n / 2, p) + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwj513s2e.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpwj513s2e.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpwj513s2e.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpwj513s2e.swift:32:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(n / 2, p) + 1\n               ^\n   \
    \             n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p == 0 {\n\t\treturn 0\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\
    \treturn p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpph7jv9i5.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpph7jv9i5.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpph7jv9i5.swift:21:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n << p) & -((n << p) &^ n)) %\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwxmjfnrc.swift:14:35: error: cannot find operator '&^' in scope\n\
    \    return ((n << p) & -((n << p) &^ n)) % p\n                              \
    \    ^~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if p > p {\n        return modp(n - p, p)\n\
    \    }\n    if p < p {\n        return modp(n, p)\n    }\n    if p < 1 {\n   \
    \     return modp(n, p)\n    }\n    if p > 1 {\n        return modp(n, p)\n  \
    \  }\n    if p < 2 {\n        return modp(n, p)\n    }\n    if p > 2 {\n     \
    \   return modp(n, p)\n    }\n    if p < 3 {\n        return modp(n, p)\n    }\n\
    \    if p > 3 {\n        return modp(n, p)\n    }\n    if p < 4 {\n        return\
    \ modp(n, p)\n    }\n    if p > 4 {\n        return modp(n, p)\n    }\n    if\
    \ p < 5 {\n        return modp(n, p)\n    }\n    if p > 5 {\n        return modp(n,\
    \ p)\n    }\n    if p < 6 {\n        return modp(n, p)\n    }\n    if p > 6 {\n\
    \        return modp(n, p)\n    }\n    if p < 7 {\n        return modp(n, p)\n\
    \    }\n    if p > 7 {\n        return modp(n, p)\n    }\n    if p < 8 {\n   \
    \     return modp(n, p)\n    }\n    if p > 8 {\n        return modp(n, p)\n  \
    \  }\n    if p < 9 {\n        return modp(n, p)\n    }\n    if p > 9 {\n     \
    \   return modp(n, p)\n    }\n    if p < 10 {\n        return modp(n, p)\n   \
    \ }\n    if p > 10 {\n        return modp(n, p)\n    }\n    if p < 11 {\n    \
    \    return modp(n, p)\n    }\n    if p > 11 {\n        return modp(n, p)\n  \
    \  }\n    if p < 12 {\n        return modp(n, p)\n    }\n    if p > 12 {\n   \
    \     return modp(n, p)\n    }\n    if p < 13 {\n        return modp(n, p)\n \
    \   }\n    if p > 13 {\n        return modp(n, p)\n    }\n    if p < 14 {\n  \
    \      return modp(n, p)\n    }\n    if p > 14 {\n        return modp(n, p)\n\
    \    }\n    if p < 15 {\n        return modp(n, p)\n    }\n    if p > 15 {\n \
    \       return modp(n, p)\n    }\n    if p < 16 {\n        return modp(n, p)\n\
    \    }\n    if p > 16 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppgs5nk8u.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmppgs5nk8u.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmppgs5nk8u.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmppgs5nk8u.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmppgs5nk8u.swift:33:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:39:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:42:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:45:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:48:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:51:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:54:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmppgs5nk8u.swift:57:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n      "
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\tpanic(\"modp: negative modulus\")\n\tcase p ==\
    \ 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p % 2 == 1:\n\t\treturn\
    \ modp(n / 2, p)\n\tdefault:\n\t\treturn modp((n-1)/2, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbidwn4ua.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpbidwn4ua.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpbidwn4ua.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpbidwn4ua.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmpbidwn4ua.swift:26:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n / 2, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpbidwn4ua.swift:28:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((n-1)/2,\
    \ p)\n                           ^\n                            n:       p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn n - p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp85avim0r.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p >\
    \ p {\n        return modp(n, p - p)\n    }\n    return n & (p - 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps3r45jlr.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmps3r45jlr.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n/tmp/tmps3r45jlr.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - p)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p)\n    }\n    if p < p {\n   \
    \     return modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p -\
    \ 2)\n    }\n    if p < p {\n        return modp(n, p - 3)\n    }\n    if p <\
    \ p {\n        return modp(n, p - 4)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 5)\n    }\n    if p < p {\n        return modp(n, p - 6)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 7)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 8)\n    }\n    if p < p {\n        return modp(n, p - 9)\n    }\n\
    \    if p < p {\n        return modp(n, p - 10)\n    }\n    if p < p {\n     \
    \   return modp(n, p - 11)\n    }\n    if p < p {\n        return modp(n, p -\
    \ 12)\n    }\n    if p < p {\n        return modp(n, p - 13)\n    }\n    if p\
    \ < p {\n        return modp(n, p - 14)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 15)\n    }\n    if p < p {\n        return modp(n, p - 16)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 17)\n    }\n    if p < p {\n \
    \       return modp(n, p - 18)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 19)\n    }\n    if p < p {\n        return modp(n, p - 20)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 21)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 22)\n    }\n    if p < p {\n        return modp(n, p - 23)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 24)\n    }\n    if p < p {\n \
    \       return modp(n, p - 25)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 26)\n    }\n    if p < p {\n        return modp(n, p - 27)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 28)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 29)\n    }\n    if p < p {\n        return modp(n, p - 30)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 31)\n    }\n    if p < p {\n \
    \       return modp(n, p - 32)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 33)\n    }\n    if p < \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt8ff2ad2.swift:126:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpt8ff2ad2.swift:24:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p)\n                   ^\n                    n: p: \n\
    /tmp/tmpt8ff2ad2.swift:27:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 1)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:30:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 2)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:33:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 3)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:36:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 4)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:39:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 5)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:42:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 6)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:45:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 7)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:48:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 8)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:51:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 9)\n                   ^\n                    n: p:\
    \ \n/tmp/tmpt8ff2ad2.swift:54:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n, p - 10)\n                   ^\n                    n:\
    \ p: \n/tmp/tmpt8ff2ad2.swift:57:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p - 11)\n                   ^\n               \
    \     n: p: \n/tmp/tmpt8ff2ad2.swift:60:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 12)\n                   "
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\t\
    case n <= p:\n\t\treturn n\n\tcase n >= p:\n\t\treturn p\n\t}\n\tlet r = n % p\n\
    \tif r == 0 {\n\t\treturn p\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3cyz8j7p.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\t\
    if p > p {\n\t\treturn modp(n, p - p)\n\t}\n\treturn modp((n - p) * (p - 1), p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv9lfybnf.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpv9lfybnf.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 1\")\n                ^~~~~\n/tmp/tmpv9lfybnf.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpv9lfybnf.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmpv9lfybnf.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - p) *\
    \ (p - 1), p)\n                   ^\n                    n:                 p:\
    \ \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\t\
    x := n\n\tfor x != 0 {\n\t\tx := x % p\n\t\tif x == 0 {\n\t\t\treturn x\n\t\t\
    }\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1ba2w9gz.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp1ba2w9gz.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp1ba2w9gz.swift:33:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmp1ba2w9gz.swift:33:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmp1ba2w9gz.swift:34:4: error: consecutive statements on a line must be separated\
    \ by ';'\n                x := x % p\n                 ^\n                 ;\n\
    /tmp/tmp1ba2w9gz.swift:34:5: error: expected expression\n                x :=\
    \ x % p\n                  ^\n/tmp/tmp1ba2w9gz.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive n\")\n    \
    \            ^~~~~\n/tmp/tmp1ba2w9gz.swift:18:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"modp requires positive p\")\n               \
    \ ^~~~~\n/tmp/tmp1ba2w9gz.swift:30:3: error: cannot find 'panic' in scope\n  \
    \              panic(\"modp requires p <= p\")\n                ^~~~~\n/tmp/tmp1ba2w9gz.swift:32:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmp1ba2w9gz.swift:33:8:\
    \ error: '!=' is not a prefix unary operator\n        for x != 0 {\n         \
    \     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv46e953w.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpv46e953w.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p >\
    \ p {\n        return modp(n, p - p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpolqoik5c.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpolqoik5c.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpolqoik5c.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpolqoik5c.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpolqoik5c.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - p)\n            \
    \       ^\n                    n: p: \n/tmp/tmpolqoik5c.swift:183:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(p / 2, p)\n    }\n    if p < p {\n        return modp((p - 1) *\
    \ (p - 1) / 2, p)\n    }\n    if p < p {\n        return modp((p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1), p)\n    }\n    if p < p {\n\
    \        return modp((p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((p\
    \ - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1), p)\n    }\n    if p < p {\n        return\
    \ modp((p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p\
    \ - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) *\
    \ (p - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p -\
    \ 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p\
    \ - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p -\
    \ 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p\
    \ - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p -\
    \ 1) * (p - 1) * (\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp13dq2okw.swift:43:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp13dq2okw.swift:64:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp13dq2okw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp13dq2okw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp13dq2okw.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(p / 2, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp13dq2okw.swift:24:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - 1) * (p - 1)\
    \ / 2, p)\n                   ^\n                    n:                     p:\
    \ \n/tmp/tmp13dq2okw.swift:27:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp((p - 1) * (p - 1) * (p - 1) * (p - 1), p)\n             \
    \      ^\n                    n:                                     p: \n/tmp/tmp13dq2okw.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1), p)\n                   ^\n\
    \                    n:                                                      \
    \   p: \n/tmp/tmp13dq2okw.swift:33:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp((p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1), p)\n                   ^\n          \
    \          n:                                                                \
    \                       p: \n/tmp/tmp13dq2okw.swift:36:16: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        return modp((p - 1) *\
    \ (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1) * (p - 1)\
    \ * (p - 1) * (p - 1) * (p - 1), p)\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014735
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 1\
    \ {\n\t\tp = -p\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase p == 0:\n\
    \t\treturn n\n\tcase p == 1:\n\t\treturn n\n\tcase p < n:\n\t\treturn n % p\n\t\
    default:\n\t\tlet q = p / 2\n\t\tlet r = n % p\n\t\treturn modp(n - r, q) + r\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4vbaj6e5.swift:20:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp4vbaj6e5.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmp4vbaj6e5.swift:18:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmp4vbaj6e5.swift:32:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - r, q) + r\n                           ^\n                            n:  \
    \   p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((n\
    \ - p) + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpx0r3dprs.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpx0r3dprs.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - p) + p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif p > n {\n\t\tp, n = n, p\n\t\
    }\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn p + modp(n - p, p)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgsl5tnf9.swift:22:4: error: consecutive statements on a line must\
    \ be separated by ';'\n                p, n = n, p\n                 ^\n     \
    \            ;\n/tmp/tmpgsl5tnf9.swift:22:4: error: expected expression\n    \
    \            p, n = n, p\n                 ^\n/tmp/tmpgsl5tnf9.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmpgsl5tnf9.swift:16:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n/tmp/tmpgsl5tnf9.swift:22:3:\
    \ warning: expression of type 'Int' is unused\n                p, n = n, p\n \
    \               ^\n/tmp/tmpgsl5tnf9.swift:24:4: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n/tmp/tmpgsl5tnf9.swift:28:17:\
    \ error: missing argument labels 'n:p:' in call\n        return p + modp(n - p,\
    \ p)\n                       ^\n                        n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2fjdafm8.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2fjdafm8.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p+1 {\n\t\treturn\
    \ 1\n\t}\n\tif n == p-1 {\n\t\treturn 0\n\t}\n\tif n == p+2 {\n\t\treturn 2\n\t\
    }\n\tif n == p+3 {\n\t\treturn 3\n\t}\n\tif n == p+4 {\n\t\treturn 4\n\t}\n\t\
    if n == p+5 {\n\t\treturn 5\n\t}\n\tif n == p+6 {\n\t\treturn 6\n\t}\n\tif n ==\
    \ p+7 {\n\t\treturn 7\n\t}\n\tif n == p+8 {\n\t\treturn 8\n\t}\n\tif n == p+9\
    \ {\n\t\treturn 9\n\t}\n\tif n == p+10 {\n\t\treturn 10\n\t}\n\tif n == p+11 {\n\
    \t\treturn 11\n\t}\n\tif n == p+12 {\n\t\treturn 12\n\t}\n\tif n == p+13 {\n\t\
    \treturn 13\n\t}\n\tif n == p+14 {\n\t\treturn 14\n\t}\n\tif n == p+15 {\n\t\t\
    return 15\n\t}\n\tif n == p+16 {\n\t\treturn 16\n\t}\n\tif n == p+17 {\n\t\treturn\
    \ 17\n\t}\n\tif n == p+18 {\n\t\treturn 18\n\t}\n\tif n == p+19 {\n\t\treturn\
    \ 19\n\t}\n\tif n == p+20 {\n\t\treturn 20\n\t}\n\tif n == p+21 {\n\t\treturn\
    \ 21\n\t}\n\tif n == p+22 {\n\t\treturn 22\n\t}\n\tif n == p+23 {\n\t\treturn\
    \ 23\n\t}\n\tif n == p+24 {\n\t\treturn 24\n\t}\n\tif n == p+25 {\n\t\treturn\
    \ 25\n\t}\n\tif n == p+26 {\n\t\treturn 26\n\t}\n\tif n == p+27 {\n\t\treturn\
    \ 27\n\t}\n\tif n == p+28 {\n\t\treturn 28\n\t}\n\tif n == p+29 {\n\t\treturn\
    \ 29\n\t}\n\tif n == p+30 {\n\t\treturn 30\n\t}\n\tif n == p+31 {\n\t\treturn\
    \ 31\n\t}\n\tif n == p+32 {\n\t\treturn 32\n\t}\n\tif n == p+33 {\n\t\treturn\
    \ 33\n\t}\n\tif n == p+34 {\n\t\treturn 34\n\t}\n\tif n == p+35 {\n\t\treturn\
    \ 35\n\t}\n\tif n == p+36 {\n\t\treturn 36\n\t}\n\tif n == p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcebgs_xz.swift:143:11: error: expected '{' after 'if' condition\n\
    \        if n == p\n                 ^\n/tmp/tmpcebgs_xz.swift:15:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive n\")\n\
    \                ^~~~~\n/tmp/tmpcebgs_xz.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp requires positive p\")\n            \
    \    ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n << p) & p) - ((n >> p) & p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbbdbda1d/tmpbbdbda1d.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac31fdc4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac31fabbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac31fabb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac31faba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbbdbda1d                        0x00005572f1b1b1bd <unavailable> + 4541

    5    libc.so.6                          0x00002ac31ffb0460 __libc_start_main +
    245

    6    tmpbbdbda1d                        0x00005572f1b1ae69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n - p, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwzstgjdr.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpwzstgjdr.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0\
    \ {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too large\")\n\t}\n\t\
    q := p / n\n\tr := p % n\n\tif r == 0 {\n\t\treturn q\n\t}\n\treturn q + modp(n\
    \ - r, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmploor3_b4.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmploor3_b4.swift:32:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmploor3_b4.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmploor3_b4.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmploor3_b4.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: modulus is too large\")\n          \
    \      ^~~~~\n/tmp/tmploor3_b4.swift:32:2: error: cannot find 'q' in scope\n \
    \       q := p / n\n        ^\n/tmp/tmploor3_b4.swift:34:5: error: cannot find\
    \ 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmploor3_b4.swift:35:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmploor3_b4.swift:37:9: error: cannot find 'q' in scope\n    \
    \    return q + modp(n - r, p)\n               ^\n/tmp/tmploor3_b4.swift:37:22:\
    \ error: cannot find 'r' in scope\n        return q + modp(n - r, p)\n       \
    \                     ^\n/tmp/tmploor3_b4.swift:37:17: error: missing argument\
    \ labels 'n:p:' in call\n        return q + modp(n - r, p)\n                 \
    \      ^\n                        n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n & (p - 1), p)\n    }\n    if\
    \ p > p {\n        return modp((n >> 1) & (p - 1), p)\n    }\n    return n & (p\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwrzy0hxy.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpwrzy0hxy.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmpwrzy0hxy.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n >> 1) & (p - 1), p)\n\
    \                   ^\n                    n:                  p: \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn n - p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp85avim0r.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < 2 {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 2\n\t\
    }\n\tif p < p {\n\t\treturn 3\n\t}\n\tif p < p {\n\t\treturn 4\n\t}\n\tif p <\
    \ p {\n\t\treturn 5\n\t}\n\tif p < p {\n\t\treturn 6\n\t}\n\tif p < p {\n\t\t\
    return 7\n\t}\n\tif p < p {\n\t\treturn 8\n\t}\n\tif p < p {\n\t\treturn 9\n\t\
    }\n\tif p < p {\n\t\treturn 10\n\t}\n\tif p < p {\n\t\treturn 11\n\t}\n\tif p\
    \ < p {\n\t\treturn 12\n\t}\n\tif p < p {\n\t\treturn 13\n\t}\n\tif p < p {\n\t\
    \treturn 14\n\t}\n\tif p < p {\n\t\treturn 15\n\t}\n\tif p < p {\n\t\treturn 16\n\
    \t}\n\tif p < p {\n\t\treturn 17\n\t}\n\tif p < p {\n\t\treturn 18\n\t}\n\tif\
    \ p < p {\n\t\treturn 19\n\t}\n\tif p < p {\n\t\treturn 20\n\t}\n\tif p < p {\n\
    \t\treturn 21\n\t}\n\tif p < p {\n\t\treturn 22\n\t}\n\tif p < p {\n\t\treturn\
    \ 23\n\t}\n\tif p < p {\n\t\treturn 24\n\t}\n\tif p < p {\n\t\treturn 25\n\t}\n\
    \tif p < p {\n\t\treturn 26\n\t}\n\tif p < p {\n\t\treturn 27\n\t}\n\tif p < p\
    \ {\n\t\treturn 28\n\t}\n\tif p < p {\n\t\treturn 29\n\t}\n\tif p < p {\n\t\t\
    return 30\n\t}\n\tif p < p {\n\t\treturn 31\n\t}\n\tif p < p {\n\t\treturn 32\n\
    \t}\n\tif p < p {\n\t\treturn 33\n\t}\n\tif p < p {\n\t\treturn 34\n\t}\n\tif\
    \ p < p {\n\t\treturn 35\n\t}\n\tif p < p {\n\t\treturn 36\n\t}\n\tif p < p {\n\
    \t\treturn 37\n\t}\n\tif p < p {\n\t\treturn 38\n\t}\n\tif p < p {\n\t\treturn\
    \ 39\n\t}\n\tif p < p {\n\t\treturn 40\n\t}\n\tif p < p {\n\t\treturn 41\n\t}\n\
    \tif p < p {\n\t\treturn 42\n\t}\n\tif p < p {\n\t\treturn 43\n\t}\n\tif p < p\
    \ {\n\t\treturn 44\n\t}\n\tif p < p {\n\t\treturn 45\n\t}\n\tif p < p {\n\t\t\
    return 46\n\t}\n\tif p < p {\n\t\treturn 47\n\t}\n\tif p < p {\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp637jnr5r.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp637jnr5r.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp637jnr5r.swift:172:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase n < p:\n\t\treturn modp(n - 1, p) % p\n\tcase n == p:\n\t\
    \treturn 1\n\tcase n < p:\n\t\treturn modp((n - p) % p, p) % p\n\tdefault:\n\t\
    \treturn modp((n - p) % p, p) % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9no0ce9j.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp9no0ce9j.swift:19:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) % p\n\
    \                           ^\n                            n:     p: \n/tmp/tmp9no0ce9j.swift:23:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((n\
    \ - p) % p, p) % p\n                           ^\n                           \
    \ n:           p: \n/tmp/tmp9no0ce9j.swift:25:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp((n - p) % p, p) % p\n          \
    \                 ^\n                            n:           p: \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyvwzfoo0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyvwzfoo0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps0qekcg4.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires n >= 0\")\n                ^~~~~\n/tmp/tmps0qekcg4.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ >= 1\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\"\
    )\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif n == p\
    \ {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnw0t772p.swift:192:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpnw0t772p.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpnw0t772p.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpnw0t772p.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 1\")\n              \
    \  ^~~~~\n/tmp/tmpnw0t772p.swift:30:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpnw0t772p.swift:33:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpnw0t772p.swift:174:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n        return\
    \ modp(n, p)\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n\
    \        return p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n \
    \   if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n        return\
    \ p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n\
    \        return p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n \
    \   if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n        return\
    \ p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n    if n == 12\
    \ {\n        return p + 11\n    }\n    if n == 13 {\n        return p + 12\n \
    \   }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15 {\n    \
    \    return p + 14\n    }\n    if n == 16 {\n        return p + 15\n    }\n  \
    \  if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n        return\
    \ p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n    if n == 20\
    \ {\n        return p + 19\n    }\n    if n == 21 {\n        return p + 20\n \
    \   }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23 {\n    \
    \    return p + 22\n    }\n    if n == 24 {\n        return p + 23\n    }\n  \
    \  if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n        return\
    \ p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n    if n == 28\
    \ {\n        return p + 27\n    }\n    if n == 29 {\n        return p + 28\n \
    \   }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31 {\n    \
    \    return p + 30\n    }\n    if n == 32 {\n        return p + 31\n    }\n  \
    \  if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n        return\
    \ p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n    if n == 36\
    \ {\n        return p + 35\n    }\n    if n == 37 {\n        return p + 36\n \
    \   }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp89fpol91.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp89fpol91.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp89fpol91.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmp89fpol91.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp89fpol91.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : ((n\
    \ & (p - 1)) + p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp1ooyl8qm/tmp1ooyl8qm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b020b5f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b020b2efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b020b2ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b020b2ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ooyl8qm                        0x000055c5a2d0623d <unavailable> + 4669

    5    libc.so.6                          0x00002b020b7e4460 __libc_start_main +
    245

    6    tmp1ooyl8qm                        0x000055c5a2d05e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014470
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyvwzfoo0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyvwzfoo0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp((n - 1) / p, p)\n    }\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2uirlffm.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp2uirlffm.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp2uirlffm.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp((n - 1) / p, p)\n               \
    \    ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif p == 2 {\n\t\treturn n + 1\n\t}\n\tif p == 3 {\n\t\treturn n +\
    \ 1\n\t}\n\tif p == 4 {\n\t\treturn n + 1\n\t}\n\tif p == 5 {\n\t\treturn n +\
    \ 1\n\t}\n\tif p == 6 {\n\t\treturn n + 1\n\t}\n\tif p == 7 {\n\t\treturn n +\
    \ 1\n\t}\n\tif p == 8 {\n\t\treturn n + 1\n\t}\n\tif p == 9 {\n\t\treturn n +\
    \ 1\n\t}\n\tif p == 10 {\n\t\treturn n + 1\n\t}\n\tif p == 11 {\n\t\treturn n\
    \ + 1\n\t}\n\tif p == 12 {\n\t\treturn n + 1\n\t}\n\tif p == 13 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 14 {\n\t\treturn n + 1\n\t}\n\tif p == 15 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 16 {\n\t\treturn n + 1\n\t}\n\tif p == 17 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 18 {\n\t\treturn n + 1\n\t}\n\tif p == 19 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 20 {\n\t\treturn n + 1\n\t}\n\tif p == 21 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 22 {\n\t\treturn n + 1\n\t}\n\tif p == 23 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 24 {\n\t\treturn n + 1\n\t}\n\tif p == 25 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 26 {\n\t\treturn n + 1\n\t}\n\tif p == 27 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 28 {\n\t\treturn n + 1\n\t}\n\tif p == 29 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 30 {\n\t\treturn n + 1\n\t}\n\tif p == 31 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 32 {\n\t\treturn n + 1\n\t}\n\tif p == 33 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 34 {\n\t\treturn n + 1\n\t}\n\tif p == 35 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 36 {\n\t\treturn n + 1\n\t}\n\tif p == 37 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 38 {\n\t\treturn n + 1\n\t}\n\tif p == 39 {\n\t\treturn\
    \ n + 1\n\t}\n\tif p == 40 == 1 {\n\t\treturn n + 1\n\t}\n\tif p == 40 == 2 {\n\
    \t\treturn n + 1\n\t}\n\tif p == 40 == 3 {\n\t\treturn \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqarngna3.swift:169:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpqarngna3.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpqarngna3.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpqarngna3.swift:18:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmpqarngna3.swift:140:7: error:\
    \ adjacent operators are in non-associative precedence group 'ComparisonPrecedence'\n\
    \        if p == 40 == 1 {\n             ^     ~~\n/tmp/tmpqarngna3.swift:140:13:\
    \ error: binary operator '==' cannot be applied to operands of type 'Bool' and\
    \ 'Int'\n        if p == 40 == 1 {\n           ~~~~~~~ ^  ~\n/tmp/tmpqarngna3.swift:140:13:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int, Int)\n        if p == 40 == 1 {\n                   ^\n\
    /tmp/tmpqarngna3.swift:143:7: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n        if p == 40 == 2 {\n       \
    \      ^     ~~\n/tmp/tmpqarngna3.swift:143:13: error: binary operator '==' cannot\
    \ be applied to operands of type 'Bool' and 'Int'\n        if p == 40 == 2 {\n\
    \           ~~~~~~~ ^  ~\n/tmp/tmpqarngna3.swift:143:13: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Bool, Bool), (Int, Int)\n\
    \        if p == 40 == 2 {\n                   ^\n/tmp/tmpqarngna3.swift:146:7:\
    \ error: adjacent operators are in non-associative precedence group 'ComparisonPrecedence'\n\
    \        if p == 40 == 3 {\n             ^     ~~\n/tmp/tmpqarngna3.swift:146:13:\
    \ error: binary operator '==' cannot be applied to operands of type 'Bool' and\
    \ 'Int'\n        if p == 40 == 3 {\n           ~~~~~~~ ^  ~\n/tmp/tmpqarngna3.swift:146:13:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int, Int)\n        if p == 40 == 3 {\n           "
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p-2 {\n\t\
    \treturn 2\n\t}\n\tif n == p-3 {\n\t\treturn 3\n\t}\n\tif n == p-4 {\n\t\treturn\
    \ 4\n\t}\n\tif n == p-5 {\n\t\treturn 5\n\t}\n\tif n == p-6 {\n\t\treturn 6\n\t\
    }\n\tif n == p-7 {\n\t\treturn 7\n\t}\n\tif n == p-8 {\n\t\treturn 8\n\t}\n\t\
    if n == p-9 {\n\t\treturn 9\n\t}\n\tif n == p-10 {\n\t\treturn 10\n\t}\n\tif n\
    \ == p-11 {\n\t\treturn 11\n\t}\n\tif n == p-12 {\n\t\treturn 12\n\t}\n\tif n\
    \ == p-13 {\n\t\treturn 13\n\t}\n\tif n == p-14 {\n\t\treturn 14\n\t}\n\tif n\
    \ == p-15 {\n\t\treturn 15\n\t}\n\tif n == p-16 {\n\t\treturn 16\n\t}\n\tif n\
    \ == p-17 {\n\t\treturn 17\n\t}\n\tif n == p-18 {\n\t\treturn 18\n\t}\n\tif n\
    \ == p-19 {\n\t\treturn 19\n\t}\n\tif n == p-20 {\n\t\treturn 20\n\t}\n\tif n\
    \ == p-21 {\n\t\treturn 21\n\t}\n\tif n == p-22 {\n\t\treturn 22\n\t}\n\tif n\
    \ == p-23 {\n\t\treturn 23\n\t}\n\tif n == p-24 {\n\t\treturn 24\n\t}\n\tif n\
    \ == p-25 {\n\t\treturn 25\n\t}\n\tif n == p-26 {\n\t\treturn 26\n\t}\n\tif n\
    \ == p-27 {\n\t\treturn 27\n\t}\n\tif n == p-28 {\n\t\treturn 28\n\t}\n\tif n\
    \ == p-29 {\n\t\treturn 29\n\t}\n\tif n == p-30 {\n\t\treturn 30\n\t}\n\tif n\
    \ == p-31 {\n\t\treturn 31\n\t}\n\tif n == p-32 {\n\t\treturn 32\n\t}\n\tif n\
    \ == p-33 {\n\t\treturn 33\n\t}\n\tif n == p-34 {\n\t\treturn 34\n\t}\n\tif n\
    \ == p-35 {\n\t\treturn 35\n\t}\n\tif n == p-36 {\n\t\treturn 36\n\t}\n\tif n\
    \ == p-37 {\n\t\treturn 37\n\t}\n\tif n == p-38 {\n\t\treturn 38\n\t}\n\tif n\
    \ == p-39 {\n\t\treturn 39\n\t}\n\tif n == p-40 {\n\t\treturn 40\n\t}\n\tif n\
    \ == p-41 {\n\t\treturn 41\n\t}\n\tif n == p-42 {\n\t\treturn 42\n\t}\n\tif n\
    \ == p-43 {\n\t\treturn 43\n\t}\n\tif n == p-44 {\n\t\treturn 44\n\t}\n\tif n\
    \ == p-45 {\n\t\treturn 45\n\t}\n\tif n == p-46\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcd26of84.swift:155:14: error: expected '{' after 'if' condition\n\
    \        if n == p-46\n                    ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbkmf0uyq.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpbkmf0uyq.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpbkmf0uyq.swift:18:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn n\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tdefault:\n\
    \t\treturn modp(p, n)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj9fowq5t.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj9fowq5t.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpj9fowq5t.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(p,\
    \ n)\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p ==\
    \ 0 {\n\t\treturn 0\n\t}\n\tif n < p {\n\t\treturn modp(n - 1, p) % p\n\t}\n\t\
    return modp(n, p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv2zfa8n4.swift:21:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - 1, p) % p\n                          \
    \ ^\n                            n:     p: \n/tmp/tmpv2zfa8n4.swift:23:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tlet r = p % n\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpminkqkg6.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpminkqkg6.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n"
  stdout: ''
  timestamp: 1660014469
