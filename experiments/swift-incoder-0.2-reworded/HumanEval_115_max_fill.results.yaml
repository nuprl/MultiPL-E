language: swift
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid[0].length\
    \ {\n        for j in 0..<grid.count {\n            if grid[j][i] == 0 {\n   \
    \             grid[j][i] = 1\n                \n                if capacity >\
    \ max {\n                    max = capacity\n                    maxIndex = j\n\
    \                }\n                \n                capacity -= 1\n        \
    \    }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_6ypvty2.swift:31:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity - col\n   \
    \         }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpszjd6vek/tmpszjd6vek.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e0f570c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e0f267b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e0f267988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e0f2667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszjd6vek                        0x0000562157f87717 <unavailable> + 5911

    5    libc.so.6                          0x00002b9e0f75c460 __libc_start_main +
    245

    6    tmpszjd6vek                        0x0000562157f870d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  var maxRow = row[0]\n        for col in row {\n            if col > maxRow\
    \ {\n                maxRow = col\n            }\n        }\n        if maxRow\
    \ > max {\n            max = maxRow\n        }\n        count += maxRow == 0\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplomfxyp0.swift:36:25: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n        count += maxRow == 0\n            \
    \            ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ max += 1\n                if max > capacity {\n                    max = capacity\n\
    \                    maxIndex = i\n                }\n            }\n        }\n\
    \    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpho_640nr/tmpho_640nr.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad10d606c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad10d2fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad10d2fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad10d2fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpho_640nr                        0x0000556405eb46f6 <unavailable> + 5878

    5    libc.so.6                          0x00002ad10d7f2460 __libc_start_main +
    245

    6    tmpho_640nr                        0x0000556405eb4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        if row[0] == 0\
    \ {\n            continue\n        }\n        result += 1\n        for col in\
    \ row {\n            if col == 0 {\n                continue\n            }\n\
    \            result -= capacity\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5fwu5zzs/tmp5fwu5zzs.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b85ba673c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85ba36ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b85ba36a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85ba3697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5fwu5zzs                        0x0000560112f84596 <unavailable> + 5526

    5    libc.so.6                          0x00002b85ba85f460 __libc_start_main +
    245

    6    tmp5fwu5zzs                        0x0000560112f84129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    var maxCount = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count\
    \ {\n        let bucket = grid[i]\n        \n        if bucket == capacity {\n\
    \            max += 1\n            maxCount += 1\n        }\n        \n      \
    \  if bucket > capacity {\n            max = max(max, maxCount)\n            maxCount\
    \ = 1\n            maxIndex = i\n        } else {\n            max = max(max,\
    \ maxCount)\n            maxCount = 1\n        }\n    }\n    \n    return max(max,\
    \ maxCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyh2q4f8r.swift:33:19: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n        if bucket == capacity {\n   \
    \        ~~~~~~ ^  ~~~~~~~~\n/tmp/tmpyh2q4f8r.swift:33:19: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Int, Int)\n     \
    \   if bucket == capacity {\n                  ^\n/tmp/tmpyh2q4f8r.swift:38:12:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \        if bucket > capacity {\n           ^\n/tmp/tmpyh2q4f8r.swift:39:19: error:\
    \ cannot call value of non-function type 'Int'\n            max = max(max, maxCount)\n\
    \                  ^\n/tmp/tmpyh2q4f8r.swift:43:19: error: cannot call value of\
    \ non-function type 'Int'\n            max = max(max, maxCount)\n            \
    \      ^\n/tmp/tmpyh2q4f8r.swift:48:12: error: cannot call value of non-function\
    \ type 'Int'\n    return max(max, maxCount)\n           ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 && capacity <= 10 else { return 0 }\n    \n\
    \    var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                max += 1\n        \
    \        maxCount += 1\n            }\n        }\n    }\n    \n    return maxCount\
    \ - max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfddgqs7v/tmpfddgqs7v.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acddb629c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acddb320b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acddb320988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acddb31f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfddgqs7v                        0x000055cf0903f546 <unavailable> + 5446

    5    libc.so.6                          0x00002acddb815460 __libc_start_main +
    245

    6    tmpfddgqs7v                        0x000055cf0903f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var min = 0\n    var count = 0\n    \n    for row in grid {\n     \
    \   for col in row {\n            if col == 0 {\n                count += 1\n\
    \                min = count if min == 0 else min\n                max = count\
    \ if max == capacity else max\n            }\n        }\n    }\n    \n    return\
    \ max - min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7y9q8pnv.swift:36:28: error: consecutive statements on a line must\
    \ be separated by ';'\n                min = count if min == 0 else min\n    \
    \                       ^\n                           ;\n/tmp/tmp7y9q8pnv.swift:36:41:\
    \ error: unexpected 'else' immediately following 'if' condition\n            \
    \    min = count if min == 0 else min\n                                      \
    \  ^\n/tmp/tmp7y9q8pnv.swift:36:41: note: remove 'else' to execute the braced\
    \ block of statements when the condition is true\n                min = count\
    \ if min == 0 else min\n                                        ^~~~~\n      \
    \                                  \n/tmp/tmp7y9q8pnv.swift:36:46: error: expected\
    \ '{' after 'if' condition\n                min = count if min == 0 else min\n\
    \                                             ^\n/tmp/tmp7y9q8pnv.swift:37:48:\
    \ error: unexpected 'else' immediately following 'if' condition\n            \
    \    max = count if max == capacity else max\n                               \
    \                ^\n/tmp/tmp7y9q8pnv.swift:37:48: note: remove 'else' to execute\
    \ the braced block of statements when the condition is true\n                max\
    \ = count if max == capacity else max\n                                      \
    \         ^~~~~\n                                               \n/tmp/tmp7y9q8pnv.swift:37:53:\
    \ error: expected '{' after 'if' condition\n                max = count if max\
    \ == capacity else max\n                                                    ^\n\
    /tmp/tmp7y9q8pnv.swift:24:13: error: cannot call value of non-function type 'Bool'\n\
    \    if grid.isEmpty() {\n            ^      ~~\n                   \n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var buckets = [Int](capacity)\n\
    \        for bucket in row {\n            buckets[bucket]++\n        }\n     \
    \   for bucket in buckets {\n            if bucket > 0 {\n                bucket--\n\
    \            }\n        }\n        result += buckets.count\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfwa5avio.swift:26:29: error: missing argument label 'arrayLiteral:'\
    \ in call\n        var buckets = [Int](capacity)\n                           \
    \ ^\n                            arrayLiteral: \n/tmp/tmpfwa5avio.swift:28:28:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  buckets[bucket]++\n                           ^~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for val in row {\n            max = max(max, val)\n        }\n       \
    \ if max > capacity {\n            result += capacity - max\n        } else {\n\
    \            result += max\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfnzdk3g.swift:28:19: error: cannot call value of non-function\
    \ type 'Int'\n            max = max(max, val)\n                  ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var\
    \ count = 0\n        for col in row {\n            if col == 0 {\n           \
    \     count += 1\n            }\n        }\n        \n        if count > max {\n\
    \            max = count\n            maxCount = 1\n        } else {\n       \
    \     maxCount *= count\n        }\n    }\n    \n    return maxCount * max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe9avqch3/tmpe9avqch3.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7bc0fa2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7bc0c99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7bc0c99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7bc0c987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe9avqch3                        0x000055aab9475546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7bc118e460 __libc_start_main +
    245

    6    tmpe9avqch3                        0x000055aab94750d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    var ans = 0\n    \n    for\
    \ row in 0..<n {\n        for col in 0..<n {\n            if grid[row][col] ==\
    \ 1 {\n                \n                let bucket = capacity / n\n         \
    \       \n                let lower = bucket * row\n                let upper\
    \ = bucket * (row + 1)\n                \n                let lower2 = bucket\
    \ * col\n                let upper2 = bucket * (col + 1)\n                \n \
    \               let lower3 = bucket * (row + col + 1)\n                let upper3\
    \ = bucket * (row + col + 2)\n                \n                let lower4 = bucket\
    \ * (row + col + 2)\n                let upper4 = bucket * (row + col + 3)\n \
    \               \n                let lower5 = bucket * (row + col + 3)\n    \
    \            let upper5 = bucket * (row + col + 4)\n                \n       \
    \         let lower6 = bucket * (row + col + 4)\n                let upper6 =\
    \ bucket * (row + col + 5)\n                \n                let lower7 = bucket\
    \ * (row + col + 5)\n                let upper7 = bucket * (row + col + 6)\n \
    \               \n                let lower8 = bucket * (row + col + 6)\n    \
    \            let upper8 = bucket * (row + col + 7)\n                \n       \
    \         let lower9 = bucket * (row + col + 7)\n                let upper9 =\
    \ bucket * (row + col + 8)\n                \n                let lower10 = bucket\
    \ * (row + col + 8)\n                let upper10 = bucket * (row + col + 9)\n\
    \                \n                let lower11 = bucket * (row + col + 9)\n  \
    \              let upper11 = bucket * (row + col + 10)\n                \n   \
    \             let lower12 = bucket * (row + col + 10)\n                let upper12\
    \ = bucket * (row + col + 11)\n                \n                let lower13 =\
    \ bucket * (row + col + 11)\n                let upper13 = bucket * (row + col\
    \ + 12)\n                \n                let lower14 = bucket * (row + col +\
    \ 12)\n                let upper14 = bucket * (row + col + 13)\n             \
    \   \n                let lower15 = bucket * (row + col + 13)\n              \
    \  let upper15 = bucket * (row + col + 14)\n                \n               \
    \ let lower16 = bucket * (row + col + 14)\n                let upper16 = bucket\
    \ * (row + col + 15)\n                \n                let lower17 = bucket *\
    \ (row + col + 15)\n                let upper17 = bucket * (row + col + 16)\n\
    \                \n                let lower18 = bucket * (row + col + 16)\n \
    \               let upper18 = bucket * (row + col + \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp95ui224e.swift:88:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp95ui224e.swift:107:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmp95ui224e.swift:30:26:\
    \ note: to match this opening '{'\n        for col in 0..<n {\n              \
    \           ^\n/tmp/tmp95ui224e.swift:107:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmp95ui224e.swift:29:22: note: to match this opening '{'\n    for row\
    \ in 0..<n {\n                     ^\n/tmp/tmp95ui224e.swift:107:71: error: expected\
    \ '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1,\
    \ 1]], capacity: 9) == 2)\n                                                  \
    \                    ^\n/tmp/tmp95ui224e.swift:23:52: note: to match this opening\
    \ '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n                \
    \                                   ^\n/tmp/tmp95ui224e.swift:87:40: error: cannot\
    \ convert value of type '()' to expected argument type 'Int'\n               \
    \ let upper18 = bucket * (row + col + \n                                     \
    \  ^\n/tmp/tmp95ui224e.swift:91:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    var max = 0\n    \n    for\
    \ _ in 0..<n {\n        \n        let buckets = makeBuckets(capacity)\n      \
    \  \n        for _ in 0..<n {\n            \n            let bucket = buckets[grid[Int(arc4random_uniform(UInt32(n)))][1]]\n\
    \            \n            if bucket > 0 {\n                \n               \
    \ buckets[grid[Int(arc4random_uniform(UInt32(n)))][1]] = bucket - 1\n        \
    \        \n                if bucket > max {\n                    \n         \
    \           max = bucket\n                }\n            }\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkxvy2cd9.swift:31:23: error: cannot find 'makeBuckets' in scope\n\
    \        let buckets = makeBuckets(capacity)\n                      ^~~~~~~~~~~\n\
    /tmp/tmpkxvy2cd9.swift:35:43: error: cannot find 'arc4random_uniform' in scope\n\
    \            let bucket = buckets[grid[Int(arc4random_uniform(UInt32(n)))][1]]\n\
    \                                          ^~~~~~~~~~~~~~~~~~\n/tmp/tmpkxvy2cd9.swift:39:34:\
    \ error: cannot find 'arc4random_uniform' in scope\n                buckets[grid[Int(arc4random_uniform(UInt32(n)))][1]]\
    \ = bucket - 1\n                                 ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz9gqtgk8/tmpz9gqtgk8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38be381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38be078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38be078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38be0777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9gqtgk8                        0x000056109f85a717 <unavailable> + 5911

    5    libc.so.6                          0x00002b38be56d460 __libc_start_main +
    245

    6    tmpz9gqtgk8                        0x000056109f85a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        if row.isEmpty\
    \ {\n            continue\n        }\n        \n        if row[0] > max {\n  \
    \          max = row[0]\n            maxCount = 1\n        }\n        \n     \
    \   if row[0] == max {\n            maxCount++\n        }\n    }\n    \n    return\
    \ maxCount + max_fill(grid: grid[1..<grid.count], capacity: capacity)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpl4r0g6zs.swift:42:21: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            maxCount++\n                    ^~\n/tmp/tmpl4r0g6zs.swift:46:42:\
    \ error: cannot convert value of type 'ArraySlice<[Int]>' to expected argument\
    \ type '[[Int]]'\n    return maxCount + max_fill(grid: grid[1..<grid.count], capacity:\
    \ capacity)\n                                         ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    for row in grid {\n        for col in row {\n            if col\
    \ > max {\n                max = col\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_enh0pa3/tmp_enh0pa3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b342d5c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b342d2bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b342d2bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b342d2ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_enh0pa3                        0x000055c612e98546 <unavailable> + 5446

    5    libc.so.6                          0x00002b342d7b0460 __libc_start_main +
    245

    6    tmp_enh0pa3                        0x000055c612e980d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    \n    var max = 0\n    \n    for row in 0..<rowCount {\n        for col in\
    \ 0..<colCount {\n            if grid[row][col] == 1 {\n                \n   \
    \             let bucket = grid[row][col]\n                \n                if\
    \ bucket > max {\n                    max = bucket\n                }\n      \
    \          \n                grid[row][col] = 0\n                \n          \
    \      if bucket > capacity {\n                    \n                    grid[row][col]\
    \ = 1\n                    \n                    max -= 1\n                  \
    \  \n                    if max == 0 {\n                        return 0\n   \
    \                 }\n                }\n                \n                grid[row][col]\
    \ = bucket\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpec730zse.swift:40:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmpec730zse.swift:44:30: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                    grid[row][col] = 1\n       \
    \             ~~~~     ^\n/tmp/tmpec730zse.swift:53:26: error: cannot assign through\
    \ subscript: 'grid' is a 'let' constant\n                grid[row][col] = bucket\n\
    \                ~~~~     ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    max -= 1\n        }\n    }\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max += 1\n        }\n        if row[0] == 1 {\n        \
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvd0jpa0z.swift:191:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpvd0jpa0z.swift:166:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpvd0jpa0z.swift:191:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpvd0jpa0z.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpvd0jpa0z.swift:175:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpvd0jpa0z.swift:29:9:\
    \ warning: initialization of variable 'maxCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var maxCount = 0\n    ~~~~^~~~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 || grid.count == grid[0].length else {\n\
    \        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n    \n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[0].length {\n      \
    \      if grid[i][j] == 1 {\n                grid[i][j] = 0\n                \n\
    \                if capacity > max {\n                    max = capacity\n   \
    \                 maxIndex = i\n                }\n                \n        \
    \        capacity -= 1\n            }\n        }\n    }\n    \n    return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp94qt83gl.swift:24:52: error: value of type '[Int]' has no member\
    \ 'length'\n    guard grid.count == 1 || grid.count == grid[0].length else {\n\
    \                                           ~~~~~~~ ^~~~~~\n/tmp/tmp94qt83gl.swift:32:30:\
    \ error: value of type '[Int]' has no member 'length'\n        for j in 0..<grid[0].length\
    \ {\n                     ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var maxCount = 0\n    var maxIndex = 0\n\
    \    \n    for row in grid {\n        for col in row {\n            if col > 0\
    \ {\n                maxCount = maxCount + 1\n                if maxCount > max\
    \ {\n                    max = maxCount\n                    maxIndex = col\n\
    \                }\n            }\n        }\n    }\n    \n    return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgux1met5/tmpgux1met5.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba7379fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba73496b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba73496988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba734957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgux1met5                        0x0000564819134546 <unavailable> + 5446

    5    libc.so.6                          0x00002aba7398b460 __libc_start_main +
    245

    6    tmpgux1met5                        0x00005648191340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdd1z4ljj/tmpdd1z4ljj.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8e88b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8e85b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8e85b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8e85af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdd1z4ljj                        0x0000563675b36546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae8e8aa5460 __libc_start_main +
    245

    6    tmpdd1z4ljj                        0x0000563675b360d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        if row[0] == 0 {\n\
    \            count += row[1]\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpv622l7z8/tmpv622l7z8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b650649cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6506193b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6506193988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65061927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv622l7z8                        0x00005611bdee2596 <unavailable> + 5526

    5    libc.so.6                          0x00002b6506688460 __libc_start_main +
    245

    6    tmpv622l7z8                        0x00005611bdee2129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket] += 1\n \
    \       }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n     \
    \       result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_0_go6qy.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    var index = 0\n    \n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                maxIndex\
    \ += 1\n                max = max(max, maxIndex)\n            }\n        }\n \
    \   }\n    \n    for row in grid {\n        for col in row {\n            if col\
    \ == 0 {\n                index += col\n            }\n        }\n    }\n    \n\
    \    return max - capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2tf1d6qn.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp2tf1d6qn.swift:36:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, maxIndex)\n                     \
    \ ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 || grid.count == grid[0].length else {\n\
    \        return 0\n    }\n    var max = 0\n    for row in 0..<grid.count {\n \
    \       for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp62zzbqcf.swift:24:52: error: value of type '[Int]' has no member\
    \ 'length'\n    guard grid.count == 1 || grid.count == grid[0].length else {\n\
    \                                           ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    \n    var result\
    \ = 0\n    \n    for row in grid {\n        if row[0] == 0 {\n            continue\n\
    \        }\n        \n        var count = 0\n        \n        for col in row\
    \ {\n            if col == 0 {\n                count += 1\n            } else\
    \ {\n                count += col\n            }\n        }\n        \n      \
    \  if count > capacity {\n            result = count\n            break\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp5kw75c48/tmp5kw75c48.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b8f5b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b8f2acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b8f2ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b8f2ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5kw75c48                        0x000055560014b596 <unavailable> + 5526

    5    libc.so.6                          0x00002b2b8f7a1460 __libc_start_main +
    245

    6    tmp5kw75c48                        0x000055560014b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid[0].length\
    \ {\n        for j in 0..<grid.count {\n            if grid[j][i] == 0 {\n   \
    \             grid[j][i] = 1\n                \n                if capacity >\
    \ max {\n                    max = capacity\n                    maxIndex = j\n\
    \                }\n                \n                capacity -= 1\n        \
    \    }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_6ypvty2.swift:31:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    if n < 1 {\n        return\
    \ 0\n    }\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n    \
    \    let buckets = [Int](repeating: 0, count: capacity)\n        \n        for\
    \ _ in 0..<n {\n            buckets[grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]]\
    \ += 1\n        }\n        \n        for _ in 0..<capacity {\n            max\
    \ += buckets[Int(arc4random_uniform(UInt32(capacity)))]\n        }\n    }\n  \
    \  \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_cnvyglm.swift:38:30: error: cannot find 'arc4random_uniform' in\
    \ scope\n            buckets[grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]]\
    \ += 1\n                             ^~~~~~~~~~~~~~~~~~\n/tmp/tmp_cnvyglm.swift:38:66:\
    \ error: cannot find 'arc4random_uniform' in scope\n            buckets[grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]]\
    \ += 1\n                                                                 ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_cnvyglm.swift:38:13: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n            buckets[grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]]\
    \ += 1\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_cnvyglm.swift:42:32: error: cannot find 'arc4random_uniform' in scope\n\
    \            max += buckets[Int(arc4random_uniform(UInt32(capacity)))]\n     \
    \                          ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824607
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for cell in row {\n            if cell > max {\n                max =\
    \ cell\n            }\n        }\n        result += max - capacity\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxi4p00i6/tmpxi4p00i6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d70232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d6ff29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d6ff29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d6ff287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxi4p00i6                        0x000055a60a8b7546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3d7041e460 __libc_start_main +
    245

    6    tmpxi4p00i6                        0x000055a60a8b70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for cell in row {\n            if cell > max {\n                max =\
    \ cell\n            }\n        }\n        if max > capacity {\n            result\
    \ += capacity - max\n        } else {\n            result += max\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkxglshbu/tmpkxglshbu.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fedb14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fed80bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fed80b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fed80a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkxglshbu                        0x000055caf744e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1fedd00460 __libc_start_main +
    245

    6    tmpkxglshbu                        0x000055caf744e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > max {\n                max = bucket\n           \
    \ }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphlhwupkg/tmphlhwupkg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b720dd86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b720da7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b720da7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b720da7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlhwupkg                        0x0000562c71a80546 <unavailable> + 5446

    5    libc.so.6                          0x00002b720df72460 __libc_start_main +
    245

    6    tmphlhwupkg                        0x0000562c71a800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz9gqtgk8/tmpz9gqtgk8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38be381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38be078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38be078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38be0777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9gqtgk8                        0x000056109f85a717 <unavailable> + 5911

    5    libc.so.6                          0x00002b38be56d460 __libc_start_main +
    245

    6    tmpz9gqtgk8                        0x000056109f85a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjibrhf9q/tmpjibrhf9q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaae2151c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaae1e48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaae1e48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaae1e477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjibrhf9q                        0x0000560959bb63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aaae233d460 __libc_start_main +
    245

    6    tmpjibrhf9q                        0x0000560959bb5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well > 0 {\n                result += capacity - well\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpu9k6q691/tmpu9k6q691.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af65516ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af654e61b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af654e61988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af654e607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu9k6q691                        0x000056121aa4a546 <unavailable> + 5446

    5    libc.so.6                          0x00002af655356460 __libc_start_main +
    245

    6    tmpu9k6q691                        0x000056121aa4a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    // init buckets\n    var buckets\
    \ = [Int](capacity)\n    \n    // init counters\n    var counters = [Int](capacity)\n\
    \    \n    // init max counter\n    var maxCounter = 0\n    \n    // init max\
    \ counter\n    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter\
    \ = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n    // init\
    \ max counter\n    var maxCounter = 0\n    \n    // init max counter\n    var\
    \ maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n\
    \    // init max counter\n    var maxCounter = 0\n    \n    // init max counter\n\
    \    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n\
    \    \n    // init max counter\n    var maxCounter = 0\n    \n    // init max\
    \ counter\n    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter\
    \ = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n    // init\
    \ max counter\n    var maxCounter = 0\n    \n    // init max counter\n    var\
    \ maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n\
    \    // init max counter\n    var maxCounter = 0\n    \n    // init max counter\n\
    \    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n\
    \    \n    // init max counter\n    var maxCounter = 0\n    \n    // init max\
    \ counter\n    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter\
    \ = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n    // init\
    \ max counter\n    var maxCounter = 0\n    \n    // init max counter\n    var\
    \ maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n\
    \    // init max counter\n    var maxCounter = 0\n    \n    // init max counter\n\
    \    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n\
    \    \n    // init max counter\n    var maxCounter = 0\n    \n    // init max\
    \ counter\n    var maxCounter = 0\n    \n    // init max counter\n    var maxCounter\
    \ = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n    // init\
    \ max counter\n    var maxCounter = 0\n    \n    // init max counter\n    var\
    \ maxCounter = 0\n    \n    // init max counter\n    var maxCounter = 0\n    \n\
    \    // init max counter\n    var maxCounter = 0\n    \n    // init max counter\n\
    \    var maxCounter = 0\n    \n    // init max \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj_ji59ad.swift:28:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpj_ji59ad.swift:31:26: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var counters = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpj_ji59ad.swift:37:9:\
    \ error: invalid redeclaration of 'maxCounter'\n    var maxCounter = 0\n     \
    \   ^\n/tmp/tmpj_ji59ad.swift:34:9: note: 'maxCounter' previously declared here\n\
    \    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:40:9: error: invalid\
    \ redeclaration of 'maxCounter'\n    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:34:9:\
    \ note: 'maxCounter' previously declared here\n    var maxCounter = 0\n      \
    \  ^\n/tmp/tmpj_ji59ad.swift:43:9: error: invalid redeclaration of 'maxCounter'\n\
    \    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:34:9: note: 'maxCounter'\
    \ previously declared here\n    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:46:9:\
    \ error: invalid redeclaration of 'maxCounter'\n    var maxCounter = 0\n     \
    \   ^\n/tmp/tmpj_ji59ad.swift:34:9: note: 'maxCounter' previously declared here\n\
    \    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:49:9: error: invalid\
    \ redeclaration of 'maxCounter'\n    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:34:9:\
    \ note: 'maxCounter' previously declared here\n    var maxCounter = 0\n      \
    \  ^\n/tmp/tmpj_ji59ad.swift:52:9: error: invalid redeclaration of 'maxCounter'\n\
    \    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:34:9: note: 'maxCounter'\
    \ previously declared here\n    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:55:9:\
    \ error: invalid redeclaration of 'maxCounter'\n    var maxCounter = 0\n     \
    \   ^\n/tmp/tmpj_ji59ad.swift:34:9: note: 'maxCounter' previously declared here\n\
    \    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:58:9: error: invalid\
    \ redeclaration of 'maxCounter'\n    var maxCounter = 0\n        ^\n/tmp/tmpj_ji59ad.swift:34:9:\
    \ note: 'maxCounter' previously declared here\n    var "
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    \n    var max = 0\n    \n    for row in 0..<rowCount {\n        for col in\
    \ 0..<colCount {\n            let bucket = grid[row][col]\n            if bucket\
    \ > 0 {\n                max += bucket\n                grid[row][col] = 0\n \
    \           }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3_otou93.swift:35:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        for _ in\
    \ 0..<grid.count {\n            if grid[Int(_)][Int(_)] <= 0 {\n             \
    \   grid[Int(_)][Int(_)] = capacity\n                result += capacity\n    \
    \        }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9e7jjf7d.swift:27:25: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[Int(_)][Int(_)] <= 0\
    \ {\n                        ^\n/tmp/tmp9e7jjf7d.swift:28:26: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n                grid[Int(_)][Int(_)]\
    \ = capacity\n                         ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var min = 0\n    for row in grid {\n     \
    \   var max = 0\n        for cell in row {\n            max = max(max, cell)\n\
    \        }\n        if max > min {\n            result += max - min\n        }\n\
    \        min = max\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp67ath0qv.swift:29:19: error: cannot call value of non-function\
    \ type 'Int'\n            max = max(max, cell)\n                  ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n               \
    \ grid[i][j] = capacity\n                \n                if max < capacity {\n\
    \                    max = capacity\n                    maxIndex = i\n      \
    \          }\n                \n                grid[i][j] = 0\n            }\n\
    \        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmps9y_fewr.swift:34:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = capacity\n               \
    \ ~~~~   ^\n/tmp/tmps9y_fewr.swift:41:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    var count\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                count += 1\n            } else {\n                count\
    \ = 0\n            }\n            if count > max {\n                max = count\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7wz32zb2/tmp7wz32zb2.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a61686c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a6137db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a6137d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a6137c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7wz32zb2                        0x000055f22973f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b0a61872460 __libc_start_main +
    245

    6    tmp7wz32zb2                        0x000055f22973f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    var max = 0\n\
    \    var maxIndex = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 0 {\n                grid[i][j] = capacity\n\
    \                max += capacity\n                maxIndex = i\n            }\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpc5urgg_k.swift:32:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = capacity\n               \
    \ ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // init result\n    var result = 0\n    \n    // init bucket\
    \ array\n    var buckets = make([][]int, capacity)\n    \n    // init bucket count\n\
    \    var count = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max sum\n \
    \   var bucketMaxSum = 0\n    \n    // init bucket min sum\n    var bucketMinSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min sum\n\
    \    var bucketMinSum = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init\
    \ bucket min sum\n    var bucketMinSum = 0\n    \n    // init bucket sum\n   \
    \ var bucketSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum =\
    \ 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max sum\n \
    \   var bucketMaxSum = 0\n    \n    // init bucket min sum\n    var bucketMinSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min sum\n\
    \    var bucketMinSum = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init\
    \ bucket min sum\n    var bucketMinSum = 0\n    \n    // init bucket sum\n   \
    \ var bucketSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum =\
    \ 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max sum\n \
    \   var bucketMaxSum = 0\n    \n    // init bucket min sum\n    var bucketMinSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max sum\n    var bucket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwjctu54p.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpwjctu54p.swift:29:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpwjctu54p.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpwjctu54p.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpwjctu54p.swift:56:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpwjctu54p.swift:47:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:59:9: error: invalid\
    \ redeclaration of 'bucketMaxSum'\n    var bucketMaxSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:50:9:\
    \ note: 'bucketMaxSum' previously declared here\n    var bucketMaxSum = 0\n  \
    \      ^\n/tmp/tmpwjctu54p.swift:62:9: error: invalid redeclaration of 'bucketMinSum'\n\
    \    var bucketMinSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:53:9: note: 'bucketMinSum'\
    \ previously declared here\n    var bucketMinSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:65:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpwjctu54p.swift:47:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:68:9: error: invalid\
    \ redeclaration of 'bucketMaxSum'\n    var bucketMaxSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:50:9:\
    \ note: 'bucketMaxSum' previously declared here\n    var bucketMaxSum = 0\n  \
    \      ^\n/tmp/tmpwjctu54p.swift:71:9: error: invalid redeclaration of 'bucketMinSum'\n\
    \    var bucketMinSum = 0\n        ^\n/tmp/tmpwjctu54p.swift:53:9: note: 'bucketMinSum'\
    \ previously declared here\n    var bucketMinSum = 0\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        var bucket = buckets[row[0]]\n        for _, val\
    \ := range row {\n            bucket += val\n            if bucket > capacity\
    \ {\n                bucket = bucket % capacity\n            }\n        }\n  \
    \      buckets[row[0]] = bucket\n        if bucket > 0 {\n            result +=\
    \ bucket - 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4nxn2vmj.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp4nxn2vmj.swift:28:14: error: expected 'in' after for-each\
    \ pattern\n        for _, val := range row {\n             ^\n/tmp/tmp4nxn2vmj.swift:28:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, val :=\
    \ range row {\n             ^\n/tmp/tmp4nxn2vmj.swift:25:19: error: cannot find\
    \ 'make' in scope\n    var buckets = make([][]int, capacity)\n               \
    \   ^~~~\n/tmp/tmp4nxn2vmj.swift:25:28: error: cannot find 'int' in scope\n  \
    \  var buckets = make([][]int, capacity)\n                           ^~~\n/tmp/tmp4nxn2vmj.swift:25:27:\
    \ error: missing argument for parameter #1 in call\n    var buckets = make([][]int,\
    \ capacity)\n                          ^\n                          <#Int#>\n\
    Swift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public\
    \ subscript(index: Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjibrhf9q/tmpjibrhf9q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaae2151c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaae1e48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaae1e48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaae1e477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjibrhf9q                        0x0000560959bb63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aaae233d460 __libc_start_main +
    245

    6    tmpjibrhf9q                        0x0000560959bb5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > max {\n                max = bucket\n           \
    \ }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphlhwupkg/tmphlhwupkg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b720dd86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b720da7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b720da7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b720da7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlhwupkg                        0x0000562c71a80546 <unavailable> + 5446

    5    libc.so.6                          0x00002b720df72460 __libc_start_main +
    245

    6    tmphlhwupkg                        0x0000562c71a800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  minCapacity = minCapacity - col\n            }\n        }\n    }\n    for row\
    \ in grid {\n        for col in row {\n            if col == 1 {\n           \
    \     result += minCapacity\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuna39y1g/tmpuna39y1g.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaab2144c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaab1e3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaab1e3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaab1e3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuna39y1g                        0x000055610ae0e546 <unavailable> + 5446

    5    libc.so.6                          0x00002aaab2330460 __libc_start_main +
    245

    6    tmpuna39y1g                        0x000055610ae0e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n\
    \        for col in 0..<grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                grid[row][col] = 0\n                \n                if\
    \ capacity > 0 {\n                    capacity -= 1\n                }\n     \
    \           \n                if capacity > max {\n                    max = capacity\n\
    \                    maxIndex = row\n                }\n            }\n      \
    \  }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0k_0ik20.swift:34:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmp0k_0ik20.swift:37:30: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                    capacity -= 1\n\
    \                    ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    var max = 0\n\
    \    var maxCount = 0\n    var buckets = [Int](capacity)\n    for row in grid\
    \ {\n        for bucket in row {\n            buckets[bucket] += 1 // count the\
    \ bucket in the row\n        }\n    }\n    for bucket in buckets {\n        if\
    \ bucket > max {\n            max = bucket\n            maxCount = 1\n       \
    \ } else {\n            if buckets[bucket] > maxCount {\n                max =\
    \ bucket\n                maxCount = buckets[bucket]\n            }\n        }\n\
    \    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8mqxi_he.swift:29:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n   \
    \     if row[0] == 0 {\n            continue\n        }\n        var count = 0\n\
    \        for j in 0..<row[0] {\n            if row[j] == 1 {\n               \
    \ count += 1\n            }\n        }\n        if count > max {\n           \
    \ max = count\n            maxCount = 1\n        } else {\n            maxCount\
    \ *= count\n        }\n    }\n    if maxCount > capacity {\n        return 0\n\
    \    }\n    for row in grid {\n        if row[0] == 0 {\n            continue\n\
    \        }\n        var count = 0\n        for j in 0..<row[0] {\n           \
    \ if row[j] == 1 {\n                count += 1\n            }\n        }\n   \
    \     if count > max {\n            max = count\n            maxCount = 1\n  \
    \      } else {\n            maxCount *= count\n        }\n    }\n    return maxCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4s0v2iea/tmp4s0v2iea.swift:79: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2bba38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2bb72fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2bb72f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2bb72e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4s0v2iea                        0x000055afec1a3726 <unavailable> + 5926

    5    libc.so.6                          0x00002ac2bbc24460 __libc_start_main +
    245

    6    tmp4s0v2iea                        0x000055afec1a32b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \           }\n            if count > max {\n                max = count\n   \
    \         }\n            count = 0\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3qmu72h8/tmp3qmu72h8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcd5edcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcd5bd3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcd5bd3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcd5bd27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qmu72h8                        0x000055c5958cc546 <unavailable> + 5446

    5    libc.so.6                          0x00002abcd60c8460 __libc_start_main +
    245

    6    tmp3qmu72h8                        0x000055c5958cc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket] += 1\n \
    \       }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n     \
    \       result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_0_go6qy.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        if row[0] == 0 {\n\
    \            count += row[1]\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpv622l7z8/tmpv622l7z8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b650649cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6506193b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6506193988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65061927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv622l7z8                        0x00005611bdee2596 <unavailable> + 5526

    5    libc.so.6                          0x00002b6506688460 __libc_start_main +
    245

    6    tmpv622l7z8                        0x00005611bdee2129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    \n    var maxCount = 0\n    \n    for row in 0..<rowCount {\n        for\
    \ col in 0..<colCount {\n            if grid[row][col] == 1 {\n              \
    \  maxCount = max(maxCount, max_fill(grid: grid[row..<min(row+capacity, rowCount),\
    \ col..<colCount], capacity: capacity))\n            }\n        }\n    }\n   \
    \ \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq3tzxifh.swift:33:61: error: cannot convert value of type 'ArraySlice<[Int]>'\
    \ to expected argument type '[[Int]]'\n                maxCount = max(maxCount,\
    \ max_fill(grid: grid[row..<min(row+capacity, rowCount), col..<colCount], capacity:\
    \ capacity))\n                                                            ^\n\
    /tmp/tmpq3tzxifh.swift:33:100: error: extra argument in call\n               \
    \ maxCount = max(maxCount, max_fill(grid: grid[row..<min(row+capacity, rowCount),\
    \ col..<colCount], capacity: capacity))\n                                    \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in bucket {\n            buckets[bucket]++\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n    \
    \        result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgfkgjrpw.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpgfkgjrpw.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpgfkgjrpw.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpgfkgjrpw.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpgfkgjrpw.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid[0].length\
    \ {\n        for j in 0..<grid.count {\n            if grid[j][i] == 1 {\n   \
    \             grid[j][i] = 0\n                \n                if capacity >\
    \ max {\n                    max = capacity\n                    maxIndex = j\n\
    \                }\n                \n                capacity -= 1\n        \
    \    }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2ic4oy7h.swift:31:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var count = 0\n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0i8cp48t/tmp0i8cp48t.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e0a7bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e0a4b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e0a4b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e0a4b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0i8cp48t                        0x0000557fbe907717 <unavailable> + 5911

    5    libc.so.6                          0x00002b2e0a9ab460 __libc_start_main +
    245

    6    tmp0i8cp48t                        0x0000557fbe9070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count\
    \ {\n        var count = 0\n        for j in 0..<grid[i].count {\n           \
    \ if grid[i][j] == 1 {\n                count += 1\n            }\n        }\n\
    \        if count > max {\n            max = count\n            maxCount = 1\n\
    \            maxIndex = i\n        } else {\n            if count == max {\n \
    \               maxCount += 1\n            }\n        }\n    }\n    \n    if maxCount\
    \ > capacity {\n        return 0\n    }\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            grid[i][j] = 0\n                grid[maxIndex][j] = 1\n         \
    \       \n                let newMax = max_fill(grid: grid, capacity: capacity)\n\
    \                \n                if newMax > 0 {\n                    grid[i][j]\
    \ = 1\n                    grid[maxIndex][j] = 0\n                    \n     \
    \               max = newMax\n                    maxCount = 1\n             \
    \       maxIndex = i\n                }\n            }\n        }\n    }\n   \
    \ \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3863tgxm.swift:57:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n/tmp/tmp3863tgxm.swift:58:31: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[maxIndex][j] = 1\n               \
    \ ~~~~          ^\n/tmp/tmp3863tgxm.swift:63:28: error: cannot assign through\
    \ subscript: 'grid' is a 'let' constant\n                    grid[i][j] = 1\n\
    \                    ~~~~   ^\n/tmp/tmp3863tgxm.swift:64:35: error: cannot assign\
    \ through subscript: 'grid' is a 'let' constant\n                    grid[maxIndex][j]\
    \ = 0\n                    ~~~~          ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        if row[0] == 0\
    \ {\n            result += 1\n        }\n    }\n    for row in grid {\n      \
    \  if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for row\
    \ in grid {\n        if row[0] == 0 {\n            result += row[1]\n        }\n\
    \    }\n    for row in grid {\n        if row[0] == 0 {\n            result +=\
    \ row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n    \
    \    }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n    \
    \    }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n    \
    \    }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n    \
    \    }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n    \
    \    }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += row[1]\n        }\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            result += row[1]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            result += row[1]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpz6ulskdb.swift:178:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpz6ulskdb.swift:155:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpz6ulskdb.swift:178:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpz6ulskdb.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpz6ulskdb.swift:162:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in row {\n            buckets[bucket] = append(buckets[bucket],\
    \ 0)\n        }\n    }\n    for bucket in buckets {\n        max = max(max, bucket.count)\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1fw31u2k.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp1fw31u2k.swift:29:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp1fw31u2k.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp1fw31u2k.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp1fw31u2k.swift:32:31:\
    \ error: cannot find 'append' in scope\n            buckets[bucket] = append(buckets[bucket],\
    \ 0)\n                              ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else {\n        return 0\n    }\n    \n \
    \   var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n \
    \       for j in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n     \
    \           grid[i][j] = capacity\n                max += capacity\n         \
    \       maxIndex = i\n            }\n        }\n    }\n    \n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == capacity\
    \ {\n                grid[i][j] = 0\n                max -= 1\n              \
    \  maxIndex = i\n            }\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1sc4rosq.swift:34:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = capacity\n               \
    \ ~~~~   ^\n/tmp/tmp1sc4rosq.swift:44:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjibrhf9q/tmpjibrhf9q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaae2151c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaae1e48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaae1e48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaae1e477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjibrhf9q                        0x0000560959bb63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aaae233d460 __libc_start_main +
    245

    6    tmpjibrhf9q                        0x0000560959bb5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        var bucket = 0\n        for _ in row {\n            bucket\
    \ += buckets[bucket]\n        }\n        buckets[bucket]--\n        result +=\
    \ bucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppx5f67v3.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmppx5f67v3.swift:31:24: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n        buckets[bucket]--\n\
    \                       ^~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for _ in row {\n            max += capacity\n        }\n        for _ in\
    \ row {\n            max -= capacity\n        }\n        if max > 0 {\n      \
    \      count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp378_vjmv/tmp378_vjmv.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d0572ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d05421b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d05421988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d054207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp378_vjmv                        0x000055ab2e784546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5d05916460 __libc_start_main +
    245

    6    tmp378_vjmv                        0x000055ab2e7840d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var maxIndex = 0\n    var index = 0\n    var buckets = make([][]int, capacity)\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                buckets[index%capacity] = append(buckets[index%capacity], 0)\n\
    \                index++\n            }\n        }\n    }\n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                for\
    \ bucket in buckets {\n                    bucket[bucket.index(col)] = -1\n  \
    \              }\n            }\n        }\n    }\n    for bucket in buckets {\n\
    \        if bucket.max() > max {\n            max = bucket.max()\n           \
    \ maxIndex = index\n        }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5cqxxag4.swift:30:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp5cqxxag4.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp5cqxxag4.swift:30:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp5cqxxag4.swift:30:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp5cqxxag4.swift:30:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp5cqxxag4.swift:34:43:\
    \ error: cannot find 'append' in scope\n                buckets[index%capacity]\
    \ = append(buckets[index%capacity], 0)\n                                     \
    \     ^~~~~~\n/tmp/tmp5cqxxag4.swift:35:22: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                index++\n                     ^~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        var bucket = buckets[row[0]]\n        for _, v in\
    \ row.enumerated() {\n            if v == 1 {\n                bucket += 1\n \
    \           }\n        }\n        if bucket > capacity {\n            result =\
    \ 1\n            break\n        }\n        buckets[row[0]] = bucket\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpztoqzogi.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpztoqzogi.swift:28:14: error: expected 'in' after for-each\
    \ pattern\n        for _, v in row.enumerated() {\n             ^\n/tmp/tmpztoqzogi.swift:28:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, v in row.enumerated()\
    \ {\n             ^\n/tmp/tmpztoqzogi.swift:25:19: error: cannot find 'make' in\
    \ scope\n    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpztoqzogi.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpztoqzogi.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var min = 0\n    var i = 0\n    var j = 0\n    var count = 0\n    \n\
    \    for row in grid {\n        i += 1\n        \n        if i == 1 {\n      \
    \      min = row[0]\n        }\n        \n        for col in row {\n         \
    \   j += 1\n            \n            if j == 1 {\n                max = col\n\
    \            }\n            \n            if col == 0 {\n                count\
    \ += capacity - max - min\n                max = 0\n                min = 0\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgkoolq34/tmpgkoolq34.swift:73: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9298e3cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9298b33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9298b33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9298b327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgkoolq34                        0x000055aefab0d7b7 <unavailable> + 6071

    5    libc.so.6                          0x00002b9299028460 __libc_start_main +
    245

    6    tmpgkoolq34                        0x000055aefab0d179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    for row in grid {\n        for col in row {\n            if col\
    \ > max {\n                max = col\n            }\n        }\n    }\n    for\
    \ row in grid {\n        for col in row {\n            if col > max {\n      \
    \          max = col\n            }\n        }\n    }\n    for row in grid {\n\
    \        for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n    }\n    for row in grid {\n        for col in row\
    \ {\n            if col > max {\n                max = col\n            }\n  \
    \      }\n    }\n    for row in grid {\n        for col in row {\n           \
    \ if col > max {\n                max = col\n            }\n        }\n    }\n\
    \    for row in grid {\n        for col in row {\n            if col > max {\n\
    \                max = col\n            }\n        }\n    }\n    for row in grid\
    \ {\n        for col in row {\n            if col > max {\n                max\
    \ = col\n            }\n        }\n    }\n    for row in grid {\n        for col\
    \ in row {\n            if col > max {\n                max = col\n          \
    \  }\n        }\n    }\n    for row in grid {\n        for col in row {\n    \
    \        if col > max {\n                max = col\n            }\n        }\n\
    \    }\n    for row in grid {\n        for col in row {\n            if col >\
    \ max {\n                max = col\n            }\n        }\n    }\n    for row\
    \ in grid {\n        for col in row {\n            if col > max {\n          \
    \      max = col\n            }\n        }\n    }\n    for row in grid {\n   \
    \     for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n    }\n    for row in grid {\n        for col in row\
    \ {\n            if col > max {\n                max = col\n            }\n  \
    \      }\n    }\n    for row in grid {\n        for col in row {\n           \
    \ if col > max {\n                max = col\n            }\n        }\n    }\n\
    \    for row in grid {\n        for col in row {\n            if col > max {\n\
    \                max = col\n            }\n        }\n    }\n    for row in grid\
    \ {\n        for col in row {\n            if col > max {\n                max\
    \ = col\n            }\n        }\n    }\n    for row in grid {\n        for col\
    \ in row {\n            if col > max {\n                max = col\n          \
    \  }\n        }\n    }\n    for row in grid {\n        for col in row {\n    \
    \        if col > max {\n                max = col\n            }\n        }\n\
    \    }\n    for row in grid {\n        for col in row {\n            if col >\
    \ max \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbnhv2ndp.swift:160:25: error: expected '{' after 'if' condition\n\
    \            if col > max \n                        ^\n/tmp/tmpbnhv2ndp.swift:180:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpbnhv2ndp.swift:158:21: note:\
    \ to match this opening '{'\n    for row in grid {\n                    ^\n/tmp/tmpbnhv2ndp.swift:180:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpbnhv2ndp.swift:23:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmpbnhv2ndp.swift:164:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in row {\n            buckets[bucket] = buckets[bucket] + 1\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > max {\n  \
    \          max = bucket\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjqqrlhz4.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpjqqrlhz4.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpjqqrlhz4.swift:29:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpjqqrlhz4.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpjqqrlhz4.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for _ in row {\n            max += capacity\n        }\n        if max\
    \ > result {\n            result = max\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf7lkl8l7/tmpf7lkl8l7.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af9a3f13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9a3c0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9a3c0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9a3c097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf7lkl8l7                        0x000055f0b3ab7546 <unavailable> + 5446

    5    libc.so.6                          0x00002af9a40ff460 __libc_start_main +
    245

    6    tmpf7lkl8l7                        0x000055f0b3ab70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  count += 1\n                if count > minCapacity {\n                    minCapacity\
    \ = count\n                }\n            }\n        }\n    }\n    return minCapacity\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp33ir3t_q/tmp33ir3t_q.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac87ddf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac87dae9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac87dae9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac87dae87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp33ir3t_q                        0x000055fbc913c717 <unavailable> + 5911

    5    libc.so.6                          0x00002ac87dfde460 __libc_start_main +
    245

    6    tmp33ir3t_q                        0x000055fbc913c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col > max {\n                max = col\n                maxIndex\
    \ = col\n            }\n        }\n    }\n    \n    for row in grid {\n      \
    \  for col in row {\n            if col == maxIndex {\n                col -=\
    \ capacity\n            }\n        }\n    }\n    \n    return maxIndex\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy6isrlzd.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpy6isrlzd.swift:43:21: error: left side of mutating operator isn't\
    \ mutable: 'col' is a 'let' constant\n                col -= capacity\n      \
    \          ~~~ ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    var bucket = make([][Int], capacity)\n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     bucket[index] = col\n                index++\n            }\n        }\n\
    \    }\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                max += bucket[col]\n            }\n        }\n    }\n \
    \   return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfdflpagw.swift:30:18: error: cannot find 'make' in scope\n    var\
    \ bucket = make([][Int], capacity)\n                 ^~~~\n/tmp/tmpfdflpagw.swift:30:25:\
    \ error: no exact matches in call to subscript \n    var bucket = make([][Int],\
    \ capacity)\n                        ^\n/tmp/tmpfdflpagw.swift:30:25: note: found\
    \ candidate with type '(Int) -> Any'\n    var bucket = make([][Int], capacity)\n\
    \                        ^\n/tmp/tmpfdflpagw.swift:30:25: note: found candidate\
    \ with type '(Range<Int>) -> ArraySlice<Any>'\n    var bucket = make([][Int],\
    \ capacity)\n                        ^\n/tmp/tmpfdflpagw.swift:30:25: note: found\
    \ candidate with type '(Int.Type) -> ArraySlice<Any>'\n    var bucket = make([][Int],\
    \ capacity)\n                        ^\n/tmp/tmpfdflpagw.swift:30:25: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Any>'\n    var\
    \ bucket = make([][Int], capacity)\n                        ^\n/tmp/tmpfdflpagw.swift:35:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      index++\n                     ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity\n         \
    \   } else {\n                result -= capacity\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppxum82dj/tmppxum82dj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accd2a0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accd2703b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accd2703988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accd27027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppxum82dj                        0x00005606b6b87546 <unavailable> + 5446

    5    libc.so.6                          0x00002accd2bf8460 __libc_start_main +
    245

    6    tmppxum82dj                        0x00005606b6b870d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var count = 0\n    \n    var max = 0\n    \n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                max += 1\n            }\n        }\n    }\n    \n    if\
    \ max > capacity {\n        return 0\n    }\n    \n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                grid[row][col] = 0\n                count += max_fill(grid:\
    \ grid, capacity: capacity)\n                grid[row][col] = 1\n            }\n\
    \        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppe591d13.swift:47:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmppe591d13.swift:49:26: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[row][col] = 1\n           \
    \     ~~~~     ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var i = 0\n    var j = 0\n    for row in grid\
    \ {\n        i += 1\n        for col in row {\n            j += 1\n          \
    \  if col == 0 {\n                max += capacity - j\n            }\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpa3pnmlh8/tmpa3pnmlh8.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad40dfdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad40dcd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad40dcd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad40dcd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3pnmlh8                        0x000055a874ddf546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad40e1c6460 __libc_start_main +
    245

    6    tmpa3pnmlh8                        0x000055a874ddf0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var buckets = [Int](capacity)\n\
    \        for row in row {\n            buckets[row]++\n        }\n        buckets.sort()\n\
    \        for bucket in buckets {\n            if bucket > 0 {\n              \
    \  bucket--\n                result += bucket\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk88uawr_.swift:26:29: error: missing argument label 'arrayLiteral:'\
    \ in call\n        var buckets = [Int](capacity)\n                           \
    \ ^\n                            arrayLiteral: \n/tmp/tmpk88uawr_.swift:28:25:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  buckets[row]++\n                        ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var index = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for col in row {\n            buckets[col%capacity]\
    \ = append(buckets[col%capacity], index)\n        }\n        index++\n    }\n\
    \    for bucket in buckets {\n        max = max(max, bucket.count)\n    }\n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3eitr1c0.swift:26:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp3eitr1c0.swift:26:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp3eitr1c0.swift:26:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp3eitr1c0.swift:26:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp3eitr1c0.swift:29:37:\
    \ error: cannot find 'append' in scope\n            buckets[col%capacity] = append(buckets[col%capacity],\
    \ index)\n                                    ^~~~~~\n/tmp/tmp3eitr1c0.swift:31:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n        result += max - capacity\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpcovqd68c/tmpcovqd68c.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06cad4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06c7cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06c7cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06c7ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcovqd68c                        0x00005584fd989546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae06ccc0460 __libc_start_main +
    245

    6    tmpcovqd68c                        0x00005584fd9890d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4aiqm4ci/tmp4aiqm4ci.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcbf427c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcbf11eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcbf11e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcbf11d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4aiqm4ci                        0x000056430bb13546 <unavailable> + 5446

    5    libc.so.6                          0x00002abcbf613460 __libc_start_main +
    245

    6    tmp4aiqm4ci                        0x000056430bb130d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         max += capacity\n                maxCount++\n            }\n       \
    \ }\n    }\n    \n    return maxCount > max ? maxCount : max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpiirh88_0.swift:35:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                maxCount++\n                        ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += min_fill(grid: grid, row:\
    \ row, col: col, capacity: capacity)\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptedpbybi.swift:28:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: grid, row: row, col: col, capacity: capacity)\n\
    \                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    var count = 0\n    \n\
    \    for row in grid {\n        if row[0] == 0 {\n            count += row[1]\n\
    \        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp0cq95xbn/tmp0cq95xbn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c135b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c132acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c132ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c132ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0cq95xbn                        0x000056152788a596 <unavailable> + 5526

    5    libc.so.6                          0x00002b4c137a1460 __libc_start_main +
    245

    6    tmp0cq95xbn                        0x000056152788a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += capacity\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpes8vn96h/tmpes8vn96h.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86847f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86844e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86844e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86844e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes8vn96h                        0x00005575e60fe717 <unavailable> + 5911

    5    libc.so.6                          0x00002b86849dd460 __libc_start_main +
    245

    6    tmpes8vn96h                        0x00005575e60fe0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in bucket {\n            if bucket >\
    \ 0 {\n                buckets[bucket-1][bucket-1]++\n            }\n        }\n\
    \    }\n    for bucket in buckets {\n        result += bucket.max()\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqw8dlxxw.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpqw8dlxxw.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpqw8dlxxw.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpqw8dlxxw.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpqw8dlxxw.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n            } else {\n                count = 0\n            }\n     \
    \       if count > max {\n                max = count\n            }\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprrrlvdwe/tmprrrlvdwe.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade645a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade6429bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade6429b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade6429a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprrrlvdwe                        0x000055bd23aa6546 <unavailable> + 5446

    5    libc.so.6                          0x00002ade64790460 __libc_start_main +
    245

    6    tmprrrlvdwe                        0x000055bd23aa60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxCount = 0\n    var min = 0\n    var\
    \ minCount = 0\n    \n    for row in 0..<grid.length {\n        for col in 0..<grid[row].length\
    \ {\n            if grid[row][col] == 1 {\n                \n                if\
    \ capacity > max {\n                    max = capacity\n                    maxCount\
    \ = 1\n                }\n                \n                if capacity < min\
    \ {\n                    min = capacity\n                    minCount = 1\n  \
    \              }\n                \n                if capacity == max {\n   \
    \                 maxCount++\n                }\n                \n          \
    \      if capacity == min {\n                    minCount++\n                }\n\
    \                \n                if maxCount > minCount {\n                \
    \    maxCount--\n                    minCount--\n                }\n         \
    \       \n                if maxCount > minCount {\n                    maxCount--\n\
    \                    minCount--\n                }\n                \n       \
    \         if maxCount > minCount {\n                    maxCount--\n         \
    \           minCount--\n                }\n                \n                if\
    \ maxCount > minCount {\n                    maxCount--\n                    minCount--\n\
    \                }\n                \n                if maxCount > minCount {\n\
    \                    maxCount--\n                    minCount--\n            \
    \    }\n                \n                if maxCount > minCount {\n         \
    \           maxCount--\n                    minCount--\n                }\n  \
    \              \n                if maxCount > minCount {\n                  \
    \  maxCount--\n                    minCount--\n                }\n           \
    \     \n                if maxCount > minCount {\n                    maxCount--\n\
    \                    minCount--\n                }\n                \n       \
    \         if maxCount > minCount {\n                    maxCount--\n         \
    \           minCount--\n                }\n                \n                if\
    \ maxCount > minCount {\n                    maxCount--\n                    minCount--\n\
    \                }\n                \n                if maxCount > minCount {\n\
    \                    maxCount--\n                    minCount--\n            \
    \    }\n                \n                if maxCount > minCount {\n         \
    \           maxCount--\n                    minCount--\n                }\n  \
    \              \n                if maxCount > minCount {\n                  \
    \  maxCount--\n                    minCount--\n                }\n           \
    \     \n                if maxCount > minCount {\n                    maxCount--\n\
    \                    minCount--\n                }\n                \n       \
    \         if maxCount > minCount {\n                    maxCount--\n         \
    \           minCount--\n                }\n                \n                if\
    \ maxCount > minCount {\n                    maxCount--\n                    minCount--\n\
    \                }\n                \n                if maxCount > minCount {\n\
    \                    maxCount--\n                    minCount--\n            \
    \    }\n                \n                if maxCount \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd12puz3y.swift:140:28: error: expected '{' after 'if' condition\n\
    \                if maxCount \n                           ^\n/tmp/tmpd12puz3y.swift:160:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpd12puz3y.swift:34:41: note: to\
    \ match this opening '{'\n        for col in 0..<grid[row].length {\n        \
    \                                ^\n/tmp/tmpd12puz3y.swift:160:71: error: expected\
    \ '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1,\
    \ 1]], capacity: 9) == 2)\n                                                  \
    \                    ^\n/tmp/tmpd12puz3y.swift:33:32: note: to match this opening\
    \ '{'\n    for row in 0..<grid.length {\n                               ^\n/tmp/tmpd12puz3y.swift:160:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpd12puz3y.swift:23:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmpd12puz3y.swift:24:13:\
    \ error: value of type '[[Int]]' has no member 'length'\n    if grid.length ==\
    \ 0 || grid[0].length == 0 {\n       ~~~~ ^~~~~~\n/tmp/tmpd12puz3y.swift:24:36:\
    \ error: value of type '[Int]' has no member 'length'\n    if grid.length == 0\
    \ || grid[0].length == 0 {\n                           ~~~~~~~ ^~~~~~\n/tmp/tmpd12puz3y.swift:33:25:\
    \ error: value of type '[[Int]]' has no member 'length'\n    for row in 0..<grid.length\
    \ {\n                   ~~~~ ^~~~~~\n/tmp/tmpd12puz3y.swift:34:34: error: reference\
    \ to member 'length' cannot be resolved without a contextual type\n        for\
    \ col in 0..<grid[row].length {\n                                 ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > max {\n\
    \                max = count\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpoaiz2n6l.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    var maxCount = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                \n                if capacity\
    \ > max {\n                    max = capacity\n                    maxCount =\
    \ 1\n                    maxIndex = i\n                } else {\n            \
    \        maxCount += 1\n                }\n            }\n        }\n    }\n \
    \   \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfw49jqq_.swift:33:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    var max = 0\n    var maxCount = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for col in row {\n            buckets[col%capacity]\
    \ = append(buckets[col%capacity], 0)\n        }\n    }\n    for row in grid {\n\
    \        for col in row {\n            buckets[col%capacity][row%capacity] = -1\n\
    \        }\n    }\n    for row in grid {\n        for col in row {\n         \
    \   if buckets[col%capacity][row%capacity] == -1 {\n                buckets[col%capacity][row%capacity]\
    \ = col\n                maxCount++\n            }\n        }\n    }\n    for\
    \ bucket in buckets {\n        if bucket[0] > max {\n            max = bucket[0]\n\
    \        }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8vc91xmf.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp8vc91xmf.swift:24:13: error: value of type '[[Int]]' has\
    \ no member 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n     \
    \  ~~~~ ^~~~~~\n/tmp/tmp8vc91xmf.swift:24:36: error: value of type '[Int]' has\
    \ no member 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n     \
    \                      ~~~~~~~ ^~~~~~\n/tmp/tmp8vc91xmf.swift:29:19: error: cannot\
    \ find 'make' in scope\n    var buckets = make([][]int, capacity)\n          \
    \        ^~~~\n/tmp/tmp8vc91xmf.swift:29:28: error: cannot find 'int' in scope\n\
    \    var buckets = make([][]int, capacity)\n                           ^~~\n/tmp/tmp8vc91xmf.swift:29:27:\
    \ error: missing argument for parameter #1 in call\n    var buckets = make([][]int,\
    \ capacity)\n                          ^\n                          <#Int#>\n\
    Swift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public\
    \ subscript(index: Int) -> Element { get set }\n                      ^\n/tmp/tmp8vc91xmf.swift:32:37:\
    \ error: cannot find 'append' in scope\n            buckets[col%capacity] = append(buckets[col%capacity],\
    \ 0)\n                                    ^~~~~~\n/tmp/tmp8vc91xmf.swift:37:35:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \            buckets[col%capacity][row%capacity] = -1\n                      \
    \            ^\n/tmp/tmp8vc91xmf.swift:42:38: error: cannot convert value of type\
    \ '[Int]' to expected argument type 'Int'\n            if buckets[col%capacity][row%capacity]\
    \ == -1 {\n                                     ^\n/tmp/tmp8vc91xmf.swift:43:39:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \                buckets[col%capacity][row%capacity] = col\n                 \
    \                     ^\n/tmp/tmp8vc91xmf.swift:44:25: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                maxCount++\n          \
    \              ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.length\
    \ {\n        for col in 0..<grid[row].length {\n            if grid[row][col]\
    \ == 1 {\n                max += capacity\n                maxCount++\n      \
    \      }\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6w_9nt1l.swift:24:13: error: value of type '[[Int]]' has no member\
    \ 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n       ~~~~ ^~~~~~\n\
    /tmp/tmp6w_9nt1l.swift:24:36: error: value of type '[Int]' has no member 'length'\n\
    \    if grid.length == 0 || grid[0].length == 0 {\n                          \
    \ ~~~~~~~ ^~~~~~\n/tmp/tmp6w_9nt1l.swift:31:25: error: value of type '[[Int]]'\
    \ has no member 'length'\n    for row in 0..<grid.length {\n                 \
    \  ~~~~ ^~~~~~\n/tmp/tmp6w_9nt1l.swift:32:34: error: reference to member 'length'\
    \ cannot be resolved without a contextual type\n        for col in 0..<grid[row].length\
    \ {\n                                 ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjibrhf9q/tmpjibrhf9q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaae2151c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaae1e48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaae1e48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaae1e477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjibrhf9q                        0x0000560959bb63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aaae233d460 __libc_start_main +
    245

    6    tmpjibrhf9q                        0x0000560959bb5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var buckets = make([][]int, capacity)\n    for\
    \ row in grid {\n        for bucket in bucket {\n            if bucket > 0 {\n\
    \                buckets[bucket-1][bucket-1]++\n            }\n        }\n   \
    \ }\n    for bucket in buckets {\n        if bucket > 0 {\n            max = max(max,\
    \ buckets[bucket-1][bucket-1])\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpek9rureu.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpek9rureu.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpek9rureu.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpek9rureu.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpek9rureu.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 0 {\n       \
    \         grid[row][col] = capacity\n                \n                if capacity\
    \ > max {\n                    max = capacity\n                    maxIndex =\
    \ row\n                }\n                \n                capacity -= 1\n  \
    \          }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqc2ujnxs.swift:34:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = capacity\n           \
    \     ~~~~     ^\n/tmp/tmpqc2ujnxs.swift:41:26: error: left side of mutating operator\
    \ isn't mutable: 'capacity' is a 'let' constant\n                capacity -= 1\n\
    \                ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ grid[i][j] = 0\n                \n                if capacity > max {\n    \
    \                max = capacity\n                    maxIndex = i\n          \
    \      }\n                \n                capacity -= 1\n            }\n   \
    \     }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgj3ua4si.swift:34:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n/tmp/tmpgj3ua4si.swift:41:26: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                capacity -= 1\n   \
    \             ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: Write your code here\n    \n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkvcbluf9/tmpkvcbluf9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae905a13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae90570ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae90570a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9057097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvcbluf9                        0x0000555bdb3983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ae905bff460 __libc_start_main +
    245

    6    tmpkvcbluf9                        0x0000555bdb397f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var maxIndex = 0\n    for row in grid {\n        if row[0] == 0 {\n     \
    \       continue\n        }\n        for col in row {\n            if col == 0\
    \ {\n                continue\n            }\n            if col > max {\n   \
    \             max = col\n                maxIndex = col\n            }\n     \
    \   }\n    }\n    for row in grid {\n        if row[0] == 0 {\n            continue\n\
    \        }\n        for col in row {\n            if col == 0 {\n            \
    \    continue\n            }\n            if col > max {\n                max\
    \ = col\n                maxIndex = col\n            }\n        }\n    }\n   \
    \ return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwkx6rn2h.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    var maxCountIndex = 0\n    \n    for\
    \ i in 0..<grid.count {\n        var count = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \  }\n        }\n        if count > max {\n            max = count\n         \
    \   maxCountIndex = i\n        }\n    }\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            grid[i][j] = 0\n            }\n        }\n    }\n    \n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 0 {\n                grid[i][j] = 1\n            }\n        }\n    }\n  \
    \  \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n   \
    \         if grid[i][j] == 1 {\n                grid[i][j] = 0\n            }\n\
    \        }\n    }\n    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 0 {\n                grid[i][j] = 1\n      \
    \      }\n        }\n    }\n    \n    for i in 0..<grid.count {\n        for j\
    \ in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                grid[i][j]\
    \ = 0\n            }\n        }\n    }\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n    \
    \            grid[i][j] = 1\n            }\n        }\n    }\n    \n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                grid[i][j] = 0\n            }\n        }\n    }\n  \
    \  \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n   \
    \         if grid[i][j] == 0 {\n                grid[i][j] = 1\n            }\n\
    \        }\n    }\n    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \      }\n        }\n    }\n    \n    for i in 0..<grid.count {\n        for j\
    \ in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n                grid[i][j]\
    \ = 1\n            }\n        }\n    }\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            grid[i][j] = 0\n            }\n        }\n    }\n    \n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfhgyti35.swift:135:15: error: expected expression, var, or let\
    \ in 'if' condition\n            if \n              ^\n/tmp/tmpfhgyti35.swift:155:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpfhgyti35.swift:133:29: note:\
    \ to match this opening '{'\n    for i in 0..<grid.count {\n                 \
    \           ^\n/tmp/tmpfhgyti35.swift:155:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmpfhgyti35.swift:23:52: note: to match this opening '{'\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n                                         \
    \          ^\n/tmp/tmpfhgyti35.swift:48:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:56:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 1\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:64:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:72:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 1\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:80:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:88:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 1\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:96:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n/tmp/tmpfhgyti35.swift:104:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] "
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        var count = 0\n    \
    \    for index in 0..<row[0] {\n            if row[index] == 1 {\n           \
    \     count += 1\n            }\n        }\n        \n        if count > max {\n\
    \            max = count\n            maxIndex = row[0]\n        }\n    }\n  \
    \  \n    for index in 0..<capacity {\n        if grid[maxIndex][index] == 1 {\n\
    \            grid[maxIndex][index] = 0\n            max -= 1\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpks9p_vve.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpks9p_vve.swift:51:27: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n            grid[maxIndex][index] = 0\n        \
    \    ~~~~          ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    var count = 0\n    \n\
    \    for row in grid {\n        if row[0] == 0 {\n            count += row[1]\n\
    \        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp0cq95xbn/tmp0cq95xbn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c135b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c132acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c132ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c132ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0cq95xbn                        0x000056152788a596 <unavailable> + 5526

    5    libc.so.6                          0x00002b4c137a1460 __libc_start_main +
    245

    6    tmp0cq95xbn                        0x000056152788a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                count += capacity - bucket\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpcp4dh3mp/tmpcp4dh3mp.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cbc875c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cbc56cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cbc56c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cbc56b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcp4dh3mp                        0x000055904a7ed546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3cbca61460 __libc_start_main +
    245

    6    tmpcp4dh3mp                        0x000055904a7ed0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    for row in grid {\n        for col in row {\n            if col\
    \ > max {\n                max = col\n            }\n        }\n    }\n    for\
    \ row in grid {\n        for col in row {\n            if col > max {\n      \
    \          max = col\n            }\n        }\n    }\n    for row in grid {\n\
    \        for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n    }\n    for row in grid {\n        for col in row\
    \ {\n            if col > max {\n                max = col\n            }\n  \
    \      }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7kqg9m3r/tmp7kqg9m3r.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab702c81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab702978b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab702978988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7029777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7kqg9m3r                        0x000055f4c2277546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab702e6d460 __libc_start_main +
    245

    6    tmp7kqg9m3r                        0x000055f4c22770d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n                if count > max {\n                    max = count\n  \
    \              }\n            }\n        }\n    }\n    \n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpguyes_6u/tmpguyes_6u.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af84e9f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af84e6eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af84e6ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af84e6ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpguyes_6u                        0x0000562463783717 <unavailable> + 5911

    5    libc.so.6                          0x00002af84ebe3460 __libc_start_main +
    245

    6    tmpguyes_6u                        0x00005624637830d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in grid {\n        if\
    \ row[0] == 0 {\n            result += row[1]\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2w1qqwtb/tmp2w1qqwtb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fd5ffdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fd5cf4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fd5cf4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fd5cf37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2w1qqwtb                        0x0000559e33eb3596 <unavailable> + 5526

    5    libc.so.6                          0x00002b0fd61e9460 __libc_start_main +
    245

    6    tmp2w1qqwtb                        0x0000559e33eb3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: Write your code here\n    \n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkvcbluf9/tmpkvcbluf9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae905a13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae90570ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae90570a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9057097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvcbluf9                        0x0000555bdb3983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ae905bff460 __libc_start_main +
    245

    6    tmpkvcbluf9                        0x0000555bdb397f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  if row[0] == 0 {\n            count += row[1]\n        }\n        if row[0]\
    \ == 1 {\n            count -= row[1]\n        }\n        if count > capacity\
    \ {\n            max = count\n            count = 0\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe1g0j1ks/tmpe1g0j1ks.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69b3797c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69b348eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69b348e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69b348d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe1g0j1ks                        0x000055dd0d356596 <unavailable> + 5526

    5    libc.so.6                          0x00002b69b3983460 __libc_start_main +
    245

    6    tmpe1g0j1ks                        0x000055dd0d356129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp4vco6lz1/tmp4vco6lz1.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af32da83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af32d77ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af32d77a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af32d7797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4vco6lz1                        0x000055f38413f717 <unavailable> + 5911

    5    libc.so.6                          0x00002af32dc6f460 __libc_start_main +
    245

    6    tmp4vco6lz1                        0x000055f38413f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \           } else {\n                count = 0\n            }\n            if\
    \ count > max {\n                max = count\n            }\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpm6nvsl53/tmpm6nvsl53.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac5ed6fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5ed3f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5ed3f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5ed3f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm6nvsl53                        0x000056115d20a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac5ed8ea460 __libc_start_main +
    245

    6    tmpm6nvsl53                        0x000056115d20a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var result = 0\n    \n    for\
    \ row in grid {\n        var max = 0\n        for col in row {\n            if\
    \ col > max {\n                max = col\n            }\n        }\n        result\
    \ += max - capacity\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpemfbh57i/tmpemfbh57i.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b829c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b826bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b826bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b826ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpemfbh57i                        0x00005596429f7546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7b82bb0460 __libc_start_main +
    245

    6    tmpemfbh57i                        0x00005596429f70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += capacity -\
    \ col\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxh8gzcs3/tmpxh8gzcs3.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba842adcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8427d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8427d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8427d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxh8gzcs3                        0x0000561c39c47717 <unavailable> + 5911

    5    libc.so.6                          0x00002ba842cc8460 __libc_start_main +
    245

    6    tmpxh8gzcs3                        0x0000561c39c470d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity.toInt()*capacity.toInt()\
    \ {\n        result += 1\n    }\n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         for _ in 0..<capacity.toInt() {\n                    grid[row][col]\
    \ = 0\n                    result += 1\n                }\n            }\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpedomgglm.swift:25:27: error: value of type 'Int' has no member\
    \ 'toInt'\n    for _ in 0..<capacity.toInt()*capacity.toInt() {\n            \
    \     ~~~~~~~~ ^~~~~\n/tmp/tmpedomgglm.swift:25:44: error: value of type 'Int'\
    \ has no member 'toInt'\n    for _ in 0..<capacity.toInt()*capacity.toInt() {\n\
    \                                  ~~~~~~~~ ^~~~~\n/tmp/tmpedomgglm.swift:31:39:\
    \ error: value of type 'Int' has no member 'toInt'\n                for _ in 0..<capacity.toInt()\
    \ {\n                             ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var minCapacity = capacity\n    var minBucket\
    \ = 0\n    var maxBucket = 0\n    var minWell = 0\n    var maxWell = 0\n    \n\
    \    for _ in 0..<grid.count {\n        minBucket = maxBucket\n        minWell\
    \ = maxWell\n        maxBucket = minBucket + grid[minBucket]!\n        maxWell\
    \ = minWell + grid[maxBucket]!\n        \n        for _ in 0..<grid[minBucket]!\
    \ {\n            minBucket++\n            minWell = maxWell\n            maxBucket\
    \ = minBucket + grid[minBucket]!\n            maxWell = minWell + grid[maxBucket]!\n\
    \        }\n        \n        for _ in 0..<grid[maxBucket]! {\n            maxBucket--\n\
    \            minWell = maxWell\n            maxBucket = minBucket + grid[minBucket]!\n\
    \            maxWell = minWell + grid[maxBucket]!\n        }\n        \n     \
    \   if minBucket < minCapacity {\n            minCapacity = minBucket\n      \
    \  }\n        if maxBucket > minCapacity {\n            minCapacity = maxBucket\n\
    \        }\n        if minWell < minCapacity {\n            minCapacity = minWell\n\
    \        }\n        if maxWell > minCapacity {\n            minCapacity = maxWell\n\
    \        }\n        \n        if minCapacity == capacity {\n            count\
    \ += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzjcq7ffj.swift:35:48: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        maxBucket = minBucket + grid[minBucket]!\n\
    \                                               ^\n/tmp/tmpzjcq7ffj.swift:36:44:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \        maxWell = minWell + grid[maxBucket]!\n                              \
    \             ^\n/tmp/tmpzjcq7ffj.swift:38:37: error: cannot convert value of\
    \ type '[Int]' to expected argument type 'Int'\n        for _ in 0..<grid[minBucket]!\
    \ {\n                                    ^\n/tmp/tmpzjcq7ffj.swift:45:37: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \   for _ in 0..<grid[maxBucket]! {\n                                    ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    var count\
    \ = 0\n    for row in grid {\n        if row[0] == 0 {\n            count += row[1]\n\
    \        }\n        if row[0] == 1 {\n            count -= row[1]\n        }\n\
    \        if count > capacity {\n            max = count\n            count = 0\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzu751_ng/tmpzu751_ng.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84ff058c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84fed4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84fed4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84fed4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzu751_ng                        0x000055a1713a5596 <unavailable> + 5526

    5    libc.so.6                          0x00002b84ff244460 __libc_start_main +
    245

    6    tmpzu751_ng                        0x000055a1713a5129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         max += 1\n                if max > capacity {\n                    maxIndex\
    \ = row\n                    break\n                }\n            }\n       \
    \ }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpckwt52cm.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var\
    \ count = 0\n        for cell in row {\n            if cell == 1 {\n         \
    \       count += 1\n            }\n        }\n        if count > max {\n     \
    \       max = count\n            maxCount = 1\n        } else {\n            maxCount\
    \ += 1\n        }\n    }\n    \n    for row in grid {\n        var count = 0\n\
    \        for cell in row {\n            if cell == 0 {\n                count\
    \ += 1\n            }\n        }\n        if count > max {\n            max =\
    \ count\n            maxCount = 1\n        } else {\n            maxCount += 1\n\
    \        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmppsfo42qp/tmppsfo42qp.swift:77: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd1e59ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd1e291b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd1e291988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd1e2907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppsfo42qp                        0x0000559bb069f546 <unavailable> + 5446

    5    libc.so.6                          0x00002abd1e786460 __libc_start_main +
    245

    6    tmppsfo42qp                        0x0000559bb069f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n               \
    \ grid[i][j] = capacity\n                max += capacity\n                maxIndex\
    \ = i\n            }\n        }\n    }\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == capacity {\n\
    \                grid[i][j] = 0\n                max -= 1\n                maxIndex\
    \ = i\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpge19hyd5.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpge19hyd5.swift:34:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = capacity\n        \
    \        ~~~~   ^\n/tmp/tmpge19hyd5.swift:44:24: error: cannot assign through\
    \ subscript: 'grid' is a 'let' constant\n                grid[i][j] = 0\n    \
    \            ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket]++\n    \
    \    }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n        \
    \    result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphxhonkyp.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmphxhonkyp.swift:28:28: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            buckets[bucket]++\n\
    \                           ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.length\
    \ {\n        for col in 0..<grid[row].length {\n            if grid[row][col]\
    \ == 1 {\n                max += capacity\n                maxCount++\n      \
    \      }\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6w_9nt1l.swift:24:13: error: value of type '[[Int]]' has no member\
    \ 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n       ~~~~ ^~~~~~\n\
    /tmp/tmp6w_9nt1l.swift:24:36: error: value of type '[Int]' has no member 'length'\n\
    \    if grid.length == 0 || grid[0].length == 0 {\n                          \
    \ ~~~~~~~ ^~~~~~\n/tmp/tmp6w_9nt1l.swift:31:25: error: value of type '[[Int]]'\
    \ has no member 'length'\n    for row in 0..<grid.length {\n                 \
    \  ~~~~ ^~~~~~\n/tmp/tmp6w_9nt1l.swift:32:34: error: reference to member 'length'\
    \ cannot be resolved without a contextual type\n        for col in 0..<grid[row].length\
    \ {\n                                 ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n\
    \        for col in 0..<grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                max += 1\n                maxCount += 1\n            }\n\
    \        }\n    }\n    \n    if maxCount > capacity {\n        return 0\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmph5m1tmy0/tmph5m1tmy0.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b917aeadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b917aba4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b917aba4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b917aba37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph5m1tmy0                        0x00005612e4725656 <unavailable> + 5718

    5    libc.so.6                          0x00002b917b099460 __libc_start_main +
    245

    6    tmph5m1tmy0                        0x00005612e47251e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n       \
    \ for col in row {\n            if col == 0 {\n                max += 1\n    \
    \            maxCount += 1\n            }\n        }\n    }\n    if maxCount >\
    \ capacity {\n        return maxCount\n    }\n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                max -= 1\n        \
    \    }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdszzfgy2.swift:24:13: error: value of type '[[Int]]' has no member\
    \ 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n       ~~~~ ^~~~~~\n\
    /tmp/tmpdszzfgy2.swift:24:36: error: value of type '[Int]' has no member 'length'\n\
    \    if grid.length == 0 || grid[0].length == 0 {\n                          \
    \ ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxIndex = 0\n    for row in grid {\n   \
    \     for col in row {\n            if col > 0 {\n                max += col\n\
    \                if max > capacity {\n                    max = capacity\n   \
    \                 maxIndex = col.index\n                }\n            }\n   \
    \     }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmprx330eaj.swift:32:36: error: value of type 'Int' has no member\
    \ 'index'\n                    maxIndex = col.index\n                        \
    \       ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n   \
    \     for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n       \
    \         max += 1\n                if max > capacity {\n                    maxIndex\
    \ = i\n                    break\n                }\n            }\n        }\n\
    \    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqtj7d1af/tmpqtj7d1af.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad04e5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad04b52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad04b52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad04b517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqtj7d1af                        0x00005654e8468656 <unavailable> + 5718

    5    libc.so.6                          0x00002aad05047460 __libc_start_main +
    245

    6    tmpqtj7d1af                        0x00005654e84681e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    var min = 0\n    \n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                count += 1\n                max = max(max, count)\n         \
    \       min = min(min, count)\n            }\n        }\n    }\n    \n    if capacity\
    \ == 0 {\n        return 0\n    }\n    \n    if capacity < min {\n        return\
    \ capacity\n    }\n    \n    if capacity > max {\n        return max\n    }\n\
    \    \n    return capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpptxn_cf9.swift:33:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, count)\n                      ^\n\
    /tmp/tmpptxn_cf9.swift:34:23: error: cannot call value of non-function type 'Int'\n\
    \                min = min(min, count)\n                      ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in bucket {\n            if bucket > 0 {\n                buckets[bucket][0]\
    \ = buckets[bucket][0] + 1\n                if buckets[bucket][0] > max {\n  \
    \                  max = buckets[bucket][0]\n                }\n            }\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6j070b74.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp6j070b74.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp6j070b74.swift:29:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp6j070b74.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp6j070b74.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp6j070b74.swift:31:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard capacity > 0\
    \ else { return 0 }\n    guard grid.count == grid[0].count else { return 0 }\n\
    \    \n    var count = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     count += min_fill(grid: &grid, row: row, col: col, capacity: capacity)\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzw30wl08.swift:33:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: &grid, row: row, col: col, capacity:\
    \ capacity)\n                         ^~~~~~~~\n/tmp/tmpzw30wl08.swift:33:41:\
    \ error: cannot pass immutable value as inout argument: 'grid' is a 'let' constant\n\
    \                count += min_fill(grid: &grid, row: row, col: col, capacity:\
    \ capacity)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: write your code here\n    \n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpt8sg7okt/tmpt8sg7okt.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba639c74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba63996bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba63996b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba63996a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt8sg7okt                        0x000055d9536153d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba639e60460 __libc_start_main +
    245

    6    tmpt8sg7okt                        0x000055d953614f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in 0..<grid.count {\n\
    \        for col in 0..<grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                result += capacity\n            }\n        }\n    }\n   \
    \ \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3xj_lmkh/tmp3xj_lmkh.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fcc1e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3fcbed9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3fcbed9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3fcbed87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3xj_lmkh                        0x000055c1b8bb0827 <unavailable> + 6183

    5    libc.so.6                          0x00002b3fcc3ce460 __libc_start_main +
    245

    6    tmp3xj_lmkh                        0x000055c1b8bb01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in row {\n            buckets[bucket]++\n        }\n    }\n  \
    \  for bucket in buckets {\n        if bucket > max {\n            max = bucket\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsdb9rly6.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpsdb9rly6.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpsdb9rly6.swift:29:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpsdb9rly6.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpsdb9rly6.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpsdb9rly6.swift:32:28:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  buckets[bucket]++\n                           ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjibrhf9q/tmpjibrhf9q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaae2151c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaae1e48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaae1e48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaae1e477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjibrhf9q                        0x0000560959bb63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aaae233d460 __libc_start_main +
    245

    6    tmpjibrhf9q                        0x0000560959bb5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n   \
    \     if row[0] > max {\n            max = row[0]\n            maxCount = 1\n\
    \        }\n        if row[0] > 0 && row[1] > 0 && row[2] > 0 && row[3] > 0 {\n\
    \            if row[0] > max {\n                max = row[0]\n               \
    \ maxCount = 1\n            }\n            if row[1] > max {\n               \
    \ max = row[1]\n                maxCount = 1\n            }\n            if row[2]\
    \ > max {\n                max = row[2]\n                maxCount = 1\n      \
    \      }\n            if row[3] > max {\n                max = row[3]\n      \
    \          maxCount = 1\n            }\n        }\n    }\n    if maxCount > capacity\
    \ {\n        return maxCount\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3wh1rmbk/tmp3wh1rmbk.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20f4814c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20f450bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20f450b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20f450a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wh1rmbk                        0x00005555c3016596 <unavailable> + 5526

    5    libc.so.6                          0x00002b20f4a00460 __libc_start_main +
    245

    6    tmp3wh1rmbk                        0x00005555c3016129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: implement the function\n    \n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3cmt4tip/tmp3cmt4tip.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeeb52c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeeb4fbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeeb4fbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeeb4fbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3cmt4tip                        0x0000555a45a673d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aeeb54b1460 __libc_start_main +
    245

    6    tmp3cmt4tip                        0x0000555a45a66f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n                if count > max {\n                    max = count\n  \
    \              }\n            }\n        }\n    }\n    \n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5nwyivt5/tmp5nwyivt5.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc84929c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc84620b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc84620988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc8461f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5nwyivt5                        0x000056234d908717 <unavailable> + 5911

    5    libc.so.6                          0x00002abc84b15460 __libc_start_main +
    245

    6    tmp5nwyivt5                        0x000056234d9080d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        result +=\
    \ max_fill_helper(grid, capacity)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8u_yvtiv.swift:26:19: error: cannot find 'max_fill_helper' in scope\n\
    \        result += max_fill_helper(grid, capacity)\n                  ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    var buckets = make([][]int, capacity)\n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     buckets[index%capacity] = append(buckets[index%capacity], 0)\n         \
    \   }\n            buckets[index%capacity][index%capacity] = col\n           \
    \ index++\n        }\n    }\n    for bucket in buckets {\n        if max < len(bucket)\
    \ {\n            max = len(bucket)\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwu4s6ku7.swift:30:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpwu4s6ku7.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpwu4s6ku7.swift:30:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpwu4s6ku7.swift:30:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpwu4s6ku7.swift:30:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpwu4s6ku7.swift:34:43:\
    \ error: cannot find 'append' in scope\n                buckets[index%capacity]\
    \ = append(buckets[index%capacity], 0)\n                                     \
    \     ^~~~~~\n/tmp/tmpwu4s6ku7.swift:37:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in bucket {\n            buckets[bucket]\
    \ = buckets[bucket] + 1\n        }\n    }\n    for bucket in buckets {\n     \
    \   if bucket > 0 {\n            result = max(result, bucket)\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkvptcbw0.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpkvptcbw0.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpkvptcbw0.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpkvptcbw0.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpkvptcbw0.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        if row[0] == 0\
    \ {\n            result += row[1]\n        }\n    }\n    for row in grid {\n \
    \       if row[0] == 1 {\n            result += row[1]\n        }\n    }\n   \
    \ for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 1 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 1 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            result += row[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcnrpw7lv.swift:177:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpcnrpw7lv.swift:155:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpcnrpw7lv.swift:177:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpcnrpw7lv.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpcnrpw7lv.swift:161:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // init result and counter\n    var result = 0\n    var\
    \ counter = 0\n    \n    // init bucket array\n    var buckets = [Int](capacity)\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfh27h3im.swift:30:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpfh27h3im.swift:42:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpfh27h3im.swift:33:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpfh27h3im.swift:45:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:36:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:48:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpfh27h3im.swift:39:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpfh27h3im.swift:51:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpfh27h3im.swift:33:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpfh27h3im.swift:54:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:36:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:57:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpfh27h3im.swift:39:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpfh27h3im.swift:60:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpfh27h3im.swift:33:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpfh27h3im.swift:63:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:36:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpfh27h3im.swift:66:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in bucket {\n            buckets[bucket] += 1\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n    \
    \        result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpct4deszf.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpct4deszf.swift:27:23: error: cannot\
    \ find 'bucket' in scope\n        for bucket in bucket {\n                   \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for _, row := range grid {\n        for _, cell := range row {\n          \
    \  if cell == 1 {\n                buckets[cell%capacity]++\n            }\n \
    \       }\n    }\n    for i := 0; i < capacity; i++ {\n        if buckets[i] !=\
    \ 0 {\n            result += buckets[i]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpuhi4t8z7.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpuhi4t8z7.swift:26:10: error: expected 'in' after for-each\
    \ pattern\n    for _, row := range grid {\n         ^\n/tmp/tmpuhi4t8z7.swift:26:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, row := range\
    \ grid {\n         ^\n/tmp/tmpuhi4t8z7.swift:27:14: error: expected 'in' after\
    \ for-each pattern\n        for _, cell := range row {\n             ^\n/tmp/tmpuhi4t8z7.swift:27:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, cell :=\
    \ range row {\n             ^\n/tmp/tmpuhi4t8z7.swift:33:12: error: expected type\n\
    \    for i := 0; i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmpuhi4t8z7.swift:33:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmpuhi4t8z7.swift:33:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmpuhi4t8z7.swift:25:19:\
    \ error: cannot find 'make' in scope\n    var buckets = make([][]int, capacity)\n\
    \                  ^~~~\n/tmp/tmpuhi4t8z7.swift:25:28: error: cannot find 'int'\
    \ in scope\n    var buckets = make([][]int, capacity)\n                      \
    \     ^~~\n/tmp/tmpuhi4t8z7.swift:25:27: error: missing argument for parameter\
    \ #1 in call\n    var buckets = make([][]int, capacity)\n                    \
    \      ^\n                          <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ declared here\n    @inlinable public subscript(index: Int) -> Element { get\
    \ set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += 1\n      \
    \      }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsey1krwp/tmpsey1krwp.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24ffe9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24ffb92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24ffb92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24ffb917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsey1krwp                        0x000055e0fe752717 <unavailable> + 5911

    5    libc.so.6                          0x00002b2500087460 __libc_start_main +
    245

    6    tmpsey1krwp                        0x000055e0fe7520d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        if row.isEmpty()\
    \ {\n            continue\n        }\n        \n        for col in row {\n   \
    \         if col == 0 {\n                count += 1\n            } else {\n  \
    \              count = 0\n            }\n            \n            if count >\
    \ max {\n                max = count\n            }\n        }\n    }\n    \n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphb7lpvd_.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmphb7lpvd_.swift:32:16: error: cannot call value of non-function\
    \ type 'Bool'\n        if row.isEmpty() {\n               ^      ~~\n        \
    \              \n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        var index = 0\n    \
    \    \n        for _ in 0..<row[0] {\n            index += 1\n        }\n    \
    \    \n        if index > max {\n            max = index\n            maxIndex\
    \ = index\n        }\n    }\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        var index = 0\n    \
    \    \n        for _ in 0..<row[0] {\n            index += 1\n        }\n    \
    \    \n        if index > max {\n            max = index\n            maxIndex\
    \ = index\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpec6rqp5v/tmpec6rqp5v.swift:81: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf69002c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf68cf9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf68cf9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf68cf87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec6rqp5v                        0x0000560b7cc04726 <unavailable> + 5926

    5    libc.so.6                          0x00002acf691ee460 __libc_start_main +
    245

    6    tmpec6rqp5v                        0x0000560b7cc042b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz9gqtgk8/tmpz9gqtgk8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38be381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38be078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38be078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38be0777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9gqtgk8                        0x000056109f85a717 <unavailable> + 5911

    5    libc.so.6                          0x00002b38be56d460 __libc_start_main +
    245

    6    tmpz9gqtgk8                        0x000056109f85a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    var maxBucket = 0\n    \n    for i\
    \ in 0..<grid[0].length {\n        for j in 0..<grid.count {\n            if grid[j][i]\
    \ == 1 {\n                max += 1\n                maxIndex = j\n           \
    \     maxBucket = i\n            }\n        }\n    }\n    \n    for i in 0..<capacity\
    \ {\n        if maxBucket == i {\n            max -= 1\n        }\n    }\n   \
    \ \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy8cfm36p.swift:32:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        var\
    \ max = 0\n        for cell in row {\n            if cell > max {\n          \
    \      max = cell\n            }\n        }\n        \n        if max > capacity\
    \ {\n            count += capacity - max\n        }\n    }\n    \n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwhbf2o6f/tmpwhbf2o6f.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7aa3ff8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7aa3cefb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7aa3cef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7aa3cee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwhbf2o6f                        0x0000562f55a58546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7aa41e4460 __libc_start_main +
    245

    6    tmpwhbf2o6f                        0x0000562f55a580d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdd1z4ljj/tmpdd1z4ljj.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8e88b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8e85b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8e85b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8e85af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdd1z4ljj                        0x0000563675b36546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae8e8aa5460 __libc_start_main +
    245

    6    tmpdd1z4ljj                        0x0000563675b360d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n            } else {\n                count = 0\n            }\n     \
    \       \n            if count > max {\n                max = count\n        \
    \    }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpczg30zxk/tmpczg30zxk.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac2040ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac20105b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac20105988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac201047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpczg30zxk                        0x0000559bdb302546 <unavailable> + 5446

    5    libc.so.6                          0x00002aac205fa460 __libc_start_main +
    245

    6    tmpczg30zxk                        0x0000559bdb3020d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for _ in row {\n            max += capacity\n        }\n        for _ in\
    \ row {\n            max -= 1\n            if max < 0 {\n                max =\
    \ 0\n            }\n        }\n        count += max - capacity\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgr91dsfq/tmpgr91dsfq.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d0ce13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d0cb0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d0cb0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d0cb097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgr91dsfq                        0x00005648a2bb2546 <unavailable> + 5446

    5    libc.so.6                          0x00002b4d0cfff460 __libc_start_main +
    245

    6    tmpgr91dsfq                        0x00005648a2bb20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]++\n\
    \        }\n    }\n    \n    for bucket in buckets {\n        if bucket > max\
    \ {\n            max = bucket\n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket < max {\n            count += bucket - max\n        }\n\
    \    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpopjzyfkm.swift:27:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpopjzyfkm.swift:31:25: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            buckets[col]++\n\
    \                        ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                index++\n            }\n     \
    \   }\n        \n        if index > max {\n            max = index\n        }\n\
    \        index = 0\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqeqburzz.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpqeqburzz.swift:34:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                index++\n                     ^~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxIndex = 0\n    var index = 0\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            max = row[0]\n        \
    \    maxIndex = index\n        }\n        index += 1\n    }\n    for row in grid\
    \ {\n        if row[0] == 0 {\n            max = row[0]\n            maxIndex\
    \ = index\n        }\n        index += 1\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        index += 1\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max = row[0]\n            maxIndex = index\n        }\n\
    \        index += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        index\
    \ += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n            max\
    \ = row[0]\n            maxIndex = index\n        }\n        index += 1\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            max = row[0]\n \
    \           maxIndex = index\n        }\n        index += 1\n    }\n    for row\
    \ in grid {\n        if row[0] == 0 {\n            max = row[0]\n            maxIndex\
    \ = index\n        }\n        index += 1\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        index += 1\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max = row[0]\n            maxIndex = index\n        }\n\
    \        index += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        index\
    \ += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n            max\
    \ = row[0]\n            maxIndex = index\n        }\n        index += 1\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            max = row[0]\n \
    \           maxIndex = index\n        }\n        index += 1\n    }\n    for row\
    \ in grid {\n        if row[0] == 0 {\n            max = row[0]\n            maxIndex\
    \ = index\n        }\n        index += 1\n    }\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        index += 1\n    }\n    for row in grid {\n        if row[0]\
    \ == 0 {\n            max = row[0]\n            maxIndex = index\n        }\n\
    \        index += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        index\
    \ += 1\n    }\n    for row in grid {\n        if row[0] == 0 {\n            max\
    \ = row[0]\n            maxIndex = index\n        }\n        index += 1\n    }\n\
    \    for row in grid {\n        if row[0] == 0 {\n            max = row\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr8v00uft.swift:175:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpr8v00uft.swift:153:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpr8v00uft.swift:175:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpr8v00uft.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpr8v00uft.swift:155:19:\
    \ error: cannot assign value of type '[Int]' to type 'Int'\n            max =\
    \ row\n                  ^~~\n/tmp/tmpr8v00uft.swift:159:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var min = 0\n    for row in grid {\n     \
    \   var minRow = row[0]\n        var maxRow = row[0]\n        for cell in row\
    \ {\n            if cell > maxRow {\n                maxRow = cell\n         \
    \   }\n            if cell < minRow {\n                minRow = cell\n       \
    \     }\n        }\n        if maxRow - minRow > capacity {\n            result\
    \ += capacity - maxRow + minRow - min\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplkyp2b_h/tmplkyp2b_h.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0eff6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0efc66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0efc66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0efc657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkyp2b_h                        0x00005643822f8596 <unavailable> + 5526

    5    libc.so.6                          0x00002ac0f015b460 __libc_start_main +
    245

    6    tmplkyp2b_h                        0x00005643822f8129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  minCapacity = minCapacity - 1\n            }\n        }\n    }\n    for row\
    \ in grid {\n        for col in row {\n            if col == 1 {\n           \
    \     result += minCapacity\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpongx3esu/tmpongx3esu.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac30f1a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac30eea0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac30eea0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac30ee9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpongx3esu                        0x00005606aca99546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac30f395460 __libc_start_main +
    245

    6    tmpongx3esu                        0x00005606aca990d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    \n    for row in grid {\n\
    \        for bucket in bucket {\n            if bucket > 0 {\n               \
    \ buckets[bucket]++\n            }\n        }\n    }\n    \n    for bucket in\
    \ buckets {\n        if bucket > max {\n            max = bucket\n        }\n\
    \    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjzvg2ixt.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpjzvg2ixt.swift:29:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpjzvg2ixt.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpjzvg2ixt.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpjzvg2ixt.swift:32:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    var max = 0\n\
    \    var count = 0\n    for row in grid {\n        if row[0] > max {\n       \
    \     max = row[0]\n        }\n        if row[1] > max {\n            max = row[1]\n\
    \        }\n        if row[2] > max {\n            max = row[2]\n        }\n \
    \       if row[3] > max {\n            max = row[3]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] > max {\n            max = row[0]\n       \
    \ }\n        if row[1] > max {\n            max = row[1]\n        }\n        if\
    \ row[2] > max {\n            max = row[2]\n        }\n        if row[3] > max\
    \ {\n            max = row[3]\n        }\n    }\n    for row in grid {\n     \
    \   if row[0] > max {\n            max = row[0]\n        }\n        if row[1]\
    \ > max {\n            max = row[1]\n        }\n        if row[2] > max {\n  \
    \          max = row[2]\n        }\n        if row[3] > max {\n            max\
    \ = row[3]\n        }\n    }\n    for row in grid {\n        if row[0] > max {\n\
    \            max = row[0]\n        }\n        if row[1] > max {\n            max\
    \ = row[1]\n        }\n        if row[2] > max {\n            max = row[2]\n \
    \       }\n        if row[3] > max {\n            max = row[3]\n        }\n  \
    \  }\n    for row in grid {\n        if row[0] > max {\n            max = row[0]\n\
    \        }\n        if row[1] > max {\n            max = row[1]\n        }\n \
    \       if row[2] > max {\n            max = row[2]\n        }\n        if row[3]\
    \ > max {\n            max = row[3]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] > max {\n            max = row[0]\n        }\n        if row[1]\
    \ > max {\n            max = row[1]\n        }\n        if row[2] > max {\n  \
    \          max = row[2]\n        }\n        if row[3] > max {\n            max\
    \ = row[3]\n        }\n    }\n    for row in grid {\n        if row[0] > max {\n\
    \            max = row[0]\n        }\n        if row[1] > max {\n            max\
    \ = row[1]\n        }\n        if row[2] > max {\n            max = row[2]\n \
    \       }\n        if row[3] > max {\n            max = row[3]\n        }\n  \
    \  }\n    for row in grid {\n        if row[0] > max {\n            max = row[0]\n\
    \        }\n        if row[1] > max {\n            max = row[1]\n        }\n \
    \       if row[2] > max {\n            max = row[2]\n        }\n        if row[3]\
    \ > max {\n            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplahm190u.swift:158:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmplahm190u.swift:127:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmplahm190u.swift:158:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmplahm190u.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmplahm190u.swift:142:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmplahm190u.swift:28:9:\
    \ warning: initialization of variable 'count' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n  \
    \  _\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var maxCount = 0\n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                buckets[col-1] += 1\n            }\n        }\n    }\n\
    \    \n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket\n            maxCount = 1\n        } else {\n            if bucket\
    \ == max {\n                maxCount += 1\n            }\n        }\n    }\n \
    \   \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppmy081sd.swift:27:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += 1\n      \
    \      } else {\n                count = 0\n            }\n            \n    \
    \        if count > max {\n                max = count\n            }\n      \
    \  }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf442nxtx/tmpf442nxtx.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3eb089c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3ead80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3ead80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3ead7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf442nxtx                        0x0000562a96699546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3eb275460 __libc_start_main +
    245

    6    tmpf442nxtx                        0x0000562a966990d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                max += capacity\n            } else\
    \ {\n                max += col\n            }\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp159lbvn2/tmp159lbvn2.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0dce0f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0dcddecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0dcddec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0dcddeb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp159lbvn2                        0x00005650a0af0546 <unavailable> + 5446

    5    libc.so.6                          0x00002b0dce2e1460 __libc_start_main +
    245

    6    tmp159lbvn2                        0x00005650a0af00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return -1\n    }\n    \n\
    \    var max = 0\n    var bucket = [0]\n    \n    for row in grid {\n        if\
    \ row[0] == 0 {\n            bucket[0] += capacity\n        } else {\n       \
    \     bucket[0] -= capacity\n        }\n        \n        if bucket[0] > max {\n\
    \            max = bucket[0]\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpylfhgpkv/tmpylfhgpkv.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002addc783bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002addc7532b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002addc7532988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002addc75317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpylfhgpkv                        0x00005614b6fa95e6 <unavailable> + 5606

    5    libc.so.6                          0x00002addc7a27460 __libc_start_main +
    245

    6    tmpylfhgpkv                        0x00005614b6fa9179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([]*Int, capacity)\n    for row in grid {\n     \
    \   buckets[row[0]] = row[1]\n        max = max(max, row[1])\n    }\n    \n  \
    \  for bucket in buckets {\n        if bucket > 0 {\n            bucket = bucket\
    \ - 1\n        }\n        max = max(max, bucket)\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjooaggy8.swift:29:19: error: cannot find 'make' in scope\n    var\
    \ buckets = make([]*Int, capacity)\n                  ^~~~\n/tmp/tmpjooaggy8.swift:29:24:\
    \ error: cannot convert value of type '[Any]' to expected argument type 'Duration'\n\
    \    var buckets = make([]*Int, capacity)\n                       ^\n/tmp/tmpjooaggy8.swift:29:26:\
    \ error: type 'Int.Type' cannot conform to 'BinaryInteger'\n    var buckets =\
    \ make([]*Int, capacity)\n                         ^\n/tmp/tmpjooaggy8.swift:29:26:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n    var buckets = make([]*Int, capacity)\n                      \
    \   ^\n/tmp/tmpjooaggy8.swift:29:26: note: required by operator function '*' where\
    \ 'T' = 'Int.Type'\n    var buckets = make([]*Int, capacity)\n               \
    \          ^\n/tmp/tmpjooaggy8.swift:32:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, row[1])\n              ^\n"
  stdout: ''
  timestamp: 1659824580
