language: swift
name: HumanEval_137_compare_one
results:
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7bw_mzg6.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp7bw_mzg6.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp7bw_mzg6.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp7bw_mzg6.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp7bw_mzg6.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp7bw_mzg6.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp7bw_mzg6.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp7bw_mzg6.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp7bw_mzg6.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp7bw_mzg6.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call\n    case .intValue(_):\n        return a.intValue()\
    \ >= b.intValue()\n    case .doubleValue(_):\n        return a.doubleValue() >=\
    \ b.doubleValue()\n    case .stringValue(_):\n        return a.stringValue() >=\
    \ b.stringValue()\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpofber96s.swift:24:27: error: missing argument for parameter #1\
    \ in call\n        return a.intValue() >= b.intValue()\n                     \
    \     ^\n                          <#Int#>\n/tmp/tmpofber96s.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpofber96s.swift:24:16:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ a.intValue() >= b.intValue()\n               ^\n               Value\n/tmp/tmpofber96s.swift:24:29:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return a.intValue() >= b.intValue()\n               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpofber96s.swift:24:29: error: referencing operator function '>=' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n        return a.intValue() >=\
    \ b.intValue()\n                            ^\nSwift.Comparable:1:17: note: where\
    \ 'Self' = 'Value'\npublic protocol Comparable : Equatable {\n               \
    \ ^\n/tmp/tmpofber96s.swift:24:29: note: binary operator '>=' cannot be synthesized\
    \ for enums with associated values\n        return a.intValue() >= b.intValue()\n\
    \                            ^\n/tmp/tmpofber96s.swift:24:43: error: missing argument\
    \ for parameter #1 in call\n        return a.intValue() >= b.intValue()\n    \
    \                                      ^\n                                   \
    \       <#Int#>\n/tmp/tmpofber96s.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpofber96s.swift:24:32: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return a.intValue()\
    \ >= b.intValue()\n                               ^\n                        \
    \       Value\n/tmp/tmpofber96s.swift:26:16: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        return a.doubleValue() >= b.doubleValue()\n\
    \               ^\n               Value\n/tmp/tmpofber96s.swift:26:30: error:\
    \ missing argument for parameter #1 in call\n        return a.doubleValue() >=\
    \ b.doubleValue()\n                             ^\n                        "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpl4ow72cf.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpl4ow72cf.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpl4ow72cf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpl4ow72cf.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpl4ow72cf.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpl4ow72cf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpl4ow72cf.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpl4ow72cf.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpl4ow72cf.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpl4ow72cf.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n        default: return nil\n    }\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n    if a.doubleValue()\
    \ < b.doubleValue() { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue()\
    \ { return .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_074l74j.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp_074l74j.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp_074l74j.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmp_074l74j.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp_074l74j.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmp_074l74j.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp_074l74j.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmp_074l74j.swift:28:23: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                      ^\n                      Value\n/tmp/tmp_074l74j.swift:28:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n                                 ^\n              \
    \                   <#Int#>\n/tmp/tmp_074l74j.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmp_074l74j.swift:28:55: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ argument\n    case .intValue(_):\n        switch b { // Switch on the type of\
    \ the second argument\n        case .intValue(_):\n            return .intValue(max(Int(a),\
    \ Int(b)))\n        case .doubleValue(_):\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on the type of the second argument\n        case .intValue(_):\n           \
    \ return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on the type of the second argument\n\
    \        case .intValue(_):\n            return .stringValue(max(String(a), String(b)))\n\
    \        case .doubleValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpttwnukct.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmpttwnukct.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmpttwnukct.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpttwnukct.swift:28:37: error: initializer 'init(_:)' requires that 'Value'\
    \ conform to 'BinaryInteger'\n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                    ^\nSwift.Double:3:23: note: where 'Source'\
    \ = 'Value'\n    @inlinable public init<Source>(_ value: Source) where Source\
    \ : BinaryInteger\n                      ^\n/tmp/tmpttwnukct.swift:28:48: error:\
    \ no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpttwnukct.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpttwnukct.swift:30:37:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmpttwnukct.swift:30:37:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmpttwnukct.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmpttwnukct.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if let bInt = b.intValue() {\n            return\
    \ aInt > bInt ? .intValue(aInt) : .intValue(bInt)\n        } else if let bDouble\
    \ = b.doubleValue() {\n            return aDouble > bDouble ? .doubleValue(aDouble)\
    \ : .doubleValue(bDouble)\n        } else if let bString = b.stringValue() {\n\
    \            return aString > bString ? .stringValue(aString) : .stringValue(bString)\n\
    \        } else {\n            return nil\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7vjtfiw7.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp7vjtfiw7.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmp7vjtfiw7.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmp7vjtfiw7.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmp7vjtfiw7.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmp7vjtfiw7.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmp7vjtfiw7.swift:24:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmp7vjtfiw7.swift:24:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmp7vjtfiw7.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmp7vjtfiw7.swift:26:33: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        } else if let bDouble = b.doubleValue()\
    \ {\n                                ^\n                                Value\n\
    /tmp/tmp7vjtfiw7.swift:26:47: error: missing argument for parameter #1 in call\n\
    \        } else if let bDouble = b.doub"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(a.intValue > b.intValue ? a.intValue\
    \ : b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp47vm4rx5.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp47vm4rx5.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp47vm4rx5.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp47vm4rx5.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp47vm4rx5.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp47vm4rx5.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ argument\n    case .intValue(_):\n        switch b { // Switch on the type of\
    \ the second argument\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n   \
    \         return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue :\
    \ b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on the type of the second argument\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue ?\
    \ a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on the type of the second argument\n        case\
    \ .intValue(_):\n            return .stringValue(a.stringValue > b.intValue ?\
    \ a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnwi5lpoc.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpnwi5lpoc.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpnwi5lpoc.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpnwi5lpoc.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpnwi5lpoc.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpnwi5lpoc.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpnwi5lpoc.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpnwi5lpoc.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(IntMax)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .stringValue(_):\n         \
    \   return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n   \
    \     switch b { // Switch on type to determine which comparison to use\n    \
    \    case .intValue(_):\n            return .doubleValue(DoubleMax)\n        case\
    \ .doubleValue(_):\n            return .intValue(IntMax)\n        case .stringValue(_):\n\
    \            return .stringValue(StringMax)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which comparison to use\n \
    \       case .intValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .doubleValue(_):\n            return .stringValue(StringMax)\n      \
    \  case .stringValue(_):\n            return .intValue(IntMax)\n        }\n  \
    \  }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxyi5y64r.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpxyi5y64r.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:37:30: error:\
    \ cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n      \
    \                       ^~~~~~\n/tmp/tmpxyi5y64r.swift:39:33: error: cannot find\
    \ 'StringMax' in scope\n            return .stringValue(StringMax)\n         \
    \                       ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:44:33: error: cannot\
    \ find 'StringMax' in scope\n            return .stringValue(StringMax)\n    \
    \                            ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:46:33: error: cannot\
    \ find 'StringMax' in scope\n            return .stringValue(StringMax)\n    \
    \                            ^~~~~~~~~\n/tmp/tmpxyi5y64r.swift:48:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n    \n    if a.intValue() > b.intValue() {\n     \
    \   return a\n    }\n    \n    if a.intValue() < b.intValue() {\n        return\
    \ b\n    }\n    \n    if a.doubleValue() > b.doubleValue() {\n        return a\n\
    \    }\n    \n    if a.doubleValue() < b.doubleValue() {\n        return b\n \
    \   }\n    \n    if a.stringValue() > b.stringValue() {\n        return a\n  \
    \  }\n    \n    if a.stringValue() < b.stringValue() {\n        return b\n   \
    \ }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplryp44xd.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmplryp44xd.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmplryp44xd.swift:34:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmplryp44xd.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmplryp44xd.swift:34:8: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() {\n       ^\n       Value\n/tmp/tmplryp44xd.swift:34:21: error:\
    \ referencing operator function '>' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() > b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmplryp44xd.swift:34:21: note: binary\
    \ operator '>' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() > b.intValue() {\n                    ^\n/tmp/tmplryp44xd.swift:34:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() {\n                      ^\n                      Value\n/tmp/tmplryp44xd.swift:34:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() > b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmplryp44xd.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmplryp44xd.swift:38:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmplryp44xd.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmplryp44xd.swift:38:8: error:\
    \ enum cas"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ value\n    case .intValue(_):\n        switch b { // Switch on the type of the\
    \ second value\n        case .intValue(_):\n            return .intValue(max(Int(a),\
    \ Int(b)))\n        case .doubleValue(_):\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on the type of the second value\n        case .intValue(_):\n            return\
    \ .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n   \
    \         return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on the type of the second value\n\
    \        case .intValue(_):\n            return .stringValue(max(String(a), String(b)))\n\
    \        case .doubleValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3alj7mr5.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp3alj7mr5.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp3alj7mr5.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp3alj7mr5.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp3alj7mr5.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp3alj7mr5.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp3alj7mr5.swift:30:48: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                               ^\n/tmp/tmp3alj7mr5.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmp3alj7mr5.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmp3alj7mr5.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpifr60zip.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpifr60zip.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpifr60zip.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpifr60zip.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpifr60zip.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpifr60zip.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpifr60zip.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpifr60zip.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n    if a.doubleValue() > b.doubleValue()\
    \ { return .doubleValue() }\n    if a.stringValue() > b.stringValue() { return\
    \ .stringValue() }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8yj289ai.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp8yj289ai.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp8yj289ai.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \              ^\n                  <#Int#>\n/tmp/tmp8yj289ai.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp8yj289ai.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n       ^\n       Value\n/tmp/tmp8yj289ai.swift:28:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp8yj289ai.swift:28:21:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() > b.intValue() { return .intValue() }\n                 \
    \   ^\n/tmp/tmp8yj289ai.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() { return .intValue() }\n       \
    \                          ^\n                                 <#Int#>\n/tmp/tmp8yj289ai.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp8yj289ai.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n                      ^\n           \
    \           Value\n/tmp/tmp8yj289ai.swift:28:55: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \                                 "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3_yia0cw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp3_yia0cw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp3_yia0cw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp3_yia0cw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp3_yia0cw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp3_yia0cw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp3_yia0cw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp3_yia0cw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.stringValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa0ivjudm.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpa0ivjudm.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpa0ivjudm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpa0ivjudm.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpa0ivjudm.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpa0ivjudm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpa0ivjudm.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpa0ivjudm.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpa0ivjudm.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpa0ivjudm.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(IntMax)\n        case .doubleValue(_):\n\
    \            return .intValue(IntMax)\n        case .stringValue(_):\n       \
    \     return .intValue(IntMax)\n        }\n    case .doubleValue(_):\n       \
    \ switch b { // Switch on the type of b\n        case .intValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(DoubleMax)\n        case .stringValue(_):\n          \
    \  return .doubleValue(DoubleMax)\n        }\n    case .stringValue(_):\n    \
    \    switch b { // Switch on the type of b\n        case .intValue(_):\n     \
    \       return .stringValue(StringMax)\n        case .doubleValue(_):\n      \
    \      return .stringValue(StringMax)\n        case .stringValue(_):\n       \
    \     return .stringValue(StringMax)\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3j5r356m.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmp3j5r356m.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmp3j5r356m.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmp3j5r356m.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp3j5r356m.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp3j5r356m.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp3j5r356m.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp3j5r356m.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp3j5r356m.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two integers\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return nil\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return nil\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return nil\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp5ewbqkdk/tmp5ewbqkdk.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba856bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba853b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba853b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba853b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ewbqkdk                        0x000055aafd8aba56 <unavailable> + 6742

    5    libc.so.6                          0x00002aba858ab460 __libc_start_main +
    245

    6    tmp5ewbqkdk                        0x000055aafd8ab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which value to return.\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which value to return.\n        case .intValue(_):\n  \
    \          return a\n        case .doubleValue(_):\n            return b\n   \
    \     case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which value to return.\n  \
    \      case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which value to return.\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp5s71m6_z/tmp5s71m6_z.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abddd85bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abddd552b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abddd552988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abddd5517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5s71m6_z                        0x00005608a8d4ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002abddda47460 __libc_start_main +
    245

    6    tmp5s71m6_z                        0x00005608a8d4c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n    \
    \        return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_wl3vjav.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp_wl3vjav.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp_wl3vjav.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp_wl3vjav.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp_wl3vjav.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp_wl3vjav.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp_wl3vjav.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp_wl3vjav.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp_wl3vjav.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp_wl3vjav.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call\n    case .intValue(_):\n        return Int(b) > Int(a)\
    \ // Compare integers\n    case .doubleValue(_):\n        return Double(b) > Double(a)\
    \ // Compare doubles\n    case .stringValue(_):\n        return String(b) > String(a)\
    \ // Compare strings\n    }\n    return nil // If values are equal, return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnzti1d5z.swift:24:16: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n        return Int(b) > Int(a) // Compare\
    \ integers\n               ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n\
    \    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n        \
    \              ^\n/tmp/tmpnzti1d5z.swift:24:25: error: no exact matches in call\
    \ to initializer \n        return Int(b) > Int(a) // Compare integers\n      \
    \                  ^\n/tmp/tmpnzti1d5z.swift:24:25: note: found candidate with\
    \ type '(Value) -> Int'\n        return Int(b) > Int(a) // Compare integers\n\
    \                        ^\n/tmp/tmpnzti1d5z.swift:24:23: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n        return Int(b)\
    \ > Int(a) // Compare integers\n               ~~~~~~~^~~~~~~~\n/tmp/tmpnzti1d5z.swift:26:28:\
    \ error: no exact matches in call to initializer \n        return Double(b) >\
    \ Double(a) // Compare doubles\n                           ^\n/tmp/tmpnzti1d5z.swift:26:28:\
    \ note: found candidate with type '(Value) -> Double'\n        return Double(b)\
    \ > Double(a) // Compare doubles\n                           ^\n/tmp/tmpnzti1d5z.swift:26:16:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \        return Double(b) > Double(a) // Compare doubles\n               ^\nSwift.Double:3:23:\
    \ note: where 'Source' = 'Value'\n    @inlinable public init<Source>(_ value:\
    \ Source) where Source : BinaryInteger\n                      ^\n/tmp/tmpnzti1d5z.swift:26:26:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return Double(b) > Double(a) // Compare doubles\n               ~~~~~~~~~~^~~~~~~~~~~\n\
    /tmp/tmpnzti1d5z.swift:28:16: error: no exact matches in call to initializer \n\
    \        return String(b) > String(a) // Compare strings\n               ^\n/tmp/tmpnzti1d5z.swift:28:16:\
    \ note: found candidate with type '(Value) -> String'\n        return String(b)\
    \ > String(a) // Compare strings\n               ^\n/tmp/tmpnzti1d5z.swift:28:16:\
    \ note: found candidate"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which type to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which type to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which type to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which type to return\n    \
    \    case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_ve_m6z1.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp_ve_m6z1.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp_ve_m6z1.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp_ve_m6z1.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp_ve_m6z1.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp_ve_m6z1.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp_ve_m6z1.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp_ve_m6z1.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two integers\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .intValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .intValue(a.stringValue > b.stringValue)\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Compare two doubles\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two strings\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .intValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4cry9wcz.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp4cry9wcz.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp4cry9wcz.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp4cry9wcz.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp4cry9wcz.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp4cry9wcz.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp4cry9wcz.swift:28:44: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n            return\
    \ .intValue(a.doubleValue > b.doubleValue)\n                                 \
    \          ^\n/tmp/tmp4cry9wcz.swift:28:30: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n            return .intValue(a.doubleValue >\
    \ b.doubleValue)\n                             ^\n                           \
    \  Value\n/tmp/tmp4cry9wcz.swift:28:44: error: type '(Double) -> Value' cannot\
    \ conform to 'Comparable'\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \                                           ^\n/tmp/tmp4cry9wcz.swift:28:44: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \            return "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), .doubleValue(aDouble), .stringValue(aString)\n\
    \        if let bInt = b.intValue() {\n            return .intValue(aInt > bInt\
    \ ? aInt : bInt)\n        } else if let bDouble = b.doubleValue() {\n        \
    \    return .doubleValue(aDouble > bDouble ? aDouble : bDouble)\n        } else\
    \ if let bString = b.stringValue() {\n            return .stringValue(aString\
    \ > bString ? aString : bString)\n        }\n        return nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp61w4zvx4.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp61w4zvx4.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ .doubleValue(aDouble), .stringValue(aString)\n                       ^\n/tmp/tmp61w4zvx4.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ .doubleValue(aDouble), .stringValue(aString)\n                       ^\n/tmp/tmp61w4zvx4.swift:23:75:\
    \ error: expected ':' after 'case'\n    case let .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                                                    \
    \                      ^\n/tmp/tmp61w4zvx4.swift:23:44: error: cannot find 'aDouble'\
    \ in scope\n    case let .intValue(aInt), .doubleValue(aDouble), .stringValue(aString)\n\
    \                                           ^~~~~~~\n/tmp/tmp61w4zvx4.swift:23:67:\
    \ error: cannot find 'aString' in scope\n    case let .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                                                    \
    \              ^~~~~~~\n/tmp/tmp61w4zvx4.swift:24:23: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        if let bInt = b.intValue() {\n\
    \                      ^\n                      Value\n/tmp/tmp61w4zvx4.swift:24:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmp61w4zvx4.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmp61w4zvx4.swift:26:47: error: missing argument for parameter\
    \ #1 in call\n        } else if let bDouble = b.doubleValue() {\n            \
    \                                  ^\n                                       \
    \       <#Double#>\n/tmp/tmp61w4zvx4.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/tmp/tmp61w4zvx4.swift:26:33:\
    \ error: enum case 'doubleValue' cannot "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString)\n            where a == .intValue(bInt)\n        \
    \    return .intValue(bInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(bInt), let\
    \ .doubleValue(bDouble), let .stringValue(bString)\n            where a == .doubleValue(bDouble)\n\
    \            return .doubleValue(bDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(bInt), let\
    \ .doubleValue(bDouble), let .stringValue(bString)\n            where a == .stringValue(bString)\n\
    \            return .stringValue(bString)\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5bgp8dox.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp5bgp8dox.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmp5bgp8dox.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmp5bgp8dox.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmp5bgp8dox.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmp5bgp8dox.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmp5bgp8dox.swift:26:52: error: 'bDouble' must be bound in every pattern\n\
    \        case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                                                   ^\n/tmp/tmp5bgp8dox.swift:26:28:\
    \ error: 'bInt' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString)\n                     \
    \      ^\n/tmp/tmp5bgp8dox.swift:26:79: error: 'bString' must be bound in every\
    \ pattern\n        case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                                                                            \
    \  ^\n/tmp/tmp5bgp8dox.swift:26:28: error: 'bInt' must be bound in every pattern\n\
    \        case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                           ^\n/tmp/tmp5bgp8dox.s"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .doubleValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmtas89zt.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpmtas89zt.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpmtas89zt.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpmtas89zt.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpmtas89zt.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpmtas89zt.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        default:\n            return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyci_lha4.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyci_lha4.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyci_lha4.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyci_lha4.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyci_lha4.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyci_lha4.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyci_lha4.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyci_lha4.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyci_lha4.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyci_lha4.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyci_lha4.s"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString)\n                    if aInt == bInt {\n         \
    \               return b\n                    }\n                    if aDouble\
    \ == bDouble {\n                        return b\n                    }\n    \
    \                if aString == bString {\n                        return b\n \
    \                   }\n                    return nil\n            }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphu6v5phd.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphu6v5phd.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmphu6v5phd.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmphu6v5phd.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmphu6v5phd.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmphu6v5phd.swift:23:87: error: expected ':' after 'case'\n   \
    \     case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \          ^\n/tmp/tmphu6v5phd.swift:24:75: error: expected ':' after 'case'\n\
    \            switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \                                                                          ^\n\
    /tmp/tmphu6v5phd.swift:25:60: error: 'bDouble' must be bound in every pattern\n\
    \                case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                                                           ^\n/tmp/tmphu6v5phd.swift:25:36:\
    \ error: 'bInt' must be bound in every pattern\n                case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString)\n                     \
    \              ^\n/tmp/tmphu6v5phd.swift:25:87: error: 'bString' must be bound\
    \ in every pattern\n                case let .intValue"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString),\
    \ let .stringValue(bString)\n            if aString == bString {\n           \
    \     return a\n            }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmzejglfz.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpmzejglfz.swift:23:49:\
    \ error: 'b' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                                            ^\n/tmp/tmpmzejglfz.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmpmzejglfz.swift:23:70: error: 'aString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                ^\n/tmp/tmpmzejglfz.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmpmzejglfz.swift:23:97: error: 'bString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                           ^\n\
    /tmp/tmpmzejglfz.swift:23:28: error: 'a' must be bound in every pattern\n    \
    \    case let .intValue(a), let .doubleValue(b), let .stringValue(aString), let\
    \ .stringValue(bString)\n                           ^\n/tmp/tmpmzejglfz.swift:23:105:\
    \ error: expected ':' after 'case'\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                            \
    \       ^\n/tmp/tmpmzejglfz.swift:24:16: error: cannot find 'aString' in scope\n\
    \            if aString == bString {\n               ^~~~~~~\n/tmp/tmpmzejglfz.swift:24:27:\
    \ error: cannot find 'bString' in scope\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfdlwzax3.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpfdlwzax3.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdaygm8wb.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmpdaygm8wb.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmpdaygm8wb.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpdaygm8wb.swift:28:48: error: no exact matches in call to initializer \n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                               ^\n/tmp/tmpdaygm8wb.swift:28:48: note: found candidate\
    \ with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpdaygm8wb.swift:30:48: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpdaygm8wb.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two ints\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two doubles\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two strings\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp30ujkuf1.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp30ujkuf1.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp30ujkuf1.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp30ujkuf1.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp30ujkuf1.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp30ujkuf1.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp30ujkuf1.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp30ujkuf1.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp30ujkuf1.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp30ujkuf1.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbqfsjlgf.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpbqfsjlgf.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpbqfsjlgf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpbqfsjlgf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpbqfsjlgf.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpbqfsjlgf.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        }\n\
    \    case .stringValue(_):\n        switch b { // Switch on b's type\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpvy57wa20/tmpvy57wa20.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6ae553c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6ae24ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6ae24a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6ae2497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvy57wa20                        0x000055b14bc5fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae6ae73f460 __libc_start_main +
    245

    6    tmpvy57wa20                        0x000055b14bc5f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpefl5_eu5.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpefl5_eu5.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? a :\
    \ b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpycb13an3.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpycb13an3.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .doubleValue(DoubleMax)\n        case .stringValue(_):\n        \
    \    return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n  \
    \      switch b { // Switch on b's type\n        case .intValue(_):\n        \
    \    return .intValue(IntMax)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(DoubleMax)\n        case .stringValue(_):\n            return .stringValue(StringMax)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .intValue(IntMax)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(DoubleMax)\n        case .stringValue(_):\n\
    \            return .stringValue(StringMax)\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpot0reqcl.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpot0reqcl.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpot0reqcl.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpot0reqcl.swift:35:30: error:\
    \ cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n      \
    \                       ^~~~~~\n/tmp/tmpot0reqcl.swift:37:33: error: cannot find\
    \ 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n         \
    \                       ^~~~~~~~~\n/tmp/tmpot0reqcl.swift:39:33: error: cannot\
    \ find 'StringMax' in scope\n            return .stringValue(StringMax)\n    \
    \                            ^~~~~~~~~\n/tmp/tmpot0reqcl.swift:44:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpot0reqcl.swift:46:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpot0reqcl.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbqfsjlgf.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpbqfsjlgf.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpbqfsjlgf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpbqfsjlgf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpbqfsjlgf.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpbqfsjlgf.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpefl5_eu5.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpefl5_eu5.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which type to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which type to return\n        case .intValue(_):\n       \
    \     return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which type to return\n    \
    \    case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which type to return\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmz1l9f1l/tmpmz1l9f1l.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adea1889c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adea1580b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adea1580988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adea157f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmz1l9f1l                        0x0000559b722c0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002adea1a75460 __libc_start_main +
    245

    6    tmpmz1l9f1l                        0x0000559b722c0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpifr60zip.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpifr60zip.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpifr60zip.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpifr60zip.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpifr60zip.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpifr60zip.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpifr60zip.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpifr60zip.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfdxy8cmn/tmpfdxy8cmn.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69d4622c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69d4319b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69d4319988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69d43187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfdxy8cmn                        0x00005603a7e6001a <unavailable> + 12314

    5    libc.so.6                          0x00002b69d480e460 __libc_start_main +
    245

    6    tmpfdxy8cmn                        0x00005603a7e5e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? a : b\n\
    \        case .doubleValue(_):\n            return a > b ? b : a\n        case\
    \ .stringValue(_):\n            return a > b ? b : a\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? a : b\n        case .doubleValue(_):\n            return\
    \ a > b ? b : a\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphaoscfe0.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmphaoscfe0.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmphaoscfe0.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmphaoscfe0.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmphaoscfe0.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmphaoscfe0.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmphaoscfe0.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmphaoscfe0.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmphaoscfe0.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call.\n    case .intValue(_):\n        return a.intValue(b)\
    \ // Call intValue function on both values.\n    case .doubleValue(_):\n     \
    \   return a.doubleValue(b) // Call doubleValue function on both values.\n   \
    \ case .stringValue(_):\n        return a.stringValue(b) // Call stringValue function\
    \ on both values.\n    }\n    return nil // If values are equal, return nil.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp08x26_30.swift:24:27: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return a.intValue(b) // Call intValue\
    \ function on both values.\n                          ^\n/tmp/tmp08x26_30.swift:24:16:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ a.intValue(b) // Call intValue function on both values.\n               ^\n\
    \               Value\n/tmp/tmp08x26_30.swift:26:30: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Double'\n        return a.doubleValue(b)\
    \ // Call doubleValue function on both values.\n                             ^\n\
    /tmp/tmp08x26_30.swift:26:16: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        return a.doubleValue(b) // Call doubleValue function\
    \ on both values.\n               ^\n               Value\n/tmp/tmp08x26_30.swift:28:30:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \        return a.stringValue(b) // Call stringValue function on both values.\n\
    \                             ^\n/tmp/tmp08x26_30.swift:28:16: error: enum case\
    \ 'stringValue' cannot be used as an instance member\n        return a.stringValue(b)\
    \ // Call stringValue function on both values.\n               ^\n           \
    \    Value\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which variable is larger.\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which variable is larger.\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which variable is larger.\n        case .intValue(_):\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which variable is larger.\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpychiyzy0.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpychiyzy0.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpychiyzy0.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpychiyzy0.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpychiyzy0.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpychiyzy0.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpychiyzy0.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpychiyzy0.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpychiyzy0.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpychiyzy0.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n    if a.doubleValue() < b.doubleValue()\
    \ { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeg2j2vls.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpeg2j2vls.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpeg2j2vls.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmpeg2j2vls.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n      \
    \                           ^\n                                 <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n                      ^\n          \
    \            Value\n/tmp/tmpeg2j2vls.swift:28:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdaygm8wb.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmpdaygm8wb.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmpdaygm8wb.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpdaygm8wb.swift:28:48: error: no exact matches in call to initializer \n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                               ^\n/tmp/tmpdaygm8wb.swift:28:48: note: found candidate\
    \ with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpdaygm8wb.swift:30:48: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpdaygm8wb.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a // a is larger\n        case .doubleValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return b // b is larger\n        case .doubleValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        }\n    case .stringValue(_):\n        switch\
    \ b { // Switch on b.\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpowqon4kl/tmpowqon4kl.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93e9e3dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93e9b34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93e9b34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93e9b337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpowqon4kl                        0x00005617f4068a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b93ea029460 __libc_start_main +
    245

    6    tmpowqon4kl                        0x00005617f4068499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which case to return\n    \
    \    case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which case to return\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp5yb3l2ey/tmp5yb3l2ey.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a522cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a4f23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41a4f23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41a4f227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yb3l2ey                        0x000056356b78fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b41a5418460 __libc_start_main +
    245

    6    tmp5yb3l2ey                        0x000056356b78f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return aInt > bInt ? .intValue(aInt) : .intValue(bInt)\n        }\n       \
    \ if let bDouble = b.doubleValue() {\n            return aDouble > bDouble ? .doubleValue(aDouble)\
    \ : .doubleValue(bDouble)\n        }\n        if let bString = b.stringValue()\
    \ {\n            return aString > bString ? .stringValue(aString) : .stringValue(bString)\n\
    \        }\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq2to4sro.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpq2to4sro.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpq2to4sro.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpq2to4sro.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpq2to4sro.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpq2to4sro.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpq2to4sro.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmpq2to4sro.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpq2to4sro.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpq2to4sro.swift:28:40: error: missing argument for parameter\
    \ #1 in call\n        if let bDouble = b.doubleValue() {\n                   \
    \                    ^\n                                       <#Double#>\n/tmp/tmpq2to4sro.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpq2to4sro.swif"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if b == .intValue(aInt) {\n            return\
    \ b\n        } else if b == .doubleValue(aDouble) {\n            return b\n  \
    \      } else if b == .stringValue(aString) {\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsj8_f9gz.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpsj8_f9gz.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpsj8_f9gz.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpsj8_f9gz.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpsj8_f9gz.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpsj8_f9gz.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpsj8_f9gz.swift:26:37: error: cannot find 'aDouble' in scope\n\
    \        } else if b == .doubleValue(aDouble) {\n                            \
    \        ^~~~~~~\n/tmp/tmpsj8_f9gz.swift:28:37: error: cannot find 'aString' in\
    \ scope\n        } else if b == .stringValue(aString) {\n                    \
    \                ^~~~~~~\n/tmp/tmpsj8_f9gz.swift:23:10: warning: case is already\
    \ handled by previous patterns; consider removing it\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n         ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpsj8_f9gz.swift:23:31: warning: case is already handled by previous patterns;\
    \ consider removing it\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                              ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpsj8_f9gz.swift:23:"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to perform\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to perform\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to perform\n        case .intValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to perform\n        case .intValue(_):\n        \
    \    return .stringValue(a.stringValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqr5vbrxs.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqr5vbrxs.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqr5vbrxs.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqr5vbrxs.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqr5vbrxs.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqr5vbrxs.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqr5vbrxs.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqr5vbrxs.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqr5vbrxs.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqr5vbrxs.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(a.intValue > b.intValue ? a.intValue\
    \ : b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on the type of b\n        case .intValue(_):\n \
    \           return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2s21qnvl.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp2s21qnvl.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp2s21qnvl.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp2s21qnvl.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp2s21qnvl.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp2s21qnvl.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp2s21qnvl.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp2s21qnvl.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n    \n    case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString)\n    \n    default:\n        return nil\n    }\n \
    \   \n    switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n   \
    \ \n    case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \    \n    case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \    \n    default:\n        return nil\n    }\n    \n    if aInt > bInt { return\
    \ .intValue(aInt) }\n    \n    if aDouble > bDouble { return .doubleValue(aDouble)\
    \ }\n    \n    if aString > bString { return .stringValue(aString) }\n    \n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9u5hwrv0.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp9u5hwrv0.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmp9u5hwrv0.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmp9u5hwrv0.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmp9u5hwrv0.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmp9u5hwrv0.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmp9u5hwrv0.swift:26:48: error: 'bDouble' must be bound in every\
    \ pattern\n    case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                                               ^\n/tmp/tmp9u5hwrv0.swift:26:24:\
    \ error: 'bInt' must be bound in every pattern\n    case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString)\n                     \
    \  ^\n/tmp/tmp9u5hwrv0.swift:26:75: error: 'bString' must be bound in every pattern\n\
    \    case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                                                                          ^\n\
    /tmp/tmp9u5hwrv0.swift:26:24: error: 'bInt' must be bound in every pattern\n \
    \   case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                   "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(a.intValue > b.intValue ? a.intValue\
    \ : b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp47vm4rx5.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp47vm4rx5.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp47vm4rx5.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp47vm4rx5.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp47vm4rx5.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp47vm4rx5.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on b.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b.\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_tatxjtp.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp_tatxjtp.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp_tatxjtp.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp_tatxjtp.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp_tatxjtp.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp_tatxjtp.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp_tatxjtp.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp_tatxjtp.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp_tatxjtp.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp_tatxjtp.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpefl5_eu5.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpefl5_eu5.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpefl5_eu5.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpefl5_eu5.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp95myflft/tmp95myflft.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5031239c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5030f30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5030f30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5030f2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp95myflft                        0x0000560866f23a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5031425460 __libc_start_main +
    245

    6    tmp95myflft                        0x0000560866f23499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp95myflft/tmp95myflft.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5031239c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5030f30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5030f30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5030f2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp95myflft                        0x0000560866f23a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5031425460 __libc_start_main +
    245

    6    tmp95myflft                        0x0000560866f23499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp95myflft/tmp95myflft.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5031239c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5030f30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5030f30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5030f2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp95myflft                        0x0000560866f23a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5031425460 __libc_start_main +
    245

    6    tmp95myflft                        0x0000560866f23499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        switch b { case .intValue(bInt), .doubleValue(bDouble),\
    \ .stringValue(bString)\n            \n            case let .intValue(bInt), let\
    \ .doubleValue(bDouble), let .stringValue(bString)\n                \n       \
    \         switch aInt, bInt {\n                    case let .intValue(aInt), let\
    \ .intValue(bInt)\n                        return .intValue(aInt > bInt ? aInt\
    \ : bInt)\n                    \n                    case let .doubleValue(aDouble),\
    \ let .doubleValue(bDouble)\n                        return .doubleValue(aDouble\
    \ > bDouble ? aDouble : bDouble)\n                    \n                    case\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \   return .stringValue(aString > bString ? aString : bString)\n             \
    \       \n                    default:\n                        return nil\n \
    \               }\n                \n            case let .intValue(bInt), let\
    \ .stringValue(bString)\n                switch aInt, bInt {\n               \
    \     case let .intValue(aInt), let .intValue(bInt)\n                        return\
    \ .intValue(aInt > bInt ? aInt : bInt)\n                    \n               \
    \     case let .doubleValue(aDouble), let .stringValue(bString)\n            \
    \            return .stringValue(aDouble > bString ? aDouble : bString)\n    \
    \                \n                    case let .stringValue(aString), let .intValue(bInt)\n\
    \                        return .intValue(aString > bInt ? aString : bString)\n\
    \                    \n                    default:\n                        return\
    \ nil\n                }\n                \n            case let .doubleValue(aDouble),\
    \ let .stringValue(bString)\n                switch aDouble, bDouble {\n     \
    \               case let .doubleValue(aDouble), let .doubleValue(bDouble)\n  \
    \                      return .doubleValue(aDouble > bDouble ? aDouble : bDouble)\n\
    \                    \n                    case let .stringValue(aString), let\
    \ .stringValue(bString)\n                        return .stringValue(aString >\
    \ bString ? aString : bString)\n                    \n                    default:\n\
    \                        return nil\n                }\n                \n   \
    \         case let .stringValue(aString), let .intValue(bInt)\n              \
    \  switch aString, bInt {\n                    case let .stringValue(aString),\
    \ let .intValue(bInt)\n                        return .stringValue(aString > bInt\
    \ ? \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpen_yu1w1.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpen_yu1w1.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpen_yu1w1.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpen_yu1w1.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpen_yu1w1.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpen_yu1w1.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpen_yu1w1.swift:25:86: error: expected ':' after 'case'\n   \
    \     switch b { case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString)\n\
    \                                                                            \
    \         ^\n/tmp/tmpen_yu1w1.swift:27:56: error: 'bDouble' must be bound in every\
    \ pattern\n            case let .intValue(bInt), let .doubleValue(bDouble), let\
    \ .stringValue(bString)\n                                                    \
    \   ^\n/tmp/tmpen_yu1w1.swift:27:32: error: 'bInt' must be bound in every pattern\n\
    \            case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString)\n\
    \                               ^\n/tmp/tmpen_yu1w1.swift:27:83: error: 'bString'\
    \ must be bound in every pattern\n            case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), .doubleValue(_), .stringValue(_)\n\
    \            where b == .intValue(aInt)\n            return nil\n        case\
    \ .intValue(_), .doubleValue(_), .stringValue(_)\n        case let .intValue(aInt),\
    \ .doubleValue(_), .stringValue(_)\n            where b == .stringValue(aString)\n\
    \            return nil\n        case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \        case let .intValue(aInt), .doubleValue(_), .stringValue(_)\n        \
    \    where b == .intValue(aDouble)\n            return nil\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n        case let .intValue(aInt), .doubleValue(_),\
    \ .stringValue(_)\n            where b == .doubleValue(aString)\n            return\
    \ nil\n        case .intValue(_), .doubleValue(_), .stringValue(_)\n        case\
    \ let .intValue(aInt), .doubleValue(_), .stringValue(_)\n            where b ==\
    \ .stringValue(aString)\n            return nil\n        case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), .doubleValue(_), .stringValue(_)\n\
    \            where b == .intValue(aDouble)\n            return nil\n        case\
    \ .intValue(_), .doubleValue(_), .stringValue(_)\n        case let .intValue(aInt),\
    \ .doubleValue(_), .stringValue(_)\n            where b == .doubleValue(aString)\n\
    \            return nil\n        case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \        case let .intValue(aInt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0ctg11y9.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp0ctg11y9.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmp0ctg11y9.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmp0ctg11y9.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmp0ctg11y9.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmp0ctg11y9.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmp0ctg11y9.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmp0ctg11y9.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmp0ctg11y9.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmp0ctg11y9.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmp0ctg11y9.s"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare all values first\n \
    \   case .intValue(_):\n        switch b { // Compare all values next\n      \
    \  case .intValue(_):\n            return .intValue(a.intValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Compare all values next\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare all values next\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeml5j_2m.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpeml5j_2m.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpeml5j_2m.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpeml5j_2m.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpeml5j_2m.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpeml5j_2m.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpeml5j_2m.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpeml5j_2m.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpeml5j_2m.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpeml5j_2m.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdaygm8wb.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmpdaygm8wb.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmpdaygm8wb.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpdaygm8wb.swift:28:48: error: no exact matches in call to initializer \n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                               ^\n/tmp/tmpdaygm8wb.swift:28:48: note: found candidate\
    \ with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpdaygm8wb.swift:30:48: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpdaygm8wb.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpdaygm8wb.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n \
    \           return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on type to determine which case\
    \ to return\n        case .intValue(_):\n            return .intValue(max(Int(a),\
    \ Int(b)))\n        case .doubleValue(_):\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    case .stringValue(_):\n        switch b { // Switch\
    \ on type to determine which case to return\n        case .intValue(_):\n    \
    \        return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkljt1sca.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpkljt1sca.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpkljt1sca.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpkljt1sca.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpkljt1sca.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpkljt1sca.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpkljt1sca.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmpkljt1sca.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmpkljt1sca.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmpkljt1sca.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? a :\
    \ b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpycb13an3.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpycb13an3.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .doubleValue(DoubleMax)\n        case .stringValue(_):\n        \
    \    return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n  \
    \      switch b { // Switch on b's type\n        case .intValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(DoubleMax)\n        case .stringValue(_):\n          \
    \  return .stringValue(StringMax)\n        }\n    case .stringValue(_):\n    \
    \    switch b { // Switch on b's type\n        case .intValue(_):\n          \
    \  return .stringValue(StringMax)\n        case .doubleValue(_):\n           \
    \ return .stringValue(StringMax)\n        case .stringValue(_):\n            return\
    \ .stringValue(StringMax)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpx5l3j8sn.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpx5l3j8sn.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:37:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:39:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:44:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:46:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:48:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to execute\n    case .intValue(i):\n        switch b { // Switch\
    \ on type to determine which case to execute\n        case .intValue(i):\n   \
    \         return i\n        case .doubleValue(let d):\n            return d\n\
    \        case .stringValue(let s):\n            return s\n        }\n    case\
    \ .doubleValue(let d):\n        switch b { // Switch on type to determine which\
    \ case to execute\n        case .intValue(i):\n            return d\n        case\
    \ .doubleValue(let d):\n            return d\n        case .stringValue(let s):\n\
    \            return s\n        }\n    case .stringValue(let s):\n        switch\
    \ b { // Switch on type to determine which case to execute\n        case .intValue(i):\n\
    \            return s\n        case .doubleValue(let d):\n            return s\n\
    \        case .stringValue(let s):\n            return s\n        }\n    }\n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9sl0489v.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i):\n                   ^\n/tmp/tmp9sl0489v.swift:25:24: error: cannot\
    \ find 'i' in scope\n        case .intValue(i):\n                       ^\n/tmp/tmp9sl0489v.swift:26:20:\
    \ error: cannot find 'i' in scope\n            return i\n                   ^\n\
    /tmp/tmp9sl0489v.swift:28:20: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n            return d\n                   ^\n\
    /tmp/tmp9sl0489v.swift:30:20: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return s\n                   ^\n\
    /tmp/tmp9sl0489v.swift:34:24: error: cannot find 'i' in scope\n        case .intValue(i):\n\
    \                       ^\n/tmp/tmp9sl0489v.swift:35:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ d\n                   ^\n/tmp/tmp9sl0489v.swift:37:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ d\n                   ^\n/tmp/tmp9sl0489v.swift:39:20: error: cannot convert\
    \ return expression of type 'String' to return type 'Value?'\n            return\
    \ s\n                   ^\n/tmp/tmp9sl0489v.swift:43:24: error: cannot find 'i'\
    \ in scope\n        case .intValue(i):\n                       ^\n/tmp/tmp9sl0489v.swift:44:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n/tmp/tmp9sl0489v.swift:46:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n/tmp/tmp9sl0489v.swift:48:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which case to return\n    \
    \    case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3vuennh0.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp3vuennh0.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp3vuennh0.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp3vuennh0.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp3vuennh0.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp3vuennh0.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp3vuennh0.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp3vuennh0.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n        default: return nil\n    }\n    if\
    \ a.intValue() > b.intValue() { return .intValue() }\n    if a.doubleValue() >\
    \ b.doubleValue() { return .doubleValue() }\n    if a.stringValue() > b.stringValue()\
    \ { return .stringValue() }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpumxv8ava.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpumxv8ava.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpumxv8ava.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \              ^\n                  <#Int#>\n/tmp/tmpumxv8ava.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpumxv8ava.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n       ^\n       Value\n/tmp/tmpumxv8ava.swift:28:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpumxv8ava.swift:28:21:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() > b.intValue() { return .intValue() }\n                 \
    \   ^\n/tmp/tmpumxv8ava.swift:28:23: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                      ^\n                      Value\n/tmp/tmpumxv8ava.swift:28:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() > b.intValue()\
    \ { return .intValue() }\n                                 ^\n               \
    \                  <#Int#>\n/tmp/tmpumxv8ava.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpumxv8ava.swift:28:55: error:\
    \ missing argument for parameter #1 in call\n    if a.intValue() > b.intValue()\
    \ { return .intValue() }\n                                     "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjzf99u2c.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpjzf99u2c.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpjzf99u2c.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpjzf99u2c.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpjzf99u2c.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpjzf99u2c.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpjzf99u2c.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpjzf99u2c.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpjzf99u2c.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpjzf99u2c.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpjzf99u2c.s"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on b.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpflyba_zu.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpflyba_zu.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpflyba_zu.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpflyba_zu.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpflyba_zu.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpflyba_zu.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpflyba_zu.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpflyba_zu.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpflyba_zu.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpflyba_zu.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ argument\n    case .intValue(_):\n        switch b { // Switch on the type of\
    \ the second argument\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n   \
    \         return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue :\
    \ b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on the type of the second argument\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue ?\
    \ a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on the type of the second argument\n        case\
    \ .intValue(_):\n            return .stringValue(a.stringValue > b.intValue ?\
    \ a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnwi5lpoc.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpnwi5lpoc.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpnwi5lpoc.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpnwi5lpoc.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpnwi5lpoc.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpnwi5lpoc.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpnwi5lpoc.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpnwi5lpoc.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n            return b\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n            where b ==\
    \ .intValue(aInt) || b == .doubleValue(aDouble) || b == .stringValue(aString)\n\
    \            return b\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n            return b\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n            where b ==\
    \ .intValue(aInt) || b == .doubleValue(aDouble) || b == .stringValue(aString)\n\
    \            return b\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n            return b\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n            where b ==\
    \ .intValue(aInt) || b == .doubleValue(aDouble) || b == .stringValue(aString)\n\
    \            return b\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n            return b\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n            where b ==\
    \ .intValue(aInt) || b == .doubleValue(aDouble) || b == .stringValue(aString)\n\
    \            return b\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n            return b\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n            where b ==\
    \ .intValue(aInt) || \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmoxiqztl.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpmoxiqztl.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpmoxiqztl.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpmoxiqztl.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpmoxiqztl.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpmoxiqztl.swift:24:99: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt) || b == .doubleValue(aDouble) || b == .stringValue(aString)\n\
    \                                                                            \
    \                      ^\n/tmp/tmpmoxiqztl.swift:26:52: error: 'aDouble' must\
    \ be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                                                \
    \   ^\n/tmp/tmpmoxiqztl.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpmoxiqztl.swift:26:79: error: 'aString'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                                                \
    \                              ^\n/tmp/tmpmoxiqztl.swift:26:28: error: 'aInt'\
    \ must be bound in every pattern\n        case l"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .doubleValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmtas89zt.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpmtas89zt.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpmtas89zt.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpmtas89zt.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpmtas89zt.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpmtas89zt.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpl4ow72cf.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpl4ow72cf.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpl4ow72cf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpl4ow72cf.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpl4ow72cf.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpl4ow72cf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpl4ow72cf.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpl4ow72cf.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpl4ow72cf.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpl4ow72cf.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbqfsjlgf.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpbqfsjlgf.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpbqfsjlgf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpbqfsjlgf.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpbqfsjlgf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpbqfsjlgf.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpbqfsjlgf.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp940951ux.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp940951ux.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmp940951ux.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmp940951ux.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmp940951ux.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmp940951ux.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmp940951ux.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmp940951ux.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmp940951ux.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmp940951ux.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmp940951ux.s"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call\n    case .intValue(_):\n        return b.intValue()\
    \ >= a.intValue()\n    case .doubleValue(_):\n        return b.doubleValue() >=\
    \ a.doubleValue()\n    case .stringValue(_):\n        return b.stringValue() >=\
    \ a.stringValue()\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpam6mde8m.swift:24:27: error: missing argument for parameter #1\
    \ in call\n        return b.intValue() >= a.intValue()\n                     \
    \     ^\n                          <#Int#>\n/tmp/tmpam6mde8m.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpam6mde8m.swift:24:16:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ b.intValue() >= a.intValue()\n               ^\n               Value\n/tmp/tmpam6mde8m.swift:24:29:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return b.intValue() >= a.intValue()\n               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpam6mde8m.swift:24:29: error: referencing operator function '>=' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n        return b.intValue() >=\
    \ a.intValue()\n                            ^\nSwift.Comparable:1:17: note: where\
    \ 'Self' = 'Value'\npublic protocol Comparable : Equatable {\n               \
    \ ^\n/tmp/tmpam6mde8m.swift:24:29: note: binary operator '>=' cannot be synthesized\
    \ for enums with associated values\n        return b.intValue() >= a.intValue()\n\
    \                            ^\n/tmp/tmpam6mde8m.swift:24:43: error: missing argument\
    \ for parameter #1 in call\n        return b.intValue() >= a.intValue()\n    \
    \                                      ^\n                                   \
    \       <#Int#>\n/tmp/tmpam6mde8m.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpam6mde8m.swift:24:32: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return b.intValue()\
    \ >= a.intValue()\n                               ^\n                        \
    \       Value\n/tmp/tmpam6mde8m.swift:26:16: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        return b.doubleValue() >= a.doubleValue()\n\
    \               ^\n               Value\n/tmp/tmpam6mde8m.swift:26:30: error:\
    \ missing argument for parameter #1 in call\n        return b.doubleValue() >=\
    \ a.doubleValue()\n                             ^\n                        "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy8rx5a2.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpyy8rx5a2.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpyy8rx5a2.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpyy8rx5a2.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpyy8rx5a2.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpyy8rx5a2.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpyy8rx5a2.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpyy8rx5a2.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmppizw2w8g/tmppizw2w8g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb80d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb80a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb80a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb80a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppizw2w8g                        0x0000561e8ee2801a <unavailable> + 12314

    5    libc.so.6                          0x00002afb80f72460 __libc_start_main +
    245

    6    tmppizw2w8g                        0x0000561e8ee26499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpisv8lcby.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpisv8lcby.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpisv8lcby.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpisv8lcby.swift:28:48: error: no exact matches\
    \ in call to initializer \n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                               ^\n/tmp/tmpisv8lcby.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpisv8lcby.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpisv8lcby.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which value to return\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which value to return\n        case .intValue(_):\n   \
    \         return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on type to determine which value\
    \ to return\n        case .intValue(_):\n            return .intValue(max(Int(a),\
    \ Int(b)))\n        case .doubleValue(_):\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n        case .stringValue(_):\n            return .stringValue(max(String(a),\
    \ String(b)))\n        }\n    case .stringValue(_):\n        switch b { // Switch\
    \ on type to determine which value to return\n        case .intValue(_):\n   \
    \         return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd1ykw9lh.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmpd1ykw9lh.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmpd1ykw9lh.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpd1ykw9lh.swift:28:37: error: initializer 'init(_:)' requires that 'Value'\
    \ conform to 'BinaryInteger'\n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                    ^\nSwift.Double:3:23: note: where 'Source'\
    \ = 'Value'\n    @inlinable public init<Source>(_ value: Source) where Source\
    \ : BinaryInteger\n                      ^\n/tmp/tmpd1ykw9lh.swift:28:48: error:\
    \ no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpd1ykw9lh.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpd1ykw9lh.swift:30:37:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmpd1ykw9lh.swift:30:37:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmpd1ykw9lh.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmpd1ykw9lh.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphs7l_20w.swift:26:42: error: no exact matches in call to initializer\
    \ \n            return .intValue(max(Int(a), Int(b)))\n                      \
    \                   ^\n/tmp/tmphs7l_20w.swift:26:42: note: found candidate with\
    \ type '(Value) -> Int'\n            return .intValue(max(Int(a), Int(b)))\n \
    \                                        ^\n/tmp/tmphs7l_20w.swift:26:34: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n  \
    \          return .intValue(max(Int(a), Int(b)))\n                           \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmphs7l_20w.swift:28:37: error: initializer 'init(_:)' requires that 'Value'\
    \ conform to 'BinaryInteger'\n            return .doubleValue(max(Double(a), Double(b)))\n\
    \                                    ^\nSwift.Double:3:23: note: where 'Source'\
    \ = 'Value'\n    @inlinable public init<Source>(_ value: Source) where Source\
    \ : BinaryInteger\n                      ^\n/tmp/tmphs7l_20w.swift:28:48: error:\
    \ no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmphs7l_20w.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmphs7l_20w.swift:30:37:\
    \ error: no exact matches in call to initializer \n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmphs7l_20w.swift:30:37:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmphs7l_20w.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmphs7l_20w.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which type to use\n    case .intValue(_):\n        switch b { // Switch on type\
    \ to determine which type to use\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which type to use\n       \
    \ case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which type to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplv19p74q.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmplv19p74q.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmplv19p74q.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmplv19p74q.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmplv19p74q.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmplv19p74q.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmplv19p74q.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmplv19p74q.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphzdmmuqq.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmphzdmmuqq.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmphzdmmuqq.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphzdmmuqq.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphzdmmuqq.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmphzdmmuqq.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmphzdmmuqq.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmphzdmmuqq.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two integers\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmper27pghz/tmper27pghz.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd5a8cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd5a5c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd5a5c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd5a5c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmper27pghz                        0x0000556ae763da56 <unavailable> + 6742

    5    libc.so.6                          0x00002abd5aab6460 __libc_start_main +
    245

    6    tmper27pghz                        0x0000556ae763d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .nil:\n            return b // b is larger\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return a // a is larger\n        case\
    \ .doubleValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .nil:\n            return b\
    \ // b is larger\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .nil:\n            return b // b is larger\n        }\n    case .nil:\n    \
    \    switch b { // Switch on b's type\n        case .intValue(_):\n          \
    \  return a // a is larger\n        case .doubleValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .nil:\n            return b // b is larger\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkf29wnhn.swift:56:11: error: type 'Value' has no member 'nil'\n\
    \    case .nil:\n         ~^~~\n/tmp/tmpkf29wnhn.swift:31:15: error: type 'Value'\
    \ has no member 'nil'\n        case .nil:\n             ~^~~\n/tmp/tmpkf29wnhn.swift:42:15:\
    \ error: type 'Value' has no member 'nil'\n        case .nil:\n             ~^~~\n\
    /tmp/tmpkf29wnhn.swift:53:15: error: type 'Value' has no member 'nil'\n      \
    \  case .nil:\n             ~^~~\n/tmp/tmpkf29wnhn.swift:64:15: error: type 'Value'\
    \ has no member 'nil'\n        case .nil:\n             ~^~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        }\n\
    \    case .stringValue(_):\n        switch b { // Switch on b's type\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        }\n    }\n    return nil // a is equal to\
    \ b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp77dzcqi8/tmp77dzcqi8.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba84d079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba84cd70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba84cd70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba84cd6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp77dzcqi8                        0x0000557433498a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ba84d265460 __libc_start_main +
    245

    6    tmp77dzcqi8                        0x0000557433498499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .doubleValue(DoubleMax)\n        case .stringValue(_):\n        \
    \    return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n  \
    \      switch b { // Switch on b's type\n        case .intValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(DoubleMax)\n        case .stringValue(_):\n          \
    \  return .stringValue(StringMax)\n        }\n    case .stringValue(_):\n    \
    \    switch b { // Switch on b's type\n        case .intValue(_):\n          \
    \  return .stringValue(StringMax)\n        case .doubleValue(_):\n           \
    \ return .stringValue(StringMax)\n        case .stringValue(_):\n            return\
    \ .stringValue(StringMax)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpx5l3j8sn.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpx5l3j8sn.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:37:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:39:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:44:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:46:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpx5l3j8sn.swift:48:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n    if a.doubleValue() < b.doubleValue()\
    \ { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeg2j2vls.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpeg2j2vls.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpeg2j2vls.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmpeg2j2vls.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n      \
    \                           ^\n                                 <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n                      ^\n          \
    \            Value\n/tmp/tmpeg2j2vls.swift:28:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .doubleValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmtas89zt.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpmtas89zt.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpmtas89zt.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpmtas89zt.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpmtas89zt.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpmtas89zt.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpmtas89zt.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp985iy5q6.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp985iy5q6.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use.\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use.\n        case .intValue(_):\n           \
    \ return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9cvhv2up.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp9cvhv2up.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp9cvhv2up.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp9cvhv2up.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp9cvhv2up.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp9cvhv2up.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp9cvhv2up.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp9cvhv2up.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp9cvhv2up.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp9cvhv2up.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ value\n    case .intValue(_):\n        switch b { // Switch on the type of the\
    \ second value\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n   \
    \         return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue :\
    \ b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on the type of the second value\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of the second value\n        case .intValue(_):\n       \
    \     return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7kteymbv.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp7kteymbv.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp7kteymbv.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7kteymbv.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7kteymbv.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp7kteymbv.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp7kteymbv.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp7kteymbv.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue:\n    case .intValue(_):\n\
    \        switch b { // case .intValue:\n        case .intValue(_):\n         \
    \   return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // case .doubleValue:\n        case .intValue(_):\n      \
    \      return a\n        case .doubleValue(_):\n            return b\n       \
    \ case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case .stringValue:\n        case .intValue(_):\n      \
    \      return a\n        case .doubleValue(_):\n            return b\n       \
    \ case .stringValue(_):\n            return b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpd8cvb4hj/tmpd8cvb4hj.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cd1643c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cd133ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cd133a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cd13397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8cvb4hj                        0x000055eb9da6aa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9cd182f460 __libc_start_main +
    245

    6    tmpd8cvb4hj                        0x000055eb9da6a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmphg4ypl3_/tmphg4ypl3_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699a38ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699a081b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699a081988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699a0807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphg4ypl3_                        0x000055c89767ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002b699a576460 __libc_start_main +
    245

    6    tmphg4ypl3_                        0x000055c89767c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_):\n        switch b { // case .intValue(_):\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // case .doubleValue(_):\n        case .doubleValue(_):\n\
    \            return a\n        case .intValue(_):\n            return b\n    \
    \    case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case .stringValue(_):\n        case .stringValue(_):\n\
    \            return a\n        case .intValue(_):\n            return b\n    \
    \    case .doubleValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpynqxobtv/tmpynqxobtv.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86f5bc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86f58b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86f58b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86f58b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpynqxobtv                        0x000056084321fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b86f5dae460 __libc_start_main +
    245

    6    tmpynqxobtv                        0x000056084321f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which type to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which type to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which type to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which type to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd7s5ngxw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpd7s5ngxw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpd7s5ngxw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpd7s5ngxw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpd7s5ngxw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpd7s5ngxw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpd7s5ngxw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpd7s5ngxw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7bw_mzg6.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp7bw_mzg6.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp7bw_mzg6.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp7bw_mzg6.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp7bw_mzg6.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp7bw_mzg6.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp7bw_mzg6.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp7bw_mzg6.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp7bw_mzg6.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp7bw_mzg6.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfdlwzax3.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpfdlwzax3.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpfdlwzax3.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpfdlwzax3.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if let bInt = b.intValue(), aInt == bInt {\n\
    \            return a\n        } else if let bDouble = b.doubleValue(), aDouble\
    \ == bDouble {\n            return a\n        } else if let bString = b.stringValue(),\
    \ aString == bString {\n            return a\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptxsg646f.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmptxsg646f.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmptxsg646f.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmptxsg646f.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmptxsg646f.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmptxsg646f.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmptxsg646f.swift:24:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue(), aInt == bInt\
    \ {\n                      ^\n                      Value\n/tmp/tmptxsg646f.swift:24:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue(),\
    \ aInt == bInt {\n                                 ^\n                       \
    \          <#Int#>\n/tmp/tmptxsg646f.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmptxsg646f.swift:26:47: error: missing\
    \ argument for parameter #1 in call\n        } else if let bDouble = b.doubleValue(),\
    \ aDouble == bDouble {\n                                              ^\n    \
    \                                          <#Double#>\n/tmp/tmptxsg646f.swift:4:10:\
    \ note: 'doubleValue' declar"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .doubleValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0fu0xmpu.swift:89:13: error: expected pattern\n        case \n\
    \            ^\n/tmp/tmp0fu0xmpu.swift:89:13: error: expected ':' after 'case'\n\
    \        case \n            ^\n/tmp/tmp0fu0xmpu.swift:112:66: error: expected\
    \ '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"1\"),\
    \ b: .intValue(1)) == nil)\n                                                 \
    \                ^\n/tmp/tmp0fu0xmpu.swift:22:14: note: to match this opening\
    \ '{'\n    switch a { // Switch on a's type\n             ^\n/tmp/tmp0fu0xmpu.swift:112:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp0fu0xmpu.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp0fu0xmpu.swift:31:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .doubleValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:33:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:35:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:37:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:39:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:41:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:43:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp0fu0xmpu.swift:"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(a.intValue > b.intValue ? a.intValue\
    \ : b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp47vm4rx5.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp47vm4rx5.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp47vm4rx5.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp47vm4rx5.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp47vm4rx5.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp47vm4rx5.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return .intValue(a.intValue > b.intValue ? a.intValue\
    \ : b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .doubleValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp47vm4rx5.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp47vm4rx5.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp47vm4rx5.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp47vm4rx5.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp47vm4rx5.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp47vm4rx5.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp47vm4rx5.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if b == .intValue(aInt) {\n            return\
    \ .intValue(aInt)\n        } else if b == .doubleValue(aDouble) {\n          \
    \  return .doubleValue(aDouble)\n        } else if b == .stringValue(aString)\
    \ {\n            return .stringValue(aString)\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphlh1ipf8.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphlh1ipf8.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmphlh1ipf8.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmphlh1ipf8.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmphlh1ipf8.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmphlh1ipf8.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmphlh1ipf8.swift:26:37: error: cannot find 'aDouble' in scope\n\
    \        } else if b == .doubleValue(aDouble) {\n                            \
    \        ^~~~~~~\n/tmp/tmphlh1ipf8.swift:27:33: error: cannot find 'aDouble' in\
    \ scope\n            return .doubleValue(aDouble)\n                          \
    \      ^~~~~~~\n/tmp/tmphlh1ipf8.swift:28:37: error: cannot find 'aString' in\
    \ scope\n        } else if b == .stringValue(aString) {\n                    \
    \                ^~~~~~~\n/tmp/tmphlh1ipf8.swift:29:33: error: cannot find 'aString'\
    \ in scope\n            return .stringValue(aString)\n                       \
    \         ^~~~~~~\n/tmp/tmphlh1ipf8.swift:23:10: warning: case is already handled\
    \ by previous patterns; consider removing it\n    case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n  "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n    \n    if a.intValue() < b.intValue() {\n     \
    \   return a\n    }\n    \n    if a.intValue() > b.intValue() {\n        return\
    \ b\n    }\n    \n    if a.doubleValue() < b.doubleValue() {\n        return a\n\
    \    }\n    \n    if a.doubleValue() > b.doubleValue() {\n        return b\n \
    \   }\n    \n    if a.stringValue() < b.stringValue() {\n        return a\n  \
    \  }\n    \n    if a.stringValue() > b.stringValue() {\n        return b\n   \
    \ }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcwlrxrd3.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpcwlrxrd3.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpcwlrxrd3.swift:34:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmpcwlrxrd3.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpcwlrxrd3.swift:34:8: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() {\n       ^\n       Value\n/tmp/tmpcwlrxrd3.swift:34:21: error:\
    \ referencing operator function '<' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() < b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmpcwlrxrd3.swift:34:21: note: binary\
    \ operator '<' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() < b.intValue() {\n                    ^\n/tmp/tmpcwlrxrd3.swift:34:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() {\n                      ^\n                      Value\n/tmp/tmpcwlrxrd3.swift:34:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpcwlrxrd3.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpcwlrxrd3.swift:38:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmpcwlrxrd3.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpcwlrxrd3.swift:38:8: error:\
    \ enum cas"
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use.\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? 1 : a.intValue < b.intValue\
    \ ? -1 : 0)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? 1 : a.doubleValue < b.doubleValue ? -1 : 0)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue\
    \ ? 1 : a.stringValue < b.stringValue ? -1 : 0)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which comparison to use.\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? 1 : a.doubleValue < b.intValue ? -1 : 0)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? 1 : a.doubleValue\
    \ < b.doubleValue ? -1 : 0)\n        case .stringValue(_):\n            return\
    \ .stringValue(a.stringValue > b.stringValue ? 1 : a.stringValue < b.stringValue\
    \ ? -1 : 0)\n        }\n    case .stringValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? 1 : a.stringValue\
    \ < b.intValue ? -1 : 0)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? 1 : a.stringValue < b.doubleValue ? -1 : 0)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue\
    \ ? 1 : a.stringValue < b.stringValue ? -1 : 0)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplm6en40c.swift:26:30: error: enum case 'intValue' cannot be used\
    \ as an instance member\n            return .intValue(a.intValue > b.intValue\
    \ ? 1 : a.intValue < b.intValue ? -1 : 0)\n                             ^\n  \
    \                           Value\n/tmp/tmplm6en40c.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? 1 : a.intValue < b.intValue ? -1 : 0)\n                     \
    \                   ^\n/tmp/tmplm6en40c.swift:26:41: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n            return\
    \ .intValue(a.intValue > b.intValue ? 1 : a.intValue < b.intValue ? -1 : 0)\n\
    \                                        ^\n/tmp/tmplm6en40c.swift:26:41: note:\
    \ required by referencing operator function '>' on 'Comparable' where 'Self' =\
    \ '(Int) -> Value'\n            return .intValue(a.intValue > b.intValue ? 1 :\
    \ a.intValue < b.intValue ? -1 : 0)\n                                        ^\n\
    /tmp/tmplm6en40c.swift:26:43: error: enum case 'intValue' cannot be used as an\
    \ instance member\n            return .intValue(a.intValue > b.intValue ? 1 :\
    \ a.intValue < b.intValue ? -1 : 0)\n                                        \
    \  ^\n                                          Value\n/tmp/tmplm6en40c.swift:26:60:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? 1 : a.intValue < b.intValue ? -1\
    \ : 0)\n                                                           ^\n       \
    \                                                    Value\n/tmp/tmplm6en40c.swift:26:71:\
    \ error: type '(Int) -> Value' cannot conform to 'Comparable'\n            return\
    \ .intValue(a.intValue > b.intValue ? 1 : a.intValue < b.intValue ? -1 : 0)\n\
    \                                                                      ^\n/tmp/tmplm6en40c.swift:26:71:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue ? 1 : a.intValue\
    \ < b.intValue ? -1 "
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return .intValue(aInt > bInt ? aInt : bInt)\n        }\n        if let bDouble\
    \ = b.doubleValue() {\n            return .doubleValue(aDouble > bDouble ? aDouble\
    \ : bDouble)\n        }\n        if let bString = b.stringValue() {\n        \
    \    return .stringValue(aString > bString ? aString : bString)\n        }\n \
    \       return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprezv9t78.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmprezv9t78.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmprezv9t78.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmprezv9t78.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmprezv9t78.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmprezv9t78.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmprezv9t78.swift:25:34: error: missing argument for parameter\
    \ #1 in call\n        if let bInt = b.intValue() {\n                         \
    \        ^\n                                 <#Int#>\n/tmp/tmprezv9t78.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmprezv9t78.swift:25:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ let bInt = b.intValue() {\n                      ^\n                      Value\n\
    /tmp/tmprezv9t78.swift:28:40: error: missing argument for parameter #1 in call\n\
    \        if let bDouble = b.doubleValue() {\n                                \
    \       ^\n                                       <#Double#>\n/tmp/tmprezv9t78.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmprezv9t78.swif"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp95myflft/tmp95myflft.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5031239c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5030f30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5030f30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5030f2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp95myflft                        0x0000560866f23a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5031425460 __libc_start_main +
    245

    6    tmp95myflft                        0x0000560866f23499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpcfhcgsac/tmpcfhcgsac.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af04788dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af047584b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af047584988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0475837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcfhcgsac                        0x000055f50e02ba56 <unavailable> + 6742

    5    libc.so.6                          0x00002af047a79460 __libc_start_main +
    245

    6    tmpcfhcgsac                        0x000055f50e02b499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call.\n    case .intValue(_):\n        return a.intValue <\
    \ b.intValue ? .intValue : b.intValue\n    case .doubleValue(_):\n        return\
    \ a.doubleValue < b.doubleValue ? .doubleValue : b.doubleValue\n    case .stringValue(_):\n\
    \        return a.stringValue < b.stringValue ? .stringValue : b.stringValue\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2grpltam.swift:24:16: error: enum case 'intValue' cannot be used\
    \ as an instance member\n        return a.intValue < b.intValue ? .intValue :\
    \ b.intValue\n               ^\n               Value\n/tmp/tmp2grpltam.swift:24:27:\
    \ error: type '(Int) -> Value' cannot conform to 'Comparable'\n        return\
    \ a.intValue < b.intValue ? .intValue : b.intValue\n                         \
    \ ^\n/tmp/tmp2grpltam.swift:24:27: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n        return a.intValue < b.intValue\
    \ ? .intValue : b.intValue\n                          ^\n/tmp/tmp2grpltam.swift:24:27:\
    \ note: required by referencing operator function '<' on 'Comparable' where 'Self'\
    \ = '(Int) -> Value'\n        return a.intValue < b.intValue ? .intValue : b.intValue\n\
    \                          ^\n/tmp/tmp2grpltam.swift:24:29: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        return a.intValue < b.intValue\
    \ ? .intValue : b.intValue\n                            ^\n                  \
    \          Value\n/tmp/tmp2grpltam.swift:24:40: error: cannot convert return expression\
    \ of type '(Int) -> Value' to return type 'Value?'\n        return a.intValue\
    \ < b.intValue ? .intValue : b.intValue\n               ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2grpltam.swift:24:43: error: member 'intValue' expects argument of type\
    \ 'Int'\n        return a.intValue < b.intValue ? .intValue : b.intValue\n   \
    \                                       ^\n/tmp/tmp2grpltam.swift:24:54: error:\
    \ enum case 'intValue' cannot be used as an instance member\n        return a.intValue\
    \ < b.intValue ? .intValue : b.intValue\n                                    \
    \                 ^\n                                                     Value\n\
    /tmp/tmp2grpltam.swift:26:16: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        return a.doubleValue < b.doubleValue ? .doubleValue\
    \ : b.doubleValue\n               ^\n               Value\n/tmp/tmp2grpltam.swift:26:30:\
    \ error: type '(Double) -> Value' cannot conform to 'Comparabl"
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a // a is larger.\n        case .doubleValue(_):\n            return b // b\
    \ is larger.\n        case .stringValue(_):\n            return a // a is larger.\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return b // b is larger.\n        case\
    \ .doubleValue(_):\n            return a // a is larger.\n        case .stringValue(_):\n\
    \            return b // b is larger.\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ a // a is larger.\n        case .doubleValue(_):\n            return b // b\
    \ is larger.\n        case .stringValue(_):\n            return a // a is larger.\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi1nwruwr/tmpi1nwruwr.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2901d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2901a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2901a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2901a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi1nwruwr                        0x00005581c96a5a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b2901f57460 __libc_start_main +
    245

    6    tmpi1nwruwr                        0x00005581c96a5499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(i):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(i):\n       \
    \     return i\n        case .doubleValue(let d):\n            return d\n    \
    \    case .stringValue(let s):\n            return s\n        }\n    case .doubleValue(let\
    \ d):\n        switch b { // Switch on type to determine which case to return\n\
    \        case .intValue(i):\n            return d\n        case .doubleValue(let\
    \ d):\n            return d\n        case .stringValue(let s):\n            return\
    \ s\n        }\n    case .stringValue(let s):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(i):\n       \
    \     return s\n        case .doubleValue(let d):\n            return s\n    \
    \    case .stringValue(let s):\n            return s\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8yf23mi7.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i):\n                   ^\n/tmp/tmp8yf23mi7.swift:25:24: error: cannot\
    \ find 'i' in scope\n        case .intValue(i):\n                       ^\n/tmp/tmp8yf23mi7.swift:26:20:\
    \ error: cannot find 'i' in scope\n            return i\n                   ^\n\
    /tmp/tmp8yf23mi7.swift:28:20: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n            return d\n                   ^\n\
    /tmp/tmp8yf23mi7.swift:30:20: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return s\n                   ^\n\
    /tmp/tmp8yf23mi7.swift:34:24: error: cannot find 'i' in scope\n        case .intValue(i):\n\
    \                       ^\n/tmp/tmp8yf23mi7.swift:35:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ d\n                   ^\n/tmp/tmp8yf23mi7.swift:37:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ d\n                   ^\n/tmp/tmp8yf23mi7.swift:39:20: error: cannot convert\
    \ return expression of type 'String' to return type 'Value?'\n            return\
    \ s\n                   ^\n/tmp/tmp8yf23mi7.swift:43:24: error: cannot find 'i'\
    \ in scope\n        case .intValue(i):\n                       ^\n/tmp/tmp8yf23mi7.swift:44:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n/tmp/tmp8yf23mi7.swift:46:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n/tmp/tmp8yf23mi7.swift:48:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return s\n                   ^\n"
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? a :\
    \ b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpycb13an3.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpycb13an3.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpycb13an3.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpycb13an3.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        }\n\
    \    case .stringValue(_):\n        switch b { // Switch on b's type\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        }\n    }\n    return nil // a is equal\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp13dcgck4/tmp13dcgck4.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7c20a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7c1d9bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7c1d9b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7c1d9a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13dcgck4                        0x00005611f8691a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab7c2290460 __libc_start_main +
    245

    6    tmp13dcgck4                        0x00005611f8691499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpl4ow72cf.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpl4ow72cf.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpl4ow72cf.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpl4ow72cf.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpl4ow72cf.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpl4ow72cf.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpl4ow72cf.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpl4ow72cf.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpl4ow72cf.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpl4ow72cf.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return a // Return a\n        case .doubleValue(_):\n            return b //\
    \ Return b\n        case .stringValue(_):\n            return a // Return a\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return a // Return a\n        case .doubleValue(_):\n\
    \            return b // Return b\n        case .stringValue(_):\n           \
    \ return a // Return a\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on type\n        case .intValue(_):\n            return a // Return\
    \ a\n        case .doubleValue(_):\n            return b // Return b\n       \
    \ case .stringValue(_):\n            return a // Return a\n        }\n    }\n\
    \    return nil // Return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp735y07qk/tmp735y07qk.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfc3c74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfc396bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfc396b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfc396a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp735y07qk                        0x0000560718455a56 <unavailable> + 6742

    5    libc.so.6                          0x00002abfc3e60460 __libc_start_main +
    245

    6    tmp735y07qk                        0x0000560718455499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824857
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp92zqla2i.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp92zqla2i.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp92zqla2i.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp92zqla2i.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp92zqla2i.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp92zqla2i.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp92zqla2i.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxlu64ftb.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpxlu64ftb.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpxlu64ftb.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpxlu64ftb.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpxlu64ftb.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpxlu64ftb.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpxlu64ftb.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n    \
    \        return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_wl3vjav.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp_wl3vjav.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp_wl3vjav.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp_wl3vjav.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp_wl3vjav.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp_wl3vjav.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp_wl3vjav.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp_wl3vjav.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp_wl3vjav.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp_wl3vjav.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp88zhuxxm.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp88zhuxxm.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp88zhuxxm.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp88zhuxxm.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp88zhuxxm.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp88zhuxxm.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp88zhuxxm.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659824856
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n    if a.doubleValue() < b.doubleValue()\
    \ { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeg2j2vls.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpeg2j2vls.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpeg2j2vls.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpeg2j2vls.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmpeg2j2vls.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n      \
    \                           ^\n                                 <#Int#>\n/tmp/tmpeg2j2vls.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeg2j2vls.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n                      ^\n          \
    \            Value\n/tmp/tmpeg2j2vls.swift:28:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1659824856
