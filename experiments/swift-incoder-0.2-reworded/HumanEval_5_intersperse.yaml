name: HumanEval_5_intersperse
language: swift
prompt: "\n/// Insert a number 'delimeter' between every two consecutive elements\
  \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
  \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n///\
  \ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter:\
  \ 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
  \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) ==\
  \ [2, 2, 2, 2, 2])"
completions: ["    var result = numbers.slice()\n    for index in stride(from: 0,\
    \ to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var i = 0\n    for n in numbers {\n        result.append(n)\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n        i += 1\n    }\n    return result", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ []) {\n        if $0.count < 2 {\n            $0.append($1)\n        } else\
    \ {\n            $0.insert($0.count - 1, $1)\n        }\n    }.map { $0 + [$delimeter]\
    \ }", "    return numbers.reduce(into: [], { result, number in\n        result.append(number)\n\
    \        result.insert(number, at: result.count)\n    })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    var i = 0\n \
    \   for n in numbers {\n        result.append(n)\n        i += 1\n        if i\
    \ == delimeter {\n            i = 0\n            result.append(delimeter)\n  \
    \      }\n    }\n    return result", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result[result.count-1] += number\n        result[result.count-1]\
    \ += delimeter\n    })", "    var result = numbers[0..<numbers.count]\n    for\
    \ i in 0..<numbers.count {\n        result[i] += delimeter\n        result[i+1]\
    \ += delimeter\n    }\n    return result", "    var numbers_ = [Int]()\n    for\
    \ number in numbers {\n        numbers_.append(number)\n    }\n    var interspersed_\
    \ = [Int]()\n    for number in numbers_ {\n        interspersed_.append(number)\n\
    \        interspersed_.append(delimeter)\n    }\n    return interspersed_", " \
    \   var result = numbers\n    for index in stride(from: 0, to: numbers.count,\
    \ by: 1) {\n        result[index] = delimeter\n    }\n    return result", "  \
    \  var numbers = numbers\n    var delimeter = delimeter\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = [Int]()\n    var i = 0\n    for\
    \ n in numbers {\n        result.append(n)\n        i += delimeter\n    }\n  \
    \  return result", "    return numbers.reduce(into: [], { result, number in\n\
    \        result.append(number)\n        result.append(delimeter)\n    })", " \
    \   var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    return numbers.reduce(into: [Int](), {\
    \ result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    var result = [Int]()\n    for number in numbers {\n\
    \        result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(number, at: result.count -\
    \ 1)\n    })", "    return numbers.reduce(into: [Int](), { result, number in\n\
    \        result[result.count] = number\n        result.insert(result.count, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        if number != delimeter {\n            result.append(delimeter)\n\
    \        }\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(number, at: result.count\
    \ - 1)\n    })", "    return numbers.reduce(into: [Int](), { result, number in\n\
    \        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.append(delimeter)\n    })", "    return\
    \ numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(number, at: result.count - 1)\n    })", '    return numbers.reduce([])
    { $0 + [$1] + [$2] + [$3] + [$4] }', "    var result = numbers\n    for i in 0..<numbers.count\
    \ {\n        result.append(delimeter)\n        result.append(numbers[i])\n   \
    \ }\n    return result", "    var result: [Int] = []\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    var result = numbers.slice()\n    for index in stride(from:\
    \ 0, to: numbers.count, by: 1) {\n        result[index] = result[index] + delimeter\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(number, at:\
    \ result.count - 1)\n    })", "    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    var numbers_copy = numbers\n    var result = [Int]()\n\
    \    for number in numbers_copy {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: []) {\n        $0.append(contentsOf:\
    \ $1)\n        $0.append(contentsOf: [delimeter])\n    }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result[result.count] = number\n      \
    \  result.insert(result.count, delimeter)\n    })", '    return numbers.reduce(into:
    [Int](), { $0.append($1).append($2); $0.append($1) })', "    return numbers.reduce(into:\
    \ []) {\n        $0.append($1)\n        $0.append($1)\n    }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        if result.count\
    \ > 0 {\n            result[result.count - 1] = delimeter\n        }\n    })",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result[result.count]\
    \ = number\n        result.insert(result.count, delimeter)\n    })", "    return\
    \ numbers.reduce(into: []) {\n        $0.append(contentsOf: $1)\n        $0.append(contentsOf:\
    \ [delimeter])\n    }", "    return numbers.reduce([]) { (result, number) -> [Int]\
    \ in\n        var result = result\n        if result.count < 2 {\n           \
    \ result.append(number)\n        } else {\n            result[result.count - 1]\
    \ = result[result.count - 1] + delimeter + number\n        }\n        return result\n\
    \    }", '    return numbers.reduce([]) { $0.append($1).append(delimeter) }',
  "    var result = [Int]()\n    var lastNumber: Int = 0\n    for number in numbers\
    \ {\n        result.append(number)\n        lastNumber = number\n    }\n    for\
    \ number in result {\n        result.append(delimeter)\n        result.append(number)\n\
    \    }\n    return result", "    var result = [Int]()\n    var i = 0\n    for\
    \ n in numbers {\n        result.append(n)\n        i += delimeter\n    }\n  \
    \  return result", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { $0.append($1) })\n     \
    \   .enumerated().map { $0.element.insert($0.offset, $0.offset + $0.stride + delimeter)\
    \ }\n        .reduce(into: [Int](), { $0.append($1) })", "    var numbers = numbers\n\
    \    var delimeter = delimeter\n    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(number, at: result.count - 1)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        if number != delimeter {\n            result.append(delimeter)\n\
    \        }\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.append(delimeter)\n    })",
  "    return numbers.reduce(into: [Int](), { $0.append($1) })\n        .enumerated().map\
    \ { i, number in\n            guard i > 0 else { return }\n            return\
    \ Array(numbers[i-1]..<number).map { number + delimeter }\n        }.joined()",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.append(delimeter)\n    })", "    return numbers.reduce(into: [],\
    \ { $0.append($1) })\n        .enumerated().map { $0.element.insert($0.offset,\
    \ $0.offset + $0.stride + delimeter) }\n        .reduce(into: [], { $0.append($1)\
    \ })", "    return numbers.reduce([]) { (result, number) -> [Int] in\n       \
    \ var result = result\n        result.append(number)\n        return result\n\
    \    }.map { number in\n        return Array(repeatElement(number, count: delimeter))\n\
    \    }", "    return numbers.reduce(into: [Int](), { result, number in\n     \
    \   result.append(number)\n        result.append(delimeter)\n    })", "    var\
    \ result = [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n        i += 1\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.append(delimeter)\n\
    \    })", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        i += delimeter\n    }\n    result.append(i)\n    return result", "  \
    \  var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", '    return numbers.reduce([])
    { $0.insert($0.count > 0 ? delimeter : 0).append($1); $0 }', "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    for number in\
    \ numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int]()) {\n    \
    \    $0.append($1)\n        if $0.count > 1 {\n            $0[$0.count - 1] =\
    \ delimeter\n        }\n    }", "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        if result.count < 2 {\n  \
    \          result.append(number)\n        } else {\n            result.append(delimeter)\n\
    \            result.append(number)\n        }\n        return result\n    }",
  "    return numbers.reduce(into: [], { $0.append($1) })\n        .enumerated().map\
    \ { $0.offset % 2 == 0 ? $0.element + delimeter : $0.element }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var numbers = numbers\n    var delimeter\
    \ = delimeter\n    var result = [Int]()\n    for number in numbers {\n       \
    \ result.append(number)\n        result.append(delimeter)\n    }\n    return result",
  "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    return numbers.reduce(into: [Int](), {\
    \ $0.append($1).append($2) })\n        .enumerated().map { $0.element + delimeter\
    \ * $0.offset }\n        .reduce(into: [Int](), { $0.append($1) })", "    return\
    \ numbers.reduce(into: [Int](), { $0.append($1).append($2) })\n        .enumerated().map\
    \ { $0.element + 1 }\n        .map { numbers[$0] + delimeter }\n        .map {\
    \ numbers[$0] }", "    var result = [Int]()\n    for number in numbers {\n   \
    \     result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    var numbers = numbers\n    var delimeter = delimeter\n    var\
    \ result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [], { result, number in\n        result.append(number)\n        if result.count\
    \ > 0 {\n            result.append(delimeter)\n        }\n    })", "    return\
    \ numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(number, at: result.count - 1)\n    })", "    var result\
    \ = numbers\n    for index in stride(from: 0, to: numbers.count, by: 1) {\n  \
    \      result[index] = delimeter\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    var lastNumber:\
    \ Int = 0\n    for number in numbers {\n        if lastNumber != 0 {\n       \
    \     result.append(delimeter)\n        }\n        result.append(number)\n   \
    \     lastNumber = number\n    }\n    return result", "    var numbers_copy =\
    \ numbers\n    var result = [Int]()\n    for number in numbers_copy {\n      \
    \  result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    var numbers = numbers\n    var result = [Int]()\n    var lastNumber:\
    \ Int? = nil\n    for number in numbers {\n        if lastNumber == nil {\n  \
    \          lastNumber = number\n            continue\n        }\n        result.append(lastNumber!)\n\
    \        result.append(delimeter)\n        lastNumber = number\n    }\n    result.append(lastNumber!)\n\
    \    return result", "    var result = numbers\n    for index in stride(from:\
    \ 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n \
    \   return result", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(number, at: result.count\
    \ - 1)\n    })", "    var result = numbers\n    for index in stride(from: 0, to:\
    \ numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var index = 0\n    for number in numbers {\n        result[index]\
    \ = number\n        index++\n        if index == delimeter {\n            index\
    \ = 0\n        }\n    }\n    return result", "    var numbers_copy = numbers\n\
    \    var result = [Int]()\n    for number in numbers_copy {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    var numbers_ =\
    \ numbers\n    var delimeter_ = delimeter\n    var result = [Int]()\n    for number\
    \ in numbers_ {\n        result.append(number)\n        result.append(delimeter_)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element + 1 }\n        .map { numbers[$0]\
    \ }\n        .append(numbers)\n        .reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element + 1 }\n        .map { numbers[$0]\
    \ }\n        .append(delimeter)\n        .reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element + 1 }\n        .map { numbers[$0]\
    \ }", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    for number in\
    \ numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [], { $0.append($1)\
    \ })\n        .enumerated().map { $0.offset % 2 == 0 ? $0.element + delimeter\
    \ : $0.element }", "    var result = [Int]()\n    for number in numbers {\n  \
    \      result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    return numbers.reduce([]) { (result, number) -> [Int] in\n   \
    \     var result = result\n        if result.count < 2 {\n            result.append(number)\n\
    \        } else {\n            result[result.count - 1] = result[result.count\
    \ - 1] + delimeter + number\n        }\n        return result\n    }", "    var\
    \ numbers = numbers\n    var delimeter = delimeter\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = [Int]()\n    var index = 0\n   \
    \ for number in numbers {\n        result[index] = number\n        index++\n \
    \       if index == delimeter {\n            index = 0\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        result += [number]\n     \
    \   if number != numbers.last {\n            result += [delimeter]\n        }\n\
    \        return result\n    }", "    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = numbers\n    for index in 0..<numbers.count {\n        result[index] = result[index]\
    \ + delimeter\n    }\n    return result", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        if result.count <\
    \ 2 {\n            result.append(number)\n        } else {\n            result.append(delimeter)\n\
    \            result.append(number)\n        }\n        return result\n    }",
  "    return numbers.reduce(into: [Int](), { $0.append($1) })\n        .enumerated().map\
    \ { $0.element + 1 }\n        .map { numbers[$0] + delimeter }\n        .reduce(into:\
    \ [Int](), { $0.append($1) })", "    var result = numbers[0..<numbers.count]\n\
    \    for i in 0..<numbers.count {\n        result[i] += delimeter\n        result[i+1]\
    \ += delimeter\n    }\n    return result", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = numbers\n    for index in\
    \ stride(from: 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n\
    \    }\n    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        if number != delimeter {\n            result.append(delimeter)\n    \
    \    }\n    }\n    return result", "    return numbers.reduce(into: [Int](), {\
    \ result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int]()) {\n        (result,\
    \ number) in result.append(number)\n        result.append(delimeter)\n    }",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last!, delimeter)\n    })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result[result.count] = number\n      \
    \  result.insert(result.count, delimeter)\n    })", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        result\
    \ += [number]\n        result += [delimeter]\n        result += [number]\n   \
    \     return result\n    }", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element + 1 }\n        .map { numbers[$0]\
    \ + delimeter }\n        .reduce(into: []) { $0.append($1) }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result[result.count] = number\n      \
    \  result.insert(result.count, delimeter)\n    })", "    return numbers.reduce(into:\
    \ []) {\n        $0.append(contentsOf: [$1]).append(contentsOf: [delimeter])\n\
    \    }", "    return numbers.reduce([]) { (result, number) -> [Int] in\n     \
    \   var result = result\n        if number != nil {\n            result.append(number)\n\
    \        }\n        if result.count > 0 {\n            result.append(delimeter)\n\
    \        }\n        return result\n    }", "    var result = [Int]()\n    for\
    \ number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = [Int]()\n    var lastNumber = 0\n\
    \    for number in numbers {\n        if lastNumber != 0 {\n            result.append(delimeter)\n\
    \        }\n        result.append(number)\n        lastNumber = number\n    }\n\
    \    return result", '    return numbers.reduce([]) { $0.append($1).append(delimeter)
    }', "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        if result.count > 0 {\n            result[result.count - 1] = delimeter\n\
    \        }\n    })", "    var result = [Int]()\n    for number in numbers {\n\
    \        result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(number, at: result.count - 1)\n\
    \    })", "    var result = [Int]()\n    var i = 0\n    for number in numbers\
    \ {\n        result.append(number)\n        i += 1\n        if i == delimeter\
    \ {\n            i = 0\n            result.append(number)\n        }\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int](), { $0.append($1).append($2)\
    \ })\n        .enumerated().map { $0.element + delimeter * $0.offset }\n     \
    \   .reduce(into: [Int](), { $0.append($1) })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    var i = 0\n \
    \   for n in numbers {\n        result.append(n)\n        if i != numbers.count\
    \ - 1 {\n            result.append(delimeter)\n        }\n        i += 1\n   \
    \ }\n    return result", '    return numbers.reduce([]) { $0 + [$1] + [$2] + [$3]
    + [$4] }', "    var result: [Int] = []\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var numbers\
    \ = numbers\n    var delimeter = delimeter\n    var result = [Int]()\n    for\
    \ number in numbers {\n        result.append(number)\n        if number != delimeter\
    \ {\n            result.append(delimeter)\n        }\n    }\n    return result",
  "    return numbers.reduce(into: [Int](), { $0.append($1).append($2) })\n      \
    \  .enumerated().map { $0.element + 1 }\n        .map { numbers[$0] }\n      \
    \  .reduce(into: [Int](), { $0.append($1).append($2) })\n        .enumerated().map\
    \ { $0.element + 1 }\n        .map { numbers[$0] }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    var result = [Int]()\n    for number in\
    \ numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", '    return numbers.reduce([]) { $0 + [$1] + [$2]
    + [$3] + [$4] }', "    return numbers.reduce([]) { (result, number) -> [Int] in\n\
    \        var result = result\n        result.append(number)\n        result.append(delimeter)\n\
    \        return result\n    }", "    return numbers.reduce(into: [], { $0.append($1)\
    \ })\n        .enumerated().map { $0.offset % 2 == 0 ? $0.element + [delimeter]\
    \ : $0.element }", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    return numbers.reduce(into: [Int](), {\
    \ result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce([]) { (result, number) -> [Int] in\n    \
    \    var result = result\n        if number != nil {\n            result.append(number)\n\
    \        }\n        if result.count > 0 {\n            result.append(delimeter)\n\
    \        }\n        return result\n    }", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result[result.count] = number\n        result.insert(result.count,\
    \ delimeter)\n    })", "    var result = [Int]()\n    for number in numbers {\n\
    \        result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    var result = numbers\n    for index in 0..<numbers.count {\n \
    \       result[index] = result[index] + delimeter\n    }\n    return result",
  "    return numbers.reduce(into: [], { $0.append($1) })\n        .enumerated().map\
    \ { $0.offset % 2 == 0 ? $0.element + [delimeter] + $0.element : $0.element }\n\
    \        .reduce(into: [], { $0.append($1) })", "    var result = [Int]()\n  \
    \  for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    var result = numbers\n    for i in 0..<numbers.count\
    \ {\n        result.append(delimeter)\n        result.append(numbers[i])\n   \
    \ }\n    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result:\
    \ [Int] = []\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n        i += 1\n    }\n    return result", "    var result = [Int]()\n\
    \    var i = 0\n    for n in numbers {\n        result.append(n)\n        if i\
    \ != numbers.count - 1 {\n            result.append(delimeter)\n        }\n  \
    \      i += 1\n    }\n    return result", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        if result.count <\
    \ 2 {\n            result.append(number)\n        } else {\n            result.append(delimeter)\n\
    \            result.append(number)\n        }\n        return result\n    }",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.append(delimeter)\n    })", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(number, at: result.count\
    \ - 1)\n    })", "    return numbers.reduce(into: []) {\n        $0.append(contentsOf:\
    \ $1)\n        $0.append(contentsOf: [delimeter])\n    }", "    var result = [Int]()\n\
    \    var i = 0\n    for number in numbers {\n        result.append(number)\n \
    \       if i != numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n        i += 1\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(number,\
    \ at: result.count - 1)\n    })", "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        if result.count < 2 {\n  \
    \          result.append(number)\n        } else {\n            result[result.count\
    \ - 1] = result[result.count - 1].prefix(delimeter) + String(number)\n       \
    \ }\n        return result\n    }", '    return numbers.reduce([]) { $0 + [$1]
    + [$2] + [$3] + [$4] }', "    var result = numbers\n    for index in stride(from:\
    \ 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n \
    \   return result"]
stop_tokens:
- "\n}"
